/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.4 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
function editor_lost_focus(e) {
("mxCellEditor" != e.target.className || "span" != e.target.tagName.toLowerCase()) && (el = document.getElementById("mxCellEditor"), 
null != el && (window.remove_editor = 1, el.style.visibility = "visible", el.focus(), 
el.blur()));
}

function mxDictionary() {
this.clear();
}

function mxPoint(a, b) {
this.x = null != a ? a :0, this.y = null != b ? b :0;
}

function mxRectangle(a, b, c, d) {
mxPoint.call(this, a, b), this.width = null != c ? c :0, this.height = null != d ? d :0;
}

function mxEventObject(a) {
this.name = a, this.properties = [];
for (var b = 1; b < arguments.length; b += 2) null != arguments[b + 1] && (this.properties[arguments[b]] = arguments[b + 1]);
}

function mxMouseEvent(a, b) {
this.evt = a, this.state = b;
}

function mxEventSource(a) {
this.setEventSource(a);
}

function mxXmlRequest(a, b, c, d, e, f) {
this.url = a, this.params = b, this.method = c || "POST", this.async = null != d ? d :!0, 
this.username = e, this.password = f;
}

function mxWindow(a, b, c, d, e, f, g, h, k, l) {
null != b && (g = null != g ? g :!0, this.content = b, this.init(c, d, e, f, l), 
this.installMaximizeHandler(), this.installMinimizeHandler(), this.installCloseHandler(), 
this.setMinimizable(g), this.setTitle(a), (null == h || h) && this.installMoveHandler(), 
null != k && null != k.parentNode ? k.parentNode.replaceChild(this.div, k) :document.body.appendChild(this.div));
}

function mxForm(a) {
this.table = document.createElement("table"), this.table.className = a, this.body = document.createElement("tbody"), 
this.table.appendChild(this.body);
}

function mxImage(a, b, c) {
this.src = a, this.width = b, this.height = c;
}

function mxDivResizer(a, b) {
if ("div" == a.nodeName.toLowerCase()) {
null == b && (b = window), this.div = a;
var c = mxUtils.getCurrentStyle(a);
null != c && (this.resizeWidth = "auto" == c.width, this.resizeHeight = "auto" == c.height), 
mxEvent.addListener(b, "resize", mxUtils.bind(this, function() {
this.handlingResize || (this.handlingResize = !0, this.resize(), this.handlingResize = !1);
})), this.resize();
}
}

function mxDragSource(a, b) {
this.element = a, this.dropHandler = b, mxEvent.addGestureListeners(a, mxUtils.bind(this, this.mouseDown));
}

function mxToolbar(a) {
this.container = a;
}

function mxSession(a, b, c, d) {
this.model = a, this.urlInit = b, this.urlPoll = c, this.urlNotify = d, null != a && (this.codec = new mxCodec(), 
this.codec.lookup = function(b) {
return a.getCell(b);
}), a.addListener(mxEvent.NOTIFY, mxUtils.bind(this, function(a, b) {
var c = b.getProperty("edit");
(null != c && this.debug || this.connected && !this.suspended) && this.notify("<edit>" + this.encodeChanges(c.changes, c.undone) + "</edit>");
}));
}

function mxUndoableEdit(a, b) {
this.source = a, this.changes = [], this.significant = null != b ? b :!0;
}

function mxUndoManager(a) {
this.size = null != a ? a :100, this.clear();
}

function mxPanningManager(a) {
this.thread = null, this.active = !1, this.dy = this.dx = this.t0y = this.t0x = this.tdy = this.tdx = 0, 
this.scrollbars = !1, this.scrollTop = this.scrollLeft = 0, this.mouseListener = {
mouseDown:function() {},
mouseMove:function() {},
mouseUp:mxUtils.bind(this, function() {
this.active && this.stop();
})
}, a.addMouseListener(this.mouseListener), mxEvent.addListener(document, "mouseup", mxUtils.bind(this, function() {
this.active && this.stop();
}));
var b = mxUtils.bind(this, function() {
return this.scrollbars = mxUtils.hasScrollbars(a.container), this.scrollLeft = a.container.scrollLeft, 
this.scrollTop = a.container.scrollTop, window.setInterval(mxUtils.bind(this, function() {
if (this.tdx -= this.dx, this.tdy -= this.dy, this.scrollbars) {
var b = -a.container.scrollLeft - Math.ceil(this.dx), d = -a.container.scrollTop - Math.ceil(this.dy);
a.panGraph(b, d), a.panDx = this.scrollLeft - a.container.scrollLeft, a.panDy = this.scrollTop - a.container.scrollTop, 
a.fireEvent(new mxEventObject(mxEvent.PAN));
} else a.panGraph(this.getDx(), this.getDy());
}), this.delay);
});
this.isActive = function() {
return active;
}, this.getDx = function() {
return Math.round(this.tdx);
}, this.getDy = function() {
return Math.round(this.tdy);
}, this.start = function() {
this.t0x = a.view.translate.x, this.t0y = a.view.translate.y, this.active = !0;
}, this.panTo = function(c, d, e, f) {
this.active || this.start(), this.scrollLeft = a.container.scrollLeft, this.scrollTop = a.container.scrollTop, 
f = null != f ? f :0;
var g = a.container;
this.dx = c + (null != e ? e :0) - g.scrollLeft - g.clientWidth, this.dx = 0 > this.dx && Math.abs(this.dx) < this.border ? this.border + this.dx :this.handleMouseOut ? Math.max(this.dx, 0) :0, 
0 == this.dx && (this.dx = c - g.scrollLeft, this.dx = 0 < this.dx && this.dx < this.border ? this.dx - this.border :this.handleMouseOut ? Math.min(0, this.dx) :0), 
this.dy = d + f - g.scrollTop - g.clientHeight, this.dy = 0 > this.dy && Math.abs(this.dy) < this.border ? this.border + this.dy :this.handleMouseOut ? Math.max(this.dy, 0) :0, 
0 == this.dy && (this.dy = d - g.scrollTop, this.dy = 0 < this.dy && this.dy < this.border ? this.dy - this.border :this.handleMouseOut ? Math.min(0, this.dy) :0), 
0 != this.dx || 0 != this.dy ? (this.dx *= this.damper, this.dy *= this.damper, 
null == this.thread && (this.thread = b())) :null != this.thread && (window.clearInterval(this.thread), 
this.thread = null);
}, this.stop = function() {
if (this.active) if (this.active = !1, null != this.thread && (window.clearInterval(this.thread), 
this.thread = null), this.tdy = this.tdx = 0, this.scrollbars) a.panDx = 0, a.panDy = 0, 
a.fireEvent(new mxEventObject(mxEvent.PAN)); else {
var b = a.panDx, d = a.panDy;
(0 != b || 0 != d) && (a.panGraph(0, 0), a.view.setTranslate(this.t0x + b / a.view.scale, this.t0y + d / a.view.scale));
}
}, this.destroy = function() {
a.removeMouseListener(this.mouseListener);
};
}

function mxPopupMenu(a) {
this.factoryMethod = a, null != a && this.init();
}

function mxAutoSaveManager(a) {
this.changeHandler = mxUtils.bind(this, function(a, c) {
this.isEnabled() && this.graphModelChanged(c.getProperty("edit").changes);
}), this.setGraph(a);
}

function mxAnimation(a) {
this.delay = null != a ? a :20;
}

function mxMorphing(a, b, c, d) {
mxAnimation.call(this, d), this.graph = a, this.steps = null != b ? b :6, this.ease = null != c ? c :1.5;
}

function mxImageBundle(a) {
this.images = [], this.alt = null != a ? a :!1;
}

function mxImageExport() {}

function mxAbstractCanvas2D() {
this.converter = this.createUrlConverter(), this.reset();
}

function mxXmlCanvas2D(a) {
mxAbstractCanvas2D.call(this), this.root = a, this.writeDefaults();
}

function mxSvgCanvas2D(a, b) {
mxAbstractCanvas2D.call(this), this.root = a, this.gradients = [], this.defs = null, 
this.styleEnabled = null != b ? b :!1;
var c = null;
if (a.ownerDocument != document) for (c = a; null != c && "svg" != c.nodeName; ) c = c.parentNode;
null != c && (0 < c.getElementsByTagName("defs").length && (this.defs = c.getElementsByTagName("defs")[0]), 
null == this.defs && (this.defs = this.createElement("defs"), null != c.firstChild ? c.insertBefore(this.defs, c.firstChild) :c.appendChild(this.defs)), 
this.styleEnabled && this.defs.appendChild(this.createStyle()));
}

function mxGuide(a, b) {
this.graph = a, this.setStates(b);
}

function mxStencil(a) {
this.desc = a, this.parseDescription(), this.parseConstraints();
}

function mxShape(a) {
this.stencil = a, this.strokewidth = 1, this.rotation = 0, this.opacity = 100, this.flipV = this.flipH = !1;
}

function mxActor(a, b, c, d) {
mxShape.call(this), this.bounds = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1;
}

function mxCloud(a, b, c, d) {
mxActor.call(this), this.bounds = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1;
}

function mxRectangleShape(a, b, c, d) {
mxShape.call(this), this.bounds = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1;
}

function mxEllipse(a, b, c, d) {
mxShape.call(this), this.bounds = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1;
}

function mxDoubleEllipse(a, b, c, d) {
mxShape.call(this), this.bounds = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1;
}

function mxRhombus(a, b, c, d) {
mxShape.call(this), this.bounds = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1;
}

function mxPolyline(a, b, c) {
mxShape.call(this), this.points = a, this.stroke = b, this.strokewidth = null != c ? c :1;
}

function mxArrow(a, b, c, d, e, f, g) {
mxShape.call(this), this.points = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1, 
this.arrowWidth = null != e ? e :mxConstants.ARROW_WIDTH, this.spacing = null != f ? f :mxConstants.ARROW_SPACING, 
this.endSize = null != g ? g :mxConstants.ARROW_SIZE;
}

function mxText(a, b, c, d, e, f, g, h, k, l, m, n, p, q, s, r, t, u, v, w) {
mxShape.call(this), this.value = a, this.bounds = b, this.color = null != e ? e :"black", 
this.align = null != c ? c :"", this.valign = null != d ? d :"", this.family = null != f ? f :mxConstants.DEFAULT_FONTFAMILY, 
this.size = null != g ? g :mxConstants.DEFAULT_FONTSIZE, this.fontStyle = null != h ? h :mxConstants.DEFAULT_FONTSTYLE, 
this.spacing = parseInt(k || 2), this.spacingTop = this.spacing + parseInt(l || 0), 
this.spacingRight = this.spacing + parseInt(m || 0), this.spacingBottom = this.spacing + parseInt(n || 0), 
this.spacingLeft = this.spacing + parseInt(p || 0), this.horizontal = null != q ? q :!0, 
this.background = s, this.border = r, this.wrap = null != t ? t :!1, this.clipped = null != u ? u :!1, 
this.overflow = null != v ? v :"visible", this.labelPadding = null != w ? w :0, 
this.rotation = 0;
}

function mxTriangle() {
mxActor.call(this);
}

function mxHexagon() {
mxActor.call(this);
}

function mxLine(a, b, c) {
mxShape.call(this), this.bounds = a, this.stroke = b, this.strokewidth = null != c ? c :1;
}

function mxImageShape(a, b, c, d, e) {
mxShape.call(this), this.bounds = a, this.image = b, this.fill = c, this.stroke = d, 
this.strokewidth = null != e ? e :1, this.shadow = !1;
}

function mxLabel(a, b, c, d) {
mxRectangleShape.call(this, a, b, c, d);
}

function mxCylinder(a, b, c, d) {
mxShape.call(this), this.bounds = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1;
}

function mxConnector(a, b, c) {
mxPolyline.call(this, a, b, c);
}

function mxSwimlane(a, b, c, d) {
mxShape.call(this), this.bounds = a, this.fill = b, this.stroke = c, this.strokewidth = null != d ? d :1;
}

function mxGraphLayout(a) {
this.graph = a;
}

function mxStackLayout(a, b, c, d, e, f) {
mxGraphLayout.call(this, a), this.horizontal = null != b ? b :!0, this.spacing = null != c ? c :0, 
this.x0 = null != d ? d :0, this.y0 = null != e ? e :0, this.border = null != f ? f :0;
}

function mxPartitionLayout(a, b, c, d) {
mxGraphLayout.call(this, a), this.horizontal = null != b ? b :!0, this.spacing = c || 0, 
this.border = d || 0;
}

function mxCompactTreeLayout(a, b, c) {
mxGraphLayout.call(this, a), this.horizontal = null != b ? b :!0, this.invert = null != c ? c :!1;
}

function WeightedCellSorter(a, b) {
this.cell = a, this.weightedValue = b;
}

function mxFastOrganicLayout(a) {
mxGraphLayout.call(this, a);
}

function mxCircleLayout(a, b) {
mxGraphLayout.call(this, a), this.radius = null != b ? b :100;
}

function mxParallelEdgeLayout(a) {
mxGraphLayout.call(this, a);
}

function mxCompositeLayout(a, b, c) {
mxGraphLayout.call(this, a), this.layouts = b, this.master = c;
}

function mxEdgeLabelLayout(a) {
mxGraphLayout.call(this, a);
}

function mxGraphAbstractHierarchyCell() {
this.x = [], this.y = [], this.temp = [];
}

function mxGraphHierarchyNode(a) {
mxGraphAbstractHierarchyCell.apply(this, arguments), this.cell = a;
}

function mxGraphHierarchyEdge(a) {
mxGraphAbstractHierarchyCell.apply(this, arguments), this.edges = a;
}

function mxGraphHierarchyModel(a, b, c, d, e) {
for (a.getGraph(), this.tightenToSource = e, this.roots = c, this.parent = d, this.vertexMapper = {}, 
this.edgeMapper = {}, this.maxRank = 0, c = [], null == b && (b = this.graph.getChildVertices(d)), 
this.maxRank = this.SOURCESCANSTARTRANK, this.createInternalCells(a, b, c), d = 0; d < b.length; d++) {
e = c[d].connectsAsSource;
for (var f = 0; f < e.length; f++) {
var g = e[f], h = g.edges;
if (null != h && 0 < h.length) {
var h = h[0], k = a.getVisibleTerminal(h, !1), k = mxCellPath.create(k), k = this.vertexMapper[k];
c[d] == k && (k = a.getVisibleTerminal(h, !0), k = mxCellPath.create(k), k = this.vertexMapper[k]), 
null != k && c[d] != k && (g.target = k, 0 == k.connectsAsTarget.length && (k.connectsAsTarget = []), 
0 > mxUtils.indexOf(k.connectsAsTarget, g) && k.connectsAsTarget.push(g));
}
}
c[d].temp[0] = 1;
}
}

function mxHierarchicalLayoutStage() {}

function mxMedianHybridCrossingReduction(a) {
this.layout = a;
}

function MedianCellSorter() {}

function mxMinimumCycleRemover(a) {
this.layout = a;
}

function mxCoordinateAssignment(a, b, c, d, e, f) {
this.layout = a, this.intraCellSpacing = b, this.interRankCellSpacing = c, this.orientation = d, 
this.initialX = e, this.parallelEdgeSpacing = f;
}

function WeightedCellSorter(a, b) {
this.cell = a, this.weightedValue = b;
}

function mxHierarchicalLayout(a, b, c) {
mxGraphLayout.call(this, a), this.orientation = null != b ? b :mxConstants.DIRECTION_NORTH, 
this.deterministic = null != c ? c :!0;
}

function mxGraphModel(a) {
this.currentEdit = this.createUndoableEdit(), null != a ? this.setRoot(a) :this.clear();
}

function mxRootChange(a, b) {
this.model = a, this.previous = this.root = b;
}

function mxChildChange(a, b, c, d) {
this.model = a, this.previous = this.parent = b, this.child = c, this.previousIndex = this.index = d;
}

function mxTerminalChange(a, b, c, d) {
this.model = a, this.cell = b, this.previous = this.terminal = c, this.source = d;
}

function mxValueChange(a, b, c) {
this.model = a, this.cell = b, this.previous = this.value = c;
}

function mxStyleChange(a, b, c) {
this.model = a, this.cell = b, this.previous = this.style = c;
}

function mxGeometryChange(a, b, c) {
this.model = a, this.cell = b, this.previous = this.geometry = c;
}

function mxCollapseChange(a, b, c) {
this.model = a, this.cell = b, this.previous = this.collapsed = c;
}

function mxVisibleChange(a, b, c) {
this.model = a, this.cell = b, this.previous = this.visible = c;
}

function mxCellAttributeChange(a, b, c) {
this.cell = a, this.attribute = b, this.previous = this.value = c;
}

function mxCell(a, b, c) {
this.value = a, this.setGeometry(b), this.setStyle(c), null != this.onInit && this.onInit();
}

function mxGeometry(a, b, c, d) {
mxRectangle.call(this, a, b, c, d);
}

function mxPrintPreview(a, b, c, d, e, f, g, h, k) {
this.graph = a, this.scale = null != b ? b :1 / a.pageScale, this.border = null != d ? d :0, 
this.pageFormat = null != c ? c :a.pageFormat, this.title = null != h ? h :"Printer-friendly version", 
this.x0 = null != e ? e :0, this.y0 = null != f ? f :0, this.borderColor = g, this.pageSelector = null != k ? k :!0;
}

function mxStylesheet() {
this.styles = {}, this.putDefaultVertexStyle(this.createDefaultVertexStyle()), this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
}

function mxCellState(a, b, c) {
this.view = a, this.cell = b, this.style = c, this.origin = new mxPoint(), this.absoluteOffset = new mxPoint();
}

function mxGraphSelectionModel(a) {
this.graph = a, this.cells = [];
}

function mxSelectionChange(a, b, c) {
this.selectionModel = a, this.added = null != b ? b.slice() :null, this.removed = null != c ? c.slice() :null;
}

function mxCellEditor(a) {
this.graph = a;
}

function mxCellRenderer() {}

function mxGraphView(a) {
this.graph = a, this.translate = new mxPoint(), this.graphBounds = new mxRectangle(), 
this.states = new mxDictionary();
}

function mxCurrentRootChange(a, b) {
if (this.view = a, this.previous = this.root = b, this.isUp = null == b, !this.isUp) for (var c = this.view.currentRoot, d = this.view.graph.getModel(); null != c; ) {
if (c == b) {
this.isUp = !0;
break;
}
c = d.getParent(c);
}
}

function mxGraph(a, b, c, d) {
this.mouseListeners = null, this.renderHint = c, this.dialect = mxClient.IS_SVG ? mxConstants.DIALECT_SVG :c == mxConstants.RENDERING_HINT_EXACT && mxClient.IS_VML ? mxConstants.DIALECT_VML :c == mxConstants.RENDERING_HINT_FASTEST ? mxConstants.DIALECT_STRICTHTML :c == mxConstants.RENDERING_HINT_FASTER ? mxConstants.DIALECT_PREFERHTML :mxConstants.DIALECT_MIXEDHTML, 
this.model = null != b ? b :new mxGraphModel(), this.multiplicities = [], this.imageBundles = [], 
this.cellRenderer = this.createCellRenderer(), this.setSelectionModel(this.createSelectionModel()), 
this.setStylesheet(null != d ? d :this.createStylesheet()), this.view = this.createGraphView(), 
this.graphModelChangeListener = mxUtils.bind(this, function(a, b) {
this.graphModelChanged(b.getProperty("edit").changes);
}), this.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener), this.createHandlers(), 
null != a && this.init(a), this.view.revalidate();
}

function mxCellOverlay(a, b, c, d, e, f) {
this.image = a, this.tooltip = b, this.align = null != c ? c :this.align, this.verticalAlign = null != d ? d :this.verticalAlign, 
this.offset = null != e ? e :new mxPoint(), this.cursor = null != f ? f :"help";
}

function mxOutline(a, b) {
this.source = a, null != b && this.init(b);
}

function mxMultiplicity(a, b, c, d, e, f, g, h, k, l) {
this.source = a, this.type = b, this.attr = c, this.value = d, this.min = null != e ? e :0, 
this.max = null != f ? f :"n", this.validNeighbors = g, this.countError = mxResources.get(h) || h, 
this.typeError = mxResources.get(k) || k, this.validNeighborsAllowed = null != l ? l :!0;
}

function mxLayoutManager(a) {
this.undoHandler = mxUtils.bind(this, function(a, c) {
this.isEnabled() && this.beforeUndo(c.getProperty("edit"));
}), this.moveHandler = mxUtils.bind(this, function(a, c) {
this.isEnabled() && this.cellsMoved(c.getProperty("cells"), c.getProperty("event"));
}), this.setGraph(a);
}

function mxSpaceManager(a, b, c, d) {
this.resizeHandler = mxUtils.bind(this, function(a, b) {
this.isEnabled() && this.cellsResized(b.getProperty("cells"));
}), this.foldHandler = mxUtils.bind(this, function(a, b) {
this.isEnabled() && this.cellsResized(b.getProperty("cells"));
}), this.shiftRightwards = null != b ? b :!0, this.shiftDownwards = null != c ? c :!0, 
this.extendParents = null != d ? d :!0, this.setGraph(a);
}

function mxSwimlaneManager(a, b, c, d) {
this.horizontal = null != b ? b :!0, this.addEnabled = null != c ? c :!0, this.resizeEnabled = null != d ? d :!0, 
this.addHandler = mxUtils.bind(this, function(a, b) {
this.isEnabled() && this.isAddEnabled() && this.cellsAdded(b.getProperty("cells"));
}), this.resizeHandler = mxUtils.bind(this, function(a, b) {
this.isEnabled() && this.isResizeEnabled() && this.cellsResized(b.getProperty("cells"));
}), this.setGraph(a);
}

function mxTemporaryCellStates(a, b, c) {
if (this.view = a, b = null != b ? b :1, this.oldBounds = a.getGraphBounds(), this.oldStates = a.getStates(), 
this.oldScale = a.getScale(), a.setStates(new mxDictionary()), a.setScale(b), null != c) {
b = a.createState(new mxCell());
for (var d = 0; d < c.length; d++) a.validateBounds(b, c[d]);
for (var e = null, d = 0; d < c.length; d++) {
var f = a.validatePoints(b, c[d]);
null == e ? e = f :e.add(f);
}
null == e && (e = new mxRectangle()), a.setGraphBounds(e);
}
}

function mxCellStatePreview(a) {
this.graph = a, this.deltas = {};
}

function mxConnectionConstraint(a, b) {
this.point = a, this.perimeter = null != b ? b :!0;
}

function mxGraphHandler(a) {
this.graph = a, this.graph.addMouseListener(this), this.panHandler = mxUtils.bind(this, function() {
this.updatePreviewShape();
}), this.graph.addListener(mxEvent.PAN, this.panHandler);
}

function mxPanningHandler(a, b) {
null != a && (this.graph = a, this.factoryMethod = b, this.graph.addMouseListener(this), 
this.init());
}

function mxCellMarker(a, b, c, d) {
mxEventSource.call(this), null != a && (this.graph = a, this.validColor = null != b ? b :mxConstants.DEFAULT_VALID_COLOR, 
this.invalidColor = null != b ? c :mxConstants.DEFAULT_INVALID_COLOR, this.hotspot = null != d ? d :mxConstants.DEFAULT_HOTSPOT, 
this.highlight = new mxCellHighlight(a));
}

function mxSelectionCellsHandler(a) {
mxEventSource.call(this), this.graph = a, this.handlers = new mxDictionary(), this.graph.addMouseListener(this), 
this.refreshHandler = mxUtils.bind(this, function() {
this.isEnabled() && this.refresh();
}), this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.refreshHandler), 
this.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler), this.graph.getView().addListener(mxEvent.SCALE, this.refreshHandler), 
this.graph.getView().addListener(mxEvent.TRANSLATE, this.refreshHandler), this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.refreshHandler), 
this.graph.getView().addListener(mxEvent.DOWN, this.refreshHandler), this.graph.getView().addListener(mxEvent.UP, this.refreshHandler);
}

function mxConnectionHandler(a, b) {
mxEventSource.call(this), null != a && (this.graph = a, this.factoryMethod = b, 
this.init());
}

function mxConstraintHandler(a) {
this.graph = a;
}

function mxRubberband(a) {
null != a && (this.graph = a, this.graph.addMouseListener(this), this.panHandler = mxUtils.bind(this, function() {
this.repaint();
}), this.graph.addListener(mxEvent.PAN, this.panHandler), mxClient.IS_IE && mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
this.destroy();
})));
}

function mxVertexHandler(a) {
null != a && (this.state = a, this.init());
}

function mxEdgeHandler(a) {
null != a && (this.state = a, this.init());
}

function mxElbowEdgeHandler(a) {
mxEdgeHandler.call(this, a);
}

function mxEdgeSegmentHandler(a) {
mxEdgeHandler.call(this, a);
}

function mxKeyHandler(a, b) {
null != a && (this.graph = a, this.target = b || document.documentElement, this.normalKeys = [], 
this.shiftKeys = [], this.controlKeys = [], this.controlShiftKeys = [], mxEvent.addListener(this.target, "keydown", mxUtils.bind(this, function(a) {
this.keyDown(a);
})), mxClient.IS_IE && mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
this.destroy();
})));
}

function mxTooltipHandler(a, b) {
null != a && (this.graph = a, this.delay = b || 500, this.graph.addMouseListener(this));
}

function mxCellTracker(a, b, c) {
mxCellMarker.call(this, a, b), this.graph.addMouseListener(this), null != c && (this.getCell = c), 
mxClient.IS_IE && mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
this.destroy();
}));
}

function mxCellHighlight(a, b, c, d) {
null != a && (this.graph = a, this.highlightColor = null != b ? b :mxConstants.DEFAULT_VALID_COLOR, 
this.strokeWidth = null != c ? c :mxConstants.HIGHLIGHT_STROKEWIDTH, this.dashed = null != d ? d :!1, 
this.repaintHandler = mxUtils.bind(this, function() {
null != this.state && (this.state = this.graph.view.getState(this.state.cell), null == this.state ? this.hide() :this.repaint());
}), this.graph.getView().addListener(mxEvent.SCALE, this.repaintHandler), this.graph.getView().addListener(mxEvent.TRANSLATE, this.repaintHandler), 
this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler), 
this.graph.getModel().addListener(mxEvent.CHANGE, this.repaintHandler), this.resetHandler = mxUtils.bind(this, function() {
this.hide();
}), this.graph.getView().addListener(mxEvent.DOWN, this.resetHandler), this.graph.getView().addListener(mxEvent.UP, this.resetHandler));
}

function mxDefaultKeyHandler(a) {
if (null != a) {
this.editor = a, this.handler = new mxKeyHandler(a.graph);
var b = this.handler.escape;
this.handler.escape = function(c) {
b.apply(this, arguments), a.hideProperties(), a.fireEvent(new mxEventObject(mxEvent.ESCAPE, "event", c));
};
}
}

function mxDefaultPopupMenu(a) {
this.config = a;
}

function mxDefaultToolbar(a, b) {
this.editor = b, null != a && null != b && this.init(a);
}

function mxEditor(a) {
this.actions = [], this.addActions(), null != document.body && (this.cycleAttributeValues = [], 
this.popupHandler = new mxDefaultPopupMenu(), this.undoManager = new mxUndoManager(), 
this.graph = this.createGraph(), this.toolbar = this.createToolbar(), this.keyHandler = new mxDefaultKeyHandler(this), 
this.configure(a), this.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName, 
!mxClient.IS_LOCAL && null != this.urlInit && (this.session = this.createSession()), 
null != this.onInit && this.onInit(), mxClient.IS_IE && mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
this.destroy();
})));
}

function mxCodec(a) {
this.document = a || mxUtils.createXmlDocument(), this.objects = [];
}

function mxObjectCodec(a, b, c, d) {
this.template = a, this.exclude = null != b ? b :[], this.idrefs = null != c ? c :[], 
this.mapping = null != d ? d :[], this.reverse = {};
for (var e in this.mapping) this.reverse[this.mapping[e]] = e;
}

/**
 * $Id: Actions.js,v 1.9 2013/04/10 11:26:47 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
function Actions(editorUi) {
this.editorUi = editorUi, this.actions = new Object(), this.init();
}

function Action(label, funct, enabled, iconCls, shortcut) {
mxEventSource.call(this), this.label = label, this.funct = funct, this.enabled = null != enabled ? enabled :!0, 
this.iconCls = iconCls, this.shortcut = shortcut;
}

/**
 * $Id: Dialogs.js,v 1.7 2013/05/07 06:54:12 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
function Dialog(editorUi, elt, w, h, modal, closable, onClose) {
var dx = 0;
mxClient.IS_IE && 9 != document.documentMode && (dx = 60), w += dx, h += dx;
var left = Math.max(0, Math.round((document.body.scrollWidth - w) / 2)), top = Math.max(0, Math.round((Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) - h) / 3)), div = editorUi.createDiv("geDialog");
if (div.style.width = w + "px", div.style.height = h + "px", div.style.left = left + "px", 
div.style.top = top + "px", null == this.bg && (this.bg = editorUi.createDiv("background"), 
this.bg.style.position = "absolute", this.bg.style.background = "white", this.bg.style.left = "0px", 
this.bg.style.top = "0px", this.bg.style.bottom = "0px", this.bg.style.right = "0px", 
mxUtils.setOpacity(this.bg, 80), mxClient.IS_QUIRKS && new mxDivResizer(this.bg)), 
modal && document.body.appendChild(this.bg), div.appendChild(elt), document.body.appendChild(div), 
closable) {
var img = document.createElement("img");
img.setAttribute("src", IMAGE_PATH + "/close.png"), img.setAttribute("title", mxResources.get("close")), 
img.className = "geDialogClose", img.style.top = top + 14 + "px", img.style.left = left + w + 38 - dx + "px", 
mxEvent.addListener(img, "click", mxUtils.bind(this, function() {
editorUi.hideDialog();
})), document.body.appendChild(img), this.dialogImg = img;
}
this.onDialogClose = onClose, this.container = div;
}

function OpenDialog() {
var iframe = document.createElement("iframe");
iframe.style.backgroundColor = "transparent", iframe.allowTransparency = "true", 
iframe.style.borderStyle = "none", iframe.style.borderWidth = "0px", iframe.style.overflow = "hidden", 
iframe.frameBorder = "0", iframe.setAttribute("width", "320px"), iframe.setAttribute("height", "190px"), 
iframe.setAttribute("src", OPEN_FORM), this.container = iframe;
}

function ColorDialog(editorUi, color, apply) {
function addPresets(presets, rowLength) {
rowLength = null != rowLength ? rowLength :12;
var table = document.createElement("table");
table.style.borderCollapse = "collapse", table.setAttribute("cellspacing", "0"), 
table.style.marginBottom = "20px", table.style.cellSpacing = "0px";
var tbody = document.createElement("tbody");
table.appendChild(tbody);
for (var rows = presets.length / rowLength, row = 0; rows > row; row++) {
for (var tr = document.createElement("tr"), i = 0; rowLength > i; i++) !function(clr) {
var td = document.createElement("td");
td.style.border = "1px solid black", td.style.padding = "0px", td.style.width = "16px", 
td.style.height = "16px", "none" == clr ? td.style.background = "url('" + IMAGE_PATH + "/nocolor.png')" :td.style.backgroundColor = "#" + clr, 
tr.appendChild(td), mxEvent.addListener(td, "click", function() {
"none" == clr ? (picker.fromString("ffffff"), input.value = "none") :picker.fromString(clr);
});
}(presets[row * rowLength + i]);
tbody.appendChild(tr);
}
return center.appendChild(table), table;
}
this.editorUi = editorUi;
var input = document.createElement("input");
input.style.marginBottom = "10px", input.style.width = "216px", mxClient.IS_IE && (input.style.marginTop = "10px", 
document.body.appendChild(input));
var picker = new jscolor.color(input);
picker.pickerOnfocus = !1, picker.showPicker();
var div = document.createElement("div");
jscolor.picker.box.style.position = "relative", jscolor.picker.box.style.width = "230px", 
jscolor.picker.box.style.height = "100px", jscolor.picker.box.style.paddingBottom = "10px", 
div.appendChild(jscolor.picker.box);
var center = document.createElement("center");
div.appendChild(input), mxUtils.br(div);
var table = addPresets([ "E6D0DE", "CDA2BE", "B5739D", "E1D5E7", "C3ABD0", "A680B8", "D4E1F5", "A9C4EB", "7EA6E0", "D5E8D4", "9AC7BF", "67AB9F", "D5E8D4", "B9E0A5", "97D077", "FFF2CC", "FFE599", "FFD966", "FFF4C3", "FFCE9F", "FFB570", "F8CECC", "F19C99", "EA6B66" ], 12);
table.style.marginBottom = "8px", table = addPresets([ "none", "FFFFFF", "E6E6E6", "CCCCCC", "B3B3B3", "999999", "808080", "666666", "4D4D4D", "333333", "1A1A1A", "000000", "FFCCCC", "FFE6CC", "FFFFCC", "E6FFCC", "CCFFCC", "CCFFE6", "CCFFFF", "CCE5FF", "CCCCFF", "E5CCFF", "FFCCFF", "FFCCE6", "FF9999", "FFCC99", "FFFF99", "CCFF99", "99FF99", "99FFCC", "99FFFF", "99CCFF", "9999FF", "CC99FF", "FF99FF", "FF99CC", "FF6666", "FFB366", "FFFF66", "B3FF66", "66FF66", "66FFB3", "66FFFF", "66B2FF", "6666FF", "B266FF", "FF66FF", "FF66B3", "FF3333", "FF9933", "FFFF33", "99FF33", "33FF33", "33FF99", "33FFFF", "3399FF", "3333FF", "9933FF", "FF33FF", "FF3399", "FF0000", "FF8000", "FFFF00", "80FF00", "00FF00", "00FF80", "00FFFF", "007FFF", "0000FF", "7F00FF", "FF00FF", "FF0080", "CC0000", "CC6600", "CCCC00", "66CC00", "00CC00", "00CC66", "00CCCC", "0066CC", "0000CC", "6600CC", "CC00CC", "CC0066", "990000", "994C00", "999900", "4D9900", "009900", "00994D", "009999", "004C99", "000099", "4C0099", "990099", "99004D", "660000", "663300", "666600", "336600", "006600", "006633", "006666", "003366", "000066", "330066", "660066", "660033", "330000", "331A00", "333300", "1A3300", "003300", "00331A", "003333", "001933", "000033", "190033", "330033", "33001A" ]), 
table.style.marginBottom = "16px", div.appendChild(center);
var buttons = document.createElement("div");
buttons.style.textAlign = "right", buttons.style.whiteSpace = "nowrap";
var applyFunction = null != apply ? apply :this.createApplyFunction();
buttons.appendChild(mxUtils.button(mxResources.get("apply"), function() {
var color = input.value;
"none" != color && (color = "#" + color), applyFunction(color), editorUi.hideDialog();
})), buttons.appendChild(mxUtils.button(mxResources.get("cancel"), function() {
editorUi.hideDialog();
})), null != color && ("none" == color ? (picker.fromString("ffffff"), input.value = "none") :picker.fromString(color)), 
div.appendChild(buttons), this.picker = picker, this.colorInput = input, this.container = div;
}

function AboutDialog(editorUi) {
var div = document.createElement("div");
div.setAttribute("align", "center");
var h3 = document.createElement("h3");
mxUtils.write(h3, mxResources.get("about") + " GraphEditor"), div.appendChild(h3);
var img = document.createElement("img");
img.style.border = "0px", img.setAttribute("width", "176"), img.setAttribute("width", "151"), 
img.setAttribute("src", IMAGE_PATH + "/logo.png"), div.appendChild(img), mxUtils.br(div), 
mxUtils.write(div, "Powered by mxGraph " + mxClient.VERSION), mxUtils.br(div);
var link = document.createElement("a");
link.setAttribute("href", "http://www.jgraph.com/"), link.setAttribute("target", "_blank"), 
mxUtils.write(link, "www.jgraph.com"), div.appendChild(link), mxUtils.br(div), mxUtils.br(div), 
div.appendChild(mxUtils.button(mxResources.get("close"), function() {
editorUi.hideDialog();
})), this.container = div;
}

function PageSetupDialog(editorUi) {
var row, td, graph = editorUi.editor.graph, a4 = mxConstants.PAGE_FORMAT_A4_PORTRAIT, pf = graph.pageFormat.width == a4.width && graph.pageFormat.height == a4.height || graph.pageFormat.height == a4.width && graph.pageFormat.width == a4.height ? a4 :mxConstants.PAGE_FORMAT_LETTER_PORTRAIT, table = document.createElement("table");
table.style.width = "100%", table.style.height = "100%";
var tbody = document.createElement("tbody");
row = document.createElement("tr"), td = document.createElement("td"), td.style.fontSize = "10pt", 
mxUtils.write(td, mxResources.get("paperSize") + ":"), row.appendChild(td);
var paperSizeSelect = document.createElement("select"), paperSizeA4Option = document.createElement("option");
paperSizeA4Option.setAttribute("value", "a4"), mxUtils.write(paperSizeA4Option, "A4"), 
paperSizeSelect.appendChild(paperSizeA4Option);
var paperSizeLetterOption = document.createElement("option");
paperSizeLetterOption.setAttribute("value", "letter"), mxUtils.write(paperSizeLetterOption, "Letter"), 
paperSizeSelect.appendChild(paperSizeLetterOption), pf === mxConstants.PAGE_FORMAT_LETTER_PORTRAIT && paperSizeLetterOption.setAttribute("selected", "selected"), 
td = document.createElement("td"), td.style.fontSize = "10pt", td.appendChild(paperSizeSelect), 
row.appendChild(td), tbody.appendChild(row), row = document.createElement("tr"), 
td = document.createElement("td"), row.appendChild(td);
var landscapeCheckBox = document.createElement("input");
landscapeCheckBox.setAttribute("type", "checkbox"), graph.pageFormat.width == pf.height && landscapeCheckBox.setAttribute("checked", "checked"), 
td = document.createElement("td"), td.style.padding = "4 0 16 2px", td.style.fontSize = "10pt", 
td.appendChild(landscapeCheckBox), mxUtils.write(td, " " + mxResources.get("landscape")), 
row.appendChild(td), tbody.appendChild(row), row = document.createElement("tr"), 
td = document.createElement("td"), td.style.fontSize = "10pt", td.style.width = "130px", 
mxUtils.write(td, mxResources.get("pageScale") + ":"), row.appendChild(td);
var pageScaleInput = document.createElement("input");
pageScaleInput.setAttribute("value", 100 * editorUi.editor.graph.pageScale + "%"), 
pageScaleInput.style.width = "60px", td = document.createElement("td"), td.appendChild(pageScaleInput), 
row.appendChild(td), tbody.appendChild(row), row = document.createElement("tr"), 
td = document.createElement("td"), td.colSpan = 2, td.style.paddingTop = "40px", 
td.setAttribute("align", "right"), td.appendChild(mxUtils.button(mxResources.get("ok"), function() {
editorUi.hideDialog();
var ls = landscapeCheckBox.checked;
graph.pageFormat = "letter" == paperSizeSelect.value ? ls ? mxConstants.PAGE_FORMAT_LETTER_LANDSCAPE :mxConstants.PAGE_FORMAT_LETTER_PORTRAIT :ls ? mxConstants.PAGE_FORMAT_A4_LANDSCAPE :mxConstants.PAGE_FORMAT_A4_PORTRAIT, 
editorUi.editor.outline.outline.pageFormat = graph.pageFormat, graph.pageScale = parseInt(pageScaleInput.value) / 100, 
graph.pageVisible ? (editorUi.editor.updateGraphComponents(), graph.view.validateBackground(), 
graph.sizeDidChange(), editorUi.editor.outline.update()) :editorUi.actions.get("pageView").funct();
})), td.appendChild(mxUtils.button(mxResources.get("cancel"), function() {
editorUi.hideDialog();
})), row.appendChild(td), tbody.appendChild(row), tbody.appendChild(row), table.appendChild(tbody), 
this.container = table;
}

function PrintDialog(editorUi) {
function preview() {
var ls = landscapeCheckBox.checked, pf = "letter" == paperSizeSelect.value ? ls ? mxConstants.PAGE_FORMAT_LETTER_LANDSCAPE :mxConstants.PAGE_FORMAT_LETTER_PORTRAIT :ls ? mxConstants.PAGE_FORMAT_A4_LANDSCAPE :mxConstants.PAGE_FORMAT_A4_PORTRAIT, scale = 1 / graph.pageScale;
if (pageCountCheckBox.checked) {
var pageCount = parseInt(pageCountInput.value);
isNaN(pageCount) || (scale = mxUtils.getScaleForPageCount(pageCount, graph, pf));
}
var gb = graph.getGraphBounds(), autoOrigin = pageCountCheckBox.checked, border = 0, x0 = 0, y0 = 0, x = gb.width > 0 ? gb.x / graph.view.scale - graph.view.translate.x :0, y = gb.height > 0 ? gb.y / graph.view.scale - graph.view.translate.y :0;
if (0 > x || 0 > y) if (autoOrigin = !0, graph.pageVisible) {
var ps = graph.pageScale, pw = pf.width * ps, ph = pf.height * ps;
x0 = x > 0 ? x :pf.width * -Math.floor(Math.min(0, x) / pw) + Math.min(0, x) / graph.pageScale, 
y0 = y > 0 ? y :pf.height * -Math.floor(Math.min(0, y) / ph) + Math.min(0, y) / graph.pageScale;
} else x0 = 10, y0 = 10;
var preview = new mxPrintPreview(graph, scale, pf, border, x0, y0);
return preview.title = mxResources.get("preview"), preview.autoOrigin = autoOrigin, 
preview.open();
}
var row, td, graph = editorUi.editor.graph, a4 = mxConstants.PAGE_FORMAT_A4_PORTRAIT, pf = graph.pageFormat.width == a4.width && graph.pageFormat.height == a4.height || graph.pageFormat.height == a4.width && graph.pageFormat.width == a4.height ? a4 :mxConstants.PAGE_FORMAT_LETTER_PORTRAIT, table = document.createElement("table");
table.style.width = "100%", table.style.height = "100%";
var tbody = document.createElement("tbody");
row = document.createElement("tr"), td = document.createElement("td"), td.style.fontSize = "10pt", 
mxUtils.write(td, mxResources.get("paperSize") + ":"), row.appendChild(td);
var paperSizeSelect = document.createElement("select"), paperSizeA4Option = document.createElement("option");
paperSizeA4Option.setAttribute("value", "a4"), mxUtils.write(paperSizeA4Option, "A4"), 
paperSizeSelect.appendChild(paperSizeA4Option);
var paperSizeLetterOption = document.createElement("option");
paperSizeLetterOption.setAttribute("value", "letter"), mxUtils.write(paperSizeLetterOption, "Letter"), 
paperSizeSelect.appendChild(paperSizeLetterOption), pf === mxConstants.PAGE_FORMAT_LETTER_PORTRAIT && paperSizeLetterOption.setAttribute("selected", "selected"), 
td = document.createElement("td"), td.style.fontSize = "10pt", td.appendChild(paperSizeSelect), 
row.appendChild(td), tbody.appendChild(row), row = document.createElement("tr"), 
td = document.createElement("td"), row.appendChild(td);
var landscapeCheckBox = document.createElement("input");
landscapeCheckBox.setAttribute("type", "checkbox"), graph.pageFormat.width == pf.height && landscapeCheckBox.setAttribute("checked", "checked"), 
td = document.createElement("td"), td.style.padding = "4 0 16 2px", td.style.fontSize = "10pt", 
td.appendChild(landscapeCheckBox), mxUtils.write(td, " " + mxResources.get("landscape")), 
row.appendChild(td), tbody.appendChild(row), row = document.createElement("tr");
var pageCountCheckBox = document.createElement("input");
pageCountCheckBox.setAttribute("type", "checkbox"), td = document.createElement("td"), 
td.style.paddingRight = "10px", td.style.fontSize = "10pt", td.appendChild(pageCountCheckBox), 
mxUtils.write(td, " " + mxResources.get("posterPrint") + ":"), row.appendChild(td);
var pageCountInput = document.createElement("input");
pageCountInput.setAttribute("value", "1"), pageCountInput.setAttribute("type", "number"), 
pageCountInput.setAttribute("min", "1"), pageCountInput.setAttribute("size", "4"), 
pageCountInput.setAttribute("disabled", "disabled"), pageCountInput.style.width = "50px", 
td = document.createElement("td"), td.style.fontSize = "10pt", td.appendChild(pageCountInput), 
mxUtils.write(td, " " + mxResources.get("pages")), row.appendChild(td), tbody.appendChild(row), 
mxEvent.addListener(pageCountCheckBox, "change", function() {
pageCountCheckBox.checked ? pageCountInput.removeAttribute("disabled") :pageCountInput.setAttribute("disabled", "disabled");
}), row = document.createElement("tr"), td = document.createElement("td"), td.colSpan = 2, 
td.style.paddingTop = "40px", td.setAttribute("align", "right"), td.appendChild(mxUtils.button(mxResources.get("print"), function() {
editorUi.hideDialog(), preview().print();
})), td.appendChild(mxUtils.button(mxResources.get("preview"), function() {
editorUi.hideDialog(), preview();
})), td.appendChild(mxUtils.button(mxResources.get("cancel"), function() {
editorUi.hideDialog();
})), row.appendChild(td), tbody.appendChild(row), tbody.appendChild(row), table.appendChild(tbody), 
this.container = table;
}

function SaveDialog(editorUi) {
var row, td, table = document.createElement("table"), tbody = document.createElement("tbody");
row = document.createElement("tr"), td = document.createElement("td"), td.style.fontSize = "10pt", 
td.style.width = "100px", mxUtils.write(td, mxResources.get("filename") + ":"), 
row.appendChild(td);
var nameInput = document.createElement("input");
nameInput.setAttribute("value", editorUi.editor.getOrCreateFilename()), nameInput.style.width = "180px", 
td = document.createElement("td"), td.appendChild(nameInput), row.appendChild(td), 
tbody.appendChild(row), row = document.createElement("tr"), td = document.createElement("td"), 
td.colSpan = 2, td.style.paddingTop = "30px", td.style.whiteSpace = "nowrap", td.setAttribute("align", "right");
var saveBtn = mxUtils.button(mxResources.get("save"), function() {
editorUi.save(nameInput.value), editorUi.hideDialog();
});
td.appendChild(saveBtn), td.appendChild(mxUtils.button(mxResources.get("cancel"), function() {
editorUi.hideDialog();
})), row.appendChild(td), tbody.appendChild(row), tbody.appendChild(row), table.appendChild(tbody), 
this.container = table;
}

function EditFileDialog(editorUi) {
function handleDrop(evt) {
if (evt.stopPropagation(), evt.preventDefault(), evt.dataTransfer.files.length > 0) {
var file = evt.dataTransfer.files[0], reader = new FileReader();
reader.onload = function(e) {
textarea.value = e.target.result;
}, reader.readAsText(file);
}
}
function handleDragOver(evt) {
evt.stopPropagation(), evt.preventDefault();
}
var div = document.createElement("div");
div.style.textAlign = "right";
var textarea = document.createElement("textarea");
textarea.style.width = "600px", textarea.style.height = "374px", textarea.value = mxUtils.getPrettyXml(editorUi.editor.getGraphXml()), 
div.appendChild(textarea), fileSupport && (textarea.addEventListener("dragover", handleDragOver, !1), 
textarea.addEventListener("drop", handleDrop, !1));
var select = document.createElement("select");
select.style.width = "180px";
var newOption = document.createElement("option");
newOption.setAttribute("value", "new"), mxUtils.write(newOption, mxResources.get("openInNewWindow")), 
select.appendChild(newOption);
var replaceOption = document.createElement("option");
replaceOption.setAttribute("value", "replace"), mxUtils.write(replaceOption, mxResources.get("replaceExistingDrawing")), 
select.appendChild(replaceOption);
var importOption = document.createElement("option");
importOption.setAttribute("value", "import"), mxUtils.write(importOption, mxResources.get("addToExistingDrawing")), 
select.appendChild(importOption), div.appendChild(select), div.appendChild(mxUtils.button(mxResources.get("ok"), function() {
if ("new" == select.value) window.openFile = new OpenFile(function() {
editorUi.hideDialog(), window.openFile = null;
}), window.openFile.setData(textarea.value, null), window.open(editorUi.getUrl()); else if ("replace" == select.value) {
var doc = mxUtils.parseXml(textarea.value);
editorUi.editor.setGraphXml(doc.documentElement), editorUi.hideDialog();
} else if ("import" == select.value) {
var doc = mxUtils.parseXml(textarea.value), model = new mxGraphModel(), codec = new mxCodec(doc);
codec.decode(doc.documentElement, model);
var children = model.getChildren(model.getChildAt(model.getRoot(), 0));
editorUi.editor.graph.setSelectionCells(editorUi.editor.graph.importCells(children)), 
editorUi.hideDialog();
}
})), div.appendChild(mxUtils.button(mxResources.get("cancel"), function() {
editorUi.hideDialog();
})), this.container = div;
}

function ExportDialog(editorUi) {
function formatChanged() {
var name = nameInput.value, dot = name.lastIndexOf(".");
nameInput.value = dot > 0 ? name.substring(0, dot + 1) + imageFormatSelect.value :name + "." + imageFormatSelect.value, 
"xml" === imageFormatSelect.value ? (widthInput.setAttribute("disabled", "true"), 
heightInput.setAttribute("disabled", "true"), borderInput.setAttribute("disabled", "true")) :(widthInput.removeAttribute("disabled"), 
heightInput.removeAttribute("disabled"), borderInput.removeAttribute("disabled"));
}
function checkValues() {
widthInput.style.backgroundColor = widthInput.value * heightInput.value > MAX_AREA || widthInput.value < 0 ? "red" :"", 
heightInput.style.backgroundColor = widthInput.value * heightInput.value > MAX_AREA || heightInput.value < 0 ? "red" :"";
}
var row, td, graph = editorUi.editor.graph, bounds = graph.getGraphBounds(), scale = graph.view.scale, width = Math.ceil(bounds.width / scale), height = Math.ceil(bounds.height / scale), table = document.createElement("table"), tbody = document.createElement("tbody");
row = document.createElement("tr"), td = document.createElement("td"), td.style.fontSize = "10pt", 
td.style.width = "100px", mxUtils.write(td, mxResources.get("filename") + ":"), 
row.appendChild(td);
var nameInput = document.createElement("input");
nameInput.setAttribute("value", editorUi.editor.getOrCreateFilename()), nameInput.style.width = "180px", 
td = document.createElement("td"), td.appendChild(nameInput), row.appendChild(td), 
tbody.appendChild(row), row = document.createElement("tr"), td = document.createElement("td"), 
td.style.fontSize = "10pt", mxUtils.write(td, mxResources.get("format") + ":"), 
row.appendChild(td);
var imageFormatSelect = document.createElement("select");
imageFormatSelect.style.width = "180px";
var pngOption = document.createElement("option");
pngOption.setAttribute("value", "png"), mxUtils.write(pngOption, "PNG - Portable Network Graphics"), 
imageFormatSelect.appendChild(pngOption);
var gifOption = document.createElement("option");
gifOption.setAttribute("value", "gif"), mxUtils.write(gifOption, "GIF - Graphics Interchange Format"), 
imageFormatSelect.appendChild(gifOption);
var jpgOption = document.createElement("option");
jpgOption.setAttribute("value", "jpg"), mxUtils.write(jpgOption, "JPG - JPEG File Interchange Format"), 
imageFormatSelect.appendChild(jpgOption);
var pdfOption = document.createElement("option");
pdfOption.setAttribute("value", "pdf"), mxUtils.write(pdfOption, "PDF - Portable Document Format"), 
imageFormatSelect.appendChild(pdfOption);
var svgOption = document.createElement("option");
svgOption.setAttribute("value", "svg"), mxUtils.write(svgOption, "SVG - Scalable Vector Graphics"), 
imageFormatSelect.appendChild(svgOption);
var xmlOption = document.createElement("option");
xmlOption.setAttribute("value", "xml"), mxUtils.write(xmlOption, "XML - Diagramly XML Document"), 
imageFormatSelect.appendChild(xmlOption), td = document.createElement("td"), td.appendChild(imageFormatSelect), 
row.appendChild(td), tbody.appendChild(row), row = document.createElement("tr"), 
td = document.createElement("td"), td.style.fontSize = "10pt", mxUtils.write(td, mxResources.get("width") + ":"), 
row.appendChild(td);
var widthInput = document.createElement("input");
widthInput.setAttribute("value", width), widthInput.style.width = "180px", td = document.createElement("td"), 
td.appendChild(widthInput), row.appendChild(td), tbody.appendChild(row), row = document.createElement("tr"), 
td = document.createElement("td"), td.style.fontSize = "10pt", mxUtils.write(td, mxResources.get("height") + ":"), 
row.appendChild(td);
var heightInput = document.createElement("input");
heightInput.setAttribute("value", height), heightInput.style.width = "180px", td = document.createElement("td"), 
td.appendChild(heightInput), row.appendChild(td), tbody.appendChild(row), row = document.createElement("tr"), 
td = document.createElement("td"), td.style.fontSize = "10pt", mxUtils.write(td, mxResources.get("borderWidth") + ":"), 
row.appendChild(td);
var borderInput = document.createElement("input");
borderInput.setAttribute("value", width), borderInput.style.width = "180px", borderInput.value = "0", 
td = document.createElement("td"), td.appendChild(borderInput), row.appendChild(td), 
tbody.appendChild(row), table.appendChild(tbody), mxEvent.addListener(imageFormatSelect, "change", formatChanged), 
formatChanged(), mxEvent.addListener(widthInput, "change", function() {
heightInput.value = width > 0 ? Math.ceil(parseInt(widthInput.value) * height / width) :"0", 
checkValues();
}), mxEvent.addListener(heightInput, "change", function() {
widthInput.value = height > 0 ? Math.ceil(parseInt(heightInput.value) * width / height) :"0", 
checkValues();
});
var imgExport = new mxImageExport();
row = document.createElement("tr"), td = document.createElement("td"), td.colSpan = 2, 
td.style.paddingTop = "40px", td.setAttribute("align", "right"), td.appendChild(mxUtils.button(mxResources.get("save"), mxUtils.bind(this, function() {
if (parseInt(widthInput.value) <= 0 && parseInt(heightInput.value) <= 0) mxUtils.alert(mxResources.get("drawingEmpty")); else {
var format = imageFormatSelect.value, name = nameInput.value;
if ("xml" == format) {
var xml = encodeURIComponent(mxUtils.getXml(editorUi.editor.getGraphXml()));
new mxXmlRequest(SAVE_URL, "filename=" + name + "&xml=" + xml).simulate(document, "_blank");
} else if ("svg" == format) {
var b = Math.max(0, parseInt(borderInput.value)) + 1, scale = parseInt(widthInput.value) / width, bounds = graph.getGraphBounds(), vs = graph.view.scale, svgDoc = mxUtils.createXmlDocument(), root = null != svgDoc.createElementNS ? svgDoc.createElementNS(mxConstants.NS_SVG, "svg") :svgDoc.createElement("svg");
null != graph.background && (null != root.style ? root.style.backgroundColor = graph.background :root.setAttribute("style", "background-color:" + graph.background)), 
null == svgDoc.createElementNS && root.setAttribute("xmlns", mxConstants.NS_SVG), 
root.setAttribute("width", Math.ceil(bounds.width * scale / vs + 2 * b) + "px"), 
root.setAttribute("height", Math.ceil(bounds.height * scale / vs + 2 * b) + "px"), 
root.setAttribute("xmlns:xlink", mxConstants.NS_XLINK), root.setAttribute("version", "1.1");
var group = null != svgDoc.createElementNS ? svgDoc.createElementNS(mxConstants.NS_SVG, "g") :svgDoc.createElement("g");
group.setAttribute("transform", "translate(0.5,0.5)"), root.appendChild(group), 
svgDoc.appendChild(root);
var svgCanvas = new mxSvgCanvas2D(group);
svgCanvas.translate(Math.floor((b / scale - bounds.x) / vs), Math.floor((b / scale - bounds.y) / vs)), 
svgCanvas.scale(scale / vs), imgExport.drawState(graph.getView().getState(graph.model.root), svgCanvas);
var xml = mxUtils.getXml(root);
xml.length < MAX_REQUEST_SIZE ? (xml = encodeURIComponent(xml), new mxXmlRequest(SAVE_URL, "filename=" + name + "&format=" + format + "&xml=" + xml).simulate(document, "_blank")) :(mxUtils.alert(mxResources.get("drawingTooLarge")), 
mxUtils.popup(xml));
} else {
var b = Math.max(0, parseInt(borderInput.value)) + 1, scale = parseInt(widthInput.value) / width, bounds = graph.getGraphBounds(), vs = graph.view.scale, xmlDoc = mxUtils.createXmlDocument(), root = xmlDoc.createElement("output");
xmlDoc.appendChild(root);
var xmlCanvas = new mxXmlCanvas2D(root);
xmlCanvas.translate(Math.floor((b / scale - bounds.x) / vs), Math.floor((b / scale - bounds.y) / vs)), 
xmlCanvas.scale(scale / vs), imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);
var w = Math.ceil(bounds.width * scale / vs + 2 * b), h = Math.ceil(bounds.height * scale / vs + 2 * b), xml = mxUtils.getXml(root);
if (xml.length <= MAX_REQUEST_SIZE && w > 0 && h > 0 && MAX_AREA > w * h) {
var bg = graph.background || "#ffffff";
new mxXmlRequest(EXPORT_URL, "filename=" + name + "&format=" + format + "&bg=" + bg + "&w=" + w + "&h=" + h + "&plain=" + encodeURIComponent(xml)).simulate(document, "_blank");
} else mxUtils.alert(mxResources.get("drawingTooLarge"));
}
editorUi.hideDialog();
}
}))), td.appendChild(mxUtils.button(mxResources.get("cancel"), function() {
editorUi.hideDialog();
})), row.appendChild(td), tbody.appendChild(row), tbody.appendChild(row), table.appendChild(tbody), 
this.container = table;
}

function Menubar(editorUi, container) {
this.editorUi = editorUi, this.container = container, mxEvent.addGestureListeners(document, mxUtils.bind(this, function() {
this.hideMenu();
}));
}

function Menu(funct, enabled) {
mxEventSource.call(this), this.funct = funct, this.enabled = null != enabled ? enabled :!0;
}

/**
 * $Id: Sidebar.js,v 1.42 2013/05/07 09:48:56 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
function Sidebar(editorUi, container, choices) {
this.choices = choices, this.editorUi = editorUi, this.container = container, this.palettes = new Object(), 
this.showTooltips = !0, this.graph = new Graph(document.createElement("div"), null, null, this.editorUi.editor.graph.getStylesheet()), 
this.graph.resetViewOnRootChange = !1, this.graph.foldingEnabled = !1, this.graph.setConnectable(!1), 
this.graph.autoScroll = !1, this.graph.setTooltips(!1), this.graph.setEnabled(!1), 
this.graph.container.style.visibility = "hidden", this.graph.container.style.position = "absolute", 
document.body.appendChild(this.graph.container), mxClient.IS_TOUCH || (mxEvent.addListener(document, "mouseup", mxUtils.bind(this, function() {
this.showTooltips = !0;
})), mxEvent.addListener(container, "scroll", mxUtils.bind(this, function() {
this.showTooltips = !0;
})), mxEvent.addListener(document, "mousedown", mxUtils.bind(this, function() {
this.showTooltips = !1, this.hideTooltip();
})), mxEvent.addListener(document, "mousemove", mxUtils.bind(this, function(evt) {
for (var src = mxEvent.getSource(evt); null != src; ) {
if (src == this.currentElt) return;
src = src.parentNode;
}
this.hideTooltip();
})), mxEvent.addListener(document, "mouseout", mxUtils.bind(this, function(evt) {
null == evt.toElement && null == evt.relatedTarget && this.hideTooltip();
}))), this.init(), new Image().src = IMAGE_PATH + "/tooltip.png";
}

/**
 * $Id: Toolbar.js,v 1.4 2013/05/01 13:10:22 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
function Toolbar(editorUi, container) {
this.editorUi = editorUi, this.container = container, this.init(), mxEvent.addGestureListeners(document, mxUtils.bind(this, function() {
this.hideMenu();
}));
}

var requirejs, require, define;

!function(global) {
function isFunction(it) {
return "[object Function]" === ostring.call(it);
}
function isArray(it) {
return "[object Array]" === ostring.call(it);
}
function each(ary, func) {
if (ary) {
var i;
for (i = 0; i < ary.length && (!ary[i] || !func(ary[i], i, ary)); i += 1) ;
}
}
function eachReverse(ary, func) {
if (ary) {
var i;
for (i = ary.length - 1; i > -1 && (!ary[i] || !func(ary[i], i, ary)); i -= 1) ;
}
}
function hasProp(obj, prop) {
return hasOwn.call(obj, prop);
}
function getOwn(obj, prop) {
return hasProp(obj, prop) && obj[prop];
}
function eachProp(obj, func) {
var prop;
for (prop in obj) if (hasProp(obj, prop) && func(obj[prop], prop)) break;
}
function mixin(target, source, force, deepStringMixin) {
return source && eachProp(source, function(value, prop) {
(force || !hasProp(target, prop)) && (deepStringMixin && "string" != typeof value ? (target[prop] || (target[prop] = {}), 
mixin(target[prop], value, force, deepStringMixin)) :target[prop] = value);
}), target;
}
function bind(obj, fn) {
return function() {
return fn.apply(obj, arguments);
};
}
function scripts() {
return document.getElementsByTagName("script");
}
function getGlobal(value) {
if (!value) return value;
var g = global;
return each(value.split("."), function(part) {
g = g[part];
}), g;
}
function makeError(id, msg, err, requireModules) {
var e = new Error(msg + "\nhttp://requirejs.org/docs/errors.html#" + id);
return e.requireType = id, e.requireModules = requireModules, err && (e.originalError = err), 
e;
}
function newContext(contextName) {
function trimDots(ary) {
var i, part;
for (i = 0; ary[i]; i += 1) if (part = ary[i], "." === part) ary.splice(i, 1), i -= 1; else if (".." === part) {
if (1 === i && (".." === ary[2] || ".." === ary[0])) break;
i > 0 && (ary.splice(i - 1, 2), i -= 2);
}
}
function normalize(name, baseName, applyMap) {
var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment, foundMap, foundI, foundStarMap, starI, baseParts = baseName && baseName.split("/"), normalizedBaseParts = baseParts, map = config.map, starMap = map && map["*"];
if (name && "." === name.charAt(0) && (baseName ? (normalizedBaseParts = getOwn(config.pkgs, baseName) ? baseParts = [ baseName ] :baseParts.slice(0, baseParts.length - 1), 
name = normalizedBaseParts.concat(name.split("/")), trimDots(name), pkgConfig = getOwn(config.pkgs, pkgName = name[0]), 
name = name.join("/"), pkgConfig && name === pkgName + "/" + pkgConfig.main && (name = pkgName)) :0 === name.indexOf("./") && (name = name.substring(2))), 
applyMap && (baseParts || starMap) && map) {
for (nameParts = name.split("/"), i = nameParts.length; i > 0; i -= 1) {
if (nameSegment = nameParts.slice(0, i).join("/"), baseParts) for (j = baseParts.length; j > 0; j -= 1) if (mapValue = getOwn(map, baseParts.slice(0, j).join("/")), 
mapValue && (mapValue = getOwn(mapValue, nameSegment))) {
foundMap = mapValue, foundI = i;
break;
}
if (foundMap) break;
!foundStarMap && starMap && getOwn(starMap, nameSegment) && (foundStarMap = getOwn(starMap, nameSegment), 
starI = i);
}
!foundMap && foundStarMap && (foundMap = foundStarMap, foundI = starI), foundMap && (nameParts.splice(0, foundI, foundMap), 
name = nameParts.join("/"));
}
return name;
}
function removeScript(name) {
isBrowser && each(scripts(), function(scriptNode) {
return scriptNode.getAttribute("data-requiremodule") === name && scriptNode.getAttribute("data-requirecontext") === context.contextName ? (scriptNode.parentNode.removeChild(scriptNode), 
!0) :void 0;
});
}
function hasPathFallback(id) {
var pathConfig = getOwn(config.paths, id);
return pathConfig && isArray(pathConfig) && pathConfig.length > 1 ? (removeScript(id), 
pathConfig.shift(), context.require.undef(id), context.require([ id ]), !0) :void 0;
}
function splitPrefix(name) {
var prefix, index = name ? name.indexOf("!") :-1;
return index > -1 && (prefix = name.substring(0, index), name = name.substring(index + 1, name.length)), 
[ prefix, name ];
}
function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
var url, pluginModule, suffix, nameParts, prefix = null, parentName = parentModuleMap ? parentModuleMap.name :null, originalName = name, isDefine = !0, normalizedName = "";
return name || (isDefine = !1, name = "_@r" + (requireCounter += 1)), nameParts = splitPrefix(name), 
prefix = nameParts[0], name = nameParts[1], prefix && (prefix = normalize(prefix, parentName, applyMap), 
pluginModule = getOwn(defined, prefix)), name && (prefix ? normalizedName = pluginModule && pluginModule.normalize ? pluginModule.normalize(name, function(name) {
return normalize(name, parentName, applyMap);
}) :normalize(name, parentName, applyMap) :(normalizedName = normalize(name, parentName, applyMap), 
nameParts = splitPrefix(normalizedName), prefix = nameParts[0], normalizedName = nameParts[1], 
isNormalized = !0, url = context.nameToUrl(normalizedName))), suffix = !prefix || pluginModule || isNormalized ? "" :"_unnormalized" + (unnormalizedCounter += 1), 
{
prefix:prefix,
name:normalizedName,
parentMap:parentModuleMap,
unnormalized:!!suffix,
url:url,
originalName:originalName,
isDefine:isDefine,
id:(prefix ? prefix + "!" + normalizedName :normalizedName) + suffix
};
}
function getModule(depMap) {
var id = depMap.id, mod = getOwn(registry, id);
return mod || (mod = registry[id] = new context.Module(depMap)), mod;
}
function on(depMap, name, fn) {
var id = depMap.id, mod = getOwn(registry, id);
!hasProp(defined, id) || mod && !mod.defineEmitComplete ? getModule(depMap).on(name, fn) :"defined" === name && fn(defined[id]);
}
function onError(err, errback) {
var ids = err.requireModules, notified = !1;
errback ? errback(err) :(each(ids, function(id) {
var mod = getOwn(registry, id);
mod && (mod.error = err, mod.events.error && (notified = !0, mod.emit("error", err)));
}), notified || req.onError(err));
}
function takeGlobalQueue() {
globalDefQueue.length && (apsp.apply(defQueue, [ defQueue.length - 1, 0 ].concat(globalDefQueue)), 
globalDefQueue = []);
}
function cleanRegistry(id) {
delete registry[id];
}
function breakCycle(mod, traced, processed) {
var id = mod.map.id;
mod.error ? mod.emit("error", mod.error) :(traced[id] = !0, each(mod.depMaps, function(depMap, i) {
var depId = depMap.id, dep = getOwn(registry, depId);
!dep || mod.depMatched[i] || processed[depId] || (getOwn(traced, depId) ? (mod.defineDep(i, defined[depId]), 
mod.check()) :breakCycle(dep, traced, processed));
}), processed[id] = !0);
}
function checkLoaded() {
var map, modId, err, usingPathFallback, waitInterval = 1e3 * config.waitSeconds, expired = waitInterval && context.startTime + waitInterval < new Date().getTime(), noLoads = [], reqCalls = [], stillLoading = !1, needCycleCheck = !0;
if (!inCheckLoaded) {
if (inCheckLoaded = !0, eachProp(registry, function(mod) {
if (map = mod.map, modId = map.id, mod.enabled && (map.isDefine || reqCalls.push(mod), 
!mod.error)) if (!mod.inited && expired) hasPathFallback(modId) ? (usingPathFallback = !0, 
stillLoading = !0) :(noLoads.push(modId), removeScript(modId)); else if (!mod.inited && mod.fetched && map.isDefine && (stillLoading = !0, 
!map.prefix)) return needCycleCheck = !1;
}), expired && noLoads.length) return err = makeError("timeout", "Load timeout for modules: " + noLoads, null, noLoads), 
err.contextName = context.contextName, onError(err);
needCycleCheck && each(reqCalls, function(mod) {
breakCycle(mod, {}, {});
}), expired && !usingPathFallback || !stillLoading || !isBrowser && !isWebWorker || checkLoadedTimeoutId || (checkLoadedTimeoutId = setTimeout(function() {
checkLoadedTimeoutId = 0, checkLoaded();
}, 50)), inCheckLoaded = !1;
}
}
function callGetModule(args) {
hasProp(defined, args[0]) || getModule(makeModuleMap(args[0], null, !0)).init(args[1], args[2]);
}
function removeListener(node, func, name, ieName) {
node.detachEvent && !isOpera ? ieName && node.detachEvent(ieName, func) :node.removeEventListener(name, func, !1);
}
function getScriptData(evt) {
var node = evt.currentTarget || evt.srcElement;
return removeListener(node, context.onScriptLoad, "load", "onreadystatechange"), 
removeListener(node, context.onScriptError, "error"), {
node:node,
id:node && node.getAttribute("data-requiremodule")
};
}
function intakeDefines() {
var args;
for (takeGlobalQueue(); defQueue.length; ) {
if (args = defQueue.shift(), null === args[0]) return onError(makeError("mismatch", "Mismatched anonymous define() module: " + args[args.length - 1]));
callGetModule(args);
}
}
var inCheckLoaded, Module, context, handlers, checkLoadedTimeoutId, config = {
waitSeconds:7,
baseUrl:"./",
paths:{},
pkgs:{},
shim:{},
map:{},
config:{}
}, registry = {}, undefEvents = {}, defQueue = [], defined = {}, urlFetched = {}, requireCounter = 1, unnormalizedCounter = 1;
return handlers = {
require:function(mod) {
return mod.require ? mod.require :mod.require = context.makeRequire(mod.map);
},
exports:function(mod) {
return mod.usingExports = !0, mod.map.isDefine ? mod.exports ? mod.exports :mod.exports = defined[mod.map.id] = {} :void 0;
},
module:function(mod) {
return mod.module ? mod.module :mod.module = {
id:mod.map.id,
uri:mod.map.url,
config:function() {
return config.config && getOwn(config.config, mod.map.id) || {};
},
exports:defined[mod.map.id]
};
}
}, Module = function(map) {
this.events = getOwn(undefEvents, map.id) || {}, this.map = map, this.shim = getOwn(config.shim, map.id), 
this.depExports = [], this.depMaps = [], this.depMatched = [], this.pluginMaps = {}, 
this.depCount = 0;
}, Module.prototype = {
init:function(depMaps, factory, errback, options) {
options = options || {}, this.inited || (this.factory = factory, errback ? this.on("error", errback) :this.events.error && (errback = bind(this, function(err) {
this.emit("error", err);
})), this.depMaps = depMaps && depMaps.slice(0), this.errback = errback, this.inited = !0, 
this.ignore = options.ignore, options.enabled || this.enabled ? this.enable() :this.check());
},
defineDep:function(i, depExports) {
this.depMatched[i] || (this.depMatched[i] = !0, this.depCount -= 1, this.depExports[i] = depExports);
},
fetch:function() {
if (!this.fetched) {
this.fetched = !0, context.startTime = new Date().getTime();
var map = this.map;
return this.shim ? (context.makeRequire(this.map, {
enableBuildCallback:!0
})(this.shim.deps || [], bind(this, function() {
return map.prefix ? this.callPlugin() :this.load();
})), void 0) :map.prefix ? this.callPlugin() :this.load();
}
},
load:function() {
var url = this.map.url;
urlFetched[url] || (urlFetched[url] = !0, context.load(this.map.id, url));
},
check:function() {
if (this.enabled && !this.enabling) {
var err, cjsModule, id = this.map.id, depExports = this.depExports, exports = this.exports, factory = this.factory;
if (this.inited) {
if (this.error) this.emit("error", this.error); else if (!this.defining) {
if (this.defining = !0, this.depCount < 1 && !this.defined) {
if (isFunction(factory)) {
if (this.events.error) try {
exports = context.execCb(id, factory, depExports, exports);
} catch (e) {
err = e;
} else exports = context.execCb(id, factory, depExports, exports);
if (this.map.isDefine && (cjsModule = this.module, cjsModule && void 0 !== cjsModule.exports && cjsModule.exports !== this.exports ? exports = cjsModule.exports :void 0 === exports && this.usingExports && (exports = this.exports)), 
err) return err.requireMap = this.map, err.requireModules = [ this.map.id ], err.requireType = "define", 
onError(this.error = err);
} else exports = factory;
this.exports = exports, this.map.isDefine && !this.ignore && (defined[id] = exports, 
req.onResourceLoad && req.onResourceLoad(context, this.map, this.depMaps)), delete registry[id], 
this.defined = !0;
}
this.defining = !1, this.defined && !this.defineEmitted && (this.defineEmitted = !0, 
this.emit("defined", this.exports), this.defineEmitComplete = !0);
}
} else this.fetch();
}
},
callPlugin:function() {
var map = this.map, id = map.id, pluginMap = makeModuleMap(map.prefix);
this.depMaps.push(pluginMap), on(pluginMap, "defined", bind(this, function(plugin) {
var load, normalizedMap, normalizedMod, name = this.map.name, parentName = this.map.parentMap ? this.map.parentMap.name :null, localRequire = context.makeRequire(map.parentMap, {
enableBuildCallback:!0
});
return this.map.unnormalized ? (plugin.normalize && (name = plugin.normalize(name, function(name) {
return normalize(name, parentName, !0);
}) || ""), normalizedMap = makeModuleMap(map.prefix + "!" + name, this.map.parentMap), 
on(normalizedMap, "defined", bind(this, function(value) {
this.init([], function() {
return value;
}, null, {
enabled:!0,
ignore:!0
});
})), normalizedMod = getOwn(registry, normalizedMap.id), normalizedMod && (this.depMaps.push(normalizedMap), 
this.events.error && normalizedMod.on("error", bind(this, function(err) {
this.emit("error", err);
})), normalizedMod.enable()), void 0) :(load = bind(this, function(value) {
this.init([], function() {
return value;
}, null, {
enabled:!0
});
}), load.error = bind(this, function(err) {
this.inited = !0, this.error = err, err.requireModules = [ id ], eachProp(registry, function(mod) {
0 === mod.map.id.indexOf(id + "_unnormalized") && cleanRegistry(mod.map.id);
}), onError(err);
}), load.fromText = bind(this, function(text, textAlt) {
var moduleName = map.name, moduleMap = makeModuleMap(moduleName), hasInteractive = useInteractive;
textAlt && (text = textAlt), hasInteractive && (useInteractive = !1), getModule(moduleMap), 
hasProp(config.config, id) && (config.config[moduleName] = config.config[id]);
try {
req.exec(text);
} catch (e) {
return onError(makeError("fromtexteval", "fromText eval for " + id + " failed: " + e, e, [ id ]));
}
hasInteractive && (useInteractive = !0), this.depMaps.push(moduleMap), context.completeLoad(moduleName), 
localRequire([ moduleName ], load);
}), plugin.load(map.name, localRequire, load, config), void 0);
})), context.enable(pluginMap, this), this.pluginMaps[pluginMap.id] = pluginMap;
},
enable:function() {
this.enabled = !0, this.enabling = !0, each(this.depMaps, bind(this, function(depMap, i) {
var id, mod, handler;
if ("string" == typeof depMap) {
if (depMap = makeModuleMap(depMap, this.map.isDefine ? this.map :this.map.parentMap, !1, !this.skipMap), 
this.depMaps[i] = depMap, handler = getOwn(handlers, depMap.id)) return this.depExports[i] = handler(this), 
void 0;
this.depCount += 1, on(depMap, "defined", bind(this, function(depExports) {
this.defineDep(i, depExports), this.check();
})), this.errback && on(depMap, "error", this.errback);
}
id = depMap.id, mod = registry[id], hasProp(handlers, id) || !mod || mod.enabled || context.enable(depMap, this);
})), eachProp(this.pluginMaps, bind(this, function(pluginMap) {
var mod = getOwn(registry, pluginMap.id);
mod && !mod.enabled && context.enable(pluginMap, this);
})), this.enabling = !1, this.check();
},
on:function(name, cb) {
var cbs = this.events[name];
cbs || (cbs = this.events[name] = []), cbs.push(cb);
},
emit:function(name, evt) {
each(this.events[name], function(cb) {
cb(evt);
}), "error" === name && delete this.events[name];
}
}, context = {
config:config,
contextName:contextName,
registry:registry,
defined:defined,
urlFetched:urlFetched,
defQueue:defQueue,
Module:Module,
makeModuleMap:makeModuleMap,
nextTick:req.nextTick,
configure:function(cfg) {
cfg.baseUrl && "/" !== cfg.baseUrl.charAt(cfg.baseUrl.length - 1) && (cfg.baseUrl += "/");
var pkgs = config.pkgs, shim = config.shim, objs = {
paths:!0,
config:!0,
map:!0
};
eachProp(cfg, function(value, prop) {
objs[prop] ? "map" === prop ? mixin(config[prop], value, !0, !0) :mixin(config[prop], value, !0) :config[prop] = value;
}), cfg.shim && (eachProp(cfg.shim, function(value, id) {
isArray(value) && (value = {
deps:value
}), !value.exports && !value.init || value.exportsFn || (value.exportsFn = context.makeShimExports(value)), 
shim[id] = value;
}), config.shim = shim), cfg.packages && (each(cfg.packages, function(pkgObj) {
var location;
pkgObj = "string" == typeof pkgObj ? {
name:pkgObj
} :pkgObj, location = pkgObj.location, pkgs[pkgObj.name] = {
name:pkgObj.name,
location:location || pkgObj.name,
main:(pkgObj.main || "main").replace(currDirRegExp, "").replace(jsSuffixRegExp, "")
};
}), config.pkgs = pkgs), eachProp(registry, function(mod, id) {
mod.inited || mod.map.unnormalized || (mod.map = makeModuleMap(id));
}), (cfg.deps || cfg.callback) && context.require(cfg.deps || [], cfg.callback);
},
makeShimExports:function(value) {
function fn() {
var ret;
return value.init && (ret = value.init.apply(global, arguments)), ret || value.exports && getGlobal(value.exports);
}
return fn;
},
makeRequire:function(relMap, options) {
function localRequire(deps, callback, errback) {
var id, map, requireMod;
return options.enableBuildCallback && callback && isFunction(callback) && (callback.__requireJsBuild = !0), 
"string" == typeof deps ? isFunction(callback) ? onError(makeError("requireargs", "Invalid require call"), errback) :relMap && hasProp(handlers, deps) ? handlers[deps](registry[relMap.id]) :req.get ? req.get(context, deps, relMap) :(map = makeModuleMap(deps, relMap, !1, !0), 
id = map.id, hasProp(defined, id) ? defined[id] :onError(makeError("notloaded", 'Module name "' + id + '" has not been loaded yet for context: ' + contextName + (relMap ? "" :". Use require([])")))) :(intakeDefines(), 
context.nextTick(function() {
intakeDefines(), requireMod = getModule(makeModuleMap(null, relMap)), requireMod.skipMap = options.skipMap, 
requireMod.init(deps, callback, errback, {
enabled:!0
}), checkLoaded();
}), localRequire);
}
return options = options || {}, mixin(localRequire, {
isBrowser:isBrowser,
toUrl:function(moduleNamePlusExt) {
var ext, url, index = moduleNamePlusExt.lastIndexOf("."), segment = moduleNamePlusExt.split("/")[0], isRelative = "." === segment || ".." === segment;
return -1 !== index && (!isRelative || index > 1) && (ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length), 
moduleNamePlusExt = moduleNamePlusExt.substring(0, index)), url = context.nameToUrl(normalize(moduleNamePlusExt, relMap && relMap.id, !0), ext || ".fake"), 
ext ? url :url.substring(0, url.length - 5);
},
defined:function(id) {
return hasProp(defined, makeModuleMap(id, relMap, !1, !0).id);
},
specified:function(id) {
return id = makeModuleMap(id, relMap, !1, !0).id, hasProp(defined, id) || hasProp(registry, id);
}
}), relMap || (localRequire.undef = function(id) {
takeGlobalQueue();
var map = makeModuleMap(id, relMap, !0), mod = getOwn(registry, id);
delete defined[id], delete urlFetched[map.url], delete undefEvents[id], mod && (mod.events.defined && (undefEvents[id] = mod.events), 
cleanRegistry(id));
}), localRequire;
},
enable:function(depMap) {
var mod = getOwn(registry, depMap.id);
mod && getModule(depMap).enable();
},
completeLoad:function(moduleName) {
var found, args, mod, shim = getOwn(config.shim, moduleName) || {}, shExports = shim.exports;
for (takeGlobalQueue(); defQueue.length; ) {
if (args = defQueue.shift(), null === args[0]) {
if (args[0] = moduleName, found) break;
found = !0;
} else args[0] === moduleName && (found = !0);
callGetModule(args);
}
if (mod = getOwn(registry, moduleName), !found && !hasProp(defined, moduleName) && mod && !mod.inited) {
if (!(!config.enforceDefine || shExports && getGlobal(shExports))) return hasPathFallback(moduleName) ? void 0 :onError(makeError("nodefine", "No define call for " + moduleName, null, [ moduleName ]));
callGetModule([ moduleName, shim.deps || [], shim.exportsFn ]);
}
checkLoaded();
},
nameToUrl:function(moduleName, ext) {
var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url, parentPath;
if (req.jsExtRegExp.test(moduleName)) url = moduleName + (ext || ""); else {
for (paths = config.paths, pkgs = config.pkgs, syms = moduleName.split("/"), i = syms.length; i > 0; i -= 1) {
if (parentModule = syms.slice(0, i).join("/"), pkg = getOwn(pkgs, parentModule), 
parentPath = getOwn(paths, parentModule)) {
isArray(parentPath) && (parentPath = parentPath[0]), syms.splice(0, i, parentPath);
break;
}
if (pkg) {
pkgPath = moduleName === pkg.name ? pkg.location + "/" + pkg.main :pkg.location, 
syms.splice(0, i, pkgPath);
break;
}
}
url = syms.join("/"), url += ext || (/\?/.test(url) ? "" :".js"), url = ("/" === url.charAt(0) || url.match(/^[\w\+\.\-]+:/) ? "" :config.baseUrl) + url;
}
return config.urlArgs ? url + ((-1 === url.indexOf("?") ? "?" :"&") + config.urlArgs) :url;
},
load:function(id, url) {
req.load(context, id, url);
},
execCb:function(name, callback, args, exports) {
return callback.apply(exports, args);
},
onScriptLoad:function(evt) {
if ("load" === evt.type || readyRegExp.test((evt.currentTarget || evt.srcElement).readyState)) {
interactiveScript = null;
var data = getScriptData(evt);
context.completeLoad(data.id);
}
},
onScriptError:function(evt) {
var data = getScriptData(evt);
return hasPathFallback(data.id) ? void 0 :onError(makeError("scripterror", "Script error", evt, [ data.id ]));
}
}, context.require = context.makeRequire(), context;
}
function getInteractiveScript() {
return interactiveScript && "interactive" === interactiveScript.readyState ? interactiveScript :(eachReverse(scripts(), function(script) {
return "interactive" === script.readyState ? interactiveScript = script :void 0;
}), interactiveScript);
}
var req, s, head, baseElement, dataMain, src, interactiveScript, currentlyAddingScript, mainScript, subPath, version = "2.1.4", commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm, cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g, jsSuffixRegExp = /\.js$/, currDirRegExp = /^\.\//, op = Object.prototype, ostring = op.toString, hasOwn = op.hasOwnProperty, ap = Array.prototype, apsp = ap.splice, isBrowser = !("undefined" == typeof window || !navigator || !document), isWebWorker = !isBrowser && "undefined" != typeof importScripts, readyRegExp = isBrowser && "PLAYSTATION 3" === navigator.platform ? /^complete$/ :/^(complete|loaded)$/, defContextName = "_", isOpera = "undefined" != typeof opera && "[object Opera]" === opera.toString(), contexts = {}, cfg = {}, globalDefQueue = [], useInteractive = !1;
if ("undefined" == typeof define) {
if ("undefined" != typeof requirejs) {
if (isFunction(requirejs)) return;
cfg = requirejs, requirejs = void 0;
}
"undefined" == typeof require || isFunction(require) || (cfg = require, require = void 0), 
req = requirejs = function(deps, callback, errback, optional) {
var context, config, contextName = defContextName;
return isArray(deps) || "string" == typeof deps || (config = deps, isArray(callback) ? (deps = callback, 
callback = errback, errback = optional) :deps = []), config && config.context && (contextName = config.context), 
context = getOwn(contexts, contextName), context || (context = contexts[contextName] = req.s.newContext(contextName)), 
config && context.configure(config), context.require(deps, callback, errback);
}, req.config = function(config) {
return req(config);
}, req.nextTick = "undefined" != typeof setTimeout ? function(fn) {
setTimeout(fn, 4);
} :function(fn) {
fn();
}, require || (require = req), req.version = version, req.jsExtRegExp = /^\/|:|\?|\.js$/, 
req.isBrowser = isBrowser, s = req.s = {
contexts:contexts,
newContext:newContext
}, req({}), each([ "toUrl", "undef", "defined", "specified" ], function(prop) {
req[prop] = function() {
var ctx = contexts[defContextName];
return ctx.require[prop].apply(ctx, arguments);
};
}), isBrowser && (head = s.head = document.getElementsByTagName("head")[0], baseElement = document.getElementsByTagName("base")[0], 
baseElement && (head = s.head = baseElement.parentNode)), req.onError = function(err) {
throw err;
}, req.load = function(context, moduleName, url) {
var node, config = context && context.config || {};
return isBrowser ? (node = config.xhtml ? document.createElementNS("http://www.w3.org/1999/xhtml", "html:script") :document.createElement("script"), 
node.type = config.scriptType || "text/javascript", node.charset = "utf-8", node.async = !0, 
node.setAttribute("data-requirecontext", context.contextName), node.setAttribute("data-requiremodule", moduleName), 
!node.attachEvent || node.attachEvent.toString && node.attachEvent.toString().indexOf("[native code") < 0 || isOpera ? (node.addEventListener("load", context.onScriptLoad, !1), 
node.addEventListener("error", context.onScriptError, !1)) :(useInteractive = !0, 
node.attachEvent("onreadystatechange", context.onScriptLoad)), node.src = url, currentlyAddingScript = node, 
baseElement ? head.insertBefore(node, baseElement) :head.appendChild(node), currentlyAddingScript = null, 
node) :(isWebWorker && (importScripts(url), context.completeLoad(moduleName)), void 0);
}, isBrowser && eachReverse(scripts(), function(script) {
return head || (head = script.parentNode), dataMain = script.getAttribute("data-main"), 
dataMain ? (cfg.baseUrl || (src = dataMain.split("/"), mainScript = src.pop(), subPath = src.length ? src.join("/") + "/" :"./", 
cfg.baseUrl = subPath, dataMain = mainScript), dataMain = dataMain.replace(jsSuffixRegExp, ""), 
cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) :[ dataMain ], !0) :void 0;
}), define = function(name, deps, callback) {
var node, context;
"string" != typeof name && (callback = deps, deps = name, name = null), isArray(deps) || (callback = deps, 
deps = []), !deps.length && isFunction(callback) && callback.length && (callback.toString().replace(commentRegExp, "").replace(cjsRequireRegExp, function(match, dep) {
deps.push(dep);
}), deps = (1 === callback.length ? [ "require" ] :[ "require", "exports", "module" ]).concat(deps)), 
useInteractive && (node = currentlyAddingScript || getInteractiveScript(), node && (name || (name = node.getAttribute("data-requiremodule")), 
context = contexts[node.getAttribute("data-requirecontext")])), (context ? context.defQueue :globalDefQueue).push([ name, deps, callback ]);
}, define.amd = {
jQuery:!0
}, req.exec = function(text) {
return eval(text);
}, req(cfg);
}
}(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var GenericModel, HR, _ref;
return GenericModel = function(_super) {
function GenericModel() {
return GenericModel.__super__.constructor.apply(this, arguments);
}
return __extends(GenericModel, _super), GenericModel.prototype.initialize = function(options) {
return this.on("error", function(_this) {
return function(model, xhr) {
var response;
return response = xhr && xhr.responseText ? JSON.parse(xhr.responseText) :{
message:""
}, void 0 !== _this.disableThrobber && _this.disableThrobber === !0 || (HR.util && HR.util.ajaxmsg && HR.util.ajaxmsg(response.message, !1, !0, 1e4), 
!HR.loadingButton) ? void 0 :HR.util.inlineLoadingEnd(response);
};
}(this)), GenericModel.__super__.initialize.call(this, options);
}, GenericModel.prototype.save = function(key, val, options) {
return void 0 === this.disableThrobber || this.disableThrobber !== !0 ? HR.util && HR.util.ajaxmsg && HR.util.ajaxmsg("Loading...", !1, !0, 1e3) :this.disableThrobber = !1, 
GenericModel.__super__.save.call(this, key, val, options);
}, GenericModel.prototype.destroy = function(options) {
return void 0 === this.disableThrobber || this.disableThrobber !== !0 ? HR.util && HR.util.ajaxmsg && HR.util.ajaxmsg("Loading...", !1, !0, 1e3) :this.disableThrobber = !1, 
GenericModel.__super__.destroy.call(this, options);
}, GenericModel.prototype.parse = function(resp, xhr) {
var model;
return this.sync_status = !0, void 0 === this.disableThrobber || this.disableThrobber !== !0 ? (HR.util && HR.util.ajaxmsg && HR.util.ajaxmsg("", !1, !0, 0), 
HR.loadingButton && HR.util.inlineLoadingEnd(resp)) :this.disableThrobber = !1, 
model = resp && resp.model ? resp.model :resp, GenericModel.__super__.parse.call(this, model, xhr);
}, GenericModel.prototype.fetch = function() {
return this.trigger("initreset"), void 0 === this.disableThrobber || this.disableThrobber !== !0 ? HR.util && HR.util.ajaxmsg && HR.util.ajaxmsg("Loading...", !1, !0, 1e3) :this.disableThrobber = !1, 
Backbone.Model.prototype.fetch.apply(this, arguments);
}, GenericModel.prototype.setCaching = function(caching) {
this.caching = caching;
}, GenericModel;
}(Backbone.Model), HR = null != (_ref = window.HR) ? _ref :{}, HR.GenericModel = GenericModel;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var GenericCollection, HR, _ref;
return GenericCollection = function(_super) {
function GenericCollection() {
return GenericCollection.__super__.constructor.apply(this, arguments);
}
return __extends(GenericCollection, _super), GenericCollection.prototype.initialize = function(options) {
return this.sync_status = !1, this.render_once = !1, this.on("error", function(_this) {
return function(model, xhr) {
var response;
return response = JSON.parse(xhr.responseText), void 0 !== _this.disableThrobber && _this.disableThrobber === !0 || (HR.util && HR.util.ajaxmsg && HR.util.ajaxmsg("", !1, !0, 0), 
!HR.loadingButton) ? void 0 :HR.util.inlineLoadingEnd(response);
};
}(this)), GenericCollection.__super__.initialize.call(this, options);
}, GenericCollection.prototype.fetch = function(options) {
return null == options && (options = {}), this.trigger("initreset"), void 0 === this.disableThrobber || this.disableThrobber !== !0 ? HR.util && HR.util.ajaxmsg && HR.util.ajaxmsg("Loading...", !1, !0, 1e3) :this.disableThrobber = !1, 
Backbone.Collection.prototype.fetch.apply(this, arguments);
}, GenericCollection.prototype.parse = function(resp) {
return this.sync_status = !0, this.render_once = !1, resp.metamodel && (this.metamodel = resp.metamodel), 
"number" == typeof resp.total && (this.total = resp.total), "number" == typeof resp.page && (this.page = resp.page), 
void 0 === this.disableThrobber || this.disableThrobber !== !0 ? (HR.util && HR.util.ajaxmsg && HR.util.ajaxmsg("", !1, !0, 0), 
HR.loadingButton && HR.util.inlineLoadingEnd(resp)) :this.disableThrobber = !1, 
resp.models;
}, GenericCollection.prototype.setCurrentPage = function(page) {
this.page = page;
}, GenericCollection.prototype.getCurrentPage = function() {
return this.page;
}, GenericCollection.prototype.getTotal = function() {
return this.total;
}, GenericCollection;
}(Backbone.Collection), HR = null != (_ref = window.HR) ? _ref :{}, HR.GenericCollection = GenericCollection;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var CandidateActivityModel, CandidateAttemptModel, CandidateCompileTestModel, CandidateDesignTestModel, CandidateQuestionModel, CandidateSolveModel, CandidateTestModel, HR, _ref;
return CandidateTestModel = function(_super) {
function CandidateTestModel() {
return CandidateTestModel.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateTestModel, _super), CandidateTestModel.prototype.idAttribute = "unique_id", 
CandidateTestModel.prototype.initialize = function(attributes, options) {
return null == attributes && (attributes = {}), null == options && (options = {}), 
this.setCaching(!1), CandidateTestModel.__super__.initialize.call(this, attributes, options);
}, CandidateTestModel.prototype.setTidAuth = function(tid, auth) {
this.tid = tid, this.auth = auth;
}, CandidateTestModel.prototype.setAction = function(action) {
this.action = null != action ? action :"show";
}, CandidateTestModel.prototype.url = function() {
switch (this.action) {
case "login":
return "/recruit/tests/" + this.tid + "/login?tauth_key=" + this.auth;

case "show":
return "/recruit/tests/" + this.tid + "?tauth_key=" + this.auth;

case "logout":
return "/recruit/tests/logout";
}
}, CandidateTestModel;
}(window.HR.GenericModel), CandidateAttemptModel = function(_super) {
function CandidateAttemptModel() {
return CandidateAttemptModel.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateAttemptModel, _super), CandidateAttemptModel.prototype.initialize = function(attributes, options) {
return null == attributes && (attributes = {}), null == options && (options = {}), 
this.setCaching(!1), CandidateAttemptModel.__super__.initialize.call(this, attributes, options);
}, CandidateAttemptModel.prototype.setAid = function(aid) {
return this.aid = aid;
}, CandidateAttemptModel.prototype.url = function() {
return "/recruit/attempts/" + this.aid;
}, CandidateAttemptModel;
}(window.HR.GenericModel), CandidateQuestionModel = function(_super) {
function CandidateQuestionModel() {
return CandidateQuestionModel.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateQuestionModel, _super), CandidateQuestionModel.prototype.idAttribute = "unique_id", 
CandidateQuestionModel.prototype.initialize = function(attributes, options) {
return null == attributes && (attributes = {}), null == options && (options = {}), 
this.setCaching(!1), CandidateQuestionModel.__super__.initialize.call(this, attributes, options);
}, CandidateQuestionModel.prototype.setAid = function(aid) {
this.aid = aid;
}, CandidateQuestionModel.prototype.setQid = function(qid) {
this.qid = qid;
}, CandidateQuestionModel.prototype.url = function() {
return "/recruit/attempts/" + this.aid + "/questions/" + this.qid;
}, CandidateQuestionModel;
}(window.HR.GenericModel), CandidateSolveModel = function(_super) {
function CandidateSolveModel() {
return CandidateSolveModel.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateSolveModel, _super), CandidateSolveModel.prototype.initialize = function(attributes, options) {
return null == attributes && (attributes = {}), null == options && (options = {}), 
this.setCaching(!1), CandidateSolveModel.__super__.initialize.call(this, attributes, options);
}, CandidateSolveModel.prototype.setAttempt = function(aid) {
this.aid = aid;
}, CandidateSolveModel.prototype.url = function() {
return "/recruit/attempts/" + this.aid + "/solves/";
}, CandidateSolveModel;
}(window.HR.GenericModel), CandidateCompileTestModel = function(_super) {
function CandidateCompileTestModel() {
return CandidateCompileTestModel.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateCompileTestModel, _super), CandidateCompileTestModel.prototype.initialize = function(attributes, options) {
return null == attributes && (attributes = {}), null == options && (options = {}), 
this.setCaching(!1), CandidateCompileTestModel.__super__.initialize.call(this, attributes, options);
}, CandidateCompileTestModel.prototype.setAid = function(aid) {
this.aid = aid;
}, CandidateCompileTestModel.prototype.setQid = function(qid) {
this.qid = qid;
}, CandidateCompileTestModel.prototype.setAllCases = function(allcases) {
this.allcases = allcases;
}, CandidateCompileTestModel.prototype.url = function() {
return this.id ? "/recruit/attempts/" + this.aid + "/questions/" + this.qid + "/compile_tests/" + this.id :this.allcases ? "/recruit/attempts/" + this.aid + "/questions/" + this.qid + "/compile_tests?allcases=" + this.allcases :"/recruit/attempts/" + this.aid + "/questions/" + this.qid + "/compile_tests";
}, CandidateCompileTestModel;
}(window.HR.GenericModel), CandidateDesignTestModel = function(_super) {
function CandidateDesignTestModel() {
return CandidateDesignTestModel.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateDesignTestModel, _super), CandidateDesignTestModel.prototype.initialize = function(attributes, options) {
return null == attributes && (attributes = {}), null == options && (options = {}), 
this.setCaching(!1), CandidateDesignTestModel.__super__.initialize.call(this, attributes, options);
}, CandidateDesignTestModel.prototype.setAid = function(aid) {
this.aid = aid;
}, CandidateDesignTestModel.prototype.setQid = function(qid) {
this.qid = qid;
}, CandidateDesignTestModel.prototype.url = function() {
return this.id ? "/recruit/attempts/" + this.aid + "/questions/" + this.qid + "/render/" + this.id :"/recruit/attempts/" + this.aid + "/questions/" + this.qid + "/render";
}, CandidateDesignTestModel;
}(window.HR.GenericModel), CandidateActivityModel = function(_super) {
function CandidateActivityModel() {
return CandidateActivityModel.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateActivityModel, _super), CandidateActivityModel.prototype.initialize = function(attributes, options) {
return null == attributes && (attributes = {}), null == options && (options = {}), 
this.setCaching(!1), CandidateActivityModel.__super__.initialize.call(this, attributes, options);
}, CandidateActivityModel.prototype.setAid = function(aid) {
this.aid = aid;
}, CandidateActivityModel.prototype.url = function() {
return "/recruit/attempts/" + this.aid + "/logActivity";
}, CandidateActivityModel;
}(window.HR.GenericModel), HR = null != (_ref = window.HR) ? _ref :{}, HR.CandidateTestModel = CandidateTestModel, 
HR.CandidateAttemptModel = CandidateAttemptModel, HR.CandidateSolveModel = CandidateSolveModel, 
HR.CandidateQuestionModel = CandidateQuestionModel, HR.CandidateCompileTestModel = CandidateCompileTestModel, 
HR.CandidateDesignTestModel = CandidateDesignTestModel, HR.CandidateActivityModel = CandidateActivityModel;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var CandidateActivityCollection, HR, _ref;
return CandidateActivityCollection = function(_super) {
function CandidateActivityCollection() {
return CandidateActivityCollection.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateActivityCollection, _super), CandidateActivityCollection.prototype.model = window.HR.CandidateActivityModel, 
CandidateActivityCollection.prototype.initialize = function() {
return this.limit || (this.limit = 10), this.page = 1, this.total = 0, this.on("add", this.pushEvent, this);
}, CandidateActivityCollection.prototype.setAid = function(aid) {
this.aid = aid;
}, CandidateActivityCollection.prototype.pushEvent = function(model) {
return model.setAid(this.aid), model.save();
}, CandidateActivityCollection.prototype.baseURL = function() {
return "";
}, CandidateActivityCollection.prototype.restURL = function() {
return "" + this.baseURL();
}, CandidateActivityCollection.prototype.getCurrentPage = function() {
return this.page;
}, CandidateActivityCollection.prototype.setPage = function(page) {
this.page = page;
}, CandidateActivityCollection.prototype.getTotal = function() {
return this.total;
}, CandidateActivityCollection.prototype.parse = function(resp, xhr) {
return this.total = resp.total, CandidateActivityCollection.__super__.parse.call(this, resp, xhr);
}, CandidateActivityCollection;
}(window.HR.GenericCollection), HR = null != (_ref = window.HR) ? _ref :{}, HR.CandidateActivityCollection = CandidateActivityCollection;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var CandidateController, HR, _ref;
return CandidateController = function(_super) {
function CandidateController() {
return CandidateController.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateController, _super), CandidateController.prototype.initialize = function(options) {
null == options && (options = {});
}, CandidateController.prototype.namespace = function(contest_slug, rest) {
return null == rest && (rest = !1), contest_slug || (contest_slug = "master"), "master" !== contest_slug || rest ? "/contests/" + contest_slug + "/" :"/";
}, CandidateController.prototype.get_challenge_pageURL = function(contest_slug, challenge_slug) {
var challenge_bit;
return challenge_bit = "challenges/" + challenge_slug, "master" === contest_slug ? "/" + challenge_bit :"/contests/" + contest_slug + "/" + challenge_bit;
}, CandidateController.prototype.contest = function(options) {
return null == options && (options = {}), options.slug && options.slug !== HR.appController.get_current_contest_slug() ? HR.model("contest", {
slug:HR.appController.get_current_contest_slug()
}).cached(options) :(this.current_contest ? this.current_contest.get("slug") !== HR.appController.get_current_contest_slug() && (this.current_contest = HR.model("contest")) :this.current_contest = HR.model("contest"), 
HR.appController.get_current_contest_slug() && this.current_contest.set("slug", HR.appController.get_current_contest_slug()), 
this.current_contest.cached());
}, CandidateController.prototype.get_current_contest_slug = function() {
return this.landing_contest_slug = void 0 === this.landing_contest_slug ? HR.PREFETCH_DATA.metadata.landing_contest_slug :this.landing_contest_slug, 
this.landing_contest_slug;
}, CandidateController.prototype.get_current_contest_namespace = function() {
return this.current_contest_namespace = void 0 === this.current_contest_namespace ? HR.PREFETCH_DATA.metadata.current_contest_namespace :this.current_contest_namespace, 
this.current_contest_namespace;
}, CandidateController.prototype.is_using_contest_namespace = function() {
return this.using_contest_namespace = void 0 === this.using_contest_namespace ? HR.PREFETCH_DATA.metadata.using_contest_namespace :this.using_contest_namespace, 
this.using_contest_namespace;
}, CandidateController.prototype.get_current_contest_home_url = function() {
return "" + HR.appController.get_current_contest_namespace() + "/challenges";
}, CandidateController.prototype.get_current_contest_slug_url = function() {
var slug;
return slug = HR.appController.get_current_contest_slug(), "master" === slug ? "" :"/" + slug;
}, CandidateController.prototype.set_contest_namespace = function(contest_slug) {
return HR.appController.get_current_contest_slug() !== contest_slug && ("master" !== contest_slug ? HR.appView.contestNavigationView.setContestSlug(contest_slug) :HR.appView.contestNavigationView.hide(), 
this.landing_contest_slug = contest_slug, this.current_contest_namespace = "master" === contest_slug ? "" :"/contests/" + contest_slug, 
this.using_contest_namespace = "master" !== contest_slug, this.current_contest = HR.model("contest"), 
HR.appView.navigationView.nav_buttons && HR.appView.navigationView.nav_buttons.updateLinks(), 
HR.appView.countdownTimerView) ? HR.appView.countdownTimerView.setContest(HR.contest().cached()) :void 0;
}, CandidateController.prototype.object = function(suffix, name, attributes, options) {
var Obj, clsName, obj, stringName;
if (stringName = name.toTitleCase() + "-" + suffix, clsName = $.camelCase(stringName), 
Obj = HR[clsName], !Obj && ("model" === suffix ? Obj = this.MODELS_DEF[name] :"collection" === suffix && (Obj = this.COLLECTIONS_DEF[name]), 
!Obj)) throw "HR." + clsName + " is not defined";
return obj = new Obj(attributes, options), obj.contest_slug = (attributes || {}).contest_slug || (options || {}).contest_slug, 
obj;
}, CandidateController.prototype.model = function(name, attributes, options) {
var model;
return model = HR.appController.object("model", name, attributes, options);
}, CandidateController.prototype.collection = function(name, attributes, options) {
return HR.appController.object("collection", name, attributes, options);
}, CandidateController.prototype.profile = function(options) {
return null == options && (options = {}), this._profile && _.size(options) > 0 ? this._profile.cached(options) :this._profile || (this._profile = this.model("profile").cached(options), 
this._profile.listenTo(this._profile, "reset", function(_this) {
return function() {
return HR.key_prefix = _this._profile.get("key_prefix");
};
}(this))), this._profile;
}, CandidateController.prototype.restURL = function(path, restPrefix) {
return restPrefix && (path = "/rest" + path), path;
}, CandidateController.prototype.log = Backbone.log, CandidateController.prototype.staticPath = function(path, base_path) {
return null == base_path && (base_path = null), path = HR.MANIFEST && HR.MANIFEST[path] ? HR.MANIFEST[path] :path, 
HR.PREFETCH_DATA && HR.PREFETCH_DATA.metadata && (base_path || (base_path = HR.PREFETCH_DATA.metadata.asset_path)), 
"" + base_path + "/" + path;
}, CandidateController.prototype.addTemplate = function(logical_path, template) {
return HR.templates[logical_path] = template;
}, CandidateController.prototype.requires = function() {
var callback, errorCallback, number_paths, staticFiles;
return number_paths = arguments.length - 1, callback = _.last(arguments), errorCallback = null, 
"function" == typeof arguments[arguments.length - 2] && (number_paths = arguments.length - 2, 
callback = arguments[arguments.length - 2], errorCallback = _.last(arguments)), 
staticFiles = _.map(_.toArray(arguments).slice(0, number_paths), function() {
return function(path) {
return HR.appController.staticPath("" + path + ".js");
};
}(this)), require(staticFiles, callback, errorCallback);
}, CandidateController.prototype.templatePath = function(template) {
var base_path;
return base_path = null, window.IE_BROWSER && (base_path = "/assets"), this.staticPath("backbone/templates/" + template, base_path);
}, CandidateController.prototype.logicalTemplatePath = function(template) {
return "backbone/templates/" + template;
}, CandidateController.prototype.template = function(template_name, template_callback, view_loader) {
var each_inline_template, logical_template_path, that, _i, _len, _ref;
if (null == template_name && (template_name = null), null == template_callback && (template_callback = null), 
null == view_loader && (view_loader = !0), HR.templates = HR.templates || {}, logical_template_path = this.logicalTemplatePath(template_name), 
void 0 === this.template_callbacks && (this.template_callbacks = {}, $('script[type="text/template"]').length > 0)) for (_ref = $('script[type="text/template"]'), 
_i = 0, _len = _ref.length; _len > _i; _i++) each_inline_template = _ref[_i], HR.templates[this.logicalTemplatePath($(each_inline_template).attr("id"))] = _.template($(each_inline_template).html());
return null !== template_name && void 0 !== HR.templates[logical_template_path] && "--insync--" !== HR.templates[logical_template_path] ? (template_callback = null, 
HR.templates[logical_template_path]) :(void 0 === this.template_callbacks[template_name] && (this.template_callbacks[template_name] = []), 
null !== template_callback && (this.template_callbacks[template_name].push(template_callback), 
template_callback = null), "--insync--" !== HR.templates[logical_template_path] && (HR.templates[logical_template_path] = "--insync--", 
that = this, $.ajax({
url:this.templatePath("" + template_name + ".js"),
dataType:"script",
success:function() {
return that.template_callbacks[template_name] && (_.each(that.template_callbacks[template_name], function(callback) {
return callback.render();
}), that.template_callbacks[template_name] = []), template_callback = null;
},
error:function() {
throw HR.connectionAlert && HR.connectionAlert(), "Template `" + that.templatePath("" + template_name + ".js") + "` Not Found";
},
cache:!HR.development
})), view_loader = view_loader ? this.viewLoader() :"<div></div>", _.template(view_loader));
}, CandidateController.prototype.setData = function(key, value) {
return void 0 === this.persistant_data && (this.persistant_data = {}), void 0 === this.persistant_data[key] && this.trigger("persistant:set:" + key), 
this.trigger("persistant:change:" + key), this.persistant_data[key] = value;
}, CandidateController.prototype.getData = function(key) {
return this.persistant_data && this.persistant_data[key] ? this.persistant_data[key] :void 0;
}, CandidateController.prototype.viewLoader = function(size) {
return null == size && (size = 32), "<div class='gray'> <div style='background: url(https://d3rpyts3de3lx8.cloudfront.net/hackerrank/hackerrank_spinner_" + size + "x" + size + ".gif); height: " + size + "px; width: " + size + "px; display: inline-block;'></div> </div>";
}, CandidateController.prototype.setModel = function(data, key, uid, casual) {
var def_key;
if (null == uid && (uid = null), null == casual && (casual = !0), def_key = key, 
uid && (key = "" + key + "-" + uid), !this.MODELS_DEF[def_key]) throw "HR Error: Model with key `" + key + "` doesn't exist";
return this.MODELS || (this.MODELS = {}), this.MODELS[key] ? this.MODELS[key].set(data) :this.MODELS[key] = new this.MODELS_DEF[def_key](data, {
casual:casual
});
}, CandidateController.prototype.getModel = function(key, uid, callback, fetch, force_fetch, disableThrobber) {
var model;
return null == uid && (uid = null), null == callback && (callback = null), null == fetch && (fetch = !0), 
null == force_fetch && (force_fetch = !1), null == disableThrobber && (disableThrobber = !1), 
model = new this.MODELS_DEF[key](null, {
casual:!1
}), callback && callback(model), fetch && model.cached({
fetch:force_fetch,
disableThrobber:disableThrobber
}), model;
}, CandidateController.prototype.cleanModelCache = function(keyPrefix) {
var that;
return that = this, _.each(this.MODELS, function(o, key) {
return 0 === key.indexOf(keyPrefix) ? delete that.MODELS[key] :void 0;
});
}, CandidateController.prototype.setCollection = function(data, key, uid) {
var def_key;
if (null == uid && (uid = null), def_key = key, uid && (key = "" + key + "-" + uid), 
!this.COLLECTIONS_DEF[def_key]) throw "HR Error: Collection with key `" + key + "` doesn't exist";
return this.COLLECTIONS || (this.COLLECTIONS = {}), this.COLLECTIONS[key] || (this.COLLECTIONS[key] = new this.COLLECTIONS_DEF[def_key]()), 
this.COLLECTIONS[key].reset(data, {
silent:!1
});
}, CandidateController.prototype.getCollection = function(key, uid, callback, fetch, force_fetch, disableThrobber) {
var cache, collection;
return null == uid && (uid = null), null == callback && (callback = null), null == fetch && (fetch = !0), 
null == force_fetch && (force_fetch = !1), null == disableThrobber && (disableThrobber = !1), 
collection = new this.COLLECTIONS_DEF[key](null, {
casual:!force_fetch
}), callback && callback(collection), fetch && (cache = !force_fetch, collection.cached({
fetch:force_fetch,
disableThrobber:disableThrobber
})), collection;
}, CandidateController.prototype.cleanCollectionCache = function(keyPrefix) {
var that;
return that = this, _.each(this.COLLECTIONS, function(o, key) {
return 0 === key.indexOf(keyPrefix) ? delete that.COLLECTIONS[key] :void 0;
});
}, CandidateController.prototype.setTitle = function(title, long) {
return null == long && (long = !0), document.title = long ? "" + title + " | Programming problems and challenges | HackerRank" :"" + title + " | HackerRank";
}, CandidateController.prototype.getTemplate = function(template_name, callback, obj) {
var data, each_inline_template, logical_template_path, that, _i, _len, _ltp, _ref;
if (null == callback && (callback = function() {}), null == obj && (obj = null), 
HR.templates = HR.templates || {}, logical_template_path = this.logicalTemplatePath(template_name), 
null === obj && (obj = this), obj && obj.cid) {
if (this.TEMPLATE_VIEWDATA || (this.TEMPLATE_VIEWDATA = {}), this.TEMPLATE_VIEWDATA["" + obj.cid + "-" + template_name]) return;
this.TEMPLATE_VIEWDATA["" + obj.cid + "-" + template_name] = !0;
}
if (void 0 === this.TEMPLATE_CALLBACKS && (this.TEMPLATE_CALLBACKS = {}, $('script[type="text/template"]').length > 0)) for (_ref = $('script[type="text/template"]'), 
_i = 0, _len = _ref.length; _len > _i; _i++) each_inline_template = _ref[_i], _ltp = this.logicalTemplatePath($(each_inline_template).attr("id")), 
HR.templates[_ltp] || (HR.templates[_ltp] = _.template($(each_inline_template).html()));
return void 0 !== HR.templates[logical_template_path] ? (data = HR.templates[logical_template_path], 
callback.call(obj, data), data) :(this.TEMPLATE_CALLBACKS[template_name] || (this.TEMPLATE_CALLBACKS[template_name] = [], 
that = this, $.ajax({
url:this.templatePath("" + template_name + ".js"),
dataType:"script",
success:function() {
var _clbk, _results;
for (_results = []; that.TEMPLATE_CALLBACKS[template_name].length > 0; ) _clbk = that.TEMPLATE_CALLBACKS[template_name].shift(), 
_results.push(_clbk.callback.call(_clbk.obj, HR.templates[logical_template_path]));
return _results;
},
cache:!HR.development
})), this.TEMPLATE_CALLBACKS[template_name].push({
callback:callback,
obj:obj
}), null);
}, CandidateController.prototype.clearTemplate = function(template_name) {
return void 0 === this.TEMPLATE_DATA && (this.TEMPLATE_DATA = {}, this.TEMPLATE_CALLBACKS = {}), 
delete this.TEMPLATE_DATA[template_name], delete (this.TEMPLATE_VIEWDATA = !1), 
delete this.TEMPLATE_CALLBACKS[template_name];
}, CandidateController.prototype.facebook_login = function(e, callback) {
var data, h, left, top, w;
if (null == e && (e = null), null == callback && (callback = function() {}), e) {
if (e.preventDefault(), data = e.data, "disabled" === $(e.currentTarget).attr("disabled")) return;
} else data = {};
return w = 600, h = 350, left = screen.width / 2 - w / 2, top = screen.height / 2 - h / 2, 
window.login_callback = function() {
return HR.profile({
fetch:!0
}), data && data.that && data.destroy && data.that.destroy(), callback();
}, window.open("/hackers/auth/facebook?display=popup", "facebook_login", "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + w + ", height=" + h + ", top=" + top + ", left=" + left);
}, CandidateController.prototype.github_login = function(e, callback) {
var data, h, left, top, w;
if (null == e && (e = null), null == callback && (callback = function() {}), e) {
if (e.preventDefault(), data = e.data, "disabled" === $(e.currentTarget).attr("disabled")) return;
} else data = {};
return w = 960, h = 500, left = screen.width / 2 - w / 2, top = screen.height / 2 - h / 2, 
window.login_callback = function() {
return HR.profile({
fetch:!0
}), data && data.that && data.destroy && data.that.destroy(), callback();
}, window.open("/hackers/auth/github?display=popup", "facebook_login", "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + w + ", height=" + h + ", top=" + top + ", left=" + left);
}, CandidateController.prototype.facebook_share = function(url, content) {
var h, left, top, w;
return null == content && (content = ""), w = 600, h = 350, left = screen.width / 2 - w / 2, 
top = screen.height / 2 - h / 2, url = "https://www.facebook.com/sharer.php?s=100&p" + encodeURIComponent("[url]") + "=" + encodeURIComponent(url) + "&p" + encodeURIComponent("[title]") + "=" + window.document.title + "&p" + encodeURIComponent("[summary]") + "=" + content, 
window.open(url, "_blank", "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + w + ", height=" + h + ", top=" + top + ", left=" + left), 
window.focus();
}, CandidateController.prototype.facebook_graph_activity = function(action, object_type, object_url) {
var params;
return params = {}, params[object_type] = object_url, window.FB.api("/me/hackerrank:" + action, "post", params, function(_this) {
return function(response) {
return _this.log(response);
};
}(this));
}, CandidateController.prototype.twitter_share = function(text) {
var h, left, top, url, w;
return w = 600, h = 350, left = screen.width / 2 - w / 2, top = screen.height / 2 - h / 2, 
url = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(text), window.open(url, "_blank", "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=" + w + ", height=" + h + ", top=" + top + ", left=" + left), 
window.focus();
}, CandidateController.prototype.querySlug = function(options) {
var cached_response, prefetch_response;
return null == options && (options = {}), HR.QUERY_SLUGS || (HR.QUERY_SLUGS = {}), 
(cached_response = HR.QUERY_SLUGS[options.slug]) ? (options.callback(cached_response), 
void 0) :(prefetch_response = HR.PREFETCH_DATA.slugs[options.slug], prefetch_response ? (options.callback(HR.PREFETCH_DATA.slugs[options.slug]), 
HR.QUERY_SLUGS[options.slug] = HR.PREFETCH_DATA.slugs[options.slug], void 0) :$.ajax({
url:"/rest/query_slug",
data:{
slug:options.slug
},
success:function(data) {
return HR.QUERY_SLUGS[options.slug] = data, options.callback(data);
}
}));
}, CandidateController.prototype.slugDetector = function(slug, callback, obj) {
var data, that;
return null == callback && (callback = function() {}), null == obj && (obj = null), 
null === obj && (obj = this), this.SLUG_DETECTOR_DATA || (this.SLUG_DETECTOR_DATA = {}, 
this.SLUG_DETECTOR_CALLBACKS = {}, HR.PREFETCH_DATA.slugs && (this.SLUG_DETECTOR_DATA = $.extend(HR.PREFETCH_DATA.slugs, this.SLUG_DETECTOR_DATA), 
_.each(HR.PREFETCH_DATA.slugs, function(data, slug) {
return this.SLUG_DETECTOR_DATA[slug].created_at = 1e3 * HR.PREFETCH_DATA.timestamp;
}, this))), void 0 !== this.SLUG_DETECTOR_DATA[slug] ? (data = this.SLUG_DETECTOR_DATA[slug], 
callback.call(obj, data), data) :(this.SLUG_DETECTOR_CALLBACKS[slug] || (this.SLUG_DETECTOR_CALLBACKS[slug] = [], 
that = this, $.ajax({
url:"/rest/query_slug",
type:"POST",
data:{
slug:slug
},
success:function(resp) {
var _clbk, _results;
for (that.SLUG_DETECTOR_DATA[slug] = resp, that.SLUG_DETECTOR_DATA[slug].created_at = new Date().getTime(), 
_results = []; that.SLUG_DETECTOR_CALLBACKS[slug].length > 0; ) _clbk = that.SLUG_DETECTOR_CALLBACKS[slug].shift(), 
_results.push(_clbk.callback.call(_clbk.obj, resp));
return _results;
}
})), this.SLUG_DETECTOR_CALLBACKS[slug].push({
callback:callback,
obj:obj
}), null);
}, CandidateController.prototype.loadCodeMirror = function(callback, errcallback) {
return null == errcallback && (errcallback = null), HR.requires("codemirror_basic", function() {
return function() {
return callback();
};
}(this), function() {
return function() {
return errcallback();
};
}(this));
}, CandidateController.prototype.loadCodeMirrorMode = function(lang, callback) {
return HR.appController.loadCodeMirror(function() {
var args;
return args = [], lang_mode_location_unconventional_mapping[lang] ? args = _.union(args, lang_mode_location_unconventional_mapping[lang]) :args.push("codemirror/mode/" + lang + "/" + lang), 
args.push(function() {
return function() {
return callback();
};
}(this)), args.push(function() {
return function() {
return callback();
};
}(this)), HR.requires.apply(this, args);
});
}, CandidateController;
}(Backbone.Model), HR = null != (_ref = window.HR) ? _ref :{}, HR.CandidateController = CandidateController;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var GenericView, HR, _ref;
return GenericView = function(_super) {
function GenericView() {
return GenericView.__super__.constructor.apply(this, arguments);
}
return __extends(GenericView, _super), GenericView.prototype.initialize = function(options) {
return null == options && (options = {}), this.has_template = !1, this.parent = options.parent;
}, GenericView.prototype.assign = function(selector, view) {
var selectors;
return _.isObject(selector) ? selectors = selector :(selectors = [], selectors[selector] = view), 
selectors ? (_.each(selectors, function(view, selector) {
return view.setElement(this.$(selector)).render();
}, this), this) :void 0;
}, GenericView.prototype.render = function() {
return this._render && "function" == typeof this._render ? ("function" == typeof this.prerender && this.prerender, 
"function" == typeof this.teardown && this.teardown(), "function" == typeof this._render && this._render(), 
"function" == typeof this.postrender && this.postrender()) :!this.has_template && this.template ? HR.appController.getTemplate(this.template, function(template) {
return this._template = template, this.has_template = !0, this.applyTemplate();
}, this) :this.applyTemplate(), this;
}, GenericView.prototype.postrender = function() {
return this.delegateEvents(), setTimeout(function() {
return $(".js-tooltip").tooltip().click(function(e) {
return $(".js-tooltip").tooltip("hide"), $(e.currentTarget).hasClass("disabled") ? !1 :!0;
});
}, 300);
}, GenericView.prototype.applyTemplate = function() {}, GenericView.prototype.loading = function(size, from) {
return null == size && (size = 32), null == from && (from = 0), this.rendered ? void 0 :$(this.el).html(HR.appController.viewLoader(size));
}, GenericView.prototype.teardown = function() {
var view, _i, _len, _ref;
if (void 0 !== this._subviews) for (_ref = this._subviews, _i = 0, _len = _ref.length; _len > _i; _i++) view = _ref[_i], 
view.remove();
return this._subviews = [], this.undelegateEvents(), this;
}, GenericView.prototype.destroy = function() {
return this._subviews && _.isArray(this._subviews) && _.each(this._subviews, function(subview) {
return subview && subview.destroy ? subview.destroy() :void 0;
}), this.undelegateEvents(), this.$el.removeData().unbind(), this.remove(), Backbone.View.prototype.remove.call(this);
}, GenericView.prototype.add_subview = function(view) {
return this._subviews || (this._subviews = []), this._subviews.push(view), this;
}, GenericView;
}(Backbone.View), HR = null != (_ref = window.HR) ? _ref :{}, HR.GenericView = GenericView, 
Backbone.View.prototype.log = Backbone.log;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var HR, LoadingView, _ref;
return LoadingView = function(_super) {
function LoadingView() {
return LoadingView.__super__.constructor.apply(this, arguments);
}
return __extends(LoadingView, _super), LoadingView.prototype.template = "loading", 
LoadingView.prototype.className = "loading-view", LoadingView.prototype.viewLoader = function(size) {
return null == size && (size = 32), "<div class='gray'> <div style='background: url(https://d3rpyts3de3lx8.cloudfront.net/hackerrank/hackerrank_spinner_" + size + "x" + size + ".gif); height: " + size + "px; width: " + size + "px; display: inline-block;'></div> </div>";
}, LoadingView.prototype.render = function() {
return $(this.el).html(this.viewLoader(64)), this;
}, LoadingView;
}(window.HR.GenericView), HR = null != (_ref = window.HR) ? _ref :{}, HR.LoadingView = LoadingView;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var CandidateView, HR, _ref;
return CandidateView = function(_super) {
function CandidateView() {
return CandidateView.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateView, _super), CandidateView.prototype.el = "#wrapper", 
CandidateView.prototype.initialize = function() {
var that;
return this.contentView || this.setLoadingView(), this.topbarview = null, that = this, 
_.each(this.liveEvents, function(callback, index) {
var ev, sl, sp;
return sp = index.indexOf(" "), ev = index.substr(0, sp), sl = index.substr(sp + 1), 
$(sl).die(ev).unbind(ev).live(ev, that[callback]);
});
}, CandidateView.prototype.setLoadingView = function() {
var loadingView;
return loadingView = new HR.LoadingView(), this.setContentView(loadingView);
}, CandidateView.prototype.setContentView = function(contentView) {
return this.contentView && (this.contentView.unbind && this.contentView.unbind(), 
this.contentView.$ && this.contentView.$("*").unbind(), this.contentView.destroy ? this.contentView.destroy() :this.contentView.remove && this.contentView.remove()), 
this.contentView = contentView, this.render();
}, CandidateView.prototype.setTopbarView = function(tbview) {
return null == tbview && (tbview = null), this.topbarview !== tbview ? (this.topbarview = tbview, 
_.isEmpty(this.topbarview) ? this.$("#navigation").empty() :this.$("#navigation").html(this.topbarview.render().el), 
tbview) :void 0;
}, CandidateView.prototype.setFooterView = function(fview) {
var html;
return null == fview && (fview = null), this.footerview = fview, fview ? (html = this.footerview.render().el, 
$("#footer").html(html)) :$("#footer").empty(), fview;
}, CandidateView.prototype.setSidebarView = function(sbview) {
return null == sbview && (sbview = null), sbview ? (this.sidebarview = sbview, this.$("#side-navigation").html(this.sidebarview.render().el)) :this.$("#side-navigation").empty();
}, CandidateView.prototype.unsetTopbarView = function() {
return this.$("#navigation").empty();
}, CandidateView.prototype.liveEvents = {
"click .backbone":"navigateAnchor"
}, CandidateView.prototype.navigateAnchor = function(e) {
var href;
return e.ctrlKey || e.metaKey ? !0 :(e.preventDefault(), href = $(e.currentTarget).attr("href"), 
HR.candidate.redirectBackTo = href, href ? (HR.candidate.attemptRefreshNeeded = !0, 
HR.router.navigate("" + href, {
trigger:!0,
replace:!0
})) :void 0);
}, CandidateView.prototype.getSubViews = function() {
var subviews;
return null === this.contentView && this.setContentView(HR.E404View), subviews = {
content:this.contentView
};
}, CandidateView.prototype.render = function() {
var curent_module_name, that;
return that = this, _.each(this.getSubViews(), function(subview, name) {
var _view;
return _view = _.isFunction(subview) ? new subview() :subview, $(that.el).find("#" + name).html(_view.render().el), 
_view.trigger("render");
}), $(".module-select-prompt").length > 0 && $("body").find("[data-module=" + HR.appController.get_current_module() + "]").length > 0 && (curent_module_name = $.trim($("body").find("[data-module=" + HR.appController.get_current_module() + "]").html()), 
HR.CURRENT_MODULE_NAME = curent_module_name, $(".module-select-prompt").html("Category: " + curent_module_name + " <i class='icon-down-open-mini'></i>")), 
this.topbarview ? (this.$("#navigation").html(this.topbarview.render().el), $("#countdown-timer").countdown("resume")) :void 0;
}, CandidateView;
}(window.HR.GenericView), HR = null != (_ref = window.HR) ? _ref :{}, HR.CandidateView = CandidateView;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
}, __bind = function(fn, me) {
return function() {
return fn.apply(me, arguments);
};
}, __indexOf = [].indexOf || function(item) {
for (var i = 0, l = this.length; l > i; i++) if (i in this && this[i] === item) return i;
return -1;
};
jQuery(function() {
var HR, RecruitCandidateCodingView, RecruitCandidateCompileTestView, RecruitCandidateCompleteView, RecruitCandidateDesignView, RecruitCandidateFileUploadView, RecruitCandidateFooterView, RecruitCandidateInstructionsView, RecruitCandidateListView, RecruitCandidateMcqView, RecruitCandidateQuestionView, RecruitCandidateSideBarView, RecruitCandidateSubjectiveView, RecruitCandidateTestCaseView, RecruitCandidateTopBarView, RecruitCandidateUMLView, _ref;
return RecruitCandidateInstructionsView = function(_super) {
function RecruitCandidateInstructionsView() {
return RecruitCandidateInstructionsView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateInstructionsView, _super), RecruitCandidateInstructionsView.prototype.template = "recruit/instructions", 
RecruitCandidateInstructionsView.prototype.className = "candidate-instructions", 
RecruitCandidateInstructionsView.prototype.initialize = function(options) {
return this.model = options.model;
}, RecruitCandidateInstructionsView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
instructions:this.model.get("instructions")
})), this;
}, RecruitCandidateInstructionsView;
}(window.HR.GenericView), RecruitCandidateListView = function(_super) {
function RecruitCandidateListView() {
return RecruitCandidateListView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateListView, _super), RecruitCandidateListView.prototype.template = "recruit/question-list", 
RecruitCandidateListView.prototype.className = "candidate-qlist", RecruitCandidateListView.prototype.events = {
"click .test-done":"testDone",
"click .next-section":"sectionNext"
}, RecruitCandidateListView.prototype.initialize = function() {
return this.model = HR.candidate.candidateAttemptModel, this.tid = HR.candidate.candidateTestModel.get("unique_id"), 
this.aid = this.model.get("id");
}, RecruitCandidateListView.prototype.render = function() {
var current_section, qi, questions, sections_mapping, solves, v;
return questions = this.model.get("questions"), solves = this.model.get("solve_mapping"), 
sections_mapping = this.model.get("sections_mapping"), current_section = this.model.get("section"), 
$(this.el).html(HR.appController.template(this.template, this)({
section_count:sections_mapping ? sections_mapping.length :1,
current_section:current_section ? current_section :1,
footer_copyright:!!HR.candidate.candidateTestModel.get("footer_copyright")
})), sections_mapping ? (qi = 0, _.each(sections_mapping, function(_this) {
return function(sec, i) {
var v;
return v = _this.getTable(questions.slice(qi, qi + parseInt(sec.questions)), qi + 1, solves, i + 1 !== current_section), 
_this.$("table.section" + (i + 1)).html(v), qi += parseInt(sec.questions);
};
}(this)), sections_mapping.length > 1 && current_section < sections_mapping.length && this.$("button.section-finish-" + current_section).removeClass("hidden")) :(v = this.getTable(questions, 1, solves), 
this.$("table.section1").html(v)), HR.candidate.lastQuestionViewed && setTimeout(function(_this) {
return function() {
return _this.$(".qlist-" + HR.candidate.lastQuestionViewed)[0] && _this.$(".qlist-" + HR.candidate.lastQuestionViewed)[0].scrollIntoView();
};
}(this)), this;
}, RecruitCandidateListView.prototype.getTable = function(questions, start, solves, disabled) {
var el, i, tid;
return null == disabled && (disabled = !1), tid = this.tid, i = start, el = "", 
_.each(questions, function(q) {
var ahref, s;
return s = "", s += 1 === i ? "<tr class='border qlist-" + i + "''>" :"<tr class='qlist-" + i + "'>", 
s += "<td width='5%' class='grey right'><span class='mdR'>Q" + i + "</span></td>", 
s += '<td width="46%"><a class="backbone question-name" ', s += disabled ? ">" :"href='" + tid + "/questions/" + q.unique_id + "'>", 
s += q.name ? q.name :"Question <em class='fnt-sz-small grey' style='font-weight: 500;'> &nbsp;&nbsp; " + _.escape(q.preview) + "..</em>", 
s += "</a></td>", s += "<td width='12%' class='fnt-sz-mid'>" + window.istreet.cfg.hrqn[q.type] + "</td>", 
ahref = disabled ? "" :"href='" + tid + "/questions/" + q.unique_id + "'", s += _.has(solves, q.unique_id) ? "<td width='12%' class='fnt-sz-mid'><span class='green'>submitted</span></td><td width='19%' class='right'><a " + ahref + " class='normal-underline display-inline-block margin-right-15 fnt-sz-mid backbone' style='margin: 9px 11px 9px 0;''>Modify Submission</a></td>" :"<td width='12%' class='fnt-sz-mid'>not answered</td><td width='19%' class='right'><a " + ahref + " class='btn btn-line margin-right-15 fnt-sz-mid backbone'>Solve Question</a></td>", 
s += "</tr>", i++, el += s;
}), el;
}, RecruitCandidateListView.prototype.testDone = function() {
return HR.util.confirm({
title:"Confirm test close",
message:"Once closed, you can no longer view or modify this test.\n\nAre you sure you are done, and want to close the test?",
okButtonText:"Yes, close this test.",
cancelButtonText:"No, go back.",
okCallback:function() {
return function() {
return HR.candidate.candidateTestModel.setAction("logout"), HR.candidate.pingTimer && clearInterval(HR.candidate.pingTimer), 
HR.candidate.candidateTestModel.save(null, {
success:function(m) {
return HR.router.navigate("" + m.get("unique_id") + "/redirect", {
trigger:!0,
replace:!0
});
}
});
};
}(this)
});
}, RecruitCandidateListView.prototype.sectionNext = function(e) {
return HR.util.confirm({
title:"Confirm section close",
message:"You will not be able access this section again.<br><br>Are you sure?",
okButtonText:"Yes, move to next section.",
cancelButtonText:"No, stay.",
okCallback:function(_this) {
return function() {
return HR.candidate.candidateAttemptModel.set("section_close", _this.$(e.currentTarget).attr("data-section")), 
HR.candidate.candidateAttemptModel.save(null, {
success:function() {
return HR.router.navigate("" + HR.candidate.candidateTestModel.get("unique_id") + "/redirect", {
trigger:!0,
replace:!0
});
},
error:function() {
return HR.router.navigate("" + HR.candidate.candidateTestModel.get("unique_id") + "/redirect", {
trigger:!0,
replace:!0
});
}
});
};
}(this)
});
}, RecruitCandidateListView;
}(window.HR.GenericView), RecruitCandidateQuestionView = function(_super) {
function RecruitCandidateQuestionView() {
return this.getAnswerToSave = __bind(this.getAnswerToSave, this), RecruitCandidateQuestionView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateQuestionView, _super), RecruitCandidateQuestionView.prototype.template = "recruit/question-base", 
RecruitCandidateQuestionView.prototype.className = "question-base", RecruitCandidateQuestionView.prototype.initialize = function(options) {
return this.model = options.model, this.tid = HR.candidate.candidateTestModel.get("unique_id");
}, RecruitCandidateQuestionView.prototype.events = {
"click .ans-submit":"submitAnswer"
}, RecruitCandidateQuestionView.prototype.getAnswerToSave = function() {
var a, qtype;
return qtype = this.model.get("type"), _.contains([ "code", "approx", "textAns", "design" ], qtype) ? this.view ? (a = {
type:qtype,
answer:this.view.answer()
}, a.answer ? a :null) :null :null;
}, RecruitCandidateQuestionView.prototype.submitAnswer = function(e) {
var a, data, request_params;
return e.preventDefault(), a = {
type:this.model.attributes.type,
answer:this.view.answer()
}, a.answer ? (this.$(e.currentTarget).html("Submitting.."), this.$(e.currentTarget).attr("disabled", "disabled"), 
data = {
qid:this.model.get("unique_id"),
answer:a
}, request_params = {
url:"/recruit/attempts/" + HR.candidate.candidateAttemptModel.get("id") + "/solves",
data:data,
dataType:"json",
type:"POST",
success:function(_this) {
return function(xhr) {
var nextpath;
return _this.$(e.currentTarget).html("Done, redirecting.."), xhr.error ? _this.showError(xhr.error) :(nextpath = _this.model.get("nextqid") ? "" + _this.tid + "/questions/" + _this.model.get("nextqid") :"" + _this.tid + "/questions", 
HR.candidate.attemptRefreshNeeded = !0, HR.router.navigate("" + nextpath, {
trigger:!0,
replace:!0
}));
};
}(this),
error:function(_this) {
return function(xhr) {
_this.$(e.currentTarget).html("Submit answer & continue"), _this.$(e.currentTarget).removeAttr("disabled");
try {
return data = JSON.parse(xhr.responseText), data.error ? _this.showError(data.error) :_this.showError();
} catch (_error) {
return _this.showError();
}
};
}(this)
}, "file_upload" !== this.model.get("type") || _.isString(this.view.answer()) || (data = {
qid:this.model.get("unique_id")
}, request_params.iframe = !0, request_params.processData = !1, request_params.data = data, 
request_params.files = this.view.answer()), $.ajax(request_params)) :HR.util.alert({
title:"Submit error",
message:"Please answer the question before submitting."
});
}, RecruitCandidateQuestionView.prototype.showError = function(err) {
return null == err && (err = "Unable to save your answer."), HR.util.candidatemsg("" + err + "<br><br>Click continue to refresh question listing.<br><br><a href='" + this.tid + "/questions' class='backbone btn'>Continue</a>", !1);
}, RecruitCandidateQuestionView.prototype._render = function() {
var cnt, problem_statement, q, viewfound;
switch (this.question = this.model.attributes, $(this.el).html(HR.appController.template(this.template, this)({
tid:this.tid,
question:this.question
})), viewfound = !0, this.question.type) {
case "code":
case "approx":
this.view = new HR.RecruitCandidateCodingView({
question:this.question
});
break;

case "design":
this.view = new HR.RecruitCandidateDesignView({
question:this.question
});
break;

case "mcq":
case "multiple_mcq":
this.view = new HR.RecruitCandidateMcqView({
question:this.question
});
break;

case "textAns":
this.view = new HR.RecruitCandidateSubjectiveView({
question:this.question
});
break;

case "complete":
for (q = this.question.complete_string, cnt = 0, problem_statement = "<h4>Complete the blanks in the following question with the appropriate answer.</h4><br/>", 
problem_statement += _.isEmpty(this.question.question) ? "" :this.question.question; -1 !== q.search("{blank}"); ) q = q.replace("{blank}", "<input type='text' class='complete-question' name='blank" + cnt + "'/>"), 
cnt += 1;
problem_statement += q, this.view = new HR.RecruitCandidateCompleteView({
question:this.question
});
break;

case "file_upload":
this.view = new HR.RecruitCandidateFileUploadView({
question:this.question
});
break;

case "uml":
case "electrical":
this.view = new HR.RecruitCandidateUMLView({
question:this.question
});
break;

default:
viewfound = !1;
}
return this.question.name ? this.$(".qtitle").html("" + this.question.name + " (" + window.istreet.cfg.hrqn[this.question.type] + ")") :this.$(".qtitle").html(window.istreet.cfg.hrqn[this.question.type]), 
"complete" === this.question.type ? this.$(".challenge-text").html(problem_statement) :this.$(".challenge-text").html(this.question.question), 
viewfound ? this.$(".qcontent").html(this.view.render().el) :(this.$(".qcontent").html("<center>This question type is not available.</center>"), 
this.$(".ans-submit").addClass("disabled")), HR.candidate.lastQuestionViewed = this.model.get("qno"), 
setTimeout(function() {
return HR.util.scrollToTop();
}, 200), this;
}, RecruitCandidateQuestionView;
}(window.HR.GenericView), RecruitCandidateCodingView = function(_super) {
function RecruitCandidateCodingView() {
return RecruitCandidateCodingView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateCodingView, _super), RecruitCandidateCodingView.prototype.template = "recruit/question-coding", 
RecruitCandidateCodingView.prototype.className = "question-coding", RecruitCandidateCodingView.prototype.initialize = function(options) {
return this.question = options.question, this.test = HR.candidate.candidateTestModel || options.test, 
this.codeshell = null, window.error_marker_widgets = [], HR.candidate && HR.candidate.candidateAttemptModel ? (this.aid = HR.candidate.candidateAttemptModel.get("id"), 
HR.appView.saveCodeOnNavigate = !0) :this.aid = "testing", this.autoSaveNamespace = options.disableLocalStorage && options.disableLocalStorage === !0 ? null :"" + this.aid + "-" + this.question.unique_id, 
this.compilingLock = !1, this;
}, RecruitCandidateCodingView.prototype.events = {
"codeshellcompile #editor":"compileAnswer",
"click #testcase-dl":"testcaseDownload"
}, RecruitCandidateCodingView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
question:this.question
})), this.show_template = !1, this.question.show_template && "true" === this.question.show_template.toLowerCase() && (this.show_template = !0), 
this.test.get("show_template") && "true" === this.test.get("show_template").toLowerCase() && (this.show_template = !0), 
HR.appController.loadCodeMirror(function(_this) {
return function() {
return _this.applyCodeshell();
};
}(this), function() {
return function() {
return HR.util.candidatemsg("Unable to load code editor.<br><br> Check your internet connection, and refresh the page to fix this.", !1);
};
}(this)), this;
}, RecruitCandidateCodingView.prototype.testcaseDownload = function() {
var url;
return url = "/recruit/attempts/" + HR.candidate.candidateAttemptModel.id + "/questions/" + this.question.unique_id + "/testcases", 
HR.util.downloadURL(url);
}, RecruitCandidateCodingView.prototype.applyCodeshell = function() {
var opts;
return opts = {
languages:this.question.languages,
language:"c",
autoSaveNamespace:this.autoSaveNamespace,
lang_template:this.getLangDefaults(),
showNonEditableHeadTail:this.show_template,
lang_head_template:this.getLangHeads(),
lang_tail_template:this.getLangTails(),
compile_button_text:"Compile & Test",
submit_button_text:"Submit code & Continue",
showSubmit:!0,
showCustomInput:this.showCustomInput(),
dynamicMode:!0,
lang_line_nos:this.question.line_nos,
loadmode:function() {
return function(e, data) {
return HR.appController.loadCodeMirrorMode(data.lang, function() {
return data.callback();
});
};
}(this)
}, ("True" === this.test.get("hide_compile_test") || "True" === this.question.hide_compile_test) && (opts.showCompileTest = !1), 
"testing" === this.aid && (opts.showSubmit = !1, opts.showCompileTest = !1), opts.showCompileTest !== !1 && (opts.showCompileTest = !0), 
this.$("#editor").codeshell(opts), this.$("#editor").codeshell("refresh"), this.$("#editor").codeshell("onChange", function(_this) {
return function(e, change) {
return _this.deleteMarkersOnSource(e, change);
};
}(this)), this.set_answer(), setTimeout(function(_this) {
return function() {
return _this.setDefaultText = !0;
};
}(this), 3e3);
}, RecruitCandidateCodingView.prototype.getLangDefaults = function() {
var l, m, _i, _len, _ref;
for (m = {}, _ref = this.question.languages, _i = 0, _len = _ref.length; _len > _i; _i++) l = _ref[_i], 
this.question[l + "_template"] && (m[l] = this.question[l + "_template"]);
return m;
}, RecruitCandidateCodingView.prototype.getLangHeads = function() {
var l, m, _i, _len, _ref;
if (m = {}, this.show_template) for (_ref = this.question.languages, _i = 0, _len = _ref.length; _len > _i; _i++) l = _ref[_i], 
this.question[l + "_template_head"] && (m[l] = this.question[l + "_template_head"]);
return m;
}, RecruitCandidateCodingView.prototype.getLangTails = function() {
var l, m, _i, _len, _ref;
if (m = {}, this.show_template) for (_ref = this.question.languages, _i = 0, _len = _ref.length; _len > _i; _i++) l = _ref[_i], 
this.question[l + "_template_tail"] && (m[l] = this.question[l + "_template_tail"]);
return m;
}, RecruitCandidateCodingView.prototype.showCustomInput = function() {
return this.question.show_custom_testcase && "True" === this.question.show_custom_testcase ? !0 :!1;
}, RecruitCandidateCodingView.prototype.compileAnswer = function(e, data) {
return data.code && !$(".bb-compile").hasClass("disabled") ? (data.custominput && (data.customtestcase = !0), 
$(".bb-compile").addClass("disabled"), this.deleteMarkersOnSource(), HR.candidate.ctmodel = new HR.CandidateCompileTestModel(), 
HR.candidate.ctmodel.setAid(this.aid), HR.candidate.ctmodel.setQid(this.question.unique_id), 
"runalltestcases" === e && HR.candidate.ctmodel.setAllCases(!0), HR.candidate.ctview = new HR.RecruitCandidateCompileTestView(), 
this.$("#runstatus").html(HR.candidate.ctview.render().el), HR.util.scrollToBottom(1e3), 
HR.candidate.ctmodel.save(data, {
success:function(_this) {
return function() {
return HR.candidate.ctview.setStatus("Uploaded. Waiting for results.."), HR.candidate.ctloop = setTimeout(function() {
return _this.checkForResult(_this, data, e);
}, 2e3);
};
}(this),
error:function() {
return function() {
return $(".bb-compile").removeClass("disabled"), HR.candidate.ctmodel = null, HR.candidate.ctview.setStatus("Could not compile as server is unreachable.");
};
}(this)
})) :void 0;
}, RecruitCandidateCodingView.prototype.checkForResult = function(that, data, e) {
return HR.candidate.ctloop ? (HR.candidate.ctview.setStatus("Processing.."), HR.candidate.ctmodel.fetch({
success:function(_this) {
return function(m) {
var expected_output, i, input, msg, output, output_debug, pass, score, st_class, _i, _len, _ref;
if (0 === m.get("status")) return HR.candidate.ctloop = setTimeout(function() {
return that.checkForResult(that, data, e);
}, 2e3), void 0;
if (0 !== m.get("status")) if ($(".bb-compile").removeClass("disabled"), clearTimeout(HR.candidate.ctloop), 
HR.candidate.ctloop = null, m.get("result") > 0) HR.candidate.ctview.setStatus("Error.", "red"), 
HR.candidate.ctview.setCompileStatus("Compilation failed.", m.get("compilemessage")), 
that.addMarkersOnSource(m); else if (pass = 0, m.get("customtestcase")) HR.candidate.ctview.setStatus("Compiled successfully.", "orange"), 
input = m.get("stdin")[0], output = m.get("stdout")[0], output_debug = m.get("stdout_debug") ? m.get("stdout_debug")[0] :null, 
st_class = "txt-green", HR.candidate.ctview.addTestCase(1, input, output, output_debug, null, "", st_class, score); else {
for (_ref = m.get("testcase_status"), i = _i = 0, _len = _ref.length; _len > _i; i = ++_i) input = _ref[i], 
output = m.get("stdout")[i], expected_output = m.get("expected_output")[i], output_debug = m.get("stdout_debug") ? m.get("stdout_debug")[i] :null, 
msg = m.get("testcase_message")[i], 1 === m.get("testcase_status")[i] ? (st_class = "txt-green", 
pass++) :st_class = "txt-orange", m.get("score") && _.isNumber(m.get("score")[i]) && (score = m.get("score")[i]), 
HR.candidate.ctview.addTestCase(i + 1, input, output, output_debug, expected_output, msg, st_class, score);
0 === m.get("testcase_status").length ? HR.candidate.ctview.setStatus("Compiled successfully.", "orange") :0 === pass ? HR.candidate.ctview.setStatus("No test cases passed.", "red") :i > pass ? "runalltestcases" === e ? HR.candidate.ctview.setStatus("Compiled successfully. " + pass + "/" + i + " test cases passed.", "orange") :HR.candidate.ctview.setStatus("Compiled successfully. " + pass + "/" + i + " sample test cases passed.", "orange") :"runalltestcases" !== e ? (HR.candidate.ctview.setStatus("Compiled successfully. All sample test cases passed!", "green"), 
_this.$(".bb-runall").show(), that.compileAnswer("runalltestcases", data)) :HR.candidate.ctview.setStatus("Compiled successfully. All test cases passed!", "green");
}
return HR.util.scrollToBottom(1e3);
};
}(this),
error:function() {
return function() {
return HR.candidate.ctmodel = null, $(".bb-compile").removeClass("disabled"), HR.candidate.ctview.setStatus("Unable to fetch compile information from server.");
};
}(this)
})) :void 0;
}, RecruitCandidateCodingView.prototype.answer = function() {
return this.$("#editor").codeshell("value");
}, RecruitCandidateCodingView.prototype.set_answer = function() {
return this.question.solve ? this.$("#editor").codeshell("setValue", this.question.solve.answer) :void 0;
}, RecruitCandidateCodingView.prototype.checkCopyPaste = function(change) {
var added_text;
if (this.setDefaultText && (added_text = change.text.join(""), added_text !== this.lastAddedText)) return this.lastAddedText = added_text, 
"paste" === change.origin && added_text.length > 100 ? HR.candidate.secureActivity.add({
action:"paste",
eid:9,
qid:this.question.unique_id,
insertTime:new Date()
}) :void 0;
}, RecruitCandidateCodingView.prototype.addMarkersOnSource = function(data) {
var editor, error_markers, error_message, i, line_number, line_offset, marker_node, markers, total_lines;
if (data.get("error_markers")) {
editor = window.codeEditor, error_markers = data.get("error_markers"), total_lines = editor.lineCount(), 
line_offset = error_markers.head_code_lines, markers = error_markers.markers;
for (i in markers) error_message = markers[i].message, line_number = markers[i].line_number, 
line_number -= line_offset, total_lines >= line_number && (marker_node = $("<div class='error-marker'><span class='error-marker-icon'>X</span>" + error_message + "</div>"), 
window.error_marker_widgets.push(editor.addLineWidget(line_number - 1, marker_node[0], {
above:!0
})));
return this.$("#editor").codeshell("refresh");
}
}, RecruitCandidateCodingView.prototype.deleteMarkersOnSource = function(e, change) {
var editor, i;
if (e && change && HR.candidate && HR.candidate.candidateAttemptModel && "True" === HR.candidate.candidateAttemptModel.get("secure") && this.checkCopyPaste(change), 
0 !== window.error_marker_widgets.length) {
editor = window.codeEditor;
for (i in window.error_marker_widgets) editor.removeLineWidget(window.error_marker_widgets[i]);
return this.$("#editor").codeshell("refresh"), window.error_marker_widgets = [];
}
}, RecruitCandidateCodingView;
}(window.HR.GenericView), RecruitCandidateDesignView = function(_super) {
function RecruitCandidateDesignView() {
return this.hideLoading = __bind(this.hideLoading, this), RecruitCandidateDesignView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateDesignView, _super), RecruitCandidateDesignView.prototype.template = "recruit/question-design", 
RecruitCandidateDesignView.prototype.className = "question-design", RecruitCandidateDesignView.prototype.initialize = function(options) {
return this.question = options.question, this.test = HR.candidate.candidateTestModel || options.test, 
this.codeshell = null, this.aid = HR.candidate && HR.candidate.candidateAttemptModel ? HR.candidate.candidateAttemptModel.get("id") :"testing", 
this.autoSaveNamespace = "testing" === this.aid ? "" + this.aid + "-" + this.test.id + "-" + this.question.id :"" + this.aid + "-" + this.question.unique_id, 
this;
}, RecruitCandidateDesignView.prototype.events = {
"click .bb-compile":"renderAnswer"
}, RecruitCandidateDesignView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
question:this.question
})), this.$("#runstatus").load(this.hideLoading), this.show_template = !1, HR.appController.loadCodeMirror(function(_this) {
return function() {
return _this.applyCodeshell();
};
}(this), function() {
return function() {
return HR.util.alert({
message:"There was an error loading the code editor. Please refresh the page."
});
};
}(this)), this;
}, RecruitCandidateDesignView.prototype.applyCodeshell = function() {
var opts, tabs, tabs_tooltip;
return opts = {
languages:this.question.languages,
language:"html",
autoSaveNamespace:this.autoSaveNamespace,
lang_template:this.getLangDefaults(),
showNonEditableHeadTail:this.show_template,
compile_button_text:"Render",
submit_button_text:"Submit code & Continue",
showSubmit:!0,
languageChangeStyle:"tabs",
showCustomInput:!1,
dynamicMode:!0,
loadmode:function() {
return function(e, data) {
return HR.appController.loadCodeMirrorMode(data.lang, function() {
return data.callback();
});
};
}(this)
}, "testing" === this.aid && (opts.showSubmit = !1, opts.showCompileTest = !0), 
opts.showCompileTest !== !1 && (opts.showCompileTest = !0), this.$("#editor").codeshell(opts), 
this.$("#select-lang").addClass("hidden"), this.$("#select-lang-tabs").remove(), 
tabs = "<div id='select-lang-tabs'> <div class='pull-left btn-group'>", this.question.languages.forEach(function(v) {
return tabs += "<a class='cursor btn btn-white " + (v === opts.language ? "active" :void 0) + "' data-lang='" + v + "'>" + lang_display_mapping[v] + "</a>";
}), tabs += "</div> </div>", tabs_tooltip = $("<span class=' pull-left icon-help-circled txt-blue psT psB psL' data-toggle='tooltip' data-placement='right' title='The tabs on the left help you view the corresponding code segment.'></span>").tooltip(), 
tabs = $(tabs), tabs.find("a").on({
click:function(_this) {
return function(e) {
return e.preventDefault(), tabs.find("a").removeClass("active"), _this.$("#editor").codeshell("saveLangCode"), 
_this.$("#editor").codeshell("changeLanguage", _this.$(e.currentTarget).addClass("active").data("lang"));
};
}(this)
}), this.$("#editor > div.grey-header").prepend(tabs.append(tabs_tooltip)), $("#render-help").remove(), 
this.$("#editor .bb-compile").parent().prepend($("<span id='render-help' class='pull-left icon-help-circled txt-blue psT psB psR' data-toggle='tooltip' data-placement='left' title='Press \"Render\" Button to view the visual output of your code. Press \"Submit code & Continue\" to submit your answer. '></span>").tooltip()), 
this.$("#editor").codeshell("refresh"), this.set_answer(), setTimeout(function(_this) {
return function() {
return _this.setDefaultText = !0;
};
}(this), 3e3);
}, RecruitCandidateDesignView.prototype.getLangDefaults = function() {
var l, m, _i, _len, _ref;
for (m = {}, _ref = this.question.languages, _i = 0, _len = _ref.length; _len > _i; _i++) l = _ref[_i], 
this.question[l + "_template"] && (m[l] = this.question[l + "_template"]);
return m;
}, RecruitCandidateDesignView.prototype.hideLoading = function() {
return this.$(".bb-compile").length ? (this.setStatus("Document prepared successfully.", "green"), 
this.$(".bb-compile").removeClass("disabled"), this.$("#runstatus-load").addClass("hidden"), 
this.$("#runstatus").removeClass("hidden")) :void 0;
}, RecruitCandidateDesignView.prototype.renderAnswer = function(e, data) {
var form_elem;
if (!$(".bb-compile").hasClass("disabled")) return this.$(".bb-compile").addClass("disabled").data("status", "sending"), 
"testing" !== this.aid ? (HR.candidate.dtmodel = new HR.CandidateDesignTestModel(), 
HR.candidate.dtmodel.setAid(this.aid), HR.candidate.dtmodel.setQid(this.question.unique_id)) :(HR.candidate.dtmodel = new HR.RecruitDesignTestModel(), 
HR.candidate.dtmodel.setQid(this.question.id), HR.candidate.dtmodel.setTid(this.test.id)), 
this.$("#runstatus").addClass("hidden"), this.$("#runstatus-load").removeClass("hidden"), 
data = this.answer(), this.setStatus("Preparing the document...", "black"), "testing" !== this.aid ? HR.candidate.dtmodel.save(data, {
success:function(_this) {
return function(m) {
return _this.setStatus("Loading document.."), _this.$("#runstatus").attr("src", m.url()), 
HR.util.scrollToBottom(1e3);
};
}(this),
error:function(_this) {
return function() {
return HR.candidate.dtmodel = null, _this.setStatus("There was an issue with rendering this code.", "red");
};
}(this)
}) :(form_elem = $('<form target="runstatus" action="' + HR.candidate.dtmodel.url() + '" method="post">\n<input type="hidden" name="testing_design" />\n</form>'), 
form_elem.find('input[name="testing_design"]').val(JSON.stringify(data)), form_elem.submit());
}, RecruitCandidateDesignView.prototype.answer = function() {
return this.$("#editor").codeshell("value", !0);
}, RecruitCandidateDesignView.prototype.setStatus = function(s, additional_class) {
return null == additional_class && (additional_class = ""), this.$(".output-area-wrap").removeClass("hidden"), 
this.$(".status-msg").html(s), "" !== additional_class ? this.$(".status-msg").addClass(additional_class) :void 0;
}, RecruitCandidateDesignView.prototype.set_answer = function() {
var m;
return this.question.solve ? (m = {}, _.each(this.question.solve.answer, function(data) {
return m[data.language] = data.code;
}), this.$("#editor").codeshell("setOption", "lang_template", m), this.$("#editor").codeshell("setValue", {
language:"html",
code:m.html
})) :void 0;
}, RecruitCandidateDesignView.prototype.checkCopyPaste = function(change) {
var added_text;
if (this.setDefaultText && (added_text = change.text.join(""), added_text !== this.lastAddedText)) return this.lastAddedText = added_text, 
"paste" === change.origin && added_text.length > 100 ? HR.candidate.secureActivity.add({
action:"paste",
eid:9,
qid:this.question.unique_id,
insertTime:new Date()
}) :void 0;
}, RecruitCandidateDesignView;
}(window.HR.GenericView), RecruitCandidateMcqView = function(_super) {
function RecruitCandidateMcqView() {
return RecruitCandidateMcqView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateMcqView, _super), RecruitCandidateMcqView.prototype.template = "recruit/question-mcq", 
RecruitCandidateMcqView.prototype.className = "question-mcq", RecruitCandidateMcqView.prototype.events = {
"click .clearall":"clearAll"
}, RecruitCandidateMcqView.prototype.initialize = function(options) {
return this.question = options.question;
}, RecruitCandidateMcqView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
question:this.question
})), this.set_answer(), this;
}, RecruitCandidateMcqView.prototype.clearAll = function(e) {
return e.preventDefault(), this.$('input[name="mcqopts"]').attr("checked", !1);
}, RecruitCandidateMcqView.prototype.answer = function() {
var answer, o;
return "mcq" === this.question.type ? (o = this.$("input[name=mcqopts]:checked").val(), 
answer = o ? o :this.question.solve ? -1 :null, this.question.explanation_box && "true" === this.question.explanation_box ? {
explanation:this.$("textarea[name=explanation]").val(),
answer:answer
} :answer) :(o = [], _.each(this.$("input[name=mcqopts]:checked"), function(_this) {
return function(e) {
return o.push(_this.$(e).val());
};
}(this)), o.length ? o :this.question.solve ? -1 :null);
}, RecruitCandidateMcqView.prototype.set_answer = function() {
var ans, metadata, _i, _len, _ref, _results;
if (this.question.solve) {
if ("mcq" !== this.question.type) {
for (_ref = this.question.solve.answer.answer, _results = [], _i = 0, _len = _ref.length; _len > _i; _i++) ans = _ref[_i], 
_results.push(this.$("input#mcqopts" + ans).prop("checked", !0));
return _results;
}
return this.$("input#mcqopts" + this.question.solve.answer.answer).prop("checked", !0), 
this.question.explanation_box && "true" === this.question.explanation_box && this.question.solve.metadata ? (metadata = JSON.parse(this.question.solve.metadata), 
this.$("textarea[name=explanation]").val(metadata.explanation)) :void 0;
}
}, RecruitCandidateMcqView;
}(window.HR.GenericView), RecruitCandidateSubjectiveView = function(_super) {
function RecruitCandidateSubjectiveView() {
return RecruitCandidateSubjectiveView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateSubjectiveView, _super), RecruitCandidateSubjectiveView.prototype.template = "recruit/question-subjective", 
RecruitCandidateSubjectiveView.prototype.className = "question-subjective", RecruitCandidateSubjectiveView.prototype.initialize = function(options) {
return this.question = options.question, HR.candidate && HR.candidate.candidateAttemptModel ? (this.aid = HR.candidate.candidateAttemptModel.get("id"), 
this.autoSaveNamespace = "" + this.aid + "-" + this.question.unique_id, HR.appView.saveCodeOnNavigate = !0) :(this.aid = "testing", 
this.autoSaveNamespace = null);
}, RecruitCandidateSubjectiveView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
question:this.question
})), HR.appController.loadCodeMirror(function(_this) {
return function() {
return _this.applyCodeshell(), _this.set_answer();
};
}(this)), this;
}, RecruitCandidateSubjectiveView.prototype.applyCodeshell = function() {
var opts;
return opts = {
languages:[ "text" ],
language:"text",
autoSaveNamespace:this.autoSaveNamespace,
showSubmit:!1,
showCompileTest:!1,
dynamicMode:!0,
showCustomInput:!1,
lang_line_nos:this.question.line_nos,
loadmode:function() {
return function(e, data) {
return data.callback();
};
}(this)
}, this.$("#editor").codeshell(opts), this.$("#editor").codeshell("refresh");
}, RecruitCandidateSubjectiveView.prototype.answer = function() {
return this.$("#editor").codeshell("value");
}, RecruitCandidateSubjectiveView.prototype.set_answer = function() {
return this.question.solve ? this.$("#editor").codeshell("setValue", {
code:this.question.solve.answer.answer,
language:"text"
}) :void 0;
}, RecruitCandidateSubjectiveView;
}(window.HR.GenericView), RecruitCandidateFileUploadView = function(_super) {
function RecruitCandidateFileUploadView() {
return RecruitCandidateFileUploadView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateFileUploadView, _super), RecruitCandidateFileUploadView.prototype.template = "recruit/question-fileupload", 
RecruitCandidateFileUploadView.prototype.className = "question-fileupload", RecruitCandidateFileUploadView.prototype.initialize = function(options) {
return this.question = options.question;
}, RecruitCandidateFileUploadView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
question:this.question
})), this.set_answer(), window.view = this, this;
}, RecruitCandidateFileUploadView.prototype.answer = function() {
return $(":file").val() ? $(":file") :this.question.solve && this.question.solve.answer ? this.question.solve.answer :!1;
}, RecruitCandidateFileUploadView.prototype.set_answer = function() {
return this.question.solve ? this.show_answer(this.question.solve.answer) :void 0;
}, RecruitCandidateFileUploadView.prototype.show_answer = function(answer) {
var html;
return html = HR.util.getFileAnchor(answer), this.$("#current_answer").html(html), 
this.$(".current-answer-section").removeClass("hidden");
}, RecruitCandidateFileUploadView;
}(window.HR.GenericView), RecruitCandidateCompleteView = function(_super) {
function RecruitCandidateCompleteView() {
return RecruitCandidateCompleteView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateCompleteView, _super), RecruitCandidateCompleteView.prototype.template = "recruit/question-completesentence", 
RecruitCandidateCompleteView.prototype.className = "question-complete", RecruitCandidateCompleteView.prototype.initialize = function(options) {
return this.question = options.question;
}, RecruitCandidateCompleteView.prototype._render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
question:this.question
})), this;
}, RecruitCandidateCompleteView.prototype.postrender = function() {
return setTimeout(function(_this) {
return function() {
return _this.set_answer();
};
}(this));
}, RecruitCandidateCompleteView.prototype.answer = function() {
return _.map($('input[name^="blank"]'), function(e) {
return $(e).val();
});
}, RecruitCandidateCompleteView.prototype.set_answer = function() {
var cnt;
return this.question.solve ? (cnt = 0, _.each(this.question.solve.answer, function(v) {
return $('input[name="blank' + cnt + '"]').val(v), cnt += 1;
})) :void 0;
}, RecruitCandidateCompleteView;
}(window.HR.GenericView), RecruitCandidateUMLView = function(_super) {
function RecruitCandidateUMLView() {
return this.saveUml = __bind(this.saveUml, this), RecruitCandidateUMLView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateUMLView, _super), RecruitCandidateUMLView.prototype.template = "recruit/question-uml", 
RecruitCandidateUMLView.prototype.className = "question-uml", RecruitCandidateUMLView.prototype.initialize = function(options) {
return this.question = options.question, HR.candidate && HR.candidate.candidateAttemptModel ? (this.aid = HR.candidate.candidateAttemptModel.get("id"), 
this.autoSaveNamespace = "" + this.aid + "-" + this.question.unique_id, HR.appView.saveCodeOnNavigate = !0) :(this.aid = "testing", 
this.autoSaveNamespace = null), this.umlStorageKey = this.autoSaveNamespace + "-" + this.question.hash, 
this.editor = new Editor();
}, RecruitCandidateUMLView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
question:this.question
})), HR.appController.loadCodeMirror(function(_this) {
return function() {
return _this.applyCodeshell(), _this.set_answer();
};
}(this)), this.initializeUMLView(), this;
}, RecruitCandidateUMLView.prototype.initializeUMLView = function() {
var choices;
if (this.localSubmissionData = $.jStorage.get(this.umlStorageKey), this.xml = "", 
this.xml = this.localSubmissionData ? this.localSubmissionData.xml :null, this.question.custom_draw_menus) choices = this.question.custom_draw_menus; else switch (this.question.type) {
case "uml":
choices = [ "uml" ];
break;

case "electrical":
choices = [ "electrical" ];
break;

default:
choices = [];
}
return this.ui = new EditorUi(this.editor, choices, this.$("#geEditor")[0]), this.xml && this.ui && mxGraphFiles.load_xml(this.ui, this.xml), 
this.ui ? setTimeout(this.saveUml, 3e3) :void 0;
}, RecruitCandidateUMLView.prototype.saveUml = function() {
return this.saveUmlTimeout && ($.jStorage.set(this.umlStorageKey, mxGraphFiles.save(this.ui)), 
clearTimeout(this.saveUmlTimeout)), this.saveUmlTimeout = setTimeout(function(_this) {
return function() {
return _this.saveUml();
};
}(this), 3e3);
}, RecruitCandidateUMLView.prototype.applyCodeshell = function() {
var opts;
return opts = {
languages:[ "text" ],
language:"text",
autoSaveNamespace:this.autoSaveNamespace,
showSubmit:!1,
showCompileTest:!1,
dynamicMode:!0,
showCustomInput:!1,
lang_line_nos:this.question.line_nos,
loadmode:function() {
return function(e, data) {
return data.callback();
};
}(this)
}, this.$("#editor").codeshell(opts), this.$("#editor").codeshell("refresh");
}, RecruitCandidateUMLView.prototype.answer = function() {
var umlDiag;
return umlDiag = mxGraphFiles.save(this.ui), {
description:this.$("#editor").codeshell("value").code,
svg:umlDiag.svg,
xml:umlDiag.xml
};
}, RecruitCandidateUMLView.prototype.set_answer = function() {
return this.question.solve ? this.$("#editor").codeshell("setValue", {
code:this.question.solve.answer.answer,
language:"text"
}) :void 0;
}, RecruitCandidateUMLView;
}(window.HR.GenericView), RecruitCandidateFooterView = function(_super) {
function RecruitCandidateFooterView() {
return RecruitCandidateFooterView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateFooterView, _super), RecruitCandidateFooterView.prototype.template = "recruit/footer", 
RecruitCandidateFooterView.prototype.className = "footer", RecruitCandidateFooterView.prototype.initialize = function() {}, 
RecruitCandidateFooterView.prototype.render = function() {
var footer_copyright;
return $("footer").show(), footer_copyright = HR.candidate.candidateTestModel.get("footer_copyright"), 
$(this.el).html(HR.appController.template(this.template, this)({
test:HR.candidate.candidateTestModel.toJSON()
})), footer_copyright && "" !== footer_copyright || $("footer").hide(), this;
}, RecruitCandidateFooterView;
}(window.HR.GenericView), RecruitCandidateTopBarView = function(_super) {
function RecruitCandidateTopBarView() {
return RecruitCandidateTopBarView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateTopBarView, _super), RecruitCandidateTopBarView.prototype.template = "recruit/topbar", 
RecruitCandidateTopBarView.prototype.className = "topbar", RecruitCandidateTopBarView.prototype.fullScreeenMode = function() {
return screenfull && !(HR.candidate.candidateAttemptModel.get("attempt_done") && HR.candidate.candidateAttemptModel.get("attempt_done") === !0 || (clearTimeout(this.fullscreenTimer), 
this.fullscreenTimer = setTimeout(function(_this) {
return function() {
return screenfull.isFullscreen || 0 !== $(".hr-dialog").length || (_this.renderedDialog = !1), 
_this.fullScreeenMode();
};
}(this), 2e3), this.renderedDialog)) ? ("undefined" == typeof this.renderedDialog && document.addEventListener(screenfull.raw.fullscreenchange, function(_this) {
return function() {
return screenfull.isFullscreen || "logout" === HR.candidate.candidateTestModel.action ? void 0 :(_this.renderedDialog = !1, 
_this.fullScreeenMode());
};
}(this)), this.renderedDialog = !0, HR.util.alert({
title:"Switch to full screen mode",
message:"Please switch to full screen mode to proceed to test",
callback:function() {
return screenfull.enabled ? (Backbone.History.started && Backbone.history.stop(), 
Backbone.history.start({
pushState:!1,
root:"/tests"
}), Backbone.history.navigate("" + HR.candidate.candidateTestModel.get("unique_id") + "/questions", !0), 
screenfull.request()) :void 0;
}
})) :void 0;
}, RecruitCandidateTopBarView.prototype.secureMonitoring = function() {
var logEvent;
if (!this.secureMonitoringActive && HR.candidate.candidateAttemptModel) return this.secureMonitoringActive = !0, 
logEvent = function(data) {
return data.insertTime = new Date(), HR.candidate.secureActivity.add(data);
}, window.onblur = function() {
return logEvent({
action:"blur",
eid:7
});
}, window.onfocus = function() {
return logEvent({
action:"focus",
eid:8
});
};
}, RecruitCandidateTopBarView.prototype.initialize = function() {
return Offline.options = {
reconnect:{
initialDelay:3
},
requests:!1,
game:!1
};
}, RecruitCandidateTopBarView.prototype.getTimeLeft = function() {
var tl;
return tl = HR.candidate.candidateTestModel.get("sectional") ? HR.candidate.candidateAttemptModel.get("section_time_left") :HR.candidate.candidateAttemptModel.get("time_left");
}, RecruitCandidateTopBarView.prototype.timerForSection = function() {
return HR.candidate.candidateTestModel.get("sectional") && HR.candidate.candidateAttemptModel.get("section_time_left") !== HR.candidate.candidateAttemptModel.get("time_left");
}, RecruitCandidateTopBarView.prototype.updateTimer = function() {
var timeLeft;
return timeLeft = this.getTimeLeft(), setTimeout(function(_this) {
return function() {
return $("#countdown-timer").countdown("destroy").countdown({
until:timeLeft,
layout:"{d<}{dn}{dl} {d>} {hnn}:{mnn}:{snn}",
compact:!0
}), $("#countdown-timer").countdown("option", "onExpiry", _this.testTimeUp), 300 > timeLeft ? $(".timerspan").addClass("alerttimer") :$(".timerspan").removeClass("alerttimer"), 
_this.timerForSection() ? $("#timertag").html("to section end") :$("#timertag").html("to test end");
};
}(this));
}, RecruitCandidateTopBarView.prototype.render = function() {
var LONG_PING_TIME, QUICK_PING_TIME, interval, qcount, qdone;
return $(this.el).html(HR.appController.template(this.template, this)({
test:HR.candidate.candidateTestModel,
attempt:HR.candidate.candidateAttemptModel,
showalert:this.getTimeLeft < 300
})), HR.candidate.candidateAttemptModel.get("secure") && "True" === HR.candidate.candidateAttemptModel.get("secure") ? (this.secureMonitoring(), 
HR.requires("screenfull/dist/screenfull", function(_this) {
return function() {
return _this.fullScreeenMode();
};
}(this))) :HR.candidate.windowFocushookPresent || (HR.candidate.windowFocushookPresent = !0, 
window.onfocus = function() {
return function() {
return HR.candidate.windowBlurred = !1, HR.candidate.showFocusMessage ? (HR.candidate.showFocusMessage = !1, 
HR.util.alert({
title:"Refresh needed",
message:"The test state changed while you were away, and will be refreshed shortly.",
timeout:15,
callback:function() {
var uid;
if (HR.candidate && HR.candidate.candidateTestModel) return uid = HR.candidate.candidateTestModel.get("unique_id"), 
HR.router.navigate("" + uid + "/redirect", {
trigger:!0,
replace:!0
});
}
})) :void 0;
};
}(this), window.onblur = function() {
return function() {
return HR.candidate.windowBlurred = !0;
};
}(this)), this.updateTimer(), HR.candidate.pingTimer && clearInterval(HR.candidate.pingTimer), 
HR.candidate.candidateAttemptModel.get("attempt_done") ? HR.appView.setTopbarView() :(qdone = _.keys(HR.candidate.candidateAttemptModel.get("solve_mapping") || {}).length, 
qcount = HR.candidate.candidateAttemptModel.get("questions").length, this.$(".qdone").html(qdone), 
this.$(".qcount").html(qcount), this.$(".progress-done").css({
width:Math.floor(100 * qdone / qcount)
}), LONG_PING_TIME = 6e4, QUICK_PING_TIME = 1e4, interval = this.getTimeLeft() < 100 ? QUICK_PING_TIME :LONG_PING_TIME, 
HR.candidate.pingTimer = setInterval(function(_this) {
return function() {
var ans, dat, outerSection, saving, sectional;
return dat = {
pong:!0
}, HR.candidate.currentQuestion && (ans = HR.candidate.questionView.getAnswerToSave(), 
saving = !1, ans && (saving = !0, dat.to_save_code = ans, dat.qid = HR.candidate.questionView.model.get("unique_id"))), 
saving && HR.candidate.questionView.view.$("#editor").codeshell("setStatusText", "Saving draft.."), 
HR.candidate.candidateTestModel ? (sectional = HR.candidate.candidateTestModel.get("sectional"), 
sectional && (outerSection = HR.candidate.candidateAttemptModel.get("section")), 
HR.candidate.candidateAttemptModel.save({
data:dat
}, {
success:function(model) {
return saving && HR.candidate.questionView.view.$("#editor").codeshell("setStatusText", "Draft saved " + moment().format("hh:mm a")), 
HR.candidate.windowBlurred && (sectional && model.get("section") !== outerSection || model.get("attempt_done")) ? HR.candidate.showFocusMessage = !0 :HR.candidate.showFocusMessage ? void 0 :_this.updateTimer();
},
error:function() {
return saving ? HR.candidate.questionView.view.$("#editor").codeshell("setStatusText", "Unable to save draft.") :void 0;
}
})) :void 0;
};
}(this), interval)), this;
}, RecruitCandidateTopBarView.prototype.testTimeUp = function() {
return HR.candidate.pingTimer && clearInterval(HR.candidate.pingTimer), HR.candidate.candidateTestModel.get("sectional") && HR.candidate.candidateAttemptModel.get("time_left") > 30 ? ($("#countdown-timer").countdown("destroy").html("Section done."), 
$(".timerspan").removeClass("alerttimer"), $("#timertag").empty(), HR.candidate.showFocusMessage = !1, 
HR.util.alert({
title:"Section closed",
message:"You have exceeded the time limit set for this section.<br><br>All answers you submitted before the time limit have been saved. You will automatically be moved to the next section shortly.",
timeout:15,
callback:function() {
var uid;
return uid = HR.candidate.candidateTestModel.get("unique_id"), HR.candidate.attemptRefreshNeeded = !0, 
HR.router.navigate("" + uid + "/redirect", {
trigger:!0,
replace:!0
});
}
})) :($("#countdown-timer").countdown("destroy").html("Test done."), $(".timerspan").removeClass("alerttimer"), 
$("#timertag").empty(), HR.candidate.showFocusMessage = !1, HR.util.alert({
title:"Test finished",
message:"Thank you for taking this test. You have exceeded the time limit set for this test.<br><br>All answers you submitted before the time limit have been saved.<br><br>You will shortly be redirected to the feedback page.",
timeout:60,
callback:function() {
return HR.candidate.candidateTestModel.setAction("logout"), HR.candidate.candidateTestModel.save(null, {
success:function() {
return function(m) {
return HR.router.navigate("" + m.get("unique_id") + "/redirect", {
trigger:!0,
replace:!0
});
};
}(this)
});
}
}));
}, RecruitCandidateTopBarView;
}(window.HR.GenericView), RecruitCandidateSideBarView = function(_super) {
function RecruitCandidateSideBarView() {
return RecruitCandidateSideBarView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateSideBarView, _super), RecruitCandidateSideBarView.prototype.template = "recruit/sidebar", 
RecruitCandidateSideBarView.prototype.className = "sbar", RecruitCandidateSideBarView.prototype.icon_types = {
QUESTION_ANSWERED:"nav",
QUESTION_UNANSWERED:1,
QUESTION_LIST:2
}, RecruitCandidateSideBarView.prototype.events = {
"click .js-navlink":"handleNav"
}, RecruitCandidateSideBarView.prototype.render = function() {
var url;
return url = Backbone.history.fragment, $(this.el).html(HR.appController.template(this.template, this)), 
this.$(".fixed-nav").html(this.getTopIcons()), url.endsWith("questions") || url.endsWith("questions/") || (this.$(".questions-nav").html(this.getQuestionIcons()), 
HR.candidate.lastQuestionViewed && setTimeout(function(_this) {
return function() {
return _this.$(".qnav-" + HR.candidate.lastQuestionViewed)[0] && _this.$(".qnav-" + HR.candidate.lastQuestionViewed)[0].scrollIntoView(), 
_this.delegateEvents();
};
}(this))), this;
}, RecruitCandidateSideBarView.prototype.handleNav = function(e) {
var hreftmp, me;
return me = this.$(e.currentTarget), me.hasClass("disabled") ? (e.preventDefault(), 
void 0) :(hreftmp = me.attr("href"), this.$(".js-navlink").removeAttr("href"), this.$(".js-navlink").removeClass("backbone"), 
this.$(".js-navlink").addClass("disabled"), me.addClass("backbone").removeClass("disabled").attr("href", hreftmp));
}, RecruitCandidateSideBarView.prototype.getTopIcons = function() {
var cls, html, url;
return html = "", url = Backbone.history.fragment, cls = "", (url.endsWith("questions") || url.endsWith("questions/")) && (cls = "active"), 
html += '<li class="' + cls + '"><a href="' + HR.candidate.candidateTestModel.get("unique_id") + '/questions" class="backbone js-navlink"><i class="nav-icon icon-list-bullet-large"></i></a></li>', 
cls = "", (url.endsWith("instructions") || url.endsWith("instructions/")) && (cls = "active"), 
html += '<li class="' + cls + '"><a href="' + HR.candidate.candidateTestModel.get("unique_id") + '/instructions" class="backbone js-navlink"><i class="nav-icon icon-help-circled"></i></a></li>';
}, RecruitCandidateSideBarView.prototype.getQuestionIcons = function() {
var active, answered, answered_qs, elhtml, label, li_gen, q, qs, _i, _len, _ref;
for (elhtml = "", li_gen = function(answered, disabled, active, link, label) {
var act, ans, btnclass, dis, href;
return ans = answered ? "answered" :"not-answered", dis = disabled ? "disabled" :"", 
act = active ? "active" :"", btnclass = disabled || active ? "" :"backbone js-navlink", 
href = disabled || active ? "" :"href='" + link + "'", '<li class="qnav-' + label + " " + ans + " " + dis + " " + act + '">\n  <a ' + href + ' class="' + btnclass + '">\n      <span class="quest-number">' + label + "</span>\n  </a>\n</li>";
}, qs = HR.candidate.candidateAttemptModel.get("questions"), answered_qs = _.keys(HR.candidate.candidateAttemptModel.get("solve_mapping")), 
label = 1, _i = 0, _len = qs.length; _len > _i; _i++) q = qs[_i], _ref = q.unique_id.toString(), 
answered = __indexOf.call(answered_qs, _ref) >= 0, active = q.unique_id === HR.candidate.currentQuestion, 
elhtml += q.disabled ? li_gen(answered, !0, active, "", label) :li_gen(answered, !1, active, "" + HR.candidate.candidateTestModel.get("unique_id") + "/questions/" + q.unique_id, label), 
label += 1;
return elhtml;
}, RecruitCandidateSideBarView;
}(window.HR.GenericView), RecruitCandidateCompileTestView = function(_super) {
function RecruitCandidateCompileTestView() {
return RecruitCandidateCompileTestView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateCompileTestView, _super), RecruitCandidateCompileTestView.prototype.template = "recruit/compiletest-base", 
RecruitCandidateCompileTestView.prototype.className = "ct-base", RecruitCandidateCompileTestView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)), this;
}, RecruitCandidateCompileTestView.prototype.setStatus = function(s, additional_class) {
return null == additional_class && (additional_class = ""), this.$(".status-msg").html(s), 
"" !== additional_class ? this.$(".status-msg").addClass(additional_class) :void 0;
}, RecruitCandidateCompileTestView.prototype.setCompileStatus = function(title, message) {
return this.$(".compile-header").html(title), this.$(".compile-message").html(message), 
this.$("#error-message").removeClass("hide");
}, RecruitCandidateCompileTestView.prototype.addTestCase = function(tno, input, output, output_debug, exp_output, compiler_msg, st_class, score) {
var tc;
return tc = new HR.RecruitCandidateTestCaseView({
tno:tno,
input:input,
output:output,
exp_output:exp_output,
st_class:st_class,
compiler_msg:compiler_msg,
output_debug:output_debug,
score:score
}), this.$(".testcases").append(tc.render().el);
}, RecruitCandidateCompileTestView;
}(window.HR.GenericView), RecruitCandidateTestCaseView = function(_super) {
function RecruitCandidateTestCaseView() {
return RecruitCandidateTestCaseView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateTestCaseView, _super), RecruitCandidateTestCaseView.prototype.template = "recruit/compiletest-testcase", 
RecruitCandidateTestCaseView.prototype.classname = "test-case-wrap", RecruitCandidateTestCaseView.prototype.initialize = function(o) {
return this.tno = o.tno, this.input = o.input, this.output = o.output, this.exp_output = o.exp_output, 
this.compiler_msg = o.compiler_msg, this.st_class = o.st_class, this.output_debug = o.output_debug, 
this.score = o.score;
}, RecruitCandidateTestCaseView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
tno:this.tno,
input:this.input,
output:this.output,
exp_output:this.exp_output,
compiler_msg:this.compiler_msg,
st_class:this.st_class,
output_debug:this.output_debug,
score:this.score
})), this;
}, RecruitCandidateTestCaseView;
}(window.HR.GenericView), HR = null != (_ref = window.HR) ? _ref :{}, HR.RecruitCandidateListView = RecruitCandidateListView, 
HR.RecruitCandidateQuestionView = RecruitCandidateQuestionView, HR.RecruitCandidateCodingView = RecruitCandidateCodingView, 
HR.RecruitCandidateDesignView = RecruitCandidateDesignView, HR.RecruitCandidateMcqView = RecruitCandidateMcqView, 
HR.RecruitCandidateSubjectiveView = RecruitCandidateSubjectiveView, HR.RecruitCandidateCompleteView = RecruitCandidateCompleteView, 
HR.RecruitCandidateFileUploadView = RecruitCandidateFileUploadView, HR.RecruitCandidateUMLView = RecruitCandidateUMLView, 
HR.RecruitCandidateTopBarView = new RecruitCandidateTopBarView(), HR.RecruitCandidateFooterView = new RecruitCandidateFooterView(), 
HR.RecruitCandidateSideBarView = new RecruitCandidateSideBarView(), HR.RecruitCandidateCompileTestView = RecruitCandidateCompileTestView, 
HR.RecruitCandidateTestCaseView = RecruitCandidateTestCaseView, HR.RecruitCandidateInstructionsView = RecruitCandidateInstructionsView;
});
}.call(this), function() {
var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var HR, RecruitCandidateLoginView, RecruitFacebookResumeView, RecruitMessageView, RecruitMismatchView, _ref;
return RecruitCandidateLoginView = function(_super) {
function RecruitCandidateLoginView() {
return RecruitCandidateLoginView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitCandidateLoginView, _super), RecruitCandidateLoginView.prototype.template = "recruit/login", 
RecruitCandidateLoginView.prototype.className = "candidate-login", RecruitCandidateLoginView.prototype.events = {
"click .test-submit":"loginAction",
"click .test-submit-feedback":"submitFeedback",
"click .test-logout":"logoutTest",
"click .fblogin":"loginToFB",
"blur input.error":"removeError"
}, RecruitCandidateLoginView.prototype.initialize = function() {}, RecruitCandidateLoginView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
test:this.model.attributes
})), this.model.get("facebook_login") && !window.fbAdded && (window.fbAdded = !0, 
$.getScript("/assets/fb.js")), this;
}, RecruitCandidateLoginView.prototype.removeError = function(e) {
return $(e.target).removeClass("error").closest(".error").removeClass("error");
}, RecruitCandidateLoginView.prototype.resetError = function() {
var $err;
return $err = this.$("#error-message"), $err.find("header").html(""), $err.find("p").html(""), 
this.$(".formgroup").removeClass("error").find("[name]").removeClass("error"), $err.hide();
}, RecruitCandidateLoginView.prototype.setError = function(title, message, alertclass, field_name) {
var $err, duration, top;
return null == alertclass && (alertclass = null), null == field_name && (field_name = null), 
$err = this.$("#error-message"), $err.find("header").html(title), $err.find("p").html(message), 
alertclass && this.$("#error-message").addClass(alertclass), field_name && this.$("[name=" + field_name + "]").addClass("error").closest(".formgroup").addClass("error"), 
$err.show(), top = $err.position().top, duration = parseInt(top, 10) / 2, setTimeout(function() {
return $("html,body").animate({
scrollTop:top
}, duration);
}, 0);
}, RecruitCandidateLoginView.prototype.loginAction = function(e) {
var email, form_data, pass, put_data, request_params, that, uniqid;
return this.disableButton("test-submit"), that = this, e.preventDefault(), this.resetError(), 
email = this.$("input[name=username]").val(), pass = this.$("input[name=password]").val(), 
this.$("#acknowledge").is(":checked") ? (this.$("#acknowledge-alert").remove(), 
form_data = $("#test-login-form").serializeArray(), put_data = {}, _.each(form_data, function(item) {
return "gender" !== item.name ? put_data[item.name] = item.value :("on" === $("input#gender-m:checked").val() && (put_data.gender = "m"), 
"on" === $("input#gender-f:checked").val() ? put_data.gender = "f" :void 0);
}), put_data.tauth_key = this.model.auth, $("#acknowledge").is(":checked") && (put_data.acknowledge = "on"), 
uniqid = this.model.get("unique_id"), request_params = {
url:"/recruit/tests/" + uniqid + "/login",
data:put_data,
type:"POST",
success:function(_this) {
return function(xhr) {
var r;
return r = "string" == typeof xhr ? $.parseJSON($(xhr).text()) :xhr, HR.candidate.candidateTestModel.set(r.model), 
r.status ? (r.model.attempt_done ? HR.router.navigate("" + uniqid) :HR.router.navigate("" + uniqid + "/questions", {
trigger:!0,
replace:!0
}), void 0) :(_this.enableButton("test-submit"), that.setError(r.message.title, r.message.body, null, r.message.field_name));
};
}(this),
error:function(_this) {
return function(xhr) {
var r;
return _this.enableButton("test-submit"), r = "string" == typeof xhr.responseText ? $.parseJSON($(xhr.responseText).text()) :xhr.responseText, 
r && r.message ? that.setError(r.message.title, r.message.body, r.message.alertclass, r.message.field_name) :that.setError("Login error", "There was an issue logging into the test");
};
}(this)
}, $(":file").length > 0 && (request_params.iframe = !0, request_params.processData = !1, 
request_params.data = put_data, request_params.files = $(":file")), $.ajax(request_params), 
this) :(this.enableButton("test-submit"), !this.$("#acknowledge-alert").length > 0 && this.$("#login-form").before('<div class="text-center alert error error-message" id="acknowledge-alert"> You cannot take this test without agreeing to the specified conditions. </div>'), 
void 0);
}, RecruitCandidateLoginView.prototype.submitFeedback = function() {
return this.disableButton("test-submit-feedback"), HR.candidate.candidateAttemptModel.set("feedback_text", this.$(".feedback-text").val()), 
HR.candidate.candidateAttemptModel.save(null, {
success:function(_this) {
return function() {
return $.removeCookie("email", {
path:"/"
}), $.removeCookie("tid", {
path:"/"
}), _this.enableButton("test-submit-feedback"), _this.logoutTest();
};
}(this),
error:function() {
return this.enableButton("test-submit-feedback"), console.log("Could not submit feedback.");
}
});
}, RecruitCandidateLoginView.prototype.logoutTest = function() {
return HR.clearCookies(), window.candidate = {}, this.$(".main-content").html("<h3>Thank you!</h3><br/><br/><p>The test is done. You may close this window, or head on to  <a href='//www.hackerrank.com'>hackerrank.com</a> and solve challenges.</p>");
}, RecruitCandidateLoginView.prototype.disableButton = function(cssClass) {
return this.$("button." + cssClass).attr("disabled", !0).addClass("disabled");
}, RecruitCandidateLoginView.prototype.enableButton = function(cssClass) {
return this.$("button." + cssClass).attr("disabled", !1).removeClass("disabled");
}, RecruitCandidateLoginView.prototype.loginToFB = function() {
return window.location = this.model.get("facebook_login_url");
}, RecruitCandidateLoginView;
}(window.HR.GenericView), RecruitFacebookResumeView = function(_super) {
function RecruitFacebookResumeView() {
return RecruitFacebookResumeView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitFacebookResumeView, _super), RecruitFacebookResumeView.prototype.template = "recruit/fbresume", 
RecruitFacebookResumeView.prototype.className = "candidate-fb", RecruitFacebookResumeView.prototype.events = {
"click .starttest":"startTest"
}, RecruitFacebookResumeView.prototype.initialize = function(options) {
return this.model = options.model, this.data = options.data;
}, RecruitFacebookResumeView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
test:this.model.attributes,
data:this.data
})), this;
}, RecruitFacebookResumeView.prototype.startTest = function() {
var p, req_params;
return p = this.$(".userprofile").val(), p ? (req_params = {
type:"put",
url:"/recruit/tests/" + this.model.get("unique_id") + "/fb_login",
data:{
profile:p
},
success:function(_this) {
return function() {
return HR.router.navigate("" + _this.model.get("unique_id") + "/questions", {
trigger:!0,
replace:!0
});
};
}(this),
error:function(_this) {
return function(e) {
return window.candidatemessage = JSON.parse(e.responseText).message, HR.router.navigate("" + _this.model.get("unique_id") + "/message", {
trigger:!0,
replace:!0
});
};
}(this)
}, $.ajax(req_params)) :new HR.util.ShowConfirmationDialog({
body:"Please enter a short profile about yourself.",
title:"Empty profile.",
buttons:[ {
name:"OK",
callback:function(dialog) {
return dialog.destroy();
}
} ]
}).render();
}, RecruitFacebookResumeView;
}(window.HR.GenericView), RecruitMessageView = function(_super) {
function RecruitMessageView() {
return RecruitMessageView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitMessageView, _super), RecruitMessageView.prototype.template = "recruit/candidatemessage", 
RecruitMessageView.prototype.className = "candidate-message", RecruitMessageView.prototype.initialize = function(options) {
return this.model = options.model, this.message = options.message;
}, RecruitMessageView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
test:this.model && this.model.attributes || {},
message:this.message
})), this;
}, RecruitMessageView;
}(window.HR.GenericView), RecruitMismatchView = function(_super) {
function RecruitMismatchView() {
return RecruitMismatchView.__super__.constructor.apply(this, arguments);
}
return __extends(RecruitMismatchView, _super), RecruitMismatchView.prototype.template = "recruit/candidatemismatch", 
RecruitMismatchView.prototype.className = "candidate-mismatch", RecruitMismatchView.prototype.events = {
"click .js-gotoother":"logoutGotoOther"
}, RecruitMismatchView.prototype.logoutGotoOther = function(e) {
return e.preventDefault(), HR.clearCookies(), HR.candidate.candidateTestModel = null, 
HR.candidate.candidateAttemptModel = null, HR.candidate.attemptRefreshNeeded = !1, 
HR.router.navigate(this.$(e.currentTarget).attr("href"), {
trigger:!0,
replace:!0
});
}, RecruitMismatchView.prototype.render = function() {
return $(this.el).html(HR.appController.template(this.template, this)({
test:HR.candidate.candidateTestModel.toJSON()
})), this;
}, RecruitMismatchView;
}(window.HR.GenericView), HR = null != (_ref = window.HR) ? _ref :{}, HR.RecruitCandidateLoginView = RecruitCandidateLoginView, 
HR.RecruitFacebookResumeView = RecruitFacebookResumeView, HR.RecruitMessageView = RecruitMessageView, 
HR.RecruitMismatchView = RecruitMismatchView;
});
}.call(this), $(function() {
$.fn.bootstrapFileInput = function() {
this.each(function(i, elem) {
var $elem = $(elem);
if ("undefined" == typeof $elem.attr("data-bfi-disabled")) {
var buttonWord = "Browse";
"undefined" != typeof $elem.attr("title") && (buttonWord = $elem.attr("title"));
var input = $("<div>").append($elem.eq(0).clone()).html(), className = "";
$elem.attr("class") && (className = " " + $elem.attr("class")), $elem.replaceWith('<a class="file-input-wrapper btn' + className + '">' + buttonWord + input + "</a>");
}
}).promise().done(function() {
$(".file-input-wrapper").mousemove(function(cursor) {
var input, wrapper, wrapperX, wrapperY, inputWidth, inputHeight, cursorX, cursorY;
wrapper = $(this), input = wrapper.find("input"), wrapperX = wrapper.offset().left, 
wrapperY = wrapper.offset().top, inputWidth = input.width(), inputHeight = input.height(), 
cursorX = cursor.pageX, cursorY = cursor.pageY, moveInputX = cursorX - wrapperX - inputWidth + 20, 
moveInputY = cursorY - wrapperY - inputHeight / 2, input.css({
left:moveInputX,
top:moveInputY
});
}), $(".file-input-wrapper input[type=file]").change(function() {
var fileName;
fileName = $(this).val(), $(this).parent().next(".file-input-name").remove(), fileName = $(this).prop("files") && $(this).prop("files").length > 1 ? $(this)[0].files.length + " files" :fileName.substring(fileName.lastIndexOf("\\") + 1, fileName.length), 
$(this).parent().after('<span class="file-input-name">' + fileName + "</span>");
});
});
};
var cssHtml = "<style>.file-input-wrapper { overflow: hidden; position: relative; cursor: pointer; z-index: 1; }.file-input-wrapper input[type=file], .file-input-wrapper input[type=file]:focus, .file-input-wrapper input[type=file]:hover { position: absolute; top: 0; left: 0; cursor: pointer; opacity: 0; filter: alpha(opacity=0); z-index: 99; outline: 0; }.file-input-name { margin-left: 8px; }</style>";
$("link[rel=stylesheet]").eq(0).before(cssHtml);
}), function() {
var __bind = function(fn, me) {
return function() {
return fn.apply(me, arguments);
};
}, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
function ctor() {
this.constructor = child;
}
for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
child;
};
jQuery(function() {
var CandidateRouter, HR, h, _ref;
return CandidateRouter = function(_super) {
function CandidateRouter() {
return this.navigate = __bind(this.navigate, this), CandidateRouter.__super__.constructor.apply(this, arguments);
}
return __extends(CandidateRouter, _super), CandidateRouter.prototype.routes = {
"":"default_route",
"_=_":"default_route",
":unique_id/redirect":"candidate_redirect",
":unique_id/mismatch":"candidate_mismatch",
":unique_id/feedback":"candidate_feedback",
":unique_id/feedback/":"candidate_feedback",
":unique_id/questions":"candidate_questionlist",
":unique_id/questions/":"candidate_questionlist",
":unique_id/instructions":"candidate_instructions",
":unique_id/instructions/":"candidate_instructions",
":unique_id/questions/:question_unique_id":"candidate_question",
":unique_id/questions/:question_unique_id/":"candidate_question",
":unique_id/fblogin":"fblogin",
":unique_id/message":"message",
":unique_id":"candidate_login",
":unique_id/":"candidate_login",
":unique_id/:authkey":"candidate_login",
":unique_id/:authkey/":"candidate_login",
":unique_id/login/:username/:password":"candidate_login_prefil"
}, CandidateRouter.prototype.initialize = function() {
return HR.requires("compound/recruit-candidate", function(_this) {
return function() {
return HR.appView = new HR.CandidateView(), HR.candidate = {}, HR.candidate.candidateTestModel = null, 
HR.candidate.candidateAttemptModel = null, HR.candidate.attemptRefreshNeeded = !1, 
HR.candidate.currentQuestion = null, HR.candidate.secureActivity = new HR.CandidateActivityCollection(), 
HR.candidate.attemptData = null, HR.candidate.windowFocushookPresent = !1, HR.candidate.windowBlurred = !1, 
HR.candidate.showFocusMessage = !1, HR.candidate.lastQuestionViewed = null, HR.authkey = null, 
HR.candidate.questionView = null, HR.candidate.questions = {}, HR.candidate.redirectBackTo = null, 
window._errs || (window._errs = {}), HR.routehistory = [], HR.redirectNeeded = function() {
return !HR.candidate.candidateTestModel || !HR.candidate.candidateAttemptModel || HR.candidate.attemptRefreshNeeded;
}, HR.clearCookies = function() {
return $.removeCookie("email", {
path:"/"
}), $.removeCookie("tid", {
path:"/"
}), $.removeCookie("fb_data", {
path:"/"
}), $.removeCookie("sfb_data", {
path:"/"
});
}, HR.setErrorceptionContext = function() {
return window._errs.meta || (window._errs.meta = {}), window._errs.meta.candidateEmail = HR.candidate.candidateAttemptModel.get("email");
}, _this.on("route", function() {
return HR.routehistory.push(moment(Date.now()).format() + " " + Backbone.history.fragment), 
HR.routehistory.length > 20 && HR.routehistory.shift(), window._errs.meta || (window._errs.meta = {}), 
window._errs.meta.history = HR.routehistory.join("\n");
}), HR.redirect = function(testmodel, attemptmodel) {
var path, tuid;
return HR.RecruitCandidateTopBarView && HR.RecruitCandidateTopBarView.updateTimer(), 
tuid = testmodel.get("unique_id"), testmodel.get("attempt_done") ? attemptmodel.get("feedback_given") ? (window.candidatemessage = "You've completed the test.", 
HR.router.navigate("" + tuid + "/message", {
trigger:!0,
replace:!0
}), HR.clearCookies(), void 0) :HR.router.navigate("" + tuid + "/feedback", {
trigger:!0,
replace:!0
}) :HR.candidate.redirectBackTo ? (path = HR.candidate.redirectBackTo, HR.candidate.redirectBackTo = null, 
HR.router.navigate(path, {
trigger:!0,
replace:!0
}), void 0) :HR.router.navigate("" + tuid + "/questions", {
trigger:!0,
replace:!0
});
}, HR.showThrobber = function() {
return HR.util.candidatemsg("Loading..");
}, HR.hideThrobber = function(delay) {
return null == delay && (delay = 0), HR.util.candidatemsg("Loading..", !1, !0, delay);
};
};
}(this));
}, CandidateRouter.prototype.default_route = function() {
return HR.requires("compound/recruit-candidate", function() {
var msgview;
return HR.appView.setTopbarView(null), HR.appView.setSidebarView(null), msgview = new HR.RecruitMessageView({
model:null,
message:"No test id provided in the URL.<br><br>You can take Hackerrank's sample test at this URL: <a href='http://www.hackerrank.com/tests/sample'>www.hackerrank.com/tests/sample</a>"
}), HR.appView.setContentView(msgview);
});
}, CandidateRouter.prototype.navigate = function(fragment, options) {
return HR.appView && HR.appView.saveCodeOnNavigate && ($("#editor").codeshell("saveLangCode"), 
HR.appView.saveCodeOnNavigate = !1), CandidateRouter.__super__.navigate.call(this, fragment, options);
}, CandidateRouter.prototype.candidate_redirect = function(unique_id) {
return HR.requires("compound/recruit-candidate", function() {
var dat, test;
return Offline && Offline.check(), HR.showThrobber(), test = new HR.CandidateTestModel(), 
test.setTidAuth(unique_id, HR.authkey), test.setAction("show"), dat = HR.candidate.attemptData ? HR.candidate.attemptData :{}, 
test.fetch({
data:dat,
processData:!0,
success:function() {
return function(m) {
var aid, attempt;
return document.title = m.get("name") + " :: powered by HackerRank", HR.candidate.candidateTestModel = m, 
aid = HR.candidate.candidateTestModel.get("attempt"), m.get("unique_id") !== unique_id ? (HR.hideThrobber(1), 
HR.router.navigate("" + unique_id + "/mismatch", {
trigger:!0,
replace:!0
}), void 0) :aid ? HR.candidate.candidateTestModel.get("attempt_object") ? (attempt = new HR.CandidateAttemptModel(), 
attempt.set(HR.candidate.candidateTestModel.get("attempt_object")), HR.hideThrobber(1), 
HR.candidate.attemptRefreshNeeded = !1, HR.candidate.candidateAttemptModel = attempt, 
HR.candidate.attemptData = null, HR.setErrorceptionContext(), HR.redirect(test, attempt)) :(attempt = new HR.CandidateAttemptModel(), 
attempt.setAid(aid), attempt.fetch({
data:dat,
processData:!0,
success:function(m) {
return HR.hideThrobber(1), HR.candidate.attemptRefreshNeeded = !1, HR.candidate.candidateAttemptModel = m, 
HR.candidate.attemptData = null, HR.setErrorceptionContext(), HR.redirect(test, attempt);
},
error:function() {
return HR.hideThrobber(1), Offline && Offline.check(), setTimeout(function() {
return HR.util.candidatemsg("Unable to receive test data from this URL.<br><br> Check your internet connection, and continue when you're back online.<br><br><a href='" + unique_id + "/questions' class='backbone btn'>Continue</a>", !1);
}, 200);
}
})) :(HR.hideThrobber(1), $.cookie("fb_data") ? HR.router.navigate("" + unique_id + "/fblogin", {
trigger:!0,
replace:!0
}) :HR.authkey ? HR.router.navigate("" + unique_id + "/" + HR.authkey, {
trigger:!0,
replace:!0
}) :HR.router.navigate("" + unique_id, {
trigger:!0,
replace:!0
}), void 0);
};
}(this),
error:function() {
return function() {
return HR.hideThrobber(), HR.candidate.candidateTestModel = null, Offline && Offline.check(), 
setTimeout(function() {
return HR.util.candidatemsg("Unable to receive test data from this URL.<br><br> Check your internet connection, and continue when you're back online.<br><br><a href='" + unique_id + "/questions' class='backbone btn'>Continue</a>", !1);
}, 200);
};
}(this)
});
});
}, CandidateRouter.prototype.message = function(unique_id) {
return null == unique_id && (unique_id = ""), HR.requires("compound/recruit-candidate", function() {
var msg, msgview;
return HR.appView.setTopbarView(null), HR.appView.setSidebarView(null), msg = window.candidatemessage || $.cookie("candidatemessage") || null, 
msg ? (msgview = new HR.RecruitMessageView({
model:HR.candidate.candidateTestModel,
message:msg
}), HR.appView.setContentView(msgview)) :HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
});
});
}, CandidateRouter.prototype.candidate_mismatch = function() {
return HR.requires("compound/recruit-candidate", function() {
var mmview;
return HR.appView.setTopbarView(null), HR.appView.setSidebarView(null), mmview = new HR.RecruitMismatchView(), 
HR.appView.setContentView(mmview);
});
}, CandidateRouter.prototype.candidate_login = function(unique_id, authkey) {
return null == unique_id && (unique_id = null), null == authkey && (authkey = null), 
HR.requires("compound/recruit-candidate", function() {
var candidate_view, m, tid;
return HR.candidate.candidateTestModel ? (m = HR.candidate.candidateTestModel, tid = m.get("unique_id"), 
candidate_view = new HR.RecruitCandidateLoginView({
model:m
}), HR.appView.setContentView(candidate_view), HR.appView.setTopbarView(null), HR.appView.setFooterView(HR.RecruitCandidateFooterView), 
HR.appView.setSidebarView(null)) :(authkey && (HR.authkey = authkey), HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
}), void 0);
});
}, CandidateRouter.prototype.candidate_login_prefil = function(unique_id, username, password) {
return null == unique_id && (unique_id = null), null == username && (username = null), 
null == password && (password = null), HR.requires("compound/recruit-candidate", function() {
HR.candidate.candidateTestModel || (username && password && (HR.username = username, 
HR.password = password), HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
}));
});
}, CandidateRouter.prototype.fblogin = function(unique_id) {
return null == unique_id && (unique_id = ""), HR.requires("compound/recruit-candidate", function() {
var fb_view;
return HR.candidate.candidateTestModel ? (fb_view = new HR.RecruitFacebookResumeView({
data:JSON.parse($.cookie("fb_data")),
model:HR.candidate.candidateTestModel
}), HR.appView.setContentView(fb_view), HR.appView.setTopbarView(null), HR.appView.setSidebarView(null)) :(HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
}), void 0);
});
}, CandidateRouter.prototype.candidate_questionlist = function(unique_id) {
return HR.requires("compound/recruit-candidate", function() {
var content_view, m;
return HR.redirectNeeded() ? (HR.candidate.redirectBackTo = Backbone.history.fragment, 
HR.candidate.attemptData = {
qlist:!0
}, HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
}), void 0) :(m = HR.candidate.candidateAttemptModel, HR.candidate.secureActivity.setAid(m.aid), 
content_view = new HR.RecruitCandidateListView(), HR.candidate.currentQuestion = null, 
HR.appView.setContentView(content_view), HR.appView.setTopbarView(HR.RecruitCandidateTopBarView), 
HR.appView.setSidebarView(HR.RecruitCandidateSideBarView), HR.appView.setFooterView(HR.RecruitCandidateFooterView));
});
}, CandidateRouter.prototype.candidate_question = function(unique_id, question_unique_id) {
return HR.requires("compound/recruit-candidate", function() {
var m, q;
return HR.redirectNeeded() ? (HR.candidate.redirectBackTo = Backbone.history.fragment, 
HR.candidate.attemptData = {
qview:!0,
qid:question_unique_id
}, HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
}), void 0) :(m = HR.candidate.candidateAttemptModel, q = new HR.CandidateQuestionModel(), 
q.setAid(m.get("id")), q.setQid(question_unique_id), q.fetch({
success:function() {
return function(m) {
var content_view;
return content_view = new HR.RecruitCandidateQuestionView({
model:m
}), HR.candidate.currentQuestion = m.get("unique_id"), HR.candidate.secureActivity.setAid(m.aid), 
HR.appView.setContentView(content_view), HR.appView.setTopbarView(HR.RecruitCandidateTopBarView), 
HR.appView.setFooterView(HR.RecruitCandidateFooterView), HR.appView.setSidebarView(HR.RecruitCandidateSideBarView), 
HR.candidate.questionView = content_view;
};
}(this),
error:function() {
return function(m, xhr) {
var msg, o;
return o = JSON.parse(xhr.responseText), msg = "", o.error && (msg = o.error), HR.util.alert({
message:"There was a problem with loading this question page.<br><br>" + msg + "<br><br>Click continue to goto test listing page.",
title:"Question load error",
okButtonTest:"Continue",
callback:function() {
return HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
});
}
});
};
}(this)
}));
});
}, CandidateRouter.prototype.candidate_feedback = function(unique_id) {
return HR.requires("compound/recruit-candidate", function() {
var candidate_view, m, mixpanel_data, mixpanel_event;
return clearInterval(HR.candidate.timerInterval), HR.redirectNeeded() ? (HR.candidate.redirectBackTo = Backbone.history.fragment, 
HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
}), void 0) :(m = HR.candidate.candidateAttemptModel, HR.candidate.secureActivity.setAid(m.aid), 
HR.appView.setTopbarView(null), HR.appView.setFooterView(HR.RecruitCandidateFooterView), 
HR.appView.setSidebarView(null), candidate_view = new HR.RecruitCandidateLoginView({
model:HR.candidate.candidateTestModel
}), HR.appView.setContentView(candidate_view), window.btoa && window.location.host.toLowerCase().indexOf("hackerrank.com") >= 0 ? (mixpanel_data = {
event:"Viewed Feedback Page",
properties:{
token:"bcb75af88bccc92724ac5fd79271e1ff",
unique_id:unique_id,
attempt_id:HR.candidate.candidateAttemptModel.get("id")
}
}, mixpanel_event = window.btoa(JSON.stringify(mixpanel_data)), $.post("http://api.mixpanel.com/track/?data=" + mixpanel_event, {}, function() {
return function() {};
}(this))) :void 0);
});
}, CandidateRouter.prototype.candidate_instructions = function(unique_id) {
return HR.requires("compound/recruit-candidate", function() {
var candidate_view;
return HR.redirectNeeded() ? (HR.candidate.redirectBackTo = Backbone.history.fragment, 
HR.router.navigate("" + unique_id + "/redirect", {
trigger:!0,
replace:!0
}), void 0) :(candidate_view = new HR.RecruitCandidateInstructionsView({
model:HR.candidate.candidateTestModel
}), HR.appView.setContentView(candidate_view), HR.candidate.currentQuestion = null, 
HR.appView.setTopbarView(HR.RecruitCandidateTopBarView), HR.appView.setFooterView(HR.RecruitCandidateFooterView), 
HR.appView.setSidebarView(HR.RecruitCandidateSideBarView));
});
}, CandidateRouter;
}(Backbone.Router), HR = null != (_ref = window.HR) ? _ref :{}, HR.CandidateRouter = CandidateRouter, 
window.istreet = new Object(), window.istreet.cfg = new Object(), window.istreet.cfg.hrqn = new Object(), 
h = window.istreet.cfg.hrqn, h.mcq = "Multiple choice", h.code = "Programming", 
h.textAns = "Subjective", h.approx = "Approximate", h.multiple_mcq = "Multiple answers", 
h.unscramble = "Unscramble Sentence", h.rewrite = "Rewrite Sentence", h.complete = "Complete Sentence", 
h.correct_errors = "Correct Errors", h.file_upload = "File upload", h.multiple_blanks = "Multiple blanks", 
h.info = "Info", h.task = "Task", h["Subjective Answer"] = "Subjective answer", 
h.uml = "UML", h.electrical = "Electrical", h.design = "Design";
});
}.call(this), window.bootbox = window.bootbox || function init($, undefined) {
"use strict";
function _t(key) {
var locale = locales[defaults.locale];
return locale ? locale[key] :locales.en[key];
}
function processCallback(e, dialog, callback) {
e.preventDefault();
var preserveDialog = $.isFunction(callback) && callback(e) === !1;
preserveDialog || dialog.modal("hide");
}
function getKeyLength(obj) {
var k, t = 0;
for (k in obj) t++;
return t;
}
function each(collection, iterator) {
var index = 0;
$.each(collection, function(key, value) {
iterator(key, value, index++);
});
}
function sanitize(options) {
var buttons, total;
if ("object" != typeof options) throw new Error("Please supply an object of options");
if (!options.message) throw new Error("Please specify a message");
return options = $.extend({}, defaults, options), options.buttons || (options.buttons = {}), 
options.backdrop = options.backdrop ? "static" :!1, buttons = options.buttons, total = getKeyLength(buttons), 
each(buttons, function(key, button, index) {
if ($.isFunction(button) && (button = buttons[key] = {
callback:button
}), "object" !== $.type(button)) throw new Error("button with key " + key + " must be an object");
button.label || (button.label = key), button.className || (button.className = 2 >= total && index === total - 1 ? "btn-primary" :"btn-default");
}), options;
}
function mapArguments(args, properties) {
var argn = args.length, options = {};
if (1 > argn || argn > 2) throw new Error("Invalid argument length");
return 2 === argn || "string" == typeof args[0] ? (options[properties[0]] = args[0], 
options[properties[1]] = args[1]) :options = args[0], options;
}
function mergeArguments(defaults, args, properties) {
return $.extend(!0, {}, defaults, mapArguments(args, properties));
}
function mergeDialogOptions(className, labels, properties, args) {
var baseOptions = {
className:"bootbox-" + className,
buttons:createLabels.apply(null, labels)
};
return validateButtons(mergeArguments(baseOptions, args, properties), labels);
}
function createLabels() {
for (var buttons = {}, i = 0, j = arguments.length; j > i; i++) {
var argument = arguments[i], key = argument.toLowerCase(), value = argument.toUpperCase();
buttons[key] = {
label:_t(value)
};
}
return buttons;
}
function validateButtons(options, buttons) {
var allowedButtons = {};
return each(buttons, function(key, value) {
allowedButtons[value] = !0;
}), each(options.buttons, function(key) {
if (allowedButtons[key] === undefined) throw new Error("button key " + key + " is not allowed (options are " + buttons.join("\n") + ")");
}), options;
}
var templates = {
dialog:"<div class='bootbox modal' tabindex='-1' role='dialog'><div class='modal-dialog'><div class='modal-content'><div class='modal-body'><div class='bootbox-body'></div></div></div></div></div>",
header:"<div class='modal-header'><h4 class='modal-title'></h4></div>",
footer:"<div class='modal-footer'></div>",
closeButton:"<button type='button' class='bootbox-close-button close'>&times;</button>",
form:"<form class='bootbox-form'></form>",
inputs:{
text:"<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text />",
email:"<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' />",
select:"<select class='bootbox-input bootbox-input-select form-control'></select>",
checkbox:"<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' /></label></div>"
}
}, appendTo = $("body"), defaults = {
locale:"en",
backdrop:!0,
animate:!0,
className:null,
closeButton:!0,
show:!0
}, exports = {};
exports.alert = function() {
var options;
if (options = mergeDialogOptions("alert", [ "ok" ], [ "message", "callback" ], arguments), 
options.callback && !$.isFunction(options.callback)) throw new Error("alert requires callback property to be a function when provided");
return options.buttons.ok.callback = options.onEscape = function() {
return $.isFunction(options.callback) ? options.callback() :!0;
}, exports.dialog(options);
}, exports.confirm = function() {
var options;
if (options = mergeDialogOptions("confirm", [ "cancel", "confirm" ], [ "message", "callback" ], arguments), 
options.buttons.cancel.callback = options.onEscape = function() {
return options.callback(!1);
}, options.buttons.confirm.callback = function() {
return options.callback(!0);
}, !$.isFunction(options.callback)) throw new Error("confirm requires a callback");
return exports.dialog(options);
}, exports.prompt = function() {
var options, defaults, dialog, form, input, shouldShow, inputOptions;
if (form = $(templates.form), defaults = {
className:"bootbox-prompt",
buttons:createLabels("cancel", "confirm"),
value:"",
inputType:"text"
}, options = validateButtons(mergeArguments(defaults, arguments, [ "title", "callback" ]), [ "cancel", "confirm" ]), 
shouldShow = options.show === undefined ? !0 :options.show, options.message = form, 
options.buttons.cancel.callback = options.onEscape = function() {
return options.callback(null);
}, options.buttons.confirm.callback = function() {
var value;
switch (options.inputType) {
case "text":
case "email":
case "select":
value = input.val();
break;

case "checkbox":
var checkedItems = input.find("input:checked");
value = [], each(checkedItems, function(_, item) {
value.push($(item).val());
});
}
return options.callback(value);
}, options.show = !1, !options.title) throw new Error("prompt requires a title");
if (!$.isFunction(options.callback)) throw new Error("prompt requires a callback");
if (!templates.inputs[options.inputType]) throw new Error("invalid prompt type");
switch (input = $(templates.inputs[options.inputType]), options.inputType) {
case "text":
case "email":
input.val(options.value);
break;

case "select":
var groups = {};
if (inputOptions = options.inputOptions || [], !inputOptions.length) throw new Error("prompt with select requires options");
each(inputOptions, function(_, option) {
var elem = input;
if (option.value === undefined || option.text === undefined) throw new Error("given options in wrong format");
option.group && (groups[option.group] || (groups[option.group] = $("<optgroup/>").attr("label", option.group)), 
elem = groups[option.group]), elem.append("<option value='" + option.value + "'>" + option.text + "</option>");
}), each(groups, function(_, group) {
input.append(group);
}), input.val(options.value);
break;

case "checkbox":
var values = $.isArray(options.value) ? options.value :[ options.value ];
if (inputOptions = options.inputOptions || [], !inputOptions.length) throw new Error("prompt with checkbox requires options");
if (!inputOptions[0].value || !inputOptions[0].text) throw new Error("given options in wrong format");
input = $("<div/>"), each(inputOptions, function(_, option) {
var checkbox = $(templates.inputs[options.inputType]);
checkbox.find("input").attr("value", option.value), checkbox.find("label").append(option.text), 
each(values, function(_, value) {
value === option.value && checkbox.find("input").prop("checked", !0);
}), input.append(checkbox);
});
}
return options.placeholder && input.attr("placeholder", options.placeholder), form.append(input), 
form.on("submit", function(e) {
e.preventDefault(), dialog.find(".btn-primary").click();
}), dialog = exports.dialog(options), dialog.off("shown.bs.modal"), dialog.on("shown.bs.modal", function() {
input.focus();
}), shouldShow === !0 && dialog.modal("show"), dialog;
}, exports.dialog = function(options) {
options = sanitize(options);
var dialog = $(templates.dialog), body = dialog.find(".modal-body"), buttons = options.buttons, buttonStr = "", callbacks = {
onEscape:options.onEscape
};
if (each(buttons, function(key, button) {
buttonStr += "<button data-bb-handler='" + key + "' type='button' class='btn " + button.className + "'>" + button.label + "</button>", 
callbacks[key] = button.callback;
}), body.find(".bootbox-body").html(options.message), options.animate === !0 && dialog.addClass("fade"), 
options.className && dialog.addClass(options.className), options.title && body.before(templates.header), 
options.closeButton) {
var closeButton = $(templates.closeButton);
options.title ? dialog.find(".modal-header").prepend(closeButton) :closeButton.css("margin-top", "-10px").prependTo(body);
}
return options.title && dialog.find(".modal-title").html(options.title), buttonStr.length && (body.after(templates.footer), 
dialog.find(".modal-footer").html(buttonStr)), dialog.on("hidden.bs.modal", function(e) {
e.target === this && dialog.remove();
}), dialog.on("shown.bs.modal", function() {
dialog.find(".btn-primary:first").focus();
}), dialog.on("escape.close.bb", function(e) {
callbacks.onEscape && processCallback(e, dialog, callbacks.onEscape);
}), dialog.on("click", ".modal-footer button", function(e) {
var callbackKey = $(this).data("bb-handler");
processCallback(e, dialog, callbacks[callbackKey]);
}), dialog.on("click", ".bootbox-close-button", function(e) {
processCallback(e, dialog, callbacks.onEscape);
}), dialog.on("keyup", function(e) {
27 === e.which && dialog.trigger("escape.close.bb");
}), appendTo.append(dialog), dialog.modal({
backdrop:options.backdrop,
keyboard:!1,
show:!1
}), options.show && dialog.modal("show"), dialog;
}, exports.setDefaults = function() {
var values = {};
2 === arguments.length ? values[arguments[0]] = arguments[1] :values = arguments[0], 
$.extend(defaults, values);
}, exports.hideAll = function() {
$(".bootbox").modal("hide");
};
var locales = {
br:{
OK:"OK",
CANCEL:"Cancelar",
CONFIRM:"Sim"
},
da:{
OK:"OK",
CANCEL:"Annuller",
CONFIRM:"Accepter"
},
de:{
OK:"OK",
CANCEL:"Abbrechen",
CONFIRM:"Akzeptieren"
},
en:{
OK:"OK",
CANCEL:"Cancel",
CONFIRM:"OK"
},
es:{
OK:"OK",
CANCEL:"Cancelar",
CONFIRM:"Aceptar"
},
fi:{
OK:"OK",
CANCEL:"Peruuta",
CONFIRM:"OK"
},
fr:{
OK:"OK",
CANCEL:"Annuler",
CONFIRM:"D'accord"
},
it:{
OK:"OK",
CANCEL:"Annulla",
CONFIRM:"Conferma"
},
nl:{
OK:"OK",
CANCEL:"Annuleren",
CONFIRM:"Accepteren"
},
no:{
OK:"OK",
CANCEL:"Avbryt",
CONFIRM:"OK"
},
pl:{
OK:"OK",
CANCEL:"Anuluj",
CONFIRM:"Potwierd\u017a"
},
ru:{
OK:"OK",
CANCEL:"\u041e\u0442\u043c\u0435\u043d\u0430",
CONFIRM:"\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c"
},
zh_CN:{
OK:"OK",
CANCEL:"\u53d6\u6d88",
CONFIRM:"\u786e\u8ba4"
},
zh_TW:{
OK:"OK",
CANCEL:"\u53d6\u6d88",
CONFIRM:"\u78ba\u8a8d"
}
};
return exports.init = function(_$) {
window.bootbox = init(_$ || $);
}, exports;
}(window.jQuery), !function(e, t) {
"use strict";
function n(e, t) {
for (var n, r = [], i = 0; i < e.length; ++i) {
if (n = s[e[i]] || o(e[i]), !n) throw "module definition dependecy not found: " + e[i];
r.push(n);
}
t.apply(null, r);
}
function r(e, r, i) {
if ("string" != typeof e) throw "invalid module definition, module id must be defined and be a string";
if (r === t) throw "invalid module definition, dependencies must be specified";
if (i === t) throw "invalid module definition, definition function must be specified";
n(r, function() {
s[e] = i.apply(null, arguments);
});
}
function o(t) {
for (var n = e, r = t.split(/[.\/]/), i = 0; i < r.length; ++i) {
if (!n[r[i]]) return;
n = n[r[i]];
}
return n;
}
function a(n) {
for (var r = 0; r < n.length; r++) {
for (var i = e, o = n[r], a = o.split(/[.\/]/), l = 0; l < a.length - 1; ++l) i[a[l]] === t && (i[a[l]] = {}), 
i = i[a[l]];
i[a[a.length - 1]] = s[o];
}
}
var s = {}, l = "tinymce/dom/EventUtils", c = "tinymce/dom/Sizzle", u = "tinymce/util/Tools", d = "tinymce/Env", f = "tinymce/dom/DomQuery", p = "tinymce/html/Styles", h = "tinymce/dom/TreeWalker", m = "tinymce/dom/Range", g = "tinymce/html/Entities", v = "tinymce/dom/StyleSheetLoader", y = "tinymce/dom/DOMUtils", b = "tinymce/dom/ScriptLoader", C = "tinymce/AddOnManager", x = "tinymce/html/Node", w = "tinymce/html/Schema", _ = "tinymce/html/SaxParser", N = "tinymce/html/DomParser", E = "tinymce/html/Writer", k = "tinymce/html/Serializer", S = "tinymce/dom/Serializer", T = "tinymce/dom/TridentSelection", R = "tinymce/util/VK", A = "tinymce/dom/ControlSelection", B = "tinymce/dom/RangeUtils", D = "tinymce/dom/BookmarkManager", L = "tinymce/dom/Selection", M = "tinymce/dom/ElementUtils", H = "tinymce/fmt/Preview", P = "tinymce/Formatter", O = "tinymce/UndoManager", I = "tinymce/EnterKey", F = "tinymce/ForceBlocks", z = "tinymce/EditorCommands", W = "tinymce/util/URI", V = "tinymce/util/Class", U = "tinymce/util/EventDispatcher", q = "tinymce/ui/Selector", $ = "tinymce/ui/Collection", j = "tinymce/ui/DomUtils", K = "tinymce/ui/Control", G = "tinymce/ui/Factory", Y = "tinymce/ui/KeyboardNavigation", X = "tinymce/ui/Container", J = "tinymce/ui/DragHelper", Q = "tinymce/ui/Scrollable", Z = "tinymce/ui/Panel", et = "tinymce/ui/Movable", tt = "tinymce/ui/Resizable", nt = "tinymce/ui/FloatPanel", rt = "tinymce/ui/Window", it = "tinymce/ui/MessageBox", ot = "tinymce/WindowManager", at = "tinymce/util/Quirks", st = "tinymce/util/Observable", lt = "tinymce/EditorObservable", ct = "tinymce/Shortcuts", ut = "tinymce/Editor", dt = "tinymce/util/I18n", ft = "tinymce/FocusManager", pt = "tinymce/EditorManager", ht = "tinymce/LegacyInput", mt = "tinymce/util/XHR", gt = "tinymce/util/JSON", vt = "tinymce/util/JSONRequest", yt = "tinymce/util/JSONP", bt = "tinymce/util/LocalStorage", Ct = "tinymce/Compat", xt = "tinymce/ui/Layout", wt = "tinymce/ui/AbsoluteLayout", _t = "tinymce/ui/Tooltip", Nt = "tinymce/ui/Widget", Et = "tinymce/ui/Button", kt = "tinymce/ui/ButtonGroup", St = "tinymce/ui/Checkbox", Tt = "tinymce/ui/ComboBox", Rt = "tinymce/ui/ColorBox", At = "tinymce/ui/PanelButton", Bt = "tinymce/ui/ColorButton", Dt = "tinymce/util/Color", Lt = "tinymce/ui/ColorPicker", Mt = "tinymce/ui/Path", Ht = "tinymce/ui/ElementPath", Pt = "tinymce/ui/FormItem", Ot = "tinymce/ui/Form", It = "tinymce/ui/FieldSet", Ft = "tinymce/ui/FilePicker", zt = "tinymce/ui/FitLayout", Wt = "tinymce/ui/FlexLayout", Vt = "tinymce/ui/FlowLayout", Ut = "tinymce/ui/FormatControls", qt = "tinymce/ui/GridLayout", $t = "tinymce/ui/Iframe", jt = "tinymce/ui/Label", Kt = "tinymce/ui/Toolbar", Gt = "tinymce/ui/MenuBar", Yt = "tinymce/ui/MenuButton", Xt = "tinymce/ui/ListBox", Jt = "tinymce/ui/MenuItem", Qt = "tinymce/ui/Menu", Zt = "tinymce/ui/Radio", en = "tinymce/ui/ResizeHandle", tn = "tinymce/ui/Spacer", nn = "tinymce/ui/SplitButton", rn = "tinymce/ui/StackLayout", on = "tinymce/ui/TabPanel", an = "tinymce/ui/TextBox", sn = "tinymce/ui/Throbber";
r(l, [], function() {
function e(e, t, n, r) {
e.addEventListener ? e.addEventListener(t, n, r || !1) :e.attachEvent && e.attachEvent("on" + t, n);
}
function t(e, t, n, r) {
e.removeEventListener ? e.removeEventListener(t, n, r || !1) :e.detachEvent && e.detachEvent("on" + t, n);
}
function n(e, t) {
function n() {
return !1;
}
function r() {
return !0;
}
var i, l, o = t || {};
for (i in e) s[i] || (o[i] = e[i]);
if (o.target || (o.target = o.srcElement || document), e && a.test(e.type) && e.pageX === l && e.clientX !== l) {
var c = o.target.ownerDocument || document, u = c.documentElement, d = c.body;
o.pageX = e.clientX + (u && u.scrollLeft || d && d.scrollLeft || 0) - (u && u.clientLeft || d && d.clientLeft || 0), 
o.pageY = e.clientY + (u && u.scrollTop || d && d.scrollTop || 0) - (u && u.clientTop || d && d.clientTop || 0);
}
return o.preventDefault = function() {
o.isDefaultPrevented = r, e && (e.preventDefault ? e.preventDefault() :e.returnValue = !1);
}, o.stopPropagation = function() {
o.isPropagationStopped = r, e && (e.stopPropagation ? e.stopPropagation() :e.cancelBubble = !0);
}, o.stopImmediatePropagation = function() {
o.isImmediatePropagationStopped = r, o.stopPropagation();
}, o.isDefaultPrevented || (o.isDefaultPrevented = n, o.isPropagationStopped = n, 
o.isImmediatePropagationStopped = n), o;
}
function r(n, r, i) {
function o() {
i.domLoaded || (i.domLoaded = !0, r(c));
}
function a() {
("complete" === l.readyState || "interactive" === l.readyState && l.body) && (t(l, "readystatechange", a), 
o());
}
function s() {
try {
l.documentElement.doScroll("left");
} catch (e) {
return void setTimeout(s, 0);
}
o();
}
var l = n.document, c = {
type:"ready"
};
return i.domLoaded ? void r(c) :(l.addEventListener ? "complete" === l.readyState ? o() :e(n, "DOMContentLoaded", o) :(e(l, "readystatechange", a), 
l.documentElement.doScroll && n.self === n.top && s()), void e(n, "load", o));
}
function i() {
function i(e, t) {
var n, r, i, o, a = s[t];
if (n = a && a[e.type]) for (r = 0, i = n.length; i > r; r++) if (o = n[r], o && o.func.call(o.scope, e) === !1 && e.preventDefault(), 
e.isImmediatePropagationStopped()) return;
}
var l, c, u, d, f, a = this, s = {};
c = o + (+new Date()).toString(32), d = "onmouseenter" in document.documentElement, 
u = "onfocusin" in document.documentElement, f = {
mouseenter:"mouseover",
mouseleave:"mouseout"
}, l = 1, a.domLoaded = !1, a.events = s, a.bind = function(t, o, p, h) {
function m(e) {
i(n(e || _.event), g);
}
var g, v, y, b, C, x, w, _ = window;
if (t && 3 !== t.nodeType && 8 !== t.nodeType) {
for (t[c] ? g = t[c] :(g = l++, t[c] = g, s[g] = {}), h = h || t, o = o.split(" "), 
y = o.length; y--; ) b = o[y], x = m, C = w = !1, "DOMContentLoaded" === b && (b = "ready"), 
a.domLoaded && "ready" === b && "complete" == t.readyState ? p.call(h, n({
type:b
})) :(d || (C = f[b], C && (x = function(e) {
var t, r;
if (t = e.currentTarget, r = e.relatedTarget, r && t.contains) r = t.contains(r); else for (;r && r !== t; ) r = r.parentNode;
r || (e = n(e || _.event), e.type = "mouseout" === e.type ? "mouseleave" :"mouseenter", 
e.target = t, i(e, g));
})), u || "focusin" !== b && "focusout" !== b || (w = !0, C = "focusin" === b ? "focus" :"blur", 
x = function(e) {
e = n(e || _.event), e.type = "focus" === e.type ? "focusin" :"focusout", i(e, g);
}), v = s[g][b], v ? "ready" === b && a.domLoaded ? p({
type:b
}) :v.push({
func:p,
scope:h
}) :(s[g][b] = v = [ {
func:p,
scope:h
} ], v.fakeName = C, v.capture = w, v.nativeHandler = x, "ready" === b ? r(t, x, a) :e(t, C || b, x, w)));
return t = v = 0, p;
}
}, a.unbind = function(e, n, r) {
var i, o, l, u, d, f;
if (!e || 3 === e.nodeType || 8 === e.nodeType) return a;
if (i = e[c]) {
if (f = s[i], n) {
for (n = n.split(" "), l = n.length; l--; ) if (d = n[l], o = f[d]) {
if (r) for (u = o.length; u--; ) if (o[u].func === r) {
var p = o.nativeHandler, h = o.fakeName, m = o.capture;
o = o.slice(0, u).concat(o.slice(u + 1)), o.nativeHandler = p, o.fakeName = h, o.capture = m, 
f[d] = o;
}
r && 0 !== o.length || (delete f[d], t(e, o.fakeName || d, o.nativeHandler, o.capture));
}
} else {
for (d in f) o = f[d], t(e, o.fakeName || d, o.nativeHandler, o.capture);
f = {};
}
for (d in f) return a;
delete s[i];
try {
delete e[c];
} catch (g) {
e[c] = null;
}
}
return a;
}, a.fire = function(e, t, r) {
var o;
if (!e || 3 === e.nodeType || 8 === e.nodeType) return a;
r = n(null, r), r.type = t, r.target = e;
do o = e[c], o && i(r, o), e = e.parentNode || e.ownerDocument || e.defaultView || e.parentWindow; while (e && !r.isPropagationStopped());
return a;
}, a.clean = function(e) {
var t, n, r = a.unbind;
if (!e || 3 === e.nodeType || 8 === e.nodeType) return a;
if (e[c] && r(e), e.getElementsByTagName || (e = e.document), e && e.getElementsByTagName) for (r(e), 
n = e.getElementsByTagName("*"), t = n.length; t--; ) e = n[t], e[c] && r(e);
return a;
}, a.destroy = function() {
s = {};
}, a.cancel = function(e) {
return e && (e.preventDefault(), e.stopImmediatePropagation()), !1;
};
}
var o = "mce-data-", a = /^(?:mouse|contextmenu)|click/, s = {
keyLocation:1,
layerX:1,
layerY:1,
returnValue:1
};
return i.Event = new i(), i.Event.bind(window, "ready", function() {}), i;
}), r(c, [], function() {
function e(e) {
return mt.test(e + "");
}
function n() {
var e, t = [];
return e = function(n, r) {
return t.push(n += " ") > _.cacheLength && delete e[t.shift()], e[n] = r, r;
};
}
function r(e) {
return e[I] = !0, e;
}
function i(e) {
var t = B.createElement("div");
try {
return !!e(t);
} catch (n) {
return !1;
} finally {
t = null;
}
}
function o(e, t, n, r) {
var i, o, a, s, l, c, f, p, h, m;
if ((t ? t.ownerDocument || t :F) !== B && A(t), t = t || B, n = n || [], !e || "string" != typeof e) return n;
if (1 !== (s = t.nodeType) && 9 !== s) return [];
if (L && !r) {
if (i = gt.exec(e)) if (a = i[1]) {
if (9 === s) {
if (o = t.getElementById(a), !o || !o.parentNode) return n;
if (o.id === a) return n.push(o), n;
} else if (t.ownerDocument && (o = t.ownerDocument.getElementById(a)) && O(t, o) && o.id === a) return n.push(o), 
n;
} else {
if (i[2]) return Z.apply(n, t.getElementsByTagName(e)), n;
if ((a = i[3]) && z.getElementsByClassName && t.getElementsByClassName) return Z.apply(n, t.getElementsByClassName(a)), 
n;
}
if (z.qsa && !M.test(e)) {
if (f = !0, p = I, h = t, m = 9 === s && e, 1 === s && "object" !== t.nodeName.toLowerCase()) {
for (c = u(e), (f = t.getAttribute("id")) ? p = f.replace(bt, "\\$&") :t.setAttribute("id", p), 
p = "[id='" + p + "'] ", l = c.length; l--; ) c[l] = p + d(c[l]);
h = ht.test(e) && t.parentNode || t, m = c.join(",");
}
if (m) try {
return Z.apply(n, h.querySelectorAll(m)), n;
} catch (g) {} finally {
f || t.removeAttribute("id");
}
}
}
return b(e.replace(lt, "$1"), t, n, r);
}
function a(e, t) {
var n = t && e, r = n && (~t.sourceIndex || Y) - (~e.sourceIndex || Y);
if (r) return r;
if (n) for (;n = n.nextSibling; ) if (n === t) return -1;
return e ? 1 :-1;
}
function s(e) {
return function(t) {
var n = t.nodeName.toLowerCase();
return "input" === n && t.type === e;
};
}
function l(e) {
return function(t) {
var n = t.nodeName.toLowerCase();
return ("input" === n || "button" === n) && t.type === e;
};
}
function c(e) {
return r(function(t) {
return t = +t, r(function(n, r) {
for (var i, o = e([], n.length, t), a = o.length; a--; ) n[i = o[a]] && (n[i] = !(r[i] = n[i]));
});
});
}
function u(e, t) {
var n, r, i, a, s, l, c, u = q[e + " "];
if (u) return t ? 0 :u.slice(0);
for (s = e, l = [], c = _.preFilter; s; ) {
(!n || (r = ct.exec(s))) && (r && (s = s.slice(r[0].length) || s), l.push(i = [])), 
n = !1, (r = ut.exec(s)) && (n = r.shift(), i.push({
value:n,
type:r[0].replace(lt, " ")
}), s = s.slice(n.length));
for (a in _.filter) !(r = pt[a].exec(s)) || c[a] && !(r = c[a](r)) || (n = r.shift(), 
i.push({
value:n,
type:a,
matches:r
}), s = s.slice(n.length));
if (!n) break;
}
return t ? s.length :s ? o.error(e) :q(e, l).slice(0);
}
function d(e) {
for (var t = 0, n = e.length, r = ""; n > t; t++) r += e[t].value;
return r;
}
function f(e, t, n) {
var r = t.dir, i = n && "parentNode" === r, o = V++;
return t.first ? function(t, n, o) {
for (;t = t[r]; ) if (1 === t.nodeType || i) return e(t, n, o);
} :function(t, n, a) {
var s, l, c, u = W + " " + o;
if (a) {
for (;t = t[r]; ) if ((1 === t.nodeType || i) && e(t, n, a)) return !0;
} else for (;t = t[r]; ) if (1 === t.nodeType || i) if (c = t[I] || (t[I] = {}), 
(l = c[r]) && l[0] === u) {
if ((s = l[1]) === !0 || s === w) return s === !0;
} else if (l = c[r] = [ u ], l[1] = e(t, n, a) || w, l[1] === !0) return !0;
};
}
function p(e) {
return e.length > 1 ? function(t, n, r) {
for (var i = e.length; i--; ) if (!e[i](t, n, r)) return !1;
return !0;
} :e[0];
}
function h(e, t, n, r, i) {
for (var o, a = [], s = 0, l = e.length, c = null != t; l > s; s++) (o = e[s]) && (!n || n(o, r, i)) && (a.push(o), 
c && t.push(s));
return a;
}
function m(e, t, n, i, o, a) {
return i && !i[I] && (i = m(i)), o && !o[I] && (o = m(o, a)), r(function(r, a, s, l) {
var c, u, d, f = [], p = [], m = a.length, g = r || y(t || "*", s.nodeType ? [ s ] :s, []), v = !e || !r && t ? g :h(g, f, e, s, l), b = n ? o || (r ? e :m || i) ? [] :a :v;
if (n && n(v, b, s, l), i) for (c = h(b, p), i(c, [], s, l), u = c.length; u--; ) (d = c[u]) && (b[p[u]] = !(v[p[u]] = d));
if (r) {
if (o || e) {
if (o) {
for (c = [], u = b.length; u--; ) (d = b[u]) && c.push(v[u] = d);
o(null, b = [], c, l);
}
for (u = b.length; u--; ) (d = b[u]) && (c = o ? tt.call(r, d) :f[u]) > -1 && (r[c] = !(a[c] = d));
}
} else b = h(b === a ? b.splice(m, b.length) :b), o ? o(null, a, b, l) :Z.apply(a, b);
});
}
function g(e) {
for (var t, n, r, i = e.length, o = _.relative[e[0].type], a = o || _.relative[" "], s = o ? 1 :0, l = f(function(e) {
return e === t;
}, a, !0), c = f(function(e) {
return tt.call(t, e) > -1;
}, a, !0), u = [ function(e, n, r) {
return !o && (r || n !== S) || ((t = n).nodeType ? l(e, n, r) :c(e, n, r));
} ]; i > s; s++) if (n = _.relative[e[s].type]) u = [ f(p(u), n) ]; else {
if (n = _.filter[e[s].type].apply(null, e[s].matches), n[I]) {
for (r = ++s; i > r && !_.relative[e[r].type]; r++) ;
return m(s > 1 && p(u), s > 1 && d(e.slice(0, s - 1)).replace(lt, "$1"), n, r > s && g(e.slice(s, r)), i > r && g(e = e.slice(r)), i > r && d(e));
}
u.push(n);
}
return p(u);
}
function v(e, t) {
var n = 0, i = t.length > 0, a = e.length > 0, s = function(r, s, l, c, u) {
var d, f, p, m = [], g = 0, v = "0", y = r && [], b = null != u, C = S, x = r || a && _.find.TAG("*", u && s.parentNode || s), N = W += null == C ? 1 :Math.random() || .1;
for (b && (S = s !== B && s, w = n); null != (d = x[v]); v++) {
if (a && d) {
for (f = 0; p = e[f++]; ) if (p(d, s, l)) {
c.push(d);
break;
}
b && (W = N, w = ++n);
}
i && ((d = !p && d) && g--, r && y.push(d));
}
if (g += v, i && v !== g) {
for (f = 0; p = t[f++]; ) p(y, m, s, l);
if (r) {
if (g > 0) for (;v--; ) y[v] || m[v] || (m[v] = J.call(c));
m = h(m);
}
Z.apply(c, m), b && !r && m.length > 0 && g + t.length > 1 && o.uniqueSort(c);
}
return b && (W = N, S = C), y;
};
return i ? r(s) :s;
}
function y(e, t, n) {
for (var r = 0, i = t.length; i > r; r++) o(e, t[r], n);
return n;
}
function b(e, t, n, r) {
var i, o, a, s, l, c = u(e);
if (!r && 1 === c.length) {
if (o = c[0] = c[0].slice(0), o.length > 2 && "ID" === (a = o[0]).type && 9 === t.nodeType && L && _.relative[o[1].type]) {
if (t = (_.find.ID(a.matches[0].replace(xt, wt), t) || [])[0], !t) return n;
e = e.slice(o.shift().value.length);
}
for (i = pt.needsContext.test(e) ? 0 :o.length; i-- && (a = o[i], !_.relative[s = a.type]); ) if ((l = _.find[s]) && (r = l(a.matches[0].replace(xt, wt), ht.test(o[0].type) && t.parentNode || t))) {
if (o.splice(i, 1), e = r.length && d(o), !e) return Z.apply(n, r), n;
break;
}
}
return k(e, c)(r, t, !L, n, ht.test(e)), n;
}
function C() {}
var x, w, _, N, E, k, S, T, R, A, B, D, L, M, H, P, O, I = "sizzle" + -new Date(), F = window.document, z = {}, W = 0, V = 0, U = n(), q = n(), $ = n(), j = !1, K = function() {
return 0;
}, G = typeof t, Y = 1 << 31, X = [], J = X.pop, Q = X.push, Z = X.push, et = X.slice, tt = X.indexOf || function(e) {
for (var t = 0, n = this.length; n > t; t++) if (this[t] === e) return t;
return -1;
}, nt = "[\\x20\\t\\r\\n\\f]", rt = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", it = rt.replace("w", "w#"), ot = "([*^$|!~]?=)", at = "\\[" + nt + "*(" + rt + ")" + nt + "*(?:" + ot + nt + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + it + ")|)|)" + nt + "*\\]", st = ":(" + rt + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + at.replace(3, 8) + ")*)|.*)\\)|)", lt = new RegExp("^" + nt + "+|((?:^|[^\\\\])(?:\\\\.)*)" + nt + "+$", "g"), ct = new RegExp("^" + nt + "*," + nt + "*"), ut = new RegExp("^" + nt + "*([\\x20\\t\\r\\n\\f>+~])" + nt + "*"), dt = new RegExp(st), ft = new RegExp("^" + it + "$"), pt = {
ID:new RegExp("^#(" + rt + ")"),
CLASS:new RegExp("^\\.(" + rt + ")"),
NAME:new RegExp("^\\[name=['\"]?(" + rt + ")['\"]?\\]"),
TAG:new RegExp("^(" + rt.replace("w", "w*") + ")"),
ATTR:new RegExp("^" + at),
PSEUDO:new RegExp("^" + st),
CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + nt + "*(even|odd|(([+-]|)(\\d*)n|)" + nt + "*(?:([+-]|)" + nt + "*(\\d+)|))" + nt + "*\\)|)", "i"),
needsContext:new RegExp("^" + nt + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + nt + "*((?:-\\d)?\\d*)" + nt + "*\\)|)(?=[^-]|$)", "i")
}, ht = /[\x20\t\r\n\f]*[+~]/, mt = /^[^{]+\{\s*\[native code/, gt = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/, vt = /^(?:input|select|textarea|button)$/i, yt = /^h\d$/i, bt = /'|\\/g, Ct = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g, xt = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g, wt = function(e, t) {
var n = "0x" + t - 65536;
return n !== n ? t :0 > n ? String.fromCharCode(n + 65536) :String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320);
};
try {
Z.apply(X = et.call(F.childNodes), F.childNodes), X[F.childNodes.length].nodeType;
} catch (_t) {
Z = {
apply:X.length ? function(e, t) {
Q.apply(e, et.call(t));
} :function(e, t) {
for (var n = e.length, r = 0; e[n++] = t[r++]; ) ;
e.length = n - 1;
}
};
}
E = o.isXML = function(e) {
var t = e && (e.ownerDocument || e).documentElement;
return t ? "HTML" !== t.nodeName :!1;
}, A = o.setDocument = function(n) {
var r = n ? n.ownerDocument || n :F;
return r !== B && 9 === r.nodeType && r.documentElement ? (B = r, D = r.documentElement, 
L = !E(r), z.getElementsByTagName = i(function(e) {
return e.appendChild(r.createComment("")), !e.getElementsByTagName("*").length;
}), z.attributes = i(function(e) {
e.innerHTML = "<select></select>";
var t = typeof e.lastChild.getAttribute("multiple");
return "boolean" !== t && "string" !== t;
}), z.getElementsByClassName = i(function(e) {
return e.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>", e.getElementsByClassName && e.getElementsByClassName("e").length ? (e.lastChild.className = "e", 
2 === e.getElementsByClassName("e").length) :!1;
}), z.getByName = i(function(e) {
e.id = I + 0, e.appendChild(B.createElement("a")).setAttribute("name", I), e.appendChild(B.createElement("i")).setAttribute("name", I), 
D.appendChild(e);
var t = r.getElementsByName && r.getElementsByName(I).length === 2 + r.getElementsByName(I + 0).length;
return D.removeChild(e), t;
}), z.sortDetached = i(function(e) {
return e.compareDocumentPosition && 1 & e.compareDocumentPosition(B.createElement("div"));
}), _.attrHandle = i(function(e) {
return e.innerHTML = "<a href='#'></a>", e.firstChild && typeof e.firstChild.getAttribute !== G && "#" === e.firstChild.getAttribute("href");
}) ? {} :{
href:function(e) {
return e.getAttribute("href", 2);
},
type:function(e) {
return e.getAttribute("type");
}
}, z.getByName ? (_.find.ID = function(e, t) {
if (typeof t.getElementById !== G && L) {
var n = t.getElementById(e);
return n && n.parentNode ? [ n ] :[];
}
}, _.filter.ID = function(e) {
var t = e.replace(xt, wt);
return function(e) {
return e.getAttribute("id") === t;
};
}) :(_.find.ID = function(e, n) {
if (typeof n.getElementById !== G && L) {
var r = n.getElementById(e);
return r ? r.id === e || typeof r.getAttributeNode !== G && r.getAttributeNode("id").value === e ? [ r ] :t :[];
}
}, _.filter.ID = function(e) {
var t = e.replace(xt, wt);
return function(e) {
var n = typeof e.getAttributeNode !== G && e.getAttributeNode("id");
return n && n.value === t;
};
}), _.find.TAG = z.getElementsByTagName ? function(e, t) {
return typeof t.getElementsByTagName !== G ? t.getElementsByTagName(e) :void 0;
} :function(e, t) {
var n, r = [], i = 0, o = t.getElementsByTagName(e);
if ("*" === e) {
for (;n = o[i++]; ) 1 === n.nodeType && r.push(n);
return r;
}
return o;
}, _.find.NAME = z.getByName && function(e, t) {
return typeof t.getElementsByName !== G ? t.getElementsByName(name) :void 0;
}, _.find.CLASS = z.getElementsByClassName && function(e, t) {
return typeof t.getElementsByClassName !== G && L ? t.getElementsByClassName(e) :void 0;
}, H = [], M = [ ":focus" ], (z.qsa = e(r.querySelectorAll)) && (i(function(e) {
e.innerHTML = "<select><option selected=''></option></select>", e.querySelectorAll("[selected]").length || M.push("\\[" + nt + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)"), 
e.querySelectorAll(":checked").length || M.push(":checked");
}), i(function(e) {
e.innerHTML = "<input type='hidden' i=''/>", e.querySelectorAll("[i^='']").length && M.push("[*^$]=" + nt + "*(?:\"\"|'')"), 
e.querySelectorAll(":enabled").length || M.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), 
M.push(",.*:");
})), (z.matchesSelector = e(P = D.matchesSelector || D.mozMatchesSelector || D.webkitMatchesSelector || D.oMatchesSelector || D.msMatchesSelector)) && i(function(e) {
z.disconnectedMatch = P.call(e, "div"), P.call(e, "[s!='']:x"), H.push("!=", st);
}), M = new RegExp(M.join("|")), H = H.length && new RegExp(H.join("|")), O = e(D.contains) || D.compareDocumentPosition ? function(e, t) {
var n = 9 === e.nodeType ? e.documentElement :e, r = t && t.parentNode;
return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) :e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
} :function(e, t) {
if (t) for (;t = t.parentNode; ) if (t === e) return !0;
return !1;
}, K = D.compareDocumentPosition ? function(e, t) {
if (e === t) return j = !0, 0;
var n = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t);
return n ? 1 & n || T && t.compareDocumentPosition(e) === n ? e === r || O(F, e) ? -1 :t === r || O(F, t) ? 1 :R ? tt.call(R, e) - tt.call(R, t) :0 :4 & n ? -1 :1 :e.compareDocumentPosition ? -1 :1;
} :function(e, t) {
var n, i = 0, o = e.parentNode, s = t.parentNode, l = [ e ], c = [ t ];
if (e === t) return j = !0, 0;
if (!o || !s) return e === r ? -1 :t === r ? 1 :o ? -1 :s ? 1 :0;
if (o === s) return a(e, t);
for (n = e; n = n.parentNode; ) l.unshift(n);
for (n = t; n = n.parentNode; ) c.unshift(n);
for (;l[i] === c[i]; ) i++;
return i ? a(l[i], c[i]) :l[i] === F ? -1 :c[i] === F ? 1 :0;
}, B) :B;
}, o.matches = function(e, t) {
return o(e, null, null, t);
}, o.matchesSelector = function(e, t) {
if ((e.ownerDocument || e) !== B && A(e), t = t.replace(Ct, "='$1']"), z.matchesSelector && L && (!H || !H.test(t)) && !M.test(t)) try {
var n = P.call(e, t);
if (n || z.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n;
} catch (r) {}
return o(t, B, null, [ e ]).length > 0;
}, o.contains = function(e, t) {
return (e.ownerDocument || e) !== B && A(e), O(e, t);
}, o.attr = function(e, t) {
var n;
return (e.ownerDocument || e) !== B && A(e), L && (t = t.toLowerCase()), (n = _.attrHandle[t]) ? n(e) :!L || z.attributes ? e.getAttribute(t) :((n = e.getAttributeNode(t)) || e.getAttribute(t)) && e[t] === !0 ? t :n && n.specified ? n.value :null;
}, o.error = function(e) {
throw new Error("Syntax error, unrecognized expression: " + e);
}, o.uniqueSort = function(e) {
var t, n = [], r = 0, i = 0;
if (j = !z.detectDuplicates, T = !z.sortDetached, R = !z.sortStable && e.slice(0), 
e.sort(K), j) {
for (;t = e[i++]; ) t === e[i] && (r = n.push(i));
for (;r--; ) e.splice(n[r], 1);
}
return e;
}, N = o.getText = function(e) {
var t, n = "", r = 0, i = e.nodeType;
if (i) {
if (1 === i || 9 === i || 11 === i) {
if ("string" == typeof e.textContent) return e.textContent;
for (e = e.firstChild; e; e = e.nextSibling) n += N(e);
} else if (3 === i || 4 === i) return e.nodeValue;
} else for (;t = e[r]; r++) n += N(t);
return n;
}, _ = o.selectors = {
cacheLength:50,
createPseudo:r,
match:pt,
find:{},
relative:{
">":{
dir:"parentNode",
first:!0
},
" ":{
dir:"parentNode"
},
"+":{
dir:"previousSibling",
first:!0
},
"~":{
dir:"previousSibling"
}
},
preFilter:{
ATTR:function(e) {
return e[1] = e[1].replace(xt, wt), e[3] = (e[4] || e[5] || "").replace(xt, wt), 
"~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
},
CHILD:function(e) {
return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || o.error(e[0]), 
e[4] = +(e[4] ? e[5] + (e[6] || 1) :2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) :e[3] && o.error(e[0]), 
e;
},
PSEUDO:function(e) {
var t, n = !e[5] && e[2];
return pt.CHILD.test(e[0]) ? null :(e[4] ? e[2] = e[4] :n && dt.test(n) && (t = u(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), 
e[2] = n.slice(0, t)), e.slice(0, 3));
}
},
filter:{
TAG:function(e) {
return "*" === e ? function() {
return !0;
} :(e = e.replace(xt, wt).toLowerCase(), function(t) {
return t.nodeName && t.nodeName.toLowerCase() === e;
});
},
CLASS:function(e) {
var t = U[e + " "];
return t || (t = new RegExp("(^|" + nt + ")" + e + "(" + nt + "|$)")) && U(e, function(e) {
return t.test(e.className || typeof e.getAttribute !== G && e.getAttribute("class") || "");
});
},
ATTR:function(e, t, n) {
return function(r) {
var i = o.attr(r, e);
return null == i ? "!=" === t :t ? (i += "", "=" === t ? i === n :"!=" === t ? i !== n :"^=" === t ? n && 0 === i.indexOf(n) :"*=" === t ? n && i.indexOf(n) > -1 :"$=" === t ? n && i.slice(-n.length) === n :"~=" === t ? (" " + i + " ").indexOf(n) > -1 :"|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-" :!1) :!0;
};
},
CHILD:function(e, t, n, r, i) {
var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t;
return 1 === r && 0 === i ? function(e) {
return !!e.parentNode;
} :function(t, n, l) {
var c, u, d, f, p, h, m = o !== a ? "nextSibling" :"previousSibling", g = t.parentNode, v = s && t.nodeName.toLowerCase(), y = !l && !s;
if (g) {
if (o) {
for (;m; ) {
for (d = t; d = d[m]; ) if (s ? d.nodeName.toLowerCase() === v :1 === d.nodeType) return !1;
h = m = "only" === e && !h && "nextSibling";
}
return !0;
}
if (h = [ a ? g.firstChild :g.lastChild ], a && y) {
for (u = g[I] || (g[I] = {}), c = u[e] || [], p = c[0] === W && c[1], f = c[0] === W && c[2], 
d = p && g.childNodes[p]; d = ++p && d && d[m] || (f = p = 0) || h.pop(); ) if (1 === d.nodeType && ++f && d === t) {
u[e] = [ W, p, f ];
break;
}
} else if (y && (c = (t[I] || (t[I] = {}))[e]) && c[0] === W) f = c[1]; else for (;(d = ++p && d && d[m] || (f = p = 0) || h.pop()) && ((s ? d.nodeName.toLowerCase() !== v :1 !== d.nodeType) || !++f || (y && ((d[I] || (d[I] = {}))[e] = [ W, f ]), 
d !== t)); ) ;
return f -= i, f === r || f % r === 0 && f / r >= 0;
}
};
},
PSEUDO:function(e, t) {
var n, i = _.pseudos[e] || _.setFilters[e.toLowerCase()] || o.error("unsupported pseudo: " + e);
return i[I] ? i(t) :i.length > 1 ? (n = [ e, e, "", t ], _.setFilters.hasOwnProperty(e.toLowerCase()) ? r(function(e, n) {
for (var r, o = i(e, t), a = o.length; a--; ) r = tt.call(e, o[a]), e[r] = !(n[r] = o[a]);
}) :function(e) {
return i(e, 0, n);
}) :i;
}
},
pseudos:{
not:r(function(e) {
var t = [], n = [], i = k(e.replace(lt, "$1"));
return i[I] ? r(function(e, t, n, r) {
for (var o, a = i(e, null, r, []), s = e.length; s--; ) (o = a[s]) && (e[s] = !(t[s] = o));
}) :function(e, r, o) {
return t[0] = e, i(t, null, o, n), !n.pop();
};
}),
has:r(function(e) {
return function(t) {
return o(e, t).length > 0;
};
}),
contains:r(function(e) {
return function(t) {
return (t.textContent || t.innerText || N(t)).indexOf(e) > -1;
};
}),
lang:r(function(e) {
return ft.test(e || "") || o.error("unsupported lang: " + e), e = e.replace(xt, wt).toLowerCase(), 
function(t) {
var n;
do if (n = L ? t.lang :t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(), 
n === e || 0 === n.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType);
return !1;
};
}),
target:function(e) {
var t = window.location && window.location.hash;
return t && t.slice(1) === e.id;
},
root:function(e) {
return e === D;
},
focus:function(e) {
return e === B.activeElement && (!B.hasFocus || B.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
},
enabled:function(e) {
return e.disabled === !1;
},
disabled:function(e) {
return e.disabled === !0;
},
checked:function(e) {
var t = e.nodeName.toLowerCase();
return "input" === t && !!e.checked || "option" === t && !!e.selected;
},
selected:function(e) {
return e.parentNode && e.parentNode.selectedIndex, e.selected === !0;
},
empty:function(e) {
for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeName > "@" || 3 === e.nodeType || 4 === e.nodeType) return !1;
return !0;
},
parent:function(e) {
return !_.pseudos.empty(e);
},
header:function(e) {
return yt.test(e.nodeName);
},
input:function(e) {
return vt.test(e.nodeName);
},
button:function(e) {
var t = e.nodeName.toLowerCase();
return "input" === t && "button" === e.type || "button" === t;
},
text:function(e) {
var t;
return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || t.toLowerCase() === e.type);
},
first:c(function() {
return [ 0 ];
}),
last:c(function(e, t) {
return [ t - 1 ];
}),
eq:c(function(e, t, n) {
return [ 0 > n ? n + t :n ];
}),
even:c(function(e, t) {
for (var n = 0; t > n; n += 2) e.push(n);
return e;
}),
odd:c(function(e, t) {
for (var n = 1; t > n; n += 2) e.push(n);
return e;
}),
lt:c(function(e, t, n) {
for (var r = 0 > n ? n + t :n; --r >= 0; ) e.push(r);
return e;
}),
gt:c(function(e, t, n) {
for (var r = 0 > n ? n + t :n; ++r < t; ) e.push(r);
return e;
})
}
};
for (x in {
radio:!0,
checkbox:!0,
file:!0,
password:!0,
image:!0
}) _.pseudos[x] = s(x);
for (x in {
submit:!0,
reset:!0
}) _.pseudos[x] = l(x);
return k = o.compile = function(e, t) {
var n, r = [], i = [], o = $[e + " "];
if (!o) {
for (t || (t = u(e)), n = t.length; n--; ) o = g(t[n]), o[I] ? r.push(o) :i.push(o);
o = $(e, v(i, r));
}
return o;
}, _.pseudos.nth = _.pseudos.eq, C.prototype = _.filters = _.pseudos, _.setFilters = new C(), 
z.sortStable = I.split("").sort(K).join("") === I, A(), [ 0, 0 ].sort(K), z.detectDuplicates = j, 
o;
}), r(u, [], function() {
function e(e) {
return null === e || e === t ? "" :("" + e).replace(m, "");
}
function n(e, n) {
return n ? "array" == n && g(e) ? !0 :typeof e == n :e !== t;
}
function r(e) {
var n, r, t = [];
for (n = 0, r = e.length; r > n; n++) t[n] = e[n];
return t;
}
function i(e, t, n) {
var r;
for (e = e || [], t = t || ",", "string" == typeof e && (e = e.split(t)), n = n || {}, 
r = e.length; r--; ) n[e[r]] = {};
return n;
}
function o(e, n, r) {
var i, o;
if (!e) return 0;
if (r = r || e, e.length !== t) {
for (i = 0, o = e.length; o > i; i++) if (n.call(r, e[i], i, e) === !1) return 0;
} else for (i in e) if (e.hasOwnProperty(i) && n.call(r, e[i], i, e) === !1) return 0;
return 1;
}
function a(e, t) {
var n = [];
return o(e, function(e) {
n.push(t(e));
}), n;
}
function s(e, t) {
var n = [];
return o(e, function(e) {
(!t || t(e)) && n.push(e);
}), n;
}
function l(e, t, n) {
var i, o, a, s, l, r = this, c = 0;
if (e = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(e), a = e[3].match(/(^|\.)(\w+)$/i)[2], 
o = r.createNS(e[3].replace(/\.\w+$/, ""), n), !o[a]) {
if ("static" == e[2]) return o[a] = t, void (this.onCreate && this.onCreate(e[2], e[3], o[a]));
t[a] || (t[a] = function() {}, c = 1), o[a] = t[a], r.extend(o[a].prototype, t), 
e[5] && (i = r.resolve(e[5]).prototype, s = e[5].match(/\.(\w+)$/i)[1], l = o[a], 
o[a] = c ? function() {
return i[s].apply(this, arguments);
} :function() {
return this.parent = i[s], l.apply(this, arguments);
}, o[a].prototype[a] = o[a], r.each(i, function(e, t) {
o[a].prototype[t] = i[t];
}), r.each(t, function(e, t) {
i[t] ? o[a].prototype[t] = function() {
return this.parent = i[t], e.apply(this, arguments);
} :t != a && (o[a].prototype[t] = e);
})), r.each(t["static"], function(e, t) {
o[a][t] = e;
});
}
}
function c(e, t) {
var n, r;
if (e) for (n = 0, r = e.length; r > n; n++) if (e[n] === t) return n;
return -1;
}
function u(e, n) {
var r, i, o, s, a = arguments;
for (r = 1, i = a.length; i > r; r++) {
n = a[r];
for (o in n) n.hasOwnProperty(o) && (s = n[o], s !== t && (e[o] = s));
}
return e;
}
function d(e, t, n, r) {
r = r || this, e && (n && (e = e[n]), o(e, function(e, i) {
return t.call(r, e, i, n) === !1 ? !1 :void d(e, t, n, r);
}));
}
function f(e, t) {
var n, r;
for (t = t || window, e = e.split("."), n = 0; n < e.length; n++) r = e[n], t[r] || (t[r] = {}), 
t = t[r];
return t;
}
function p(e, t) {
var n, r;
for (t = t || window, e = e.split("."), n = 0, r = e.length; r > n && (t = t[e[n]]); n++) ;
return t;
}
function h(t, r) {
return !t || n(t, "array") ? t :a(t.split(r || ","), e);
}
var m = /^\s*|\s*$/g, g = Array.isArray || function(e) {
return "[object Array]" === Object.prototype.toString.call(e);
};
return {
trim:e,
isArray:g,
is:n,
toArray:r,
makeMap:i,
each:o,
map:a,
grep:s,
inArray:c,
extend:u,
create:l,
walk:d,
createNS:f,
resolve:p,
explode:h
};
}), r(d, [], function() {
var n, r, i, o, a, s, l, e = navigator, t = e.userAgent;
n = window.opera && window.opera.buildNumber, r = /WebKit/.test(t), i = !r && !n && /MSIE/gi.test(t) && /Explorer/gi.test(e.appName), 
i = i && /MSIE (\w+)\./.exec(t)[1], o = -1 == t.indexOf("Trident/") || -1 == t.indexOf("rv:") && -1 == e.appName.indexOf("Netscape") ? !1 :11, 
i = i || o, a = !r && !o && /Gecko/.test(t), s = -1 != t.indexOf("Mac"), l = /(iPad|iPhone)/.test(t);
var c = !l || t.match(/AppleWebKit\/(\d*)/)[1] >= 534;
return {
opera:n,
webkit:r,
ie:i,
gecko:a,
mac:s,
iOS:l,
contentEditable:c,
transparentSrc:"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
caretAfter:8 != i,
range:window.getSelection && "Range" in window,
documentMode:i ? document.documentMode || 7 :10
};
}), r(f, [ l, c, u, d ], function(e, n, r, i) {
function o(e) {
return "undefined" != typeof e;
}
function a(e) {
return "string" == typeof e;
}
function s(e, t) {
var n, r, i;
for (t = t || b, i = t.createElement("div"), n = t.createDocumentFragment(), i.innerHTML = e; r = i.firstChild; ) n.appendChild(r);
return n;
}
function l(e, t, n, r) {
var i;
if (a(t)) t = s(t); else if (t.length && !t.nodeType) {
if (r) for (i = t.length - 1; i >= 0; i--) l(e, t[i], n, r); else for (i = 0; i < t.length; i++) l(e, t[i], n, r);
return e;
}
for (i = e.length; i--; ) n.call(e[i], t.parentNode ? t :t);
return e;
}
function c(e, t) {
return e && t && -1 !== (" " + e.className + " ").indexOf(" " + t + " ");
}
function u(e, t, n) {
var r, i;
return t = f(t)[0], e.each(function() {
var e = this;
n && r == e.parentNode ? i.appendChild(e) :(r = e.parentNode, i = t.cloneNode(!1), 
e.parentNode.insertBefore(i, e), i.appendChild(e));
}), e;
}
function d(e, t) {
m(t, function(t, n) {
m(t.split(" "), function() {
e[this] = n;
});
});
}
function f(e, t) {
return new f.fn.init(e, t);
}
function p(e, t) {
var n;
if (t.indexOf) return t.indexOf(e);
for (n = t.length; n--; ) if (t[n] === e) return n;
return -1;
}
function h(e) {
return null === e || e === N ? "" :("" + e).replace(A, "");
}
function m(e, t) {
var n, r, i, o, a;
if (e) if (n = e.length, n === o) {
for (r in e) if (e.hasOwnProperty(r) && (a = e[r], t.call(a, r, a) === !1)) break;
} else for (i = 0; n > i && (a = e[i], t.call(a, i, a) !== !1); i++) ;
return e;
}
function g(e, n, r) {
for (var i = [], o = e[n]; o && 9 !== o.nodeType && (r === t || 1 !== o.nodeType || !f(o).is(r)); ) 1 === o.nodeType && i.push(o), 
o = o[n];
return i;
}
function v(e, t, n, r) {
for (var i = []; e; e = e[t]) if (!n || e.nodeType === n) {
if (r && (r.nodeType && e === r || f(e).is(r))) break;
i.push(e);
}
return i;
}
function y(e, t, n) {
for (e = e[t]; e; e = e[t]) if (e.nodeType == n) return e;
return null;
}
var N, b = document, C = Array.prototype.push, x = Array.prototype.slice, w = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/, _ = e.Event, E = r.makeMap("fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom", " "), k = r.makeMap("checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected", " "), S = {
"for":"htmlFor",
"class":"className",
readonly:"readOnly"
}, T = {}, R = {};
i.ie && i.ie <= 7 && (d(T, {
maxlength:function(e, t) {
return t = e.maxLength, 2147483647 === t ? N :t;
},
size:function(e, t) {
return t = e.size, 20 === t ? N :t;
},
"class":function(e) {
return e.className;
},
style:function(e) {
return 0 === e.style.cssText.length ? N :e.style.cssText;
}
}), d(R, {
"class":function(e, t) {
e.className = t;
},
style:function(e, t) {
e.style.cssText = t;
}
}));
var A = /^\s*|\s*$/g;
return f.fn = f.prototype = {
constructor:f,
selector:"",
context:null,
length:0,
init:function(e, t) {
var r, i, n = this;
if (!e) return n;
if (e.nodeType) return n.context = n[0] = e, n.length = 1, n;
if (t && t.nodeType) n.context = t; else {
if (t) return f(e).attr(t);
n.context = t = document;
}
if (a(e)) {
if (n.selector = e, r = "<" === e.charAt(0) && ">" === e.charAt(e.length - 1) && e.length >= 3 ? [ null, e, null ] :w.exec(e), 
!r) return f(t).find(e);
if (r[1]) for (i = s(e, t).firstChild; i; ) C.call(n, i), i = i.nextSibling; else {
if (i = b.getElementById(r[2]), i.id !== r[2]) return n.find(e);
n.length = 1, n[0] = i;
}
} else this.add(e, !1);
return n;
},
toArray:function() {
return r.toArray(this);
},
add:function(e, t) {
var r, i, n = this;
if (a(e)) return n.add(f(e));
if (e.nodeType) return n.add([ e ]);
if (t !== !1) for (r = f.unique(n.toArray().concat(f.makeArray(e))), n.length = r.length, 
i = 0; i < r.length; i++) n[i] = r[i]; else C.apply(n, f.makeArray(e));
return n;
},
attr:function(e, t) {
var r, n = this;
if ("object" == typeof e) m(e, function(e, t) {
n.attr(e, t);
}); else {
if (!o(t)) {
if (n[0] && 1 === n[0].nodeType) {
if (k[e]) return n.prop(e) ? e :N;
if (t = n[0].getAttribute(e, 2), r = T[e]) return r(n[0], t, e);
null === t && (t = N);
}
return t;
}
this.each(function() {
var n;
1 === this.nodeType && (n = R[e], n && n(this, t, e), null === t ? this.removeAttribute(e, 2) :this.setAttribute(e, t, 2));
});
}
return n;
},
removeAttr:function(e) {
return this.attr(e, null);
},
prop:function(e, t) {
var n = this;
if (e = S[e] || e, "object" == typeof e) m(e, function(e, t) {
n.prop(e, t);
}); else {
if (!o(t)) return n[0] && n[0].nodeType && e in n[0] ? n[0][e] :t;
this.each(function() {
1 == this.nodeType && (this[e] = t);
});
}
return n;
},
css:function(e, t) {
var n = this;
if ("object" == typeof e) m(e, function(e, t) {
n.css(e, t);
}); else if (e = e.replace(/-(\D)/g, function(e, t) {
return t.toUpperCase();
}), o(t)) "number" != typeof t || E[e] || (t += "px"), n.each(function() {
var n = this.style;
"opacity" === e && this.runtimeStyle && "undefined" == typeof this.runtimeStyle.opacity && (n.filter = "" === t ? "" :"alpha(opacity=" + 100 * t + ")");
try {
n[e] = t;
} catch (r) {}
}); else if (n.context.defaultView) {
e = e.replace(/[A-Z]/g, function(e) {
return "-" + e;
});
try {
return n.context.defaultView.getComputedStyle(n[0], null).getPropertyValue(e);
} catch (r) {
return N;
}
} else if (n[0].currentStyle) return n[0].currentStyle[e];
return n;
},
remove:function() {
for (var t, e = this, n = this.length; n--; ) t = e[n], _.clean(t), t.parentNode && t.parentNode.removeChild(t);
return this;
},
empty:function() {
for (var t, e = this, n = this.length; n--; ) for (t = e[n]; t.firstChild; ) t.removeChild(t.firstChild);
return this;
},
html:function(e) {
var n, t = this;
if (o(e)) {
n = t.length;
try {
for (;n--; ) t[n].innerHTML = e;
} catch (r) {
f(t[n]).empty().append(e);
}
return t;
}
return t[0] ? t[0].innerHTML :"";
},
text:function(e) {
var n, t = this;
if (o(e)) {
for (n = t.length; n--; ) "innerText" in t[n] ? t[n].innerText = e :t[0].textContent = e;
return t;
}
return t[0] ? t[0].innerText || t[0].textContent :"";
},
append:function() {
return l(this, arguments, function(e) {
1 === this.nodeType && this.appendChild(e);
});
},
prepend:function() {
return l(this, arguments, function(e) {
1 === this.nodeType && this.insertBefore(e, this.firstChild);
}, !0);
},
before:function() {
var e = this;
return e[0] && e[0].parentNode ? l(e, arguments, function(e) {
this.parentNode.insertBefore(e, this);
}) :e;
},
after:function() {
var e = this;
return e[0] && e[0].parentNode ? l(e, arguments, function(e) {
this.parentNode.insertBefore(e, this.nextSibling);
}, !0) :e;
},
appendTo:function(e) {
return f(e).append(this), this;
},
prependTo:function(e) {
return f(e).prepend(this), this;
},
replaceWith:function(e) {
return this.before(e).remove();
},
wrap:function(e) {
return u(this, e);
},
wrapAll:function(e) {
return u(this, e, !0);
},
wrapInner:function(e) {
return this.each(function() {
f(this).contents().wrapAll(e);
}), this;
},
unwrap:function() {
return this.each(function() {
var e = f(this.parentNode);
e.before(e.contents()), e.remove();
});
},
clone:function() {
var e = [];
return this.each(function() {
e.push(this.cloneNode(!0));
}), f(e);
},
addClass:function(e) {
return this.toggleClass(e, !0);
},
removeClass:function(e) {
return this.toggleClass(e, !1);
},
toggleClass:function(e, t) {
var n = this;
return "string" != typeof e ? n :(-1 !== e.indexOf(" ") ? m(e.split(" "), function() {
n.toggleClass(this, t);
}) :n.each(function(n, r) {
var i, o;
o = c(r, e), o !== t && (i = r.className, o ? r.className = h((" " + i + " ").replace(" " + e + " ", " ")) :r.className += i ? " " + e :e);
}), n);
},
hasClass:function(e) {
return c(this[0], e);
},
each:function(e) {
return m(this, e);
},
on:function(e, t) {
return this.each(function() {
_.bind(this, e, t);
});
},
off:function(e, t) {
return this.each(function() {
_.unbind(this, e, t);
});
},
trigger:function(e) {
return this.each(function() {
"object" == typeof e ? _.fire(this, e.type, e) :_.fire(this, e);
});
},
show:function() {
return this.css("display", "");
},
hide:function() {
return this.css("display", "none");
},
slice:function() {
return new f(x.apply(this, arguments));
},
eq:function(e) {
return -1 === e ? this.slice(e) :this.slice(e, +e + 1);
},
first:function() {
return this.eq(0);
},
last:function() {
return this.eq(-1);
},
find:function(e) {
var t, n, r = [];
for (t = 0, n = this.length; n > t; t++) f.find(e, this[t], r);
return f(r);
},
filter:function(e) {
return f(f.filter(e, this.toArray()));
},
closest:function(e) {
var t = [];
return this.each(function(n, r) {
for (;r; ) {
if (e.nodeType && r == e || f(r).is(e)) {
t.push(r);
break;
}
r = r.parentNode;
}
}), f(t);
},
push:C,
sort:[].sort,
splice:[].splice
}, r.extend(f, {
extend:r.extend,
makeArray:r.toArray,
inArray:p,
isArray:r.isArray,
each:m,
trim:h,
find:n,
expr:n.selectors,
unique:n.uniqueSort,
text:n.getText,
contains:n.contains,
filter:function(e, t, n) {
return n && (e = ":not(" + e + ")"), t = 1 === t.length ? f.find.matchesSelector(t[0], e) ? [ t[0] ] :[] :f.find.matches(e, t);
}
}), m({
parent:function(e) {
var t = e.parentNode;
return t && 11 !== t.nodeType ? t :null;
},
parents:function(e) {
return g(e, "parentNode");
},
parentsUntil:function(e, t) {
return g(e, "parentNode", t);
},
next:function(e) {
return y(e, "nextSibling", 1);
},
prev:function(e) {
return y(e, "previousSibling", 1);
},
nextUntil:function(e, t) {
return v(e, "nextSibling", 1, t).slice(1);
},
prevUntil:function(e, t) {
return v(e, "previousSibling", 1, t).slice(1);
},
children:function(e) {
return v(e.firstChild, "nextSibling", 1);
},
contents:function(e) {
return r.toArray(("iframe" === e.nodeName ? e.contentDocument || e.contentWindow.document :e).childNodes);
}
}, function(e, t) {
f.fn[e] = function(n) {
var r = this, i = [];
return r.each(function() {
var e = t.call(i, this, n, i);
e && (f.isArray(e) ? i.push.apply(i, e) :i.push(e));
}), i = f.unique(i), (0 === e.indexOf("parents") || "prevUntil" === e) && (i = i.reverse()), 
i = f(i), n && -1 == e.indexOf("Until") ? i.filter(n) :i;
};
}), f.fn.is = function(e) {
return !!e && this.filter(e).length > 0;
}, f.fn.init.prototype = f.fn, f.overrideDefaults = function(e) {
function t(r, i) {
return n = n || e(), new t.fn.init(r || n.element, i || n.context);
}
var n;
return f.extend(t, this), t;
}, f;
}), r(p, [], function() {
return function(e, t) {
function n(e, t, n, r) {
function i(e) {
return e = parseInt(e, 10).toString(16), e.length > 1 ? e :"0" + e;
}
return "#" + i(t) + i(n) + i(r);
}
var s, l, u, d, f, r = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, i = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, o = /\s*([^:]+):\s*([^;]+);?/g, a = /\s+$/, c = {}, p = "\ufeff";
for (e = e || {}, t && (d = t.getValidStyles(), f = t.getInvalidStyles()), u = ("\\\" \\' \\; \\: ; : " + p).split(" "), 
l = 0; l < u.length; l++) c[u[l]] = p + l, c[p + l] = u[l];
return {
toHex:function(e) {
return e.replace(r, n);
},
parse:function(t) {
function s(e, t, n) {
var r, i, o, a;
if (r = m[e + "-top" + t], r && (i = m[e + "-right" + t], i && (o = m[e + "-bottom" + t], 
o && (a = m[e + "-left" + t])))) {
var s = [ r, i, o, a ];
for (l = s.length - 1; l-- && s[l] === s[l + 1]; ) ;
l > -1 && n || (m[e + t] = -1 == l ? s[0] :s.join(" "), delete m[e + "-top" + t], 
delete m[e + "-right" + t], delete m[e + "-bottom" + t], delete m[e + "-left" + t]);
}
}
function u(e) {
var n, t = m[e];
if (t) {
for (t = t.split(" "), n = t.length; n--; ) if (t[n] !== t[0]) return !1;
return m[e] = t[0], !0;
}
}
function d(e, t, n, r) {
u(t) && u(n) && u(r) && (m[e] = m[t] + " " + m[n] + " " + m[r], delete m[t], delete m[n], 
delete m[r]);
}
function f(e) {
return b = !0, c[e];
}
function p(e, t) {
return b && (e = e.replace(/\uFEFF[0-9]/g, function(e) {
return c[e];
})), t || (e = e.replace(/\\([\'\";:])/g, "$1")), e;
}
function h(t, n, r, i, o, a) {
if (o = o || a) return o = p(o), "'" + o.replace(/\'/g, "\\'") + "'";
if (n = p(n || r || i), !e.allow_script_urls) {
var s = n.replace(/[\s\r\n]+/, "");
if (/(java|vb)script:/i.test(s)) return "";
if (!e.allow_svg_data_urls && /^data:image\/svg/i.test(s)) return "";
}
return C && (n = C.call(x, n, "style")), "url('" + n.replace(/\'/g, "\\'") + "')";
}
var g, v, y, b, m = {}, C = e.url_converter, x = e.url_converter_scope || this;
if (t) {
for (t = t.replace(/[\u0000-\u001F]/g, ""), t = t.replace(/\\[\"\';:\uFEFF]/g, f).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(e) {
return e.replace(/[;:]/g, f);
}); g = o.exec(t); ) {
if (v = g[1].replace(a, "").toLowerCase(), y = g[2].replace(a, ""), y = y.replace(/\\[0-9a-f]+/g, function(e) {
return String.fromCharCode(parseInt(e.substr(1), 16));
}), v && y.length > 0) {
if (!e.allow_script_urls && ("behavior" == v || /expression\s*\(|\/\*|\*\//.test(y))) continue;
"font-weight" === v && "700" === y ? y = "bold" :("color" === v || "background-color" === v) && (y = y.toLowerCase()), 
y = y.replace(r, n), y = y.replace(i, h), m[v] = b ? p(y, !0) :y;
}
o.lastIndex = g.index + g[0].length;
}
s("border", "", !0), s("border", "-width"), s("border", "-color"), s("border", "-style"), 
s("padding", ""), s("margin", ""), d("border", "border-width", "border-style", "border-color"), 
"medium none" === m.border && delete m.border, "none" === m["border-image"] && delete m["border-image"];
}
return m;
},
serialize:function(e, t) {
function n(t) {
var n, r, o, a;
if (n = d[t]) for (r = 0, o = n.length; o > r; r++) t = n[r], a = e[t], a !== s && a.length > 0 && (i += (i.length > 0 ? " " :"") + t + ": " + a + ";");
}
function r(e, t) {
var n;
return n = f["*"], n && n[e] ? !1 :(n = f[t], n && n[e] ? !1 :!0);
}
var o, a, i = "";
if (t && d) n("*"), n(t); else for (o in e) a = e[o], a !== s && a.length > 0 && (!f || r(o, t)) && (i += (i.length > 0 ? " " :"") + o + ": " + a + ";");
return i;
}
};
};
}), r(h, [], function() {
return function(e, t) {
function n(e, n, r, i) {
var o, a;
if (e) {
if (!i && e[n]) return e[n];
if (e != t) {
if (o = e[r]) return o;
for (a = e.parentNode; a && a != t; a = a.parentNode) if (o = a[r]) return o;
}
}
}
var r = e;
this.current = function() {
return r;
}, this.next = function(e) {
return r = n(r, "firstChild", "nextSibling", e);
}, this.prev = function(e) {
return r = n(r, "lastChild", "previousSibling", e);
};
};
}), r(m, [ u ], function(e) {
function t(n) {
function r() {
return H.createDocumentFragment();
}
function i(e, t) {
_(F, e, t);
}
function o(e, t) {
_(z, e, t);
}
function a(e) {
i(e.parentNode, j(e));
}
function s(e) {
i(e.parentNode, j(e) + 1);
}
function l(e) {
o(e.parentNode, j(e));
}
function c(e) {
o(e.parentNode, j(e) + 1);
}
function u(e) {
e ? (M[U] = M[V], M[q] = M[W]) :(M[V] = M[U], M[W] = M[q]), M.collapsed = F;
}
function d(e) {
a(e), c(e);
}
function f(e) {
i(e, 0), o(e, 1 === e.nodeType ? e.childNodes.length :e.nodeValue.length);
}
function p(e, t) {
var n = M[V], r = M[W], i = M[U], o = M[q], a = t.startContainer, s = t.startOffset, l = t.endContainer, c = t.endOffset;
return 0 === e ? w(n, r, a, s) :1 === e ? w(i, o, a, s) :2 === e ? w(i, o, l, c) :3 === e ? w(n, r, l, c) :void 0;
}
function h() {
N(I);
}
function m() {
return N(P);
}
function g() {
return N(O);
}
function v(e) {
var i, o, t = this[V], r = this[W];
3 !== t.nodeType && 4 !== t.nodeType || !t.nodeValue ? (t.childNodes.length > 0 && (o = t.childNodes[r]), 
o ? t.insertBefore(e, o) :3 == t.nodeType ? n.insertAfter(e, t) :t.appendChild(e)) :r ? r >= t.nodeValue.length ? n.insertAfter(e, t) :(i = t.splitText(r), 
t.parentNode.insertBefore(e, i)) :t.parentNode.insertBefore(e, t);
}
function y(e) {
var t = M.extractContents();
M.insertNode(e), e.appendChild(t), M.selectNode(e);
}
function b() {
return $(new t(n), {
startContainer:M[V],
startOffset:M[W],
endContainer:M[U],
endOffset:M[q],
collapsed:M.collapsed,
commonAncestorContainer:M.commonAncestorContainer
});
}
function C(e, t) {
var n;
if (3 == e.nodeType) return e;
if (0 > t) return e;
for (n = e.firstChild; n && t > 0; ) --t, n = n.nextSibling;
return n ? n :e;
}
function x() {
return M[V] == M[U] && M[W] == M[q];
}
function w(e, t, r, i) {
var o, a, s, l, c, u;
if (e == r) return t == i ? 0 :i > t ? -1 :1;
for (o = r; o && o.parentNode != e; ) o = o.parentNode;
if (o) {
for (a = 0, s = e.firstChild; s != o && t > a; ) a++, s = s.nextSibling;
return a >= t ? -1 :1;
}
for (o = e; o && o.parentNode != r; ) o = o.parentNode;
if (o) {
for (a = 0, s = r.firstChild; s != o && i > a; ) a++, s = s.nextSibling;
return i > a ? -1 :1;
}
for (l = n.findCommonAncestor(e, r), c = e; c && c.parentNode != l; ) c = c.parentNode;
for (c || (c = l), u = r; u && u.parentNode != l; ) u = u.parentNode;
if (u || (u = l), c == u) return 0;
for (s = l.firstChild; s; ) {
if (s == c) return -1;
if (s == u) return 1;
s = s.nextSibling;
}
}
function _(e, t, r) {
var i, o;
for (e ? (M[V] = t, M[W] = r) :(M[U] = t, M[q] = r), i = M[U]; i.parentNode; ) i = i.parentNode;
for (o = M[V]; o.parentNode; ) o = o.parentNode;
o == i ? w(M[V], M[W], M[U], M[q]) > 0 && M.collapse(e) :M.collapse(e), M.collapsed = x(), 
M.commonAncestorContainer = n.findCommonAncestor(M[V], M[U]);
}
function N(e) {
var t, i, o, a, s, l, c, n = 0, r = 0;
if (M[V] == M[U]) return E(e);
for (t = M[U], i = t.parentNode; i; t = i, i = i.parentNode) {
if (i == M[V]) return k(t, e);
++n;
}
for (t = M[V], i = t.parentNode; i; t = i, i = i.parentNode) {
if (i == M[U]) return S(t, e);
++r;
}
for (o = r - n, a = M[V]; o > 0; ) a = a.parentNode, o--;
for (s = M[U]; 0 > o; ) s = s.parentNode, o++;
for (l = a.parentNode, c = s.parentNode; l != c; l = l.parentNode, c = c.parentNode) a = l, 
s = c;
return T(a, s, e);
}
function E(e) {
var t, n, i, o, a, s, l, c, u;
if (e != I && (t = r()), M[W] == M[q]) return t;
if (3 == M[V].nodeType) {
if (n = M[V].nodeValue, i = n.substring(M[W], M[q]), e != O && (o = M[V], c = M[W], 
u = M[q] - M[W], 0 === c && u >= o.nodeValue.length - 1 ? o.parentNode.removeChild(o) :o.deleteData(c, u), 
M.collapse(F)), e == I) return;
return i.length > 0 && t.appendChild(H.createTextNode(i)), t;
}
for (o = C(M[V], M[W]), a = M[q] - M[W]; o && a > 0; ) s = o.nextSibling, l = D(o, e), 
t && t.appendChild(l), --a, o = s;
return e != O && M.collapse(F), t;
}
function k(e, t) {
var n, i, o, a, s, l;
if (t != I && (n = r()), i = R(e, t), n && n.appendChild(i), o = j(e), a = o - M[W], 
0 >= a) return t != O && (M.setEndBefore(e), M.collapse(z)), n;
for (i = e.previousSibling; a > 0; ) s = i.previousSibling, l = D(i, t), n && n.insertBefore(l, n.firstChild), 
--a, i = s;
return t != O && (M.setEndBefore(e), M.collapse(z)), n;
}
function S(e, t) {
var n, i, o, a, s, l;
for (t != I && (n = r()), o = A(e, t), n && n.appendChild(o), i = j(e), ++i, a = M[q] - i, 
o = e.nextSibling; o && a > 0; ) s = o.nextSibling, l = D(o, t), n && n.appendChild(l), 
--a, o = s;
return t != O && (M.setStartAfter(e), M.collapse(F)), n;
}
function T(e, t, n) {
var i, o, a, s, l, c, u;
for (n != I && (o = r()), i = A(e, n), o && o.appendChild(i), a = j(e), s = j(t), 
++a, l = s - a, c = e.nextSibling; l > 0; ) u = c.nextSibling, i = D(c, n), o && o.appendChild(i), 
c = u, --l;
return i = R(t, n), o && o.appendChild(i), n != O && (M.setStartAfter(e), M.collapse(F)), 
o;
}
function R(e, t) {
var r, i, o, a, s, n = C(M[U], M[q] - 1), l = n != M[U];
if (n == e) return B(n, l, z, t);
for (r = n.parentNode, i = B(r, z, z, t); r; ) {
for (;n; ) o = n.previousSibling, a = B(n, l, z, t), t != I && i.insertBefore(a, i.firstChild), 
l = F, n = o;
if (r == e) return i;
n = r.previousSibling, r = r.parentNode, s = B(r, z, z, t), t != I && s.appendChild(i), 
i = s;
}
}
function A(e, t) {
var i, o, a, s, l, n = C(M[V], M[W]), r = n != M[V];
if (n == e) return B(n, r, F, t);
for (i = n.parentNode, o = B(i, z, F, t); i; ) {
for (;n; ) a = n.nextSibling, s = B(n, r, F, t), t != I && o.appendChild(s), r = F, 
n = a;
if (i == e) return o;
n = i.nextSibling, i = i.parentNode, l = B(i, z, F, t), t != I && l.appendChild(o), 
o = l;
}
}
function B(e, t, r, i) {
var o, a, s, l, c;
if (t) return D(e, i);
if (3 == e.nodeType) {
if (o = e.nodeValue, r ? (l = M[W], a = o.substring(l), s = o.substring(0, l)) :(l = M[q], 
a = o.substring(0, l), s = o.substring(l)), i != O && (e.nodeValue = s), i == I) return;
return c = n.clone(e, z), c.nodeValue = a, c;
}
return i != I ? n.clone(e, z) :void 0;
}
function D(e, t) {
return t != I ? t == O ? n.clone(e, F) :e :void e.parentNode.removeChild(e);
}
function L() {
return n.create("body", null, g()).outerText;
}
var M = this, H = n.doc, P = 0, O = 1, I = 2, F = !0, z = !1, W = "startOffset", V = "startContainer", U = "endContainer", q = "endOffset", $ = e.extend, j = n.nodeIndex;
return $(M, {
startContainer:H,
startOffset:0,
endContainer:H,
endOffset:0,
collapsed:F,
commonAncestorContainer:H,
START_TO_START:0,
START_TO_END:1,
END_TO_END:2,
END_TO_START:3,
setStart:i,
setEnd:o,
setStartBefore:a,
setStartAfter:s,
setEndBefore:l,
setEndAfter:c,
collapse:u,
selectNode:d,
selectNodeContents:f,
compareBoundaryPoints:p,
deleteContents:h,
extractContents:m,
cloneContents:g,
insertNode:v,
surroundContents:y,
cloneRange:b,
toStringIE:L
}), M;
}
return t.prototype.toString = function() {
return this.toStringIE();
}, t;
}), r(g, [ u ], function(e) {
function t(e) {
var t;
return t = document.createElement("div"), t.innerHTML = e, t.textContent || t.innerText || e;
}
function n(e, t) {
var n, r, i, a = {};
if (e) {
for (e = e.split(","), t = t || 10, n = 0; n < e.length; n += 2) r = String.fromCharCode(parseInt(e[n], t)), 
o[r] || (i = "&" + e[n + 1] + ";", a[r] = i, a[i] = r);
return a;
}
}
var i, o, a, r = e.makeMap, s = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, l = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = /[<>&\"\']/g, u = /&(#x|#)?([\w]+);/g, d = {
128:"\u20ac",
130:"\u201a",
131:"\u0192",
132:"\u201e",
133:"\u2026",
134:"\u2020",
135:"\u2021",
136:"\u02c6",
137:"\u2030",
138:"\u0160",
139:"\u2039",
140:"\u0152",
142:"\u017d",
145:"\u2018",
146:"\u2019",
147:"\u201c",
148:"\u201d",
149:"\u2022",
150:"\u2013",
151:"\u2014",
152:"\u02dc",
153:"\u2122",
154:"\u0161",
155:"\u203a",
156:"\u0153",
158:"\u017e",
159:"\u0178"
};
o = {
'"':"&quot;",
"'":"&#39;",
"<":"&lt;",
">":"&gt;",
"&":"&amp;",
"`":"&#96;"
}, a = {
"&lt;":"<",
"&gt;":">",
"&amp;":"&",
"&quot;":'"',
"&apos;":"'"
}, i = n("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
var f = {
encodeRaw:function(e, t) {
return e.replace(t ? s :l, function(e) {
return o[e] || e;
});
},
encodeAllRaw:function(e) {
return ("" + e).replace(c, function(e) {
return o[e] || e;
});
},
encodeNumeric:function(e, t) {
return e.replace(t ? s :l, function(e) {
return e.length > 1 ? "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" :o[e] || "&#" + e.charCodeAt(0) + ";";
});
},
encodeNamed:function(e, t, n) {
return n = n || i, e.replace(t ? s :l, function(e) {
return o[e] || n[e] || e;
});
},
getEncodeFunc:function(e, t) {
function a(e, n) {
return e.replace(n ? s :l, function(e) {
return o[e] || t[e] || "&#" + e.charCodeAt(0) + ";" || e;
});
}
function c(e, n) {
return f.encodeNamed(e, n, t);
}
return t = n(t) || i, e = r(e.replace(/\+/g, ",")), e.named && e.numeric ? a :e.named ? t ? c :f.encodeNamed :e.numeric ? f.encodeNumeric :f.encodeRaw;
},
decode:function(e) {
return e.replace(u, function(e, n, r) {
return n ? (r = parseInt(r, 2 === n.length ? 16 :10), r > 65535 ? (r -= 65536, String.fromCharCode(55296 + (r >> 10), 56320 + (1023 & r))) :d[r] || String.fromCharCode(r)) :a[e] || i[e] || t(e);
});
}
};
return f;
}), r(v, [], function() {
return function(e, t) {
function n(t) {
e.getElementsByTagName("head")[0].appendChild(t);
}
function r(t, r, s) {
function l() {
for (var e = v.passed, t = e.length; t--; ) e[t]();
v.status = 2, v.passed = [], v.failed = [];
}
function c() {
for (var e = v.failed, t = e.length; t--; ) e[t]();
v.status = 3, v.passed = [], v.failed = [];
}
function u() {
var e = navigator.userAgent.match(/WebKit\/(\d*)/);
return !!(e && e[1] < 536);
}
function d(e, t) {
e() || (new Date().getTime() - g < a ? window.setTimeout(t, 0) :c());
}
function f() {
d(function() {
for (var n, i, t = e.styleSheets, r = t.length; r--; ) if (n = t[r], i = n.ownerNode ? n.ownerNode :n.owningElement, 
i && i.id === h.id) return l(), !0;
}, f);
}
function p() {
d(function() {
try {
var e = m.sheet.cssRules;
return l(), !!e;
} catch (t) {}
}, p);
}
var h, m, g, v;
if (o[t] ? v = o[t] :(v = {
passed:[],
failed:[]
}, o[t] = v), r && v.passed.push(r), s && v.failed.push(s), 1 != v.status) {
if (2 == v.status) return void l();
if (3 == v.status) return void c();
if (v.status = 1, h = e.createElement("link"), h.rel = "stylesheet", h.type = "text/css", 
h.id = "u" + i++, h.async = !1, h.defer = !1, g = new Date().getTime(), "onload" in h && !u()) h.onload = f, 
h.onerror = c; else {
if (navigator.userAgent.indexOf("Firefox") > 0) return m = e.createElement("style"), 
m.textContent = '@import "' + t + '"', p(), void n(m);
f();
}
n(h), h.href = t;
}
}
var a, i = 0, o = {};
t = t || {}, a = t.maxLoadTime || 5e3, this.load = r;
};
}), r(y, [ c, f, p, l, h, m, g, d, u, v ], function(e, n, r, i, o, a, s, l, c, u) {
function d(e, t) {
var a, o = this;
o.doc = e, o.win = window, o.files = {}, o.counter = 0, o.stdMode = !y || e.documentMode >= 8, 
o.boxModel = !y || "CSS1Compat" == e.compatMode || o.stdMode, o.hasOuterHTML = "outerHTML" in e.createElement("a"), 
o.styleSheetLoader = new u(e), this.boundEvents = [], o.settings = t = g({
keep_values:!1,
hex_colors:1
}, t), o.schema = t.schema, o.styles = new r({
url_converter:t.url_converter,
url_converter_scope:t.url_converter_scope
}, t.schema), o.fixDoc(e), o.events = t.ownEvents ? new i(t.proxy) :i.Event, a = t.schema ? t.schema.getBlockElements() :{}, 
o.$ = n.overrideDefaults(function() {
return {
context:e,
element:o.getRoot()
};
}), o.isBlock = function(e) {
if (!e) return !1;
var t = e.nodeType;
return t ? !(1 !== t || !a[e.nodeName]) :!!a[e];
};
}
var f = c.each, p = c.is, h = c.grep, m = c.trim, g = c.extend, v = l.webkit, y = l.ie, b = /^([a-z0-9],?)+$/i, C = /^[ \t\r\n]*$/, x = c.makeMap("fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom", " ");
return d.prototype = {
root:null,
props:{
"for":"htmlFor",
"class":"className",
className:"className",
checked:"checked",
disabled:"disabled",
maxlength:"maxLength",
readonly:"readOnly",
selected:"selected",
value:"value",
id:"id",
name:"name",
type:"type"
},
fixDoc:function(e) {
var n, t = this.settings;
if (y && t.schema) {
"abbr article aside audio canvas details figcaption figure footer header hgroup mark menu meter nav output progress section summary time video".replace(/\w+/g, function(t) {
e.createElement(t);
});
for (n in t.schema.getCustomElements()) e.createElement(n);
}
},
clone:function(e, t) {
var r, i, n = this;
return !y || 1 !== e.nodeType || t ? e.cloneNode(t) :(i = n.doc, t ? r.firstChild :(r = i.createElement(e.nodeName), 
f(n.getAttribs(e), function(t) {
n.setAttrib(r, t.nodeName, n.getAttrib(e, t.nodeName));
}), r));
},
getRoot:function() {
var e = this;
return e.get(e.settings.root_element) || e.doc.body;
},
getViewPort:function(e) {
var t, n;
return e = e ? e :this.win, t = e.document, n = this.boxModel ? t.documentElement :t.body, 
{
x:e.pageXOffset || n.scrollLeft,
y:e.pageYOffset || n.scrollTop,
w:e.innerWidth || n.clientWidth,
h:e.innerHeight || n.clientHeight
};
},
getRect:function(e) {
var n, r, t = this;
return e = t.get(e), n = t.getPos(e), r = t.getSize(e), {
x:n.x,
y:n.y,
w:r.w,
h:r.h
};
},
getSize:function(e) {
var n, r, t = this;
return e = t.get(e), n = t.getStyle(e, "width"), r = t.getStyle(e, "height"), -1 === n.indexOf("px") && (n = 0), 
-1 === r.indexOf("px") && (r = 0), {
w:parseInt(n, 10) || e.offsetWidth || e.clientWidth,
h:parseInt(r, 10) || e.offsetHeight || e.clientHeight
};
},
getParent:function(e, t, n) {
return this.getParents(e, t, n, !1);
},
getParents:function(e, n, r, i) {
var a, o = this, s = [];
for (e = o.get(e), i = i === t, r = r || ("BODY" != o.getRoot().nodeName ? o.getRoot().parentNode :null), 
p(n, "string") && (a = n, n = "*" === n ? function(e) {
return 1 == e.nodeType;
} :function(e) {
return o.is(e, a);
}); e && e != r && e.nodeType && 9 !== e.nodeType; ) {
if (!n || n(e)) {
if (!i) return e;
s.push(e);
}
e = e.parentNode;
}
return i ? s :null;
},
get:function(e) {
var t;
return e && this.doc && "string" == typeof e && (t = e, e = this.doc.getElementById(e), 
e && e.id !== t) ? this.doc.getElementsByName(t)[1] :e;
},
getNext:function(e, t) {
return this._findSib(e, t, "nextSibling");
},
getPrev:function(e, t) {
return this._findSib(e, t, "previousSibling");
},
select:function(t, n) {
var r = this;
return e(t, r.get(n) || r.get(r.settings.root_element) || r.doc, []);
},
is:function(n, r) {
var i;
if (n.length === t) {
if ("*" === r) return 1 == n.nodeType;
if (b.test(r)) {
for (r = r.toLowerCase().split(/,/), n = n.nodeName.toLowerCase(), i = r.length - 1; i >= 0; i--) if (r[i] == n) return !0;
return !1;
}
}
if (n.nodeType && 1 != n.nodeType) return !1;
var o = n.nodeType ? [ n ] :n;
return e(r, o[0].ownerDocument || o[0], null, o).length > 0;
},
add:function(e, t, n, r, i) {
var o = this;
return this.run(e, function(e) {
var a;
return a = p(t, "string") ? o.doc.createElement(t) :t, o.setAttribs(a, n), r && (r.nodeType ? a.appendChild(r) :o.setHTML(a, r)), 
i ? a :e.appendChild(a);
});
},
create:function(e, t, n) {
return this.add(this.doc.createElement(e), e, t, n, 1);
},
createHTML:function(e, t, n) {
var i, r = "";
r += "<" + e;
for (i in t) t.hasOwnProperty(i) && null !== t[i] && "undefined" != typeof t[i] && (r += " " + i + '="' + this.encode(t[i]) + '"');
return "undefined" != typeof n ? r + ">" + n + "</" + e + ">" :r + " />";
},
createFragment:function(e) {
var t, n, i, r = this.doc;
for (i = r.createElement("div"), t = r.createDocumentFragment(), e && (i.innerHTML = e); n = i.firstChild; ) t.appendChild(n);
return t;
},
remove:function(e, t) {
return this.run(e, function(e) {
var n, r = e.parentNode;
if (!r) return null;
if (t) for (;n = e.firstChild; ) !y || 3 !== n.nodeType || n.nodeValue ? r.insertBefore(n, e) :e.removeChild(n);
return r.removeChild(e);
});
},
setStyle:function(e, t, n) {
return this.run(e, function(e) {
var i, o, r = this;
if (t) if ("string" == typeof t) {
i = e.style, t = t.replace(/-(\D)/g, function(e, t) {
return t.toUpperCase();
}), "number" != typeof n && !/^[\-0-9\.]+$/.test(n) || x[t] || (n += "px"), "opacity" === t && e.runtimeStyle && "undefined" == typeof e.runtimeStyle.opacity && (i.filter = "" === n ? "" :"alpha(opacity=" + 100 * n + ")"), 
"float" == t && (t = "cssFloat" in e.style ? "cssFloat" :"styleFloat");
try {
i[t] = n;
} catch (a) {}
r.settings.update_styles && e.removeAttribute("data-mce-style");
} else for (o in t) r.setStyle(e, o, t[o]);
});
},
getStyle:function(e, n, r) {
if (e = this.get(e)) {
if (this.doc.defaultView && r) {
n = n.replace(/[A-Z]/g, function(e) {
return "-" + e;
});
try {
return this.doc.defaultView.getComputedStyle(e, null).getPropertyValue(n);
} catch (i) {
return null;
}
}
return n = n.replace(/-(\D)/g, function(e, t) {
return t.toUpperCase();
}), "float" == n && (n = y ? "styleFloat" :"cssFloat"), e.currentStyle && r ? e.currentStyle[n] :e.style ? e.style[n] :t;
}
},
setStyles:function(e, t) {
this.setStyle(e, t);
},
css:function(e, t, n) {
this.setStyle(e, t, n);
},
removeAllAttribs:function(e) {
return this.run(e, function(e) {
var t, n = e.attributes;
for (t = n.length - 1; t >= 0; t--) e.removeAttributeNode(n.item(t));
});
},
setAttrib:function(e, t, n) {
var r = this;
return e && t ? this.run(e, function(e) {
var i = r.settings, o = e.getAttribute(t);
if (null !== n) switch (t) {
case "style":
if (!p(n, "string")) return void f(n, function(t, n) {
r.setStyle(e, n, t);
});
i.keep_values && (n ? e.setAttribute("data-mce-style", n, 2) :e.removeAttribute("data-mce-style", 2)), 
e.style.cssText = n;
break;

case "class":
e.className = n || "";
break;

case "src":
case "href":
i.keep_values && (i.url_converter && (n = i.url_converter.call(i.url_converter_scope || r, n, t, e)), 
r.setAttrib(e, "data-mce-" + t, n, 2));
break;

case "shape":
e.setAttribute("data-mce-style", n);
}
p(n) && null !== n && 0 !== n.length ? e.setAttribute(t, "" + n, 2) :e.removeAttribute(t, 2), 
o != n && i.onSetAttrib && i.onSetAttrib({
attrElm:e,
attrName:t,
attrValue:n
});
}) :void 0;
},
setAttribs:function(e, t) {
var n = this;
return this.run(e, function(e) {
f(t, function(t, r) {
n.setAttrib(e, r, t);
});
});
},
getAttrib:function(e, t, n) {
var r, o, i = this;
if (e = i.get(e), !e || 1 !== e.nodeType) return n === o ? !1 :n;
if (p(n) || (n = ""), /^(src|href|style|coords|shape)$/.test(t) && (r = e.getAttribute("data-mce-" + t))) return r;
if (y && i.props[t] && (r = e[i.props[t]], r = r && r.nodeValue ? r.nodeValue :r), 
r || (r = e.getAttribute(t, 2)), /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noshade|nowrap|readonly|selected)$/.test(t)) return e[i.props[t]] === !0 && "" === r ? t :r ? t :"";
if ("FORM" === e.nodeName && e.getAttributeNode(t)) return e.getAttributeNode(t).nodeValue;
if ("style" === t && (r = r || e.style.cssText, r && (r = i.serializeStyle(i.parseStyle(r), e.nodeName), 
i.settings.keep_values && e.setAttribute("data-mce-style", r))), v && "class" === t && r && (r = r.replace(/(apple|webkit)\-[a-z\-]+/gi, "")), 
y) switch (t) {
case "rowspan":
case "colspan":
1 === r && (r = "");
break;

case "size":
("+0" === r || 20 === r || 0 === r) && (r = "");
break;

case "width":
case "height":
case "vspace":
case "checked":
case "disabled":
case "readonly":
0 === r && (r = "");
break;

case "hspace":
-1 === r && (r = "");
break;

case "maxlength":
case "tabindex":
(32768 === r || 2147483647 === r || "32768" === r) && (r = "");
break;

case "multiple":
case "compact":
case "noshade":
case "nowrap":
return 65535 === r ? t :n;

case "shape":
r = r.toLowerCase();
break;

default:
0 === t.indexOf("on") && r && (r = ("" + r).replace(/^function\s+\w+\(\)\s+\{\s+(.*)\s+\}$/, "$1"));
}
return r !== o && null !== r && "" !== r ? "" + r :n;
},
getPos:function(e, t) {
var o, s, n = this, r = 0, i = 0, a = n.doc;
if (e = n.get(e), t = t || a.body, e) {
if (t === a.body && e.getBoundingClientRect) return s = e.getBoundingClientRect(), 
t = n.boxModel ? a.documentElement :a.body, r = s.left + (a.documentElement.scrollLeft || a.body.scrollLeft) - t.clientLeft, 
i = s.top + (a.documentElement.scrollTop || a.body.scrollTop) - t.clientTop, {
x:r,
y:i
};
for (o = e; o && o != t && o.nodeType; ) r += o.offsetLeft || 0, i += o.offsetTop || 0, 
o = o.offsetParent;
for (o = e.parentNode; o && o != t && o.nodeType; ) r -= o.scrollLeft || 0, i -= o.scrollTop || 0, 
o = o.parentNode;
}
return {
x:r,
y:i
};
},
parseStyle:function(e) {
return this.styles.parse(e);
},
serializeStyle:function(e, t) {
return this.styles.serialize(e, t);
},
addStyle:function(e) {
var r, i, t = this, n = t.doc;
if (t !== d.DOM && n === document) {
var o = d.DOM.addedStyles;
if (o = o || [], o[e]) return;
o[e] = !0, d.DOM.addedStyles = o;
}
i = n.getElementById("mceDefaultStyles"), i || (i = n.createElement("style"), i.id = "mceDefaultStyles", 
i.type = "text/css", r = n.getElementsByTagName("head")[0], r.firstChild ? r.insertBefore(i, r.firstChild) :r.appendChild(i)), 
i.styleSheet ? i.styleSheet.cssText += e :i.appendChild(n.createTextNode(e));
},
loadCSS:function(e) {
var r, t = this, n = t.doc;
return t !== d.DOM && n === document ? void d.DOM.loadCSS(e) :(e || (e = ""), r = n.getElementsByTagName("head")[0], 
void f(e.split(","), function(e) {
var i;
t.files[e] || (t.files[e] = !0, i = t.create("link", {
rel:"stylesheet",
href:e
}), y && n.documentMode && n.recalc && (i.onload = function() {
n.recalc && n.recalc(), i.onload = null;
}), r.appendChild(i));
}));
},
addClass:function(e, t) {
return this.run(e, function(e) {
var n;
return t ? this.hasClass(e, t) ? e.className :(n = this.removeClass(e, t), e.className = n = ("" !== n ? n + " " :"") + t, 
n) :0;
});
},
removeClass:function(e, t) {
var r, n = this;
return n.run(e, function(e) {
var i;
return n.hasClass(e, t) ? (r || (r = new RegExp("(^|\\s+)" + t + "(\\s+|$)", "g")), 
i = e.className.replace(r, " "), i = m(" " != i ? i :""), e.className = i, i || (e.removeAttribute("class"), 
e.removeAttribute("className")), i) :e.className;
});
},
hasClass:function(e, t) {
return e = this.get(e), e && t ? -1 !== (" " + e.className + " ").indexOf(" " + t + " ") :!1;
},
toggleClass:function(e, n, r) {
r = r === t ? !this.hasClass(e, n) :r, this.hasClass(e, n) !== r && (r ? this.addClass(e, n) :this.removeClass(e, n));
},
show:function(e) {
return this.setStyle(e, "display", "block");
},
hide:function(e) {
return this.setStyle(e, "display", "none");
},
isHidden:function(e) {
return e = this.get(e), !e || "none" == e.style.display || "none" == this.getStyle(e, "display");
},
uniqueId:function(e) {
return (e ? e :"mce_") + this.counter++;
},
setHTML:function(e, t) {
var n = this;
return n.run(e, function(e) {
if (y) {
for (;e.firstChild; ) e.removeChild(e.firstChild);
try {
e.innerHTML = "<br />" + t, e.removeChild(e.firstChild);
} catch (r) {
var i = n.create("div");
i.innerHTML = "<br />" + t, f(h(i.childNodes), function(t, n) {
n && e.canHaveHTML && e.appendChild(t);
});
}
} else e.innerHTML = t;
return t;
});
},
getOuterHTML:function(e) {
var t, n = this;
return (e = n.get(e)) ? 1 === e.nodeType && n.hasOuterHTML ? e.outerHTML :(t = (e.ownerDocument || n.doc).createElement("body"), 
t.appendChild(e.cloneNode(!0)), t.innerHTML) :null;
},
setOuterHTML:function(e, t, n) {
var r = this;
return r.run(e, function(e) {
function i() {
var i, o;
for (o = n.createElement("body"), o.innerHTML = t, i = o.lastChild; i; ) r.insertAfter(i.cloneNode(!0), e), 
i = i.previousSibling;
r.remove(e);
}
if (1 == e.nodeType) if (n = n || e.ownerDocument || r.doc, y) try {
1 == e.nodeType && r.hasOuterHTML ? e.outerHTML = t :i();
} catch (o) {
i();
} else i();
});
},
decode:s.decode,
encode:s.encodeAllRaw,
insertAfter:function(e, t) {
return t = this.get(t), this.run(e, function(e) {
var n, r;
return n = t.parentNode, r = t.nextSibling, r ? n.insertBefore(e, r) :n.appendChild(e), 
e;
});
},
replace:function(e, t, n) {
var r = this;
return r.run(t, function(t) {
return p(t, "array") && (e = e.cloneNode(!0)), n && f(h(t.childNodes), function(t) {
e.appendChild(t);
}), t.parentNode.replaceChild(e, t);
});
},
rename:function(e, t) {
var r, n = this;
return e.nodeName != t.toUpperCase() && (r = n.create(t), f(n.getAttribs(e), function(t) {
n.setAttrib(r, t.nodeName, n.getAttrib(e, t.nodeName));
}), n.replace(r, e, 1)), r || e;
},
findCommonAncestor:function(e, t) {
for (var r, n = e; n; ) {
for (r = t; r && n != r; ) r = r.parentNode;
if (n == r) break;
n = n.parentNode;
}
return !n && e.ownerDocument ? e.ownerDocument.documentElement :n;
},
toHex:function(e) {
return this.styles.toHex(c.trim(e));
},
run:function(e, t, n) {
var i, r = this;
return "string" == typeof e && (e = r.get(e)), e ? (n = n || this, e.nodeType || !e.length && 0 !== e.length ? t.call(n, e) :(i = [], 
f(e, function(e, o) {
e && ("string" == typeof e && (e = r.get(e)), i.push(t.call(n, e, o)));
}), i)) :!1;
},
getAttribs:function(e) {
var t;
if (e = this.get(e), !e) return [];
if (y) {
if (t = [], "OBJECT" == e.nodeName) return e.attributes;
"OPTION" === e.nodeName && this.getAttrib(e, "selected") && t.push({
specified:1,
nodeName:"selected"
});
var n = /<\/?[\w:\-]+ ?|=[\"][^\"]+\"|=\'[^\']+\'|=[\w\-]+|>/gi;
return e.cloneNode(!1).outerHTML.replace(n, "").replace(/[\w:\-]+/gi, function(e) {
t.push({
specified:1,
nodeName:e
});
}), t;
}
return e.attributes;
},
isEmpty:function(e, t) {
var r, i, a, s, l, n = this, c = 0;
if (e = e.firstChild) {
s = new o(e, e.parentNode), t = t || n.schema ? n.schema.getNonEmptyElements() :null;
do {
if (a = e.nodeType, 1 === a) {
if (e.getAttribute("data-mce-bogus")) continue;
if (l = e.nodeName.toLowerCase(), t && t[l]) {
if ("br" === l) {
c++;
continue;
}
return !1;
}
for (i = n.getAttribs(e), r = i.length; r--; ) if (l = i[r].nodeName, "name" === l || "data-mce-bookmark" === l) return !1;
}
if (8 == a) return !1;
if (3 === a && !C.test(e.nodeValue)) return !1;
} while (e = s.next());
}
return 1 >= c;
},
createRng:function() {
var e = this.doc;
return e.createRange ? e.createRange() :new a(this);
},
nodeIndex:function(e, t) {
var r, i, n = 0;
if (e) for (r = e.nodeType, e = e.previousSibling; e; e = e.previousSibling) i = e.nodeType, 
(!t || 3 != i || i != r && e.nodeValue.length) && (n++, r = i);
return n;
},
split:function(e, t, n) {
function r(e) {
function t(e) {
var t = e.previousSibling && "SPAN" == e.previousSibling.nodeName, n = e.nextSibling && "SPAN" == e.nextSibling.nodeName;
return t && n;
}
var n, o = e.childNodes, a = e.nodeType;
if (1 != a || "bookmark" != e.getAttribute("data-mce-type")) {
for (n = o.length - 1; n >= 0; n--) r(o[n]);
if (9 != a) {
if (3 == a && e.nodeValue.length > 0) {
var s = m(e.nodeValue).length;
if (!i.isBlock(e.parentNode) || s > 0 || 0 === s && t(e)) return;
} else if (1 == a && (o = e.childNodes, 1 == o.length && o[0] && 1 == o[0].nodeType && "bookmark" == o[0].getAttribute("data-mce-type") && e.parentNode.insertBefore(o[0], e), 
o.length || /^(br|hr|input|img)$/i.test(e.nodeName))) return;
i.remove(e);
}
return e;
}
}
var a, s, l, i = this, o = i.createRng();
return e && t ? (o.setStart(e.parentNode, i.nodeIndex(e)), o.setEnd(t.parentNode, i.nodeIndex(t)), 
a = o.extractContents(), o = i.createRng(), o.setStart(t.parentNode, i.nodeIndex(t) + 1), 
o.setEnd(e.parentNode, i.nodeIndex(e) + 1), s = o.extractContents(), l = e.parentNode, 
l.insertBefore(r(a), e), n ? l.replaceChild(n, t) :l.insertBefore(t, e), l.insertBefore(r(s), e), 
i.remove(e), n || t) :void 0;
},
bind:function(e, t, n, r) {
var i = this;
if (c.isArray(e)) {
for (var o = e.length; o--; ) e[o] = i.bind(e[o], t, n, r);
return e;
}
return !i.settings.collect || e !== i.doc && e !== i.win || i.boundEvents.push([ e, t, n, r ]), 
i.events.bind(e, t, n, r || i);
},
unbind:function(e, t, n) {
var i, r = this;
if (c.isArray(e)) {
for (i = e.length; i--; ) e[i] = r.unbind(e[i], t, n);
return e;
}
if (r.boundEvents && (e === r.doc || e === r.win)) for (i = r.boundEvents.length; i--; ) {
var o = r.boundEvents[i];
e != o[0] || t && t != o[1] || n && n != o[2] || this.events.unbind(o[0], o[1], o[2]);
}
return this.events.unbind(e, t, n);
},
fire:function(e, t, n) {
return this.events.fire(e, t, n);
},
getContentEditable:function(e) {
var t;
return e && 1 == e.nodeType ? (t = e.getAttribute("data-mce-contenteditable"), t && "inherit" !== t ? t :"inherit" !== e.contentEditable ? e.contentEditable :null) :null;
},
getContentEditableParent:function(e) {
for (var t = this.getRoot(), n = null; e && e !== t && (n = this.getContentEditable(e), 
null === n); e = e.parentNode) ;
return n;
},
destroy:function() {
var t = this;
if (t.boundEvents) {
for (var n = t.boundEvents.length; n--; ) {
var r = t.boundEvents[n];
this.events.unbind(r[0], r[1], r[2]);
}
t.boundEvents = null;
}
e.setDocument && e.setDocument(), t.win = t.doc = t.root = t.events = t.frag = null;
},
isChildOf:function(e, t) {
for (;e; ) {
if (t === e) return !0;
e = e.parentNode;
}
return !1;
},
dumpRng:function(e) {
return "startContainer: " + e.startContainer.nodeName + ", startOffset: " + e.startOffset + ", endContainer: " + e.endContainer.nodeName + ", endOffset: " + e.endOffset;
},
_findSib:function(e, t, n) {
var r = this, i = t;
if (e) for ("string" == typeof i && (i = function(e) {
return r.is(e, t);
}), e = e[n]; e; e = e[n]) if (i(e)) return e;
return null;
}
}, d.DOM = new d(document), d;
}), r(b, [ y, u ], function(e, t) {
function n() {
function e(e, t) {
function n() {
o.remove(s), a && (a.onreadystatechange = a.onload = a = null), t();
}
function i() {
"undefined" != typeof console && console.log && console.log("Failed to load: " + e);
}
var a, s, o = r;
s = o.uniqueId(), a = document.createElement("script"), a.id = s, a.type = "text/javascript", 
a.src = e, "onreadystatechange" in a ? a.onreadystatechange = function() {
/loaded|complete/.test(a.readyState) && n();
} :a.onload = n, a.onerror = i, (document.getElementsByTagName("head")[0] || document.body).appendChild(a);
}
var f, t = 0, n = 1, a = 2, s = {}, l = [], c = {}, u = [], d = 0;
this.isDone = function(e) {
return s[e] == a;
}, this.markDone = function(e) {
s[e] = a;
}, this.add = this.load = function(e, n, r) {
var i = s[e];
i == f && (l.push(e), s[e] = t), n && (c[e] || (c[e] = []), c[e].push({
func:n,
scope:r || this
}));
}, this.loadQueue = function(e, t) {
this.loadScripts(l, e, t);
}, this.loadScripts = function(t, r, l) {
function p(e) {
i(c[e], function(e) {
e.func.call(e.scope);
}), c[e] = f;
}
var h;
u.push({
func:r,
scope:l || this
}), (h = function() {
var r = o(t);
t.length = 0, i(r, function(t) {
return s[t] == a ? void p(t) :void (s[t] != n && (s[t] = n, d++, e(t, function() {
s[t] = a, d--, p(t), h();
})));
}), d || (i(u, function(e) {
e.func.call(e.scope);
}), u.length = 0);
})();
};
}
var r = e.DOM, i = t.each, o = t.grep;
return n.ScriptLoader = new n(), n;
}), r(C, [ b, u ], function(e, n) {
function r() {
var e = this;
e.items = [], e.urls = {}, e.lookup = {};
}
var i = n.each;
return r.prototype = {
get:function(e) {
return this.lookup[e] ? this.lookup[e].instance :t;
},
dependencies:function(e) {
var t;
return this.lookup[e] && (t = this.lookup[e].dependencies), t || [];
},
requireLangPack:function(t, n) {
var i = r.language;
if (i && r.languageLoad !== !1) {
if (n) if (n = "," + n + ",", -1 != n.indexOf("," + i.substr(0, 2) + ",")) i = i.substr(0, 2); else if (-1 == n.indexOf("," + i + ",")) return;
e.ScriptLoader.add(this.urls[t] + "/langs/" + i + ".js");
}
},
add:function(e, t, n) {
return this.items.push(t), this.lookup[e] = {
instance:t,
dependencies:n
}, t;
},
createUrl:function(e, t) {
return "object" == typeof t ? t :{
prefix:e.prefix,
resource:t,
suffix:e.suffix
};
},
addComponents:function(t, n) {
var r = this.urls[t];
i(n, function(t) {
e.ScriptLoader.add(r + "/" + t);
});
},
load:function(n, o, a, s) {
function l() {
var r = c.dependencies(n);
i(r, function(e) {
var n = c.createUrl(o, e);
c.load(n.resource, n, t, t);
}), a && a.call(s ? s :e);
}
var c = this, u = o;
c.urls[n] || ("object" == typeof o && (u = o.prefix + o.resource + o.suffix), 0 !== u.indexOf("/") && -1 == u.indexOf("://") && (u = r.baseURL + "/" + u), 
c.urls[n] = u.substring(0, u.lastIndexOf("/")), c.lookup[n] ? l() :e.ScriptLoader.add(u, l, s));
}
}, r.PluginManager = new r(), r.ThemeManager = new r(), r;
}), r(x, [], function() {
function e(e, t, n) {
var r, i, o = n ? "lastChild" :"firstChild", a = n ? "prev" :"next";
if (e[o]) return e[o];
if (e !== t) {
if (r = e[a]) return r;
for (i = e.parent; i && i !== t; i = i.parent) if (r = i[a]) return r;
}
}
function t(e, t) {
this.name = e, this.type = t, 1 === t && (this.attributes = [], this.attributes.map = {});
}
var n = /^[ \t\r\n]*$/, r = {
"#text":3,
"#comment":8,
"#cdata":4,
"#pi":7,
"#doctype":10,
"#document-fragment":11
};
return t.prototype = {
replace:function(e) {
var t = this;
return e.parent && e.remove(), t.insert(e, t), t.remove(), t;
},
attr:function(e, t) {
var r, i, o, n = this;
if ("string" != typeof e) {
for (i in e) n.attr(i, e[i]);
return n;
}
if (r = n.attributes) {
if (t !== o) {
if (null === t) {
if (e in r.map) for (delete r.map[e], i = r.length; i--; ) if (r[i].name === e) return r = r.splice(i, 1), 
n;
return n;
}
if (e in r.map) {
for (i = r.length; i--; ) if (r[i].name === e) {
r[i].value = t;
break;
}
} else r.push({
name:e,
value:t
});
return r.map[e] = t, n;
}
return r.map[e];
}
},
clone:function() {
var r, i, o, a, s, e = this, n = new t(e.name, e.type);
if (o = e.attributes) {
for (s = [], s.map = {}, r = 0, i = o.length; i > r; r++) a = o[r], "id" !== a.name && (s[s.length] = {
name:a.name,
value:a.value
}, s.map[a.name] = a.value);
n.attributes = s;
}
return n.value = e.value, n.shortEnded = e.shortEnded, n;
},
wrap:function(e) {
var t = this;
return t.parent.insert(e, t), e.append(t), t;
},
unwrap:function() {
var t, n, e = this;
for (t = e.firstChild; t; ) n = t.next, e.insert(t, e, !0), t = n;
e.remove();
},
remove:function() {
var e = this, t = e.parent, n = e.next, r = e.prev;
return t && (t.firstChild === e ? (t.firstChild = n, n && (n.prev = null)) :r.next = n, 
t.lastChild === e ? (t.lastChild = r, r && (r.next = null)) :n.prev = r, e.parent = e.next = e.prev = null), 
e;
},
append:function(e) {
var n, t = this;
return e.parent && e.remove(), n = t.lastChild, n ? (n.next = e, e.prev = n, t.lastChild = e) :t.lastChild = t.firstChild = e, 
e.parent = t, e;
},
insert:function(e, t, n) {
var r;
return e.parent && e.remove(), r = t.parent || this, n ? (t === r.firstChild ? r.firstChild = e :t.prev.next = e, 
e.prev = t.prev, e.next = t, t.prev = e) :(t === r.lastChild ? r.lastChild = e :t.next.prev = e, 
e.next = t.next, e.prev = t, t.next = e), e.parent = r, e;
},
getAll:function(t) {
var r, n = this, i = [];
for (r = n.firstChild; r; r = e(r, n)) r.name === t && i.push(r);
return i;
},
empty:function() {
var n, r, i, t = this;
if (t.firstChild) {
for (n = [], i = t.firstChild; i; i = e(i, t)) n.push(i);
for (r = n.length; r--; ) i = n[r], i.parent = i.firstChild = i.lastChild = i.next = i.prev = null;
}
return t.firstChild = t.lastChild = null, t;
},
isEmpty:function(t) {
var o, a, r = this, i = r.firstChild;
if (i) do {
if (1 === i.type) {
if (i.attributes.map["data-mce-bogus"]) continue;
if (t[i.name]) return !1;
for (o = i.attributes.length; o--; ) if (a = i.attributes[o].name, "name" === a || 0 === a.indexOf("data-mce-")) return !1;
}
if (8 === i.type) return !1;
if (3 === i.type && !n.test(i.value)) return !1;
} while (i = e(i, r));
return !0;
},
walk:function(t) {
return e(this, null, t);
}
}, t.create = function(e, n) {
var i, o;
if (i = new t(e, r[e] || 1), n) for (o in n) i.attr(o, n[o]);
return i;
}, t;
}), r(w, [ u ], function(e) {
function t(e, t) {
return e ? e.split(t || " ") :[];
}
function n(e) {
function n(e, n, r) {
function i(e) {
var n, r, t = {};
for (n = 0, r = e.length; r > n; n++) t[e[n]] = {};
return t;
}
var a, l, c, u = arguments;
for (r = r || [], n = n || "", "string" == typeof r && (r = t(r)), l = 3; l < u.length; l++) "string" == typeof u[l] && (u[l] = t(u[l])), 
r.push.apply(r, u[l]);
for (e = t(e), a = e.length; a--; ) c = [].concat(s, t(n)), o[e[a]] = {
attributes:i(c),
attributesOrder:c,
children:i(r)
};
}
function r(e, n) {
var r, i, a, s;
for (e = t(e), r = e.length, n = t(n); r--; ) for (i = o[e[r]], a = 0, s = n.length; s > a; a++) i.attributes[n[a]] = {}, 
i.attributesOrder.push(n[a]);
}
var s, l, c, u, d, f, o = {};
return i[e] ? i[e] :(s = t("id accesskey class dir lang style tabindex title"), 
l = t("address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul"), 
c = t("a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment"), 
"html4" != e && (s.push.apply(s, t("contenteditable contextmenu draggable dropzone hidden spellcheck translate")), 
l.push.apply(l, t("article aside details dialog figure header footer hgroup section nav")), 
c.push.apply(c, t("audio canvas command datalist mark meter output progress time wbr video ruby bdi keygen"))), 
"html5-strict" != e && (s.push("xml:lang"), f = t("acronym applet basefont big font strike tt"), 
c.push.apply(c, f), a(f, function(e) {
n(e, "", c);
}), d = t("center dir isindex noframes"), l.push.apply(l, d), u = [].concat(l, c), 
a(d, function(e) {
n(e, "", u);
})), u = u || [].concat(l, c), n("html", "manifest", "head body"), n("head", "", "base command link meta noscript script style title"), 
n("title hr noscript br"), n("base", "href target"), n("link", "href rel media hreflang type sizes hreflang"), 
n("meta", "name http-equiv content charset"), n("style", "media type scoped"), n("script", "src async defer type charset"), 
n("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", u), 
n("address dt dd div caption", "", u), n("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", c), 
n("blockquote", "cite", u), n("ol", "reversed start type", "li"), n("ul", "", "li"), 
n("li", "value", u), n("dl", "", "dt dd"), n("a", "href target rel media hreflang type", c), 
n("q", "cite", c), n("ins del", "cite datetime", u), n("img", "src alt usemap ismap width height"), 
n("iframe", "src name width height", u), n("embed", "src type width height"), n("object", "data type typemustmatch name usemap form width height", u, "param"), 
n("param", "name value"), n("map", "name", u, "area"), n("area", "alt coords shape href target rel media hreflang type"), 
n("table", "border", "caption colgroup thead tfoot tbody tr" + ("html4" == e ? " col" :"")), 
n("colgroup", "span", "col"), n("col", "span"), n("tbody thead tfoot", "", "tr"), 
n("tr", "", "td th"), n("td", "colspan rowspan headers", u), n("th", "colspan rowspan headers scope abbr", u), 
n("form", "accept-charset action autocomplete enctype method name novalidate target", u), 
n("fieldset", "disabled form name", u, "legend"), n("label", "form for", c), n("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), 
n("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", "html4" == e ? u :c), 
n("select", "disabled form multiple name required size", "option optgroup"), n("optgroup", "disabled label", "option"), 
n("option", "disabled label selected value"), n("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), 
n("menu", "type label", u, "li"), n("noscript", "", u), "html4" != e && (n("wbr"), 
n("ruby", "", c, "rt rp"), n("figcaption", "", u), n("mark rt rp summary bdi", "", c), 
n("canvas", "width height", u), n("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", u, "track source"), 
n("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", u, "track source"), 
n("source", "src type media"), n("track", "kind src srclang label default"), n("datalist", "", c, "option"), 
n("article section nav aside header footer", "", u), n("hgroup", "", "h1 h2 h3 h4 h5 h6"), 
n("figure", "", u, "figcaption"), n("time", "datetime", c), n("dialog", "open", u), 
n("command", "type label icon disabled checked radiogroup command"), n("output", "for form name", c), 
n("progress", "value max", c), n("meter", "value min max low high optimum", c), 
n("details", "open", u, "summary"), n("keygen", "autofocus challenge disabled form keytype name")), 
"html5-strict" != e && (r("script", "language xml:space"), r("style", "xml:space"), 
r("object", "declare classid code codebase codetype archive standby align border hspace vspace"), 
r("embed", "align name hspace vspace"), r("param", "valuetype type"), r("a", "charset name rev shape coords"), 
r("br", "clear"), r("applet", "codebase archive code object alt name width height align hspace vspace"), 
r("img", "name longdesc align border hspace vspace"), r("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), 
r("font basefont", "size color face"), r("input", "usemap align"), r("select", "onchange"), 
r("textarea"), r("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), r("ul", "type compact"), 
r("li", "type"), r("ol dl menu dir", "compact"), r("pre", "width xml:space"), r("hr", "align noshade size width"), 
r("isindex", "prompt"), r("table", "summary width frame rules cellspacing cellpadding align bgcolor"), 
r("col", "width align char charoff valign"), r("colgroup", "width align char charoff valign"), 
r("thead", "align char charoff valign"), r("tr", "align char charoff valign bgcolor"), 
r("th", "axis align char charoff valign nowrap bgcolor width height"), r("form", "accept"), 
r("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), 
r("tfoot", "align char charoff valign"), r("tbody", "align char charoff valign"), 
r("area", "nohref"), r("body", "background bgcolor text link vlink alink")), "html4" != e && (r("input button select textarea", "autofocus"), 
r("input textarea", "placeholder"), r("a", "download"), r("link script img", "crossorigin"), 
r("iframe", "sandbox seamless allowfullscreen")), a(t("a form meter progress dfn"), function(e) {
o[e] && delete o[e].children[e];
}), delete o.caption.children.table, i[e] = o, o);
}
function r(e, t) {
var n;
return e && (n = {}, "string" == typeof e && (e = {
"*":e
}), a(e, function(e, r) {
n[r] = "map" == t ? o(e, /[, ]/) :l(e, /[, ]/);
})), n;
}
var i = {}, o = e.makeMap, a = e.each, s = e.extend, l = e.explode, c = e.inArray;
return function(e) {
function u(t, n, r) {
var a = e[t];
return a ? a = o(a, /[, ]/, o(a.toUpperCase(), /[, ]/)) :(a = i[t], a || (a = o(n, " ", o(n.toUpperCase(), " ")), 
a = s(a, r), i[t] = a)), a;
}
function d(e) {
return new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$");
}
function f(e) {
var n, r, i, a, s, l, u, f, p, h, m, g, v, b, x, w, _, N, E, k = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/, S = /^([!\-])?(\w+::\w+|[^=:<]+)?(?:([=:<])(.*))?$/, T = /[*?+]/;
if (e) for (e = t(e, ","), y["@"] && (w = y["@"].attributes, _ = y["@"].attributesOrder), 
n = 0, r = e.length; r > n; n++) if (s = k.exec(e[n])) {
if (b = s[1], p = s[2], x = s[3], f = s[5], g = {}, v = [], l = {
attributes:g,
attributesOrder:v
}, "#" === b && (l.paddEmpty = !0), "-" === b && (l.removeEmpty = !0), "!" === s[4] && (l.removeEmptyAttrs = !0), 
w) {
for (N in w) g[N] = w[N];
v.push.apply(v, _);
}
if (f) for (f = t(f, "|"), i = 0, a = f.length; a > i; i++) if (s = S.exec(f[i])) {
if (u = {}, m = s[1], h = s[2].replace(/::/g, ":"), b = s[3], E = s[4], "!" === m && (l.attributesRequired = l.attributesRequired || [], 
l.attributesRequired.push(h), u.required = !0), "-" === m) {
delete g[h], v.splice(c(v, h), 1);
continue;
}
b && ("=" === b && (l.attributesDefault = l.attributesDefault || [], l.attributesDefault.push({
name:h,
value:E
}), u.defaultValue = E), ":" === b && (l.attributesForced = l.attributesForced || [], 
l.attributesForced.push({
name:h,
value:E
}), u.forcedValue = E), "<" === b && (u.validValues = o(E, "?"))), T.test(h) ? (l.attributePatterns = l.attributePatterns || [], 
u.pattern = d(h), l.attributePatterns.push(u)) :(g[h] || v.push(h), g[h] = u);
}
w || "@" != p || (w = g, _ = v), x && (l.outputName = p, y[x] = l), T.test(p) ? (l.pattern = d(p), 
C.push(l)) :y[p] = l;
}
}
function p(e) {
y = {}, C = [], f(e), a(_, function(e, t) {
b[t] = e.children;
});
}
function h(e) {
var n = /^(~)?(.+)$/;
e && (i.text_block_elements = i.block_elements = null, a(t(e, ","), function(e) {
var t = n.exec(e), r = "~" === t[1], i = r ? "span" :"div", o = t[2];
if (b[o] = b[i], L[o] = i, r || (R[o.toUpperCase()] = {}, R[o] = {}), !y[o]) {
var l = y[i];
l = s({}, l), delete l.removeEmptyAttrs, delete l.removeEmpty, y[o] = l;
}
a(b, function(e, t) {
e[i] && (b[t] = e = s({}, b[t]), e[o] = e[i]);
});
}));
}
function m(e) {
var n = /^([+\-]?)(\w+)\[([^\]]+)\]$/;
e && a(t(e, ","), function(e) {
var i, o, r = n.exec(e);
r && (o = r[1], i = o ? b[r[2]] :b[r[2]] = {
"#comment":{}
}, i = b[r[2]], a(t(r[3], "|"), function(e) {
"-" === o ? (b[r[2]] = i = s({}, b[r[2]]), delete i[e]) :i[e] = {};
}));
});
}
function g(e) {
var n, t = y[e];
if (t) return t;
for (n = C.length; n--; ) if (t = C[n], t.pattern.test(e)) return t;
}
var x, w, _, N, E, k, S, T, R, A, B, D, v = this, y = {}, b = {}, C = [], L = {}, M = {};
e = e || {}, _ = n(e.schema), e.verify_html === !1 && (e.valid_elements = "*[*]"), 
x = r(e.valid_styles), w = r(e.invalid_styles, "map"), T = r(e.valid_classes, "map"), 
N = u("whitespace_elements", "pre script noscript style textarea video audio iframe object"), 
E = u("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), 
k = u("short_ended_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), 
S = u("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls"), 
A = u("non_empty_elements", "td th iframe video audio object script", k), B = u("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside nav figure"), 
R = u("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup", B), 
D = u("text_inline_elements", "span strong b em i font strike u var cite dfn code mark q sup sub samp"), 
a((e.special || "script noscript style textarea").split(" "), function(e) {
M[e] = new RegExp("</" + e + "[^>]*>", "gi");
}), e.valid_elements ? p(e.valid_elements) :(a(_, function(e, t) {
y[t] = {
attributes:e.attributes,
attributesOrder:e.attributesOrder
}, b[t] = e.children;
}), "html5" != e.schema && a(t("strong/b em/i"), function(e) {
e = t(e, "/"), y[e[1]].outputName = e[0];
}), y.img.attributesDefault = [ {
name:"alt",
value:""
} ], a(t("ol ul sub sup blockquote span font a table tbody tr strong em b i"), function(e) {
y[e] && (y[e].removeEmpty = !0);
}), a(t("p h1 h2 h3 h4 h5 h6 th td pre div address caption"), function(e) {
y[e].paddEmpty = !0;
}), a(t("span"), function(e) {
y[e].removeEmptyAttrs = !0;
})), h(e.custom_elements), m(e.valid_children), f(e.extended_valid_elements), m("+ol[ul|ol],+ul[ul|ol]"), 
e.invalid_elements && a(l(e.invalid_elements), function(e) {
y[e] && delete y[e];
}), g("span") || f("span[!data-mce-type|*]"), v.children = b, v.getValidStyles = function() {
return x;
}, v.getInvalidStyles = function() {
return w;
}, v.getValidClasses = function() {
return T;
}, v.getBoolAttrs = function() {
return S;
}, v.getBlockElements = function() {
return R;
}, v.getTextBlockElements = function() {
return B;
}, v.getTextInlineElements = function() {
return D;
}, v.getShortEndedElements = function() {
return k;
}, v.getSelfClosingElements = function() {
return E;
}, v.getNonEmptyElements = function() {
return A;
}, v.getWhiteSpaceElements = function() {
return N;
}, v.getSpecialElements = function() {
return M;
}, v.isValidChild = function(e, t) {
var n = b[e];
return !(!n || !n[t]);
}, v.isValid = function(e, t) {
var n, r, i = g(e);
if (i) {
if (!t) return !0;
if (i.attributes[t]) return !0;
if (n = i.attributePatterns) for (r = n.length; r--; ) if (n[r].pattern.test(e)) return !0;
}
return !1;
}, v.getElementRule = g, v.getCustomElements = function() {
return L;
}, v.addValidElements = f, v.setValidElements = p, v.addCustomElements = h, v.addValidChildren = m, 
v.elements = y;
};
}), r(_, [ w, g, u ], function(e, t, n) {
function r(e, t, n) {
var i, o, a, s, r = 1;
for (s = e.getShortEndedElements(), a = /<([!?\/])?([A-Za-z0-9\-\:\.]+)((?:\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\/|\s+)>/g, 
a.lastIndex = i = n; o = a.exec(t); ) {
if (i = a.lastIndex, "/" === o[1]) r--; else if (!o[1]) {
if (o[2] in s) continue;
r++;
}
if (0 === r) break;
}
return i;
}
function i(i, a) {
function s() {}
var l = this;
i = i || {}, l.schema = a = a || new e(), i.fix_self_closing !== !1 && (i.fix_self_closing = !0), 
o("comment cdata text start end pi doctype".split(" "), function(e) {
e && (l[e] = i[e] || s);
}), l.parse = function(e) {
function o(e) {
var t, n;
for (t = p.length; t-- && p[t].name !== e; ) ;
if (t >= 0) {
for (n = p.length - 1; n >= t; n--) e = p[n], e.valid && l.end(e.name);
p.length = t;
}
}
function s(e, t, n, r, o) {
var a, s, l = /[\s\u0000-\u001F]+/g;
if (t = t.toLowerCase(), n = t in x ? t :z(n || r || o || ""), _ && !y && 0 !== t.indexOf("data-")) {
if (a = T[t], !a && R) {
for (s = R.length; s-- && (a = R[s], !a.pattern.test(t)); ) ;
-1 === s && (a = null);
}
if (!a) return;
if (a.validValues && !(n in a.validValues)) return;
}
if (V[t] && !i.allow_script_urls) {
var c = n.replace(l, "");
try {
c = decodeURIComponent(c);
} catch (u) {
c = unescape(c);
}
if (U.test(c)) return;
if (!i.allow_html_data_urls && q.test(c) && !/^data:image\//i.test(c)) return;
}
h.map[t] = n, h.push({
name:t,
value:n
});
}
var c, d, f, h, m, g, v, y, b, C, x, w, _, N, E, k, S, T, R, A, B, D, L, M, H, P, O, I, W, l = this, u = 0, p = [], F = 0, z = t.decode, V = n.makeMap("src,href,data,background,formaction,poster"), U = /((java|vb)script|mhtml):/i, q = /^data:/i;
for (H = new RegExp("<(?:(?:!--([\\w\\W]*?)-->)|(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|(?:!DOCTYPE([\\w\\W]*?)>)|(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|(?:\\/([^>]+)>)|(?:([A-Za-z0-9\\-\\:\\.]+)((?:\\s+[^\"'>]+(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>]*))*|\\/|\\s+)>))", "g"), 
P = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g, 
C = a.getShortEndedElements(), M = i.self_closing_elements || a.getSelfClosingElements(), 
x = a.getBoolAttrs(), _ = i.validate, b = i.remove_internals, W = i.fix_self_closing, 
O = a.getSpecialElements(); c = H.exec(e); ) {
if (u < c.index && l.text(z(e.substr(u, c.index - u))), d = c[6]) d = d.toLowerCase(), 
":" === d.charAt(0) && (d = d.substr(1)), o(d); else if (d = c[7]) {
if (d = d.toLowerCase(), ":" === d.charAt(0) && (d = d.substr(1)), w = d in C, W && M[d] && p.length > 0 && p[p.length - 1].name === d && o(d), 
!_ || (N = a.getElementRule(d))) {
if (E = !0, _ && (T = N.attributes, R = N.attributePatterns), (S = c[8]) ? (y = -1 !== S.indexOf("data-mce-type"), 
y && b && (E = !1), h = [], h.map = {}, S.replace(P, s)) :(h = [], h.map = {}), 
_ && !y) {
if (A = N.attributesRequired, B = N.attributesDefault, D = N.attributesForced, L = N.removeEmptyAttrs, 
L && !h.length && (E = !1), D) for (m = D.length; m--; ) k = D[m], v = k.name, I = k.value, 
"{$uid}" === I && (I = "mce_" + F++), h.map[v] = I, h.push({
name:v,
value:I
});
if (B) for (m = B.length; m--; ) k = B[m], v = k.name, v in h.map || (I = k.value, 
"{$uid}" === I && (I = "mce_" + F++), h.map[v] = I, h.push({
name:v,
value:I
}));
if (A) {
for (m = A.length; m-- && !(A[m] in h.map); ) ;
-1 === m && (E = !1);
}
if (k = h.map["data-mce-bogus"]) {
if ("all" === k) {
u = r(a, e, H.lastIndex), H.lastIndex = u;
continue;
}
E = !1;
}
}
E && l.start(d, h, w);
} else E = !1;
if (f = O[d]) {
f.lastIndex = u = c.index + c[0].length, (c = f.exec(e)) ? (E && (g = e.substr(u, c.index - u)), 
u = c.index + c[0].length) :(g = e.substr(u), u = e.length), E && (g.length > 0 && l.text(g, !0), 
l.end(d)), H.lastIndex = u;
continue;
}
w || (S && S.indexOf("/") == S.length - 1 ? E && l.end(d) :p.push({
name:d,
valid:E
}));
} else (d = c[1]) ? (">" === d.charAt(0) && (d = " " + d), i.allow_conditional_comments || "[if" !== d.substr(0, 3) || (d = " " + d), 
l.comment(d)) :(d = c[2]) ? l.cdata(d) :(d = c[3]) ? l.doctype(d) :(d = c[4]) && l.pi(d, c[5]);
u = c.index + c[0].length;
}
for (u < e.length && l.text(z(e.substr(u))), m = p.length - 1; m >= 0; m--) d = p[m], 
d.valid && l.end(d.name);
};
}
var o = n.each;
return i.findEndTag = r, i;
}), r(N, [ x, w, _, u ], function(e, t, n, r) {
var i = r.makeMap, o = r.each, a = r.explode, s = r.extend;
return function(r, l) {
function c(t) {
var n, r, o, a, s, c, d, f, p, h, m, g, v, y;
for (m = i("tr,td,th,tbody,thead,tfoot,table"), h = l.getNonEmptyElements(), g = l.getTextBlockElements(), 
n = 0; n < t.length; n++) if (r = t[n], r.parent && !r.fixed) if (g[r.name] && "li" == r.parent.name) {
for (v = r.next; v && g[v.name]; ) v.name = "li", v.fixed = !0, r.parent.insert(v, r.parent), 
v = v.next;
r.unwrap(r);
} else {
for (a = [ r ], o = r.parent; o && !l.isValidChild(o.name, r.name) && !m[o.name]; o = o.parent) a.push(o);
if (o && a.length > 1) {
for (a.reverse(), s = c = u.filterNode(a[0].clone()), p = 0; p < a.length - 1; p++) {
for (l.isValidChild(c.name, a[p].name) ? (d = u.filterNode(a[p].clone()), c.append(d)) :d = c, 
f = a[p].firstChild; f && f != a[p + 1]; ) y = f.next, d.append(f), f = y;
c = d;
}
s.isEmpty(h) ? o.insert(r, a[0], !0) :(o.insert(s, a[0], !0), o.insert(r, s)), o = a[0], 
(o.isEmpty(h) || o.firstChild === o.lastChild && "br" === o.firstChild.name) && o.empty().remove();
} else if (r.parent) {
if ("li" === r.name) {
if (v = r.prev, v && ("ul" === v.name || "ul" === v.name)) {
v.append(r);
continue;
}
if (v = r.next, v && ("ul" === v.name || "ul" === v.name)) {
v.insert(r, v.firstChild, !0);
continue;
}
r.wrap(u.filterNode(new e("ul", 1)));
continue;
}
l.isValidChild(r.parent.name, "div") && l.isValidChild("div", r.name) ? r.wrap(u.filterNode(new e("div", 1))) :"style" === r.name || "script" === r.name ? r.empty().remove() :r.unwrap();
}
}
}
var u = this, d = {}, f = [], p = {}, h = {};
r = r || {}, r.validate = "validate" in r ? r.validate :!0, r.root_name = r.root_name || "body", 
u.schema = l = l || new t(), u.filterNode = function(e) {
var t, n, r;
n in d && (r = p[n], r ? r.push(e) :p[n] = [ e ]), t = f.length;
for (;t--; ) n = f[t].name, n in e.attributes.map && (r = h[n], r ? r.push(e) :h[n] = [ e ]);
return e;
}, u.addNodeFilter = function(e, t) {
o(a(e), function(e) {
var n = d[e];
n || (d[e] = n = []), n.push(t);
});
}, u.addAttributeFilter = function(e, t) {
o(a(e), function(e) {
var n;
for (n = 0; n < f.length; n++) if (f[n].name === e) return void f[n].callbacks.push(t);
f.push({
name:e,
callbacks:[ t ]
});
});
}, u.parse = function(t, o) {
function a() {
function e(e) {
e && (t = e.firstChild, t && 3 == t.type && (t.value = t.value.replace(R, "")), 
t = e.lastChild, t && 3 == t.type && (t.value = t.value.replace(D, "")));
}
var n, i, t = y.firstChild;
if (l.isValidChild(y.name, I.toLowerCase())) {
for (;t; ) n = t.next, 3 == t.type || 1 == t.type && "p" !== t.name && !T[t.name] && !t.attr("data-mce-type") ? i ? i.append(t) :(i = u(I, 1), 
i.attr(r.forced_root_block_attrs), y.insert(i, t), i.append(t)) :(e(i), i = null), 
t = n;
e(i);
}
}
function u(t, n) {
var i, r = new e(t, n);
return t in d && (i = p[t], i ? i.push(r) :p[t] = [ r ]), r;
}
function m(e) {
var t, n, r;
for (t = e.prev; t && 3 === t.type; ) n = t.value.replace(D, ""), n.length > 0 ? (t.value = n, 
t = t.prev) :(r = t.prev, t.remove(), t = r);
}
function g(e) {
var t, n = {};
for (t in e) "li" !== t && "p" != t && (n[t] = e[t]);
return n;
}
var v, y, b, C, x, w, _, N, E, k, S, T, R, B, D, L, M, H, P, O, I, A = [];
if (o = o || {}, p = {}, h = {}, T = s(i("script,style,head,html,body,title,meta,param"), l.getBlockElements()), 
O = l.getNonEmptyElements(), P = l.children, S = r.validate, I = "forced_root_block" in o ? o.forced_root_block :r.forced_root_block, 
H = l.getWhiteSpaceElements(), R = /^[ \t\r\n]+/, D = /[ \t\r\n]+$/, L = /[ \t\r\n]+/g, 
M = /^[ \t\r\n]+$/, v = new n({
validate:S,
allow_script_urls:r.allow_script_urls,
allow_conditional_comments:r.allow_conditional_comments,
self_closing_elements:g(l.getSelfClosingElements()),
cdata:function(e) {
b.append(u("#cdata", 4)).value = e;
},
text:function(e, t) {
var n;
B || (e = e.replace(L, " "), b.lastChild && T[b.lastChild.name] && (e = e.replace(R, ""))), 
0 !== e.length && (n = u("#text", 3), n.raw = !!t, b.append(n).value = e);
},
comment:function(e) {
b.append(u("#comment", 8)).value = e;
},
pi:function(e, t) {
b.append(u(e, 7)).value = t, m(b);
},
doctype:function(e) {
var t;
t = b.append(u("#doctype", 10)), t.value = e, m(b);
},
start:function(e, t, n) {
var r, i, o, a, s;
if (o = S ? l.getElementRule(e) :{}) {
for (r = u(o.outputName || e, 1), r.attributes = t, r.shortEnded = n, b.append(r), 
s = P[b.name], s && P[r.name] && !s[r.name] && A.push(r), i = f.length; i--; ) a = f[i].name, 
a in t.map && (E = h[a], E ? E.push(r) :h[a] = [ r ]);
T[e] && m(r), n || (b = r), !B && H[e] && (B = !0);
}
},
end:function(t) {
var n, r, i, o, a;
if (r = S ? l.getElementRule(t) :{}) {
if (T[t] && !B) {
if (n = b.firstChild, n && 3 === n.type) if (i = n.value.replace(R, ""), i.length > 0) n.value = i, 
n = n.next; else for (o = n.next, n.remove(), n = o; n && 3 === n.type; ) i = n.value, 
o = n.next, (0 === i.length || M.test(i)) && (n.remove(), n = o), n = o;
if (n = b.lastChild, n && 3 === n.type) if (i = n.value.replace(D, ""), i.length > 0) n.value = i, 
n = n.prev; else for (o = n.prev, n.remove(), n = o; n && 3 === n.type; ) i = n.value, 
o = n.prev, (0 === i.length || M.test(i)) && (n.remove(), n = o), n = o;
}
if (B && H[t] && (B = !1), (r.removeEmpty || r.paddEmpty) && b.isEmpty(O)) if (r.paddEmpty) b.empty().append(new e("#text", "3")).value = "\xa0"; else if (!b.attributes.map.name && !b.attributes.map.id) return a = b.parent, 
b.unwrap(), void (b = a);
b = b.parent;
}
}
}, l), y = b = new e(o.context || r.root_name, 11), v.parse(t), S && A.length && (o.context ? o.invalid = !0 :c(A)), 
I && ("body" == y.name || o.isRootContent) && a(), !o.invalid) {
for (k in p) {
for (E = d[k], C = p[k], _ = C.length; _--; ) C[_].parent || C.splice(_, 1);
for (x = 0, w = E.length; w > x; x++) E[x](C, k, o);
}
for (x = 0, w = f.length; w > x; x++) if (E = f[x], E.name in h) {
for (C = h[E.name], _ = C.length; _--; ) C[_].parent || C.splice(_, 1);
for (_ = 0, N = E.callbacks.length; N > _; _++) E.callbacks[_](C, E.name, o);
}
}
return y;
}, r.remove_trailing_brs && u.addNodeFilter("br", function(t) {
var n, i, c, u, d, f, p, h, r = t.length, o = s({}, l.getBlockElements()), a = l.getNonEmptyElements();
for (o.body = 1, n = 0; r > n; n++) if (i = t[n], c = i.parent, o[i.parent.name] && i === c.lastChild) {
for (d = i.prev; d; ) {
if (f = d.name, "span" !== f || "bookmark" !== d.attr("data-mce-type")) {
if ("br" !== f) break;
if ("br" === f) {
i = null;
break;
}
}
d = d.prev;
}
i && (i.remove(), c.isEmpty(a) && (p = l.getElementRule(c.name), p && (p.removeEmpty ? c.remove() :p.paddEmpty && (c.empty().append(new e("#text", 3)).value = "\xa0"))));
} else {
for (u = i; c && c.firstChild === u && c.lastChild === u && (u = c, !o[c.name]); ) c = c.parent;
u === c && (h = new e("#text", 3), h.value = "\xa0", i.replace(h));
}
}), r.allow_html_in_named_anchor || u.addAttributeFilter("id,name", function(e) {
for (var n, r, i, o, t = e.length; t--; ) if (o = e[t], "a" === o.name && o.firstChild && !o.attr("href")) {
i = o.parent, n = o.lastChild;
do r = n.prev, i.insert(n, o), n = r; while (n);
}
}), r.validate && l.getValidClasses() && u.addAttributeFilter("class", function(e) {
for (var n, r, i, o, a, c, u, t = e.length, s = l.getValidClasses(); t--; ) {
for (n = e[t], r = n.attr("class").split(" "), a = "", i = 0; i < r.length; i++) o = r[i], 
u = !1, c = s["*"], c && c[o] && (u = !0), c = s[n.name], u || !c || c[o] || (u = !0), 
u && (a && (a += " "), a += o);
a.length || (a = null), n.attr("class", a);
}
});
};
}), r(E, [ g, u ], function(e, t) {
var n = t.makeMap;
return function(t) {
var i, o, a, s, l, r = [];
return t = t || {}, i = t.indent, o = n(t.indent_before || ""), a = n(t.indent_after || ""), 
s = e.getEncodeFunc(t.entity_encoding || "raw", t.entities), l = "html" == t.element_format, 
{
start:function(e, t, n) {
var c, u, d, f;
if (i && o[e] && r.length > 0 && (f = r[r.length - 1], f.length > 0 && "\n" !== f && r.push("\n")), 
r.push("<", e), t) for (c = 0, u = t.length; u > c; c++) d = t[c], r.push(" ", d.name, '="', s(d.value, !0), '"');
r[r.length] = !n || l ? ">" :" />", n && i && a[e] && r.length > 0 && (f = r[r.length - 1], 
f.length > 0 && "\n" !== f && r.push("\n"));
},
end:function(e) {
var t;
r.push("</", e, ">"), i && a[e] && r.length > 0 && (t = r[r.length - 1], t.length > 0 && "\n" !== t && r.push("\n"));
},
text:function(e, t) {
e.length > 0 && (r[r.length] = t ? e :s(e));
},
cdata:function(e) {
r.push("<![CDATA[", e, "]]>");
},
comment:function(e) {
r.push("<!--", e, "-->");
},
pi:function(e, t) {
t ? r.push("<?", e, " ", t, "?>") :r.push("<?", e, "?>"), i && r.push("\n");
},
doctype:function(e) {
r.push("<!DOCTYPE", e, ">", i ? "\n" :"");
},
reset:function() {
r.length = 0;
},
getContent:function() {
return r.join("").replace(/\n$/, "");
}
};
};
}), r(k, [ E, w ], function(e, t) {
return function(n, r) {
var i = this, o = new e(n);
n = n || {}, n.validate = "validate" in n ? n.validate :!0, i.schema = r = r || new t(), 
i.writer = o, i.serialize = function(e) {
function t(e) {
var s, l, c, u, d, f, p, h, m, n = i[e.type];
if (n) n(e); else {
if (s = e.name, l = e.shortEnded, c = e.attributes, a && c && c.length > 1) {
for (f = [], f.map = {}, m = r.getElementRule(e.name), p = 0, h = m.attributesOrder.length; h > p; p++) u = m.attributesOrder[p], 
u in c.map && (d = c.map[u], f.map[u] = d, f.push({
name:u,
value:d
}));
for (p = 0, h = c.length; h > p; p++) u = c[p].name, u in f.map || (d = c.map[u], 
f.map[u] = d, f.push({
name:u,
value:d
}));
c = f;
}
if (o.start(e.name, c, l), !l) {
if (e = e.firstChild) do t(e); while (e = e.next);
o.end(s);
}
}
}
var i, a;
return a = n.validate, i = {
3:function(e) {
o.text(e.value, e.raw);
},
8:function(e) {
o.comment(e.value);
},
7:function(e) {
o.pi(e.name, e.value);
},
10:function(e) {
o.doctype(e.value);
},
4:function(e) {
o.cdata(e.value);
},
11:function(e) {
if (e = e.firstChild) do t(e); while (e = e.next);
}
}, o.reset(), 1 != e.type || n.inner ? i[11](e) :t(e), o.getContent();
};
};
}), r(S, [ y, N, g, k, x, w, d, u ], function(e, t, n, r, i, o, a, s) {
var l = s.each, c = s.trim, u = e.DOM;
return function(e, i) {
var s, d, f;
return i && (s = i.dom, d = i.schema), s = s || u, d = d || new o(e), e.entity_encoding = e.entity_encoding || "named", 
e.remove_trailing_brs = "remove_trailing_brs" in e ? e.remove_trailing_brs :!0, 
f = new t(e, d), f.addAttributeFilter("data-mce-tabindex", function(e, t) {
for (var r, n = e.length; n--; ) r = e[n], r.attr("tabindex", r.attributes.map["data-mce-tabindex"]), 
r.attr(t, null);
}), f.addAttributeFilter("src,href,style", function(t, n) {
for (var i, o, u, r = t.length, a = "data-mce-" + n, l = e.url_converter, c = e.url_converter_scope; r--; ) i = t[r], 
o = i.attributes.map[a], o !== u ? (i.attr(n, o.length > 0 ? o :null), i.attr(a, null)) :(o = i.attributes.map[n], 
"style" === n ? o = s.serializeStyle(s.parseStyle(o), i.name) :l && (o = l.call(c, o, n, i.name)), 
i.attr(n, o.length > 0 ? o :null));
}), f.addAttributeFilter("class", function(e) {
for (var n, r, t = e.length; t--; ) n = e[t], r = n.attr("class"), r && (r = n.attr("class").replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), 
n.attr("class", r.length > 0 ? r :null));
}), f.addAttributeFilter("data-mce-type", function(e, t, n) {
for (var i, r = e.length; r--; ) i = e[r], "bookmark" !== i.attributes.map["data-mce-type"] || n.cleanup || i.remove();
}), f.addNodeFilter("noscript", function(e) {
for (var r, t = e.length; t--; ) r = e[t].firstChild, r && (r.value = n.decode(r.value));
}), f.addNodeFilter("script,style", function(e, t) {
function n(e) {
return e.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
}
for (var i, o, a, r = e.length; r--; ) i = e[r], o = i.firstChild ? i.firstChild.value :"", 
"script" === t ? (a = i.attr("type"), a && i.attr("type", "mce-no/type" == a ? null :a.replace(/^mce\-/, "")), 
o.length > 0 && (i.firstChild.value = "// <![CDATA[\n" + n(o) + "\n// ]]>")) :o.length > 0 && (i.firstChild.value = "<!--\n" + n(o) + "\n-->");
}), f.addNodeFilter("#comment", function(e) {
for (var n, t = e.length; t--; ) n = e[t], 0 === n.value.indexOf("[CDATA[") ? (n.name = "#cdata", 
n.type = 4, n.value = n.value.replace(/^\[CDATA\[|\]\]$/g, "")) :0 === n.value.indexOf("mce:protected ") && (n.name = "#text", 
n.type = 3, n.raw = !0, n.value = unescape(n.value).substr(14));
}), f.addNodeFilter("xml:namespace,input", function(e, t) {
for (var r, n = e.length; n--; ) r = e[n], 7 === r.type ? r.remove() :1 === r.type && ("input" !== t || "type" in r.attributes.map || r.attr("type", "text"));
}), e.fix_list_elements && f.addNodeFilter("ul,ol", function(e) {
for (var n, r, t = e.length; t--; ) n = e[t], r = n.parent, ("ul" === r.name || "ol" === r.name) && n.prev && "li" === n.prev.name && n.prev.append(n);
}), f.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-type,data-mce-resize", function(e, t) {
for (var n = e.length; n--; ) e[n].attr(t, null);
}), {
schema:d,
addNodeFilter:f.addNodeFilter,
addAttributeFilter:f.addAttributeFilter,
serialize:function(t, n) {
var o, u, p, h, m, i = this;
return a.ie && s.select("script,style,select,map").length > 0 ? (m = t.innerHTML, 
t = t.cloneNode(!1), s.setHTML(t, m)) :t = t.cloneNode(!0), o = t.ownerDocument.implementation, 
o.createHTMLDocument && (u = o.createHTMLDocument(""), l("BODY" == t.nodeName ? t.childNodes :[ t ], function(e) {
u.body.appendChild(u.importNode(e, !0));
}), t = "BODY" != t.nodeName ? u.body.firstChild :u.body, p = s.doc, s.doc = u), 
n = n || {}, n.format = n.format || "html", n.selection && (n.forced_root_block = ""), 
n.no_events || (n.node = t, i.onPreProcess(n)), h = new r(e, d), n.content = h.serialize(f.parse(c(n.getInner ? t.innerHTML :s.getOuterHTML(t)), n)), 
n.cleanup || (n.content = n.content.replace(/\uFEFF/g, "")), n.no_events || i.onPostProcess(n), 
p && (s.doc = p), n.node = null, n.content;
},
addRules:function(e) {
d.addValidElements(e);
},
setRules:function(e) {
d.setValidElements(e);
},
onPreProcess:function(e) {
i && i.fire("PreProcess", e);
},
onPostProcess:function(e) {
i && i.fire("PostProcess", e);
}
};
};
}), r(T, [], function() {
function e(e) {
function t(t, n) {
var r, o, a, s, l, c, u, f, i = 0, d = -1;
if (r = t.duplicate(), r.collapse(n), f = r.parentElement(), f.ownerDocument === e.dom.doc) {
for (;"false" === f.contentEditable; ) f = f.parentNode;
if (!f.hasChildNodes()) return {
node:f,
inside:1
};
for (s = f.children, o = s.length - 1; o >= i; ) if (u = Math.floor((i + o) / 2), 
l = s[u], r.moveToElementText(l), d = r.compareEndPoints(n ? "StartToStart" :"EndToEnd", t), 
d > 0) o = u - 1; else {
if (!(0 > d)) return {
node:l
};
i = u + 1;
}
if (0 > d) for (l ? r.collapse(!1) :(r.moveToElementText(f), r.collapse(!0), l = f, 
a = !0), c = 0; 0 !== r.compareEndPoints(n ? "StartToStart" :"StartToEnd", t) && 0 !== r.move("character", 1) && f == r.parentElement(); ) c++; else for (r.collapse(!0), 
c = 0; 0 !== r.compareEndPoints(n ? "StartToStart" :"StartToEnd", t) && 0 !== r.move("character", -1) && f == r.parentElement(); ) c++;
return {
node:l,
position:d,
offset:c,
inside:a
};
}
}
function n() {
function n(e) {
var r, i, l, c, u, n = t(o, e), s = 0;
if (r = n.node, i = n.offset, n.inside && !r.hasChildNodes()) return void a[e ? "setStart" :"setEnd"](r, 0);
if (i === c) return void a[e ? "setStartBefore" :"setEndAfter"](r);
if (n.position < 0) {
if (l = n.inside ? r.firstChild :r.nextSibling, !l) return void a[e ? "setStartAfter" :"setEndAfter"](r);
if (!i) return void (3 == l.nodeType ? a[e ? "setStart" :"setEnd"](l, 0) :a[e ? "setStartBefore" :"setEndBefore"](l));
for (;l; ) {
if (3 == l.nodeType && (u = l.nodeValue, s += u.length, s >= i)) {
r = l, s -= i, s = u.length - s;
break;
}
l = l.nextSibling;
}
} else {
if (l = r.previousSibling, !l) return a[e ? "setStartBefore" :"setEndBefore"](r);
if (!i) return void (3 == r.nodeType ? a[e ? "setStart" :"setEnd"](l, r.nodeValue.length) :a[e ? "setStartAfter" :"setEndAfter"](l));
for (;l; ) {
if (3 == l.nodeType && (s += l.nodeValue.length, s >= i)) {
r = l, s -= i;
break;
}
l = l.previousSibling;
}
}
a[e ? "setStart" :"setEnd"](r, s);
}
var s, l, c, u, d, o = e.getRng(), a = i.createRng();
if (s = o.item ? o.item(0) :o.parentElement(), s.ownerDocument != i.doc) return a;
if (l = e.isCollapsed(), o.item) return a.setStart(s.parentNode, i.nodeIndex(s)), 
a.setEnd(a.startContainer, a.startOffset + 1), a;
try {
n(!0), l || n();
} catch (f) {
if (-2147024809 != f.number) throw f;
d = r.getBookmark(2), c = o.duplicate(), c.collapse(!0), s = c.parentElement(), 
l || (c = o.duplicate(), c.collapse(!1), u = c.parentElement(), u.innerHTML = u.innerHTML), 
s.innerHTML = s.innerHTML, r.moveToBookmark(d), o = e.getRng(), n(!0), l || n();
}
return a;
}
var r = this, i = e.dom, o = !1;
this.getBookmark = function(n) {
function r(e) {
var t, n, r, o, a = [];
for (t = e.parentNode, n = i.getRoot().parentNode; t != n && 9 !== t.nodeType; ) {
for (r = t.children, o = r.length; o--; ) if (e === r[o]) {
a.push(o);
break;
}
e = t, t = t.parentNode;
}
return a;
}
function o(e) {
var n;
return n = t(a, e), n ? {
position:n.position,
offset:n.offset,
indexes:r(n.node),
inside:n.inside
} :void 0;
}
var a = e.getRng(), s = {};
return 2 === n && (a.item ? s.start = {
ctrl:!0,
indexes:r(a.item(0))
} :(s.start = o(!0), e.isCollapsed() || (s.end = o()))), s;
}, this.moveToBookmark = function(e) {
function t(e) {
var t, n, r, o;
for (t = i.getRoot(), n = e.length - 1; n >= 0; n--) o = t.children, r = e[n], r <= o.length - 1 && (t = o[r]);
return t;
}
function n(n) {
var a, s, l, c, i = e[n ? "start" :"end"];
i && (a = i.position > 0, s = o.createTextRange(), s.moveToElementText(t(i.indexes)), 
c = i.offset, c !== l ? (s.collapse(i.inside || a), s.moveStart("character", a ? -c :c)) :s.collapse(n), 
r.setEndPoint(n ? "StartToStart" :"EndToStart", s), n && r.collapse(!0));
}
var r, o = i.doc.body;
e.start && (e.start.ctrl ? (r = o.createControlRange(), r.addElement(t(e.start.indexes)), 
r.select()) :(r = o.createTextRange(), n(!0), n(), r.select()));
}, this.addRange = function(t) {
function n(e) {
var t, n, a, d, h;
a = i.create("a"), t = e ? s :c, n = e ? l :u, d = r.duplicate(), (t == f || t == f.documentElement) && (t = p, 
n = 0), 3 == t.nodeType ? (t.parentNode.insertBefore(a, t), d.moveToElementText(a), 
d.moveStart("character", n), i.remove(a), r.setEndPoint(e ? "StartToStart" :"EndToEnd", d)) :(h = t.childNodes, 
h.length ? (n >= h.length ? i.insertAfter(a, h[h.length - 1]) :t.insertBefore(a, h[n]), 
d.moveToElementText(a)) :t.canHaveHTML && (t.innerHTML = "<span>&#xFEFF;</span>", 
a = t.firstChild, d.moveToElementText(a), d.collapse(o)), r.setEndPoint(e ? "StartToStart" :"EndToEnd", d), 
i.remove(a));
}
var r, a, s, l, c, u, d, h, m, f = e.dom.doc, p = f.body;
if (s = t.startContainer, l = t.startOffset, c = t.endContainer, u = t.endOffset, 
r = p.createTextRange(), s == c && 1 == s.nodeType) {
if (l == u && !s.hasChildNodes()) {
if (s.canHaveHTML) return d = s.previousSibling, d && !d.hasChildNodes() && i.isBlock(d) ? d.innerHTML = "&#xFEFF;" :d = null, 
s.innerHTML = "<span>&#xFEFF;</span><span>&#xFEFF;</span>", r.moveToElementText(s.lastChild), 
r.select(), i.doc.selection.clear(), s.innerHTML = "", void (d && (d.innerHTML = ""));
l = i.nodeIndex(s), s = s.parentNode;
}
if (l == u - 1) try {
if (m = s.childNodes[l], a = p.createControlRange(), a.addElement(m), a.select(), 
h = e.getRng(), h.item && m === h.item(0)) return;
} catch (g) {}
}
n(!0), n(), r.select();
}, this.getRangeAt = n;
}
return e;
}), r(R, [ d ], function(e) {
return {
BACKSPACE:8,
DELETE:46,
DOWN:40,
ENTER:13,
LEFT:37,
RIGHT:39,
SPACEBAR:32,
TAB:9,
UP:38,
modifierPressed:function(e) {
return e.shiftKey || e.ctrlKey || e.altKey;
},
metaKeyPressed:function(t) {
return e.mac ? t.metaKey :t.ctrlKey && !t.altKey;
}
};
}), r(A, [ R, u, d ], function(e, t, n) {
return function(r, i) {
function o(e) {
var t = i.settings.object_resizing;
return t === !1 || n.iOS ? !1 :("string" != typeof t && (t = "table,img,div"), "false" === e.getAttribute("data-mce-resize") ? !1 :i.dom.is(e, t));
}
function a(t) {
var n, r, o, a, s;
n = t.screenX - T, r = t.screenY - R, P = n * k[2] + D, O = r * k[3] + L, P = 5 > P ? 5 :P, 
O = 5 > O ? 5 :O, o = "IMG" == w.nodeName && i.settings.resize_img_proportional !== !1 ? !e.modifierPressed(t) :e.modifierPressed(t) || "IMG" == w.nodeName && k[2] * k[3] !== 0, 
o && (W(n) > W(r) ? (O = V(P * M), P = V(O / M)) :(P = V(O / M), O = V(P * M))), 
C.setStyles(_, {
width:P,
height:O
}), a = k.startPos.x + n, s = k.startPos.y + r, a = a > 0 ? a :0, s = s > 0 ? s :0, 
C.setStyles(N, {
left:a,
top:s,
display:"block"
}), N.innerHTML = P + " &times; " + O, k[2] < 0 && _.clientWidth <= P && C.setStyle(_, "left", A + (D - P)), 
k[3] < 0 && _.clientHeight <= O && C.setStyle(_, "top", B + (L - O)), n = U.scrollWidth - q, 
r = U.scrollHeight - $, n + r !== 0 && C.setStyles(N, {
left:a - n,
top:s - r
}), H || (i.fire("ObjectResizeStart", {
target:w,
width:D,
height:L
}), H = !0);
}
function s() {
function e(e, t) {
t && (w.style[e] || !i.schema.isValid(w.nodeName.toLowerCase(), e) ? C.setStyle(w, e, t) :C.setAttrib(w, e, t));
}
H = !1, e("width", P), e("height", O), C.unbind(I, "mousemove", a), C.unbind(I, "mouseup", s), 
F != I && (C.unbind(F, "mousemove", a), C.unbind(F, "mouseup", s)), C.remove(_), 
C.remove(N), z && "TABLE" != w.nodeName || l(w), i.fire("ObjectResized", {
target:w,
width:P,
height:O
}), i.nodeChanged();
}
function l(e, t, r) {
var l, u, d, f, p;
g(), l = C.getPos(e, U), A = l.x, B = l.y, p = e.getBoundingClientRect(), u = p.width || p.right - p.left, 
d = p.height || p.bottom - p.top, w != e && (m(), w = e, P = O = 0), f = i.fire("ObjectSelected", {
target:e
}), o(e) && !f.isDefaultPrevented() ? x(E, function(e, i) {
function o(t) {
T = t.screenX, R = t.screenY, D = w.clientWidth, L = w.clientHeight, M = L / D, 
k = e, e.startPos = C.getPos(e.elm, U), q = U.scrollWidth, $ = U.scrollHeight, _ = w.cloneNode(!0), 
C.addClass(_, "mce-clonedresizable"), C.setAttrib(_, "data-mce-bogus", "all"), _.contentEditable = !1, 
_.unSelectabe = !0, C.setStyles(_, {
left:A,
top:B,
margin:0
}), _.removeAttribute("data-mce-selected"), U.appendChild(_), C.bind(I, "mousemove", a), 
C.bind(I, "mouseup", s), F != I && (C.bind(F, "mousemove", a), C.bind(F, "mouseup", s)), 
N = C.add(U, "div", {
"class":"mce-resize-helper",
"data-mce-bogus":"all"
}, D + " &times; " + L);
}
var l, c;
return t ? void (i == t && o(r)) :(l = C.get("mceResizeHandle" + i), l ? C.show(l) :(c = U, 
l = C.add(c, "div", {
id:"mceResizeHandle" + i,
"data-mce-bogus":"all",
"class":"mce-resizehandle",
unselectable:!0,
style:"cursor:" + i + "-resize; margin:0; padding:0"
}), n.ie && (l.contentEditable = !1)), e.elm || (C.bind(l, "mousedown", function(e) {
e.stopImmediatePropagation(), e.preventDefault(), o(e);
}), e.elm = l), void C.setStyles(l, {
left:u * e[0] + A - l.offsetWidth / 2,
top:d * e[1] + B - l.offsetHeight / 2
}));
}) :c(), w.setAttribute("data-mce-selected", "1");
}
function c() {
var e, t;
g(), w && w.removeAttribute("data-mce-selected");
for (e in E) t = C.get("mceResizeHandle" + e), t && (C.unbind(t), C.remove(t));
}
function u(e) {
function t(e, t) {
if (e) do if (e === t) return !0; while (e = e.parentNode);
}
var n;
return x(C.select("img[data-mce-selected],hr[data-mce-selected]"), function(e) {
e.removeAttribute("data-mce-selected");
}), n = "mousedown" == e.type ? e.target :r.getNode(), n = C.getParent(n, z ? "table" :"table,img,hr"), 
t(n, U) && (v(), t(r.getStart(), n) && t(r.getEnd(), n) && (!z || n != r.getStart() && "IMG" !== r.getStart().nodeName)) ? void l(n) :void c();
}
function d(e, t, n) {
e && e.attachEvent && e.attachEvent("on" + t, n);
}
function f(e, t, n) {
e && e.detachEvent && e.detachEvent("on" + t, n);
}
function p(e) {
var n, r, o, a, s, c, u, t = e.srcElement;
n = t.getBoundingClientRect(), c = S.clientX - n.left, u = S.clientY - n.top;
for (r in E) if (o = E[r], a = t.offsetWidth * o[0], s = t.offsetHeight * o[1], 
W(a - c) < 8 && W(s - u) < 8) {
k = o;
break;
}
H = !0, i.getDoc().selection.empty(), l(t, r, S);
}
function h(e) {
var t = e.srcElement;
if (t != w) {
if (m(), 0 === t.id.indexOf("mceResizeHandle")) return void (e.returnValue = !1);
("IMG" == t.nodeName || "TABLE" == t.nodeName) && (c(), w = t, d(t, "resizestart", p));
}
}
function m() {
f(w, "resizestart", p);
}
function g() {
for (var e in E) {
var t = E[e];
t.elm && (C.unbind(t.elm), delete t.elm);
}
}
function v() {
try {
i.getDoc().execCommand("enableObjectResizing", !1, !1);
} catch (e) {}
}
function y(e) {
var t;
if (z) {
t = I.body.createControlRange();
try {
return t.addElement(e), t.select(), !0;
} catch (n) {}
}
}
function b() {
w = _ = null, z && (m(), f(U, "controlselect", h));
}
var w, _, N, E, k, S, T, R, A, B, D, L, M, H, P, O, q, $, C = i.dom, x = t.each, I = i.getDoc(), F = document, z = n.ie && n.ie < 11, W = Math.abs, V = Math.round, U = i.getBody();
E = {
n:[ .5, 0, 0, -1 ],
e:[ 1, .5, 1, 0 ],
s:[ .5, 1, 0, 1 ],
w:[ 0, .5, -1, 0 ],
nw:[ 0, 0, -1, -1 ],
ne:[ 1, 0, 1, -1 ],
se:[ 1, 1, 1, 1 ],
sw:[ 0, 1, -1, 1 ]
};
var j = ".mce-content-body";
return i.contentStyles.push(j + " div.mce-resizehandle {position: absolute;border: 1px solid black;background: #FFF;width: 5px;height: 5px;z-index: 10000}" + j + " .mce-resizehandle:hover {background: #000}" + j + " img[data-mce-selected], hr[data-mce-selected] {outline: 1px solid black;resize: none}" + j + " .mce-clonedresizable {position: absolute;" + (n.gecko ? "" :"outline: 1px dashed black;") + "opacity: .5;filter: alpha(opacity=50);z-index: 10000}" + j + " .mce-resize-helper {background-color: #555;background-color: rgba(0,0,0,0.75);border-radius: 3px;border: 1px;color: white;display: none;font-family: sans-serif;font-size: 12px;white-space: nowrap;line-height: 14px;margin: 5px 10px;padding: 5px;position: absolute;z-index: 10001}"), 
i.on("init", function() {
z ? (i.on("ObjectResized", function(e) {
"TABLE" != e.target.nodeName && (c(), y(e.target));
}), d(U, "controlselect", h), i.on("mousedown", function(e) {
S = e;
})) :(v(), n.ie >= 11 && (i.on("mouseup", function(e) {
var t = e.target.nodeName;
/^(TABLE|IMG|HR)$/.test(t) && (i.selection.select(e.target, "TABLE" == t), i.nodeChanged());
}), i.dom.bind(U, "mscontrolselect", function(e) {
/^(TABLE|IMG|HR)$/.test(e.target.nodeName) && (e.preventDefault(), "IMG" == e.target.tagName && window.setTimeout(function() {
i.selection.select(e.target);
}, 0));
}))), i.on("nodechange mousedown mouseup ResizeEditor", u), i.on("keydown keyup", function(e) {
w && "TABLE" == w.nodeName && u(e);
}), i.on("hide", c);
}), i.on("remove", g), {
isResizable:o,
showResizeRect:l,
hideResizeRect:c,
updateResizeRect:u,
controlSelect:y,
destroy:b
};
};
}), r(B, [ u, h ], function(e, t) {
function n(e, t) {
var n = e.childNodes;
return t--, t > n.length - 1 ? t = n.length - 1 :0 > t && (t = 0), n[t] || e;
}
function r(e) {
this.walk = function(t, r) {
function o(e) {
var t;
return t = e[0], 3 === t.nodeType && t === c && u >= t.nodeValue.length && e.splice(0, 1), 
t = e[e.length - 1], 0 === f && e.length > 0 && t === d && 3 === t.nodeType && e.splice(e.length - 1, 1), 
e;
}
function a(e, t, n) {
for (var r = []; e && e != n; e = e[t]) r.push(e);
return r;
}
function s(e, t) {
do {
if (e.parentNode == t) return e;
e = e.parentNode;
} while (e);
}
function l(e, t, n) {
var i = n ? "nextSibling" :"previousSibling";
for (g = e, v = g.parentNode; g && g != t; g = v) v = g.parentNode, y = a(g == e ? g :g[i], i), 
y.length && (n || y.reverse(), r(o(y)));
}
var p, h, m, g, v, y, b, c = t.startContainer, u = t.startOffset, d = t.endContainer, f = t.endOffset;
if (b = e.select("td.mce-item-selected,th.mce-item-selected"), b.length > 0) return void i(b, function(e) {
r([ e ]);
});
if (1 == c.nodeType && c.hasChildNodes() && (c = c.childNodes[u]), 1 == d.nodeType && d.hasChildNodes() && (d = n(d, f)), 
c == d) return r(o([ c ]));
for (p = e.findCommonAncestor(c, d), g = c; g; g = g.parentNode) {
if (g === d) return l(c, p, !0);
if (g === p) break;
}
for (g = d; g; g = g.parentNode) {
if (g === c) return l(d, p);
if (g === p) break;
}
h = s(c, p) || c, m = s(d, p) || d, l(c, h, !0), y = a(h == c ? h :h.nextSibling, "nextSibling", m == d ? m.nextSibling :m), 
y.length && r(o(y)), l(d, m);
}, this.split = function(e) {
function t(e, t) {
return e.splitText(t);
}
var n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset;
return n == i && 3 == n.nodeType ? r > 0 && r < n.nodeValue.length && (i = t(n, r), 
n = i.previousSibling, o > r ? (o -= r, n = i = t(i, o).previousSibling, o = i.nodeValue.length, 
r = 0) :o = 0) :(3 == n.nodeType && r > 0 && r < n.nodeValue.length && (n = t(n, r), 
r = 0), 3 == i.nodeType && o > 0 && o < i.nodeValue.length && (i = t(i, o).previousSibling, 
o = i.nodeValue.length)), {
startContainer:n,
startOffset:r,
endContainer:i,
endOffset:o
};
}, this.normalize = function(n) {
function r(r) {
function a(n, r) {
for (var i = new t(n, e.getParent(n.parentNode, e.isBlock) || f); n = i[r ? "prev" :"next"](); ) if ("BR" === n.nodeName) return !0;
}
function s(e, t) {
return e.previousSibling && e.previousSibling.nodeName == t;
}
function l(n, r) {
var a, s, l;
if (r = r || c, l = e.getParent(r.parentNode, e.isBlock) || f, n && "BR" == r.nodeName && g && e.isEmpty(l)) return c = r.parentNode, 
u = e.nodeIndex(r), void (i = !0);
for (a = new t(r, l); p = a[n ? "prev" :"next"](); ) {
if ("false" === e.getContentEditableParent(p)) return;
if (3 === p.nodeType && p.nodeValue.length > 0) return c = p, u = n ? p.nodeValue.length :0, 
void (i = !0);
if (e.isBlock(p) || h[p.nodeName.toLowerCase()]) return;
s = p;
}
o && s && (c = s, i = !0, u = 0);
}
var c, u, d, p, h, m, g, f = e.getRoot();
if (c = n[(r ? "start" :"end") + "Container"], u = n[(r ? "start" :"end") + "Offset"], 
g = 1 == c.nodeType && u === c.childNodes.length, h = e.schema.getNonEmptyElements(), 
m = r, 1 == c.nodeType && u > c.childNodes.length - 1 && (m = !1), 9 === c.nodeType && (c = e.getRoot(), 
u = 0), c === f) {
if (m && (p = c.childNodes[u > 0 ? u - 1 :0], p && (h[p.nodeName] || "TABLE" == p.nodeName))) return;
if (c.hasChildNodes() && (u = Math.min(!m && u > 0 ? u - 1 :u, c.childNodes.length - 1), 
c = c.childNodes[u], u = 0, c.hasChildNodes() && !/TABLE/.test(c.nodeName))) {
p = c, d = new t(c, f);
do {
if (3 === p.nodeType && p.nodeValue.length > 0) {
u = m ? 0 :p.nodeValue.length, c = p, i = !0;
break;
}
if (h[p.nodeName.toLowerCase()]) {
u = e.nodeIndex(p), c = p.parentNode, "IMG" != p.nodeName || m || u++, i = !0;
break;
}
} while (p = m ? d.next() :d.prev());
}
}
o && (3 === c.nodeType && 0 === u && l(!0), 1 === c.nodeType && (p = c.childNodes[u], 
p || (p = c.childNodes[u - 1]), !p || "BR" !== p.nodeName || s(p, "A") || a(p) || a(p, !0) || l(!0, p))), 
m && !o && 3 === c.nodeType && u === c.nodeValue.length && l(!1), i && n["set" + (r ? "Start" :"End")](c, u);
}
var i, o;
return o = n.collapsed, r(!0), o || r(), i && o && n.collapse(!0), i;
};
}
var i = e.each;
return r.compareRanges = function(e, t) {
if (e && t) {
if (!e.item && !e.duplicate) return e.startContainer == t.startContainer && e.startOffset == t.startOffset;
if (e.item && t.item && e.item(0) === t.item(0)) return !0;
if (e.isEqual && t.isEqual && t.isEqual(e)) return !0;
}
return !1;
}, r;
}), r(D, [ d, u ], function(e, t) {
function n(n) {
var r = n.dom;
this.getBookmark = function(e, i) {
function o(e, n) {
var i = 0;
return t.each(r.select(e), function(e, t) {
e == n && (i = t);
}), i;
}
function a(e) {
function t(t) {
var n, r, i, o = t ? "start" :"end";
n = e[o + "Container"], r = e[o + "Offset"], 1 == n.nodeType && "TR" == n.nodeName && (i = n.childNodes, 
n = i[Math.min(t ? r :r - 1, i.length - 1)], n && (r = t ? 0 :n.childNodes.length, 
e["set" + (t ? "Start" :"End")](n, r)));
}
return t(!0), t(), e;
}
function s() {
function e(e, t) {
var l, c, n = e[t ? "startContainer" :"endContainer"], a = e[t ? "startOffset" :"endOffset"], s = [], u = 0;
if (3 == n.nodeType) {
if (i) for (l = n.previousSibling; l && 3 == l.nodeType; l = l.previousSibling) a += l.nodeValue.length;
s.push(a);
} else c = n.childNodes, a >= c.length && c.length && (u = 1, a = Math.max(0, c.length - 1)), 
s.push(r.nodeIndex(c[a], i) + u);
for (;n && n != o; n = n.parentNode) s.push(r.nodeIndex(n, i));
return s;
}
var t = n.getRng(!0), o = r.getRoot(), a = {};
return a.start = e(t, !0), n.isCollapsed() || (a.end = e(t)), a;
}
var l, c, u, d, f, p, m, h = "&#xFEFF;";
if (2 == e) return p = n.getNode(), f = p ? p.nodeName :null, "IMG" == f ? {
name:f,
index:o(f, p)
} :n.tridentSel ? n.tridentSel.getBookmark(e) :s();
if (e) return {
rng:n.getRng()
};
if (l = n.getRng(), u = r.uniqueId(), d = n.isCollapsed(), m = "overflow:hidden;line-height:0px", 
l.duplicate || l.item) {
if (l.item) return p = l.item(0), f = p.nodeName, {
name:f,
index:o(f, p)
};
c = l.duplicate();
try {
l.collapse(), l.pasteHTML('<span data-mce-type="bookmark" id="' + u + '_start" style="' + m + '">' + h + "</span>"), 
d || (c.collapse(!1), l.moveToElementText(c.parentElement()), 0 === l.compareEndPoints("StartToEnd", c) && c.move("character", -1), 
c.pasteHTML('<span data-mce-type="bookmark" id="' + u + '_end" style="' + m + '">' + h + "</span>"));
} catch (g) {
return null;
}
} else {
if (p = n.getNode(), f = p.nodeName, "IMG" == f) return {
name:f,
index:o(f, p)
};
c = a(l.cloneRange()), d || (c.collapse(!1), c.insertNode(r.create("span", {
"data-mce-type":"bookmark",
id:u + "_end",
style:m
}, h))), l = a(l), l.collapse(!0), l.insertNode(r.create("span", {
"data-mce-type":"bookmark",
id:u + "_start",
style:m
}, h));
}
return n.moveToBookmark({
id:u,
keep:1
}), {
id:u
};
}, this.moveToBookmark = function(i) {
function o(e) {
var n, r, o, a, t = i[e ? "start" :"end"];
if (t) {
for (o = t[0], r = c, n = t.length - 1; n >= 1; n--) {
if (a = r.childNodes, t[n] > a.length - 1) return;
r = a[t[n]];
}
3 === r.nodeType && (o = Math.min(t[0], r.nodeValue.length)), 1 === r.nodeType && (o = Math.min(t[0], r.childNodes.length)), 
e ? l.setStart(r, o) :l.setEnd(r, o);
}
return !0;
}
function a(n) {
var a, s, l, c, o = r.get(i.id + "_" + n), h = i.keep;
if (o && (a = o.parentNode, "start" == n ? (h ? (a = o.firstChild, s = 1) :s = r.nodeIndex(o), 
u = d = a, f = p = s) :(h ? (a = o.firstChild, s = 1) :s = r.nodeIndex(o), d = a, 
p = s), !h)) {
for (c = o.previousSibling, l = o.nextSibling, t.each(t.grep(o.childNodes), function(e) {
3 == e.nodeType && (e.nodeValue = e.nodeValue.replace(/\uFEFF/g, ""));
}); o = r.get(i.id + "_" + n); ) r.remove(o, 1);
c && l && c.nodeType == l.nodeType && 3 == c.nodeType && !e.opera && (s = c.nodeValue.length, 
c.appendData(l.nodeValue), r.remove(l), "start" == n ? (u = d = c, f = p = s) :(d = c, 
p = s));
}
}
function s(t) {
return !r.isBlock(t) || t.innerHTML || e.ie || (t.innerHTML = '<br data-mce-bogus="1" />'), 
t;
}
var l, c, u, d, f, p;
if (i) if (i.start) {
if (l = r.createRng(), c = r.getRoot(), n.tridentSel) return n.tridentSel.moveToBookmark(i);
o(!0) && o() && n.setRng(l);
} else i.id ? (a("start"), a("end"), u && (l = r.createRng(), l.setStart(s(u), f), 
l.setEnd(s(d), p), n.setRng(l))) :i.name ? n.select(r.select(i.name)[i.index]) :i.rng && n.setRng(i.rng);
};
}
return n.isBookmarkNode = function(e) {
return e && "SPAN" === e.tagName && "bookmark" === e.getAttribute("data-mce-type");
}, n;
}), r(L, [ h, T, A, B, D, d, u ], function(e, n, r, i, o, a, s) {
function l(e, t, i, a) {
var s = this;
s.dom = e, s.win = t, s.serializer = i, s.editor = a, s.bookmarkManager = new o(s), 
s.controlSelection = new r(s, a), s.win.getSelection || (s.tridentSel = new n(s));
}
var c = s.each, u = s.trim, d = a.ie;
return l.prototype = {
setCursorLocation:function(e, t) {
var n = this, r = n.dom.createRng();
e ? (r.setStart(e, t), r.setEnd(e, t), n.setRng(r), n.collapse(!1)) :(n._moveEndPoint(r, n.editor.getBody(), !0), 
n.setRng(r));
},
getContent:function(e) {
var a, s, l, n = this, r = n.getRng(), i = n.dom.create("body"), o = n.getSel();
return e = e || {}, a = s = "", e.get = !0, e.format = e.format || "html", e.selection = !0, 
n.editor.fire("BeforeGetContent", e), "text" == e.format ? n.isCollapsed() ? "" :r.text || (o.toString ? o.toString() :"") :(r.cloneContents ? (l = r.cloneContents(), 
l && i.appendChild(l)) :r.item !== t || r.htmlText !== t ? (i.innerHTML = "<br>" + (r.item ? r.item(0).outerHTML :r.htmlText), 
i.removeChild(i.firstChild)) :i.innerHTML = r.toString(), /^\s/.test(i.innerHTML) && (a = " "), 
/\s+$/.test(i.innerHTML) && (s = " "), e.getInner = !0, e.content = n.isCollapsed() ? "" :a + n.serializer.serialize(i, e) + s, 
n.editor.fire("GetContent", e), e.content);
},
setContent:function(e, t) {
var i, a, s, n = this, r = n.getRng(), o = n.win.document;
if (t = t || {
format:"html"
}, t.set = !0, t.selection = !0, e = t.content = e, t.no_events || n.editor.fire("BeforeSetContent", t), 
e = t.content, r.insertNode) {
e += '<span id="__caret">_</span>', r.startContainer == o && r.endContainer == o ? o.body.innerHTML = e :(r.deleteContents(), 
0 === o.body.childNodes.length ? o.body.innerHTML = e :r.createContextualFragment ? r.insertNode(r.createContextualFragment(e)) :(a = o.createDocumentFragment(), 
s = o.createElement("div"), a.appendChild(s), s.outerHTML = e, r.insertNode(a))), 
i = n.dom.get("__caret"), r = o.createRange(), r.setStartBefore(i), r.setEndBefore(i), 
n.setRng(r), n.dom.remove("__caret");
try {
n.setRng(r);
} catch (l) {}
} else r.item && (o.execCommand("Delete", !1, null), r = n.getRng()), /^\s+/.test(e) ? (r.pasteHTML('<span id="__mce_tmp">_</span>' + e), 
n.dom.remove("__mce_tmp")) :r.pasteHTML(e);
t.no_events || n.editor.fire("SetContent", t);
},
getStart:function() {
var n, r, i, o, e = this, t = e.getRng();
if (t.duplicate || t.item) {
if (t.item) return t.item(0);
for (i = t.duplicate(), i.collapse(1), n = i.parentElement(), n.ownerDocument !== e.dom.doc && (n = e.dom.getRoot()), 
r = o = t.parentElement(); o = o.parentNode; ) if (o == n) {
n = r;
break;
}
return n;
}
return n = t.startContainer, 1 == n.nodeType && n.hasChildNodes() && (n = n.childNodes[Math.min(n.childNodes.length - 1, t.startOffset)]), 
n && 3 == n.nodeType ? n.parentNode :n;
},
getEnd:function() {
var n, r, e = this, t = e.getRng();
return t.duplicate || t.item ? t.item ? t.item(0) :(t = t.duplicate(), t.collapse(0), 
n = t.parentElement(), n.ownerDocument !== e.dom.doc && (n = e.dom.getRoot()), n && "BODY" == n.nodeName ? n.lastChild || n :n) :(n = t.endContainer, 
r = t.endOffset, 1 == n.nodeType && n.hasChildNodes() && (n = n.childNodes[r > 0 ? r - 1 :r]), 
n && 3 == n.nodeType ? n.parentNode :n);
},
getBookmark:function(e, t) {
return this.bookmarkManager.getBookmark(e, t);
},
moveToBookmark:function(e) {
return this.bookmarkManager.moveToBookmark(e);
},
select:function(e, t) {
var o, n = this, r = n.dom, i = r.createRng();
if (n.lastFocusBookmark = null, e) {
if (!t && n.controlSelection.controlSelect(e)) return;
o = r.nodeIndex(e), i.setStart(e.parentNode, o), i.setEnd(e.parentNode, o + 1), 
t && (n._moveEndPoint(i, e, !0), n._moveEndPoint(i, e)), n.setRng(i);
}
return e;
},
isCollapsed:function() {
var e = this, t = e.getRng(), n = e.getSel();
return !t || t.item ? !1 :t.compareEndPoints ? 0 === t.compareEndPoints("StartToEnd", t) :!n || t.collapsed;
},
collapse:function(e) {
var r, t = this, n = t.getRng();
n.item && (r = n.item(0), n = t.win.document.body.createTextRange(), n.moveToElementText(r)), 
n.collapse(!!e), t.setRng(n);
},
getSel:function() {
var e = this.win;
return e.getSelection ? e.getSelection() :e.document.selection;
},
getRng:function(e) {
function t(e, t, n) {
try {
return t.compareBoundaryPoints(e, n);
} catch (r) {
return -1;
}
}
var r, i, o, s, n = this, a = n.win.document;
if (!e && n.lastFocusBookmark) {
var l = n.lastFocusBookmark;
return l.startContainer ? (i = a.createRange(), i.setStart(l.startContainer, l.startOffset), 
i.setEnd(l.endContainer, l.endOffset)) :i = l, i;
}
if (e && n.tridentSel) return n.tridentSel.getRangeAt(0);
try {
(r = n.getSel()) && (i = r.rangeCount > 0 ? r.getRangeAt(0) :r.createRange ? r.createRange() :a.createRange());
} catch (c) {}
if (d && i && i.setStart && a.selection) {
try {
s = a.selection.createRange();
} catch (c) {}
s && s.item && (o = s.item(0), i = a.createRange(), i.setStartBefore(o), i.setEndAfter(o));
}
return i || (i = a.createRange ? a.createRange() :a.body.createTextRange()), i.setStart && 9 === i.startContainer.nodeType && i.collapsed && (o = n.dom.getRoot(), 
i.setStart(o, 0), i.setEnd(o, 0)), n.selectedRange && n.explicitRange && (0 === t(i.START_TO_START, i, n.selectedRange) && 0 === t(i.END_TO_END, i, n.selectedRange) ? i = n.explicitRange :(n.selectedRange = null, 
n.explicitRange = null)), i;
},
setRng:function(e, t) {
var r, n = this;
if (e.select) try {
e.select();
} catch (i) {} else if (n.tridentSel) {
if (e.cloneRange) try {
return void n.tridentSel.addRange(e);
} catch (i) {}
} else if (r = n.getSel()) {
n.explicitRange = e;
try {
r.removeAllRanges(), r.addRange(e);
} catch (i) {}
t === !1 && r.extend && (r.collapse(e.endContainer, e.endOffset), r.extend(e.startContainer, e.startOffset)), 
n.selectedRange = r.rangeCount > 0 ? r.getRangeAt(0) :null;
}
},
setNode:function(e) {
var t = this;
return t.setContent(t.dom.getOuterHTML(e)), e;
},
getNode:function() {
function e(e, t) {
for (var n = e; e && 3 === e.nodeType && 0 === e.length; ) e = t ? e.nextSibling :e.previousSibling;
return e || n;
}
var r, t = this, n = t.getRng(), i = n.startContainer, o = n.endContainer, a = n.startOffset, s = n.endOffset, l = t.dom.getRoot();
return n ? n.setStart ? (r = n.commonAncestorContainer, !n.collapsed && (i == o && 2 > s - a && i.hasChildNodes() && (r = i.childNodes[a]), 
3 === i.nodeType && 3 === o.nodeType && (i = i.length === a ? e(i.nextSibling, !0) :i.parentNode, 
o = 0 === s ? e(o.previousSibling, !1) :o.parentNode, i && i === o)) ? i :r && 3 == r.nodeType ? r.parentNode :r) :(r = n.item ? n.item(0) :n.parentElement(), 
r.ownerDocument !== t.win.document && (r = l), r) :l;
},
getSelectedBlocks:function(t, n) {
var o, a, r = this, i = r.dom, s = [];
if (a = i.getRoot(), t = i.getParent(t || r.getStart(), i.isBlock), n = i.getParent(n || r.getEnd(), i.isBlock), 
t && t != a && s.push(t), t && n && t != n) {
o = t;
for (var l = new e(t, a); (o = l.next()) && o != n; ) i.isBlock(o) && s.push(o);
}
return n && t != n && n != a && s.push(n), s;
},
isForward:function() {
var n, r, e = this.dom, t = this.getSel();
return t && t.anchorNode && t.focusNode ? (n = e.createRng(), n.setStart(t.anchorNode, t.anchorOffset), 
n.collapse(!0), r = e.createRng(), r.setStart(t.focusNode, t.focusOffset), r.collapse(!0), 
n.compareBoundaryPoints(n.START_TO_START, r) <= 0) :!0;
},
normalize:function() {
var e = this, t = e.getRng();
return !d && new i(e.dom).normalize(t) && e.setRng(t, e.isForward()), t;
},
selectorChanged:function(e, t) {
var r, n = this;
return n.selectorChangedData || (n.selectorChangedData = {}, r = {}, n.editor.on("NodeChange", function(e) {
var t = e.element, i = n.dom, o = i.getParents(t, null, i.getRoot()), a = {};
c(n.selectorChangedData, function(e, t) {
c(o, function(n) {
return i.is(n, t) ? (r[t] || (c(e, function(e) {
e(!0, {
node:n,
selector:t,
parents:o
});
}), r[t] = e), a[t] = e, !1) :void 0;
});
}), c(r, function(e, n) {
a[n] || (delete r[n], c(e, function(e) {
e(!1, {
node:t,
selector:n,
parents:o
});
}));
});
})), n.selectorChangedData[e] || (n.selectorChangedData[e] = []), n.selectorChangedData[e].push(t), 
n;
},
getScrollContainer:function() {
for (var e, t = this.dom.getRoot(); t && "BODY" != t.nodeName; ) {
if (t.scrollHeight > t.clientHeight) {
e = t;
break;
}
t = t.parentNode;
}
return e;
},
scrollIntoView:function(e) {
function t(e) {
for (var t = 0, n = 0, r = e; r && r.nodeType; ) t += r.offsetLeft || 0, n += r.offsetTop || 0, 
r = r.offsetParent;
return {
x:t,
y:n
};
}
var n, r, s, l, i = this, o = i.dom, a = o.getRoot();
if ("BODY" != a.nodeName) {
var c = i.getScrollContainer();
if (c) return n = t(e).y - t(c).y, l = c.clientHeight, s = c.scrollTop, void ((s > n || n + 25 > s + l) && (c.scrollTop = s > n ? n :n - l + 25));
}
r = o.getViewPort(i.editor.getWin()), n = o.getPos(e).y, s = r.y, l = r.h, (n < r.y || n + 25 > s + l) && i.editor.getWin().scrollTo(0, s > n ? n :n - l + 25);
},
_moveEndPoint:function(t, n, r) {
var i = n, o = new e(n, i), s = this.dom.schema.getNonEmptyElements();
do {
if (3 == n.nodeType && 0 !== u(n.nodeValue).length) return void (r ? t.setStart(n, 0) :t.setEnd(n, n.nodeValue.length));
if (s[n.nodeName]) return void (r ? t.setStartBefore(n) :"BR" == n.nodeName ? t.setEndBefore(n) :t.setEndAfter(n));
if (a.ie && a.ie < 11 && this.dom.isBlock(n) && this.dom.isEmpty(n)) return void (r ? t.setStart(n, 0) :t.setEnd(n, 0));
} while (n = r ? o.next() :o.prev());
"BODY" == i.nodeName && (r ? t.setStart(i, 0) :t.setEnd(i, i.childNodes.length));
},
destroy:function() {
this.win = null, this.controlSelection.destroy();
}
}, l;
}), r(M, [ D, u ], function(e, t) {
function n(t) {
this.compare = function(n, i) {
function o(e) {
var n = {};
return r(t.getAttribs(e), function(r) {
var i = r.nodeName.toLowerCase();
0 !== i.indexOf("_") && "style" !== i && "data-mce-style" !== i && (n[i] = t.getAttrib(e, i));
}), n;
}
function a(e, t) {
var n, r;
for (r in e) if (e.hasOwnProperty(r)) {
if (n = t[r], "undefined" == typeof n) return !1;
if (e[r] != n) return !1;
delete t[r];
}
for (r in t) if (t.hasOwnProperty(r)) return !1;
return !0;
}
return n.nodeName != i.nodeName ? !1 :a(o(n), o(i)) && a(t.parseStyle(t.getAttrib(n, "style")), t.parseStyle(t.getAttrib(i, "style"))) ? !e.isBookmarkNode(n) && !e.isBookmarkNode(i) :!1;
};
}
var r = t.each;
return n;
}), r(H, [ u ], function(e) {
function t(e, t) {
function r(e) {
return e.replace(/%(\w+)/g, "");
}
var i, o, l, c, a = e.dom, s = "";
if (c = e.settings.preview_styles, c === !1) return "";
if (c || (c = "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"), 
"string" == typeof t) {
if (t = e.formatter.get(t), !t) return;
t = t[0];
}
return i = t.block || t.inline || "span", o = a.create(i), n(t.styles, function(e, t) {
e = r(e), e && a.setStyle(o, t, e);
}), n(t.attributes, function(e, t) {
e = r(e), e && a.setAttrib(o, t, e);
}), n(t.classes, function(e) {
e = r(e), a.hasClass(o, e) || a.addClass(o, e);
}), e.fire("PreviewFormats"), a.setStyles(o, {
position:"absolute",
left:-65535
}), e.getBody().appendChild(o), l = a.getStyle(e.getBody(), "fontSize", !0), l = /px$/.test(l) ? parseInt(l, 10) :0, 
n(c.split(" "), function(t) {
var n = a.getStyle(o, t, !0);
if (!("background-color" == t && /transparent|rgba\s*\([^)]+,\s*0\)/.test(n) && (n = a.getStyle(e.getBody(), t, !0), 
"#ffffff" == a.toHex(n).toLowerCase()) || "color" == t && "#000000" == a.toHex(n).toLowerCase())) {
if ("font-size" == t && /em|%$/.test(n)) {
if (0 === l) return;
n = parseFloat(n, 10) / (/%$/.test(n) ? 100 :1), n = n * l + "px";
}
"border" == t && n && (s += "padding:0 2px;"), s += t + ":" + n + ";";
}
}), e.fire("AfterPreviewFormats"), a.remove(o), s;
}
var n = e.each;
return {
getCssText:t
};
}), r(P, [ h, B, D, M, u, H ], function(e, t, n, r, i, o) {
return function(a) {
function s(e) {
return e.nodeType && (e = e.nodeName), !!a.schema.getTextBlockElements()[e.toLowerCase()];
}
function l(e, t) {
return W.getParents(e, t, W.getRoot());
}
function c(e) {
return 1 === e.nodeType && "_mce_caret" === e.id;
}
function u() {
p({
valigntop:[ {
selector:"td,th",
styles:{
verticalAlign:"top"
}
} ],
valignmiddle:[ {
selector:"td,th",
styles:{
verticalAlign:"middle"
}
} ],
valignbottom:[ {
selector:"td,th",
styles:{
verticalAlign:"bottom"
}
} ],
alignleft:[ {
selector:"figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
styles:{
textAlign:"left"
},
defaultBlock:"div"
}, {
selector:"img,table",
collapsed:!1,
styles:{
"float":"left"
}
} ],
aligncenter:[ {
selector:"figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
styles:{
textAlign:"center"
},
defaultBlock:"div"
}, {
selector:"img",
collapsed:!1,
styles:{
display:"block",
marginLeft:"auto",
marginRight:"auto"
}
}, {
selector:"table",
collapsed:!1,
styles:{
marginLeft:"auto",
marginRight:"auto"
}
} ],
alignright:[ {
selector:"figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
styles:{
textAlign:"right"
},
defaultBlock:"div"
}, {
selector:"img,table",
collapsed:!1,
styles:{
"float":"right"
}
} ],
alignjustify:[ {
selector:"figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li",
styles:{
textAlign:"justify"
},
defaultBlock:"div"
} ],
bold:[ {
inline:"strong",
remove:"all"
}, {
inline:"span",
styles:{
fontWeight:"bold"
}
}, {
inline:"b",
remove:"all"
} ],
italic:[ {
inline:"em",
remove:"all"
}, {
inline:"span",
styles:{
fontStyle:"italic"
}
}, {
inline:"i",
remove:"all"
} ],
underline:[ {
inline:"span",
styles:{
textDecoration:"underline"
},
exact:!0
}, {
inline:"u",
remove:"all"
} ],
strikethrough:[ {
inline:"span",
styles:{
textDecoration:"line-through"
},
exact:!0
}, {
inline:"strike",
remove:"all"
} ],
forecolor:{
inline:"span",
styles:{
color:"%value"
},
wrap_links:!1,
remove_similar:!0
},
hilitecolor:{
inline:"span",
styles:{
backgroundColor:"%value"
},
wrap_links:!1,
remove_similar:!0
},
fontname:{
inline:"span",
styles:{
fontFamily:"%value"
}
},
fontsize:{
inline:"span",
styles:{
fontSize:"%value"
}
},
fontsize_class:{
inline:"span",
attributes:{
"class":"%value"
}
},
blockquote:{
block:"blockquote",
wrapper:1,
remove:"all"
},
subscript:{
inline:"sub"
},
superscript:{
inline:"sup"
},
code:{
inline:"code"
},
link:{
inline:"a",
selector:"a",
remove:"all",
split:!0,
deep:!0,
onmatch:function() {
return !0;
},
onformat:function(e, t, n) {
it(n, function(t, n) {
W.setAttrib(e, n, t);
});
}
},
removeformat:[ {
selector:"b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q",
remove:"all",
split:!0,
expand:!1,
block_expand:!0,
deep:!0
}, {
selector:"span",
attributes:[ "style", "class" ],
remove:"empty",
split:!0,
expand:!1,
deep:!0
}, {
selector:"*",
attributes:[ "style", "class" ],
split:!1,
expand:!1,
deep:!0
} ]
}), it("p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp".split(/\s/), function(e) {
p(e, {
block:e,
remove:"all"
});
}), p(a.settings.formats);
}
function d() {
a.addShortcut("ctrl+b", "bold_desc", "Bold"), a.addShortcut("ctrl+i", "italic_desc", "Italic"), 
a.addShortcut("ctrl+u", "underline_desc", "Underline");
for (var e = 1; 6 >= e; e++) a.addShortcut("ctrl+" + e, "", [ "FormatBlock", !1, "h" + e ]);
a.addShortcut("ctrl+7", "", [ "FormatBlock", !1, "p" ]), a.addShortcut("ctrl+8", "", [ "FormatBlock", !1, "div" ]), 
a.addShortcut("ctrl+9", "", [ "FormatBlock", !1, "address" ]);
}
function f(e) {
return e ? z[e] :z;
}
function p(e, t) {
e && ("string" != typeof e ? it(e, function(e, t) {
p(t, e);
}) :(t = t.length ? t :[ t ], it(t, function(e) {
e.deep === Z && (e.deep = !e.selector), e.split === Z && (e.split = !e.selector || e.inline), 
e.remove === Z && e.selector && !e.inline && (e.remove = "none"), e.selector && e.inline && (e.mixed = !0, 
e.block_expand = !0), "string" == typeof e.classes && (e.classes = e.classes.split(/\s+/));
}), z[e] = t));
}
function h(e) {
var t;
return a.dom.getParent(e, function(e) {
return t = a.dom.getStyle(e, "text-decoration"), t && "none" !== t;
}), t;
}
function m(e) {
var t;
1 === e.nodeType && e.parentNode && 1 === e.parentNode.nodeType && (t = h(e.parentNode), 
a.dom.getStyle(e, "color") && t ? a.dom.setStyle(e, "text-decoration", t) :a.dom.getStyle(e, "textdecoration") === t && a.dom.setStyle(e, "text-decoration", null));
}
function g(t, n, r) {
function i(e, t) {
if (t = t || p, e) {
if (t.onformat && t.onformat(e, t, n, r), it(t.styles, function(t, r) {
W.setStyle(e, r, R(t, n));
}), t.styles) {
var i = W.getAttrib(e, "style");
i && e.setAttribute("data-mce-style", i);
}
it(t.attributes, function(t, r) {
W.setAttrib(e, r, R(t, n));
}), it(t.classes, function(t) {
t = R(t, n), W.hasClass(e, t) || W.addClass(e, t);
});
}
}
function o() {
function t(t, n) {
var i = new e(n);
for (r = i.current(); r; r = i.prev()) if (r.childNodes.length > 1 || r == t || "BR" == r.tagName) return r;
}
var n = a.selection.getRng(), i = n.startContainer, o = n.endContainer;
if (i != o && 0 === n.endOffset) {
var s = t(i, o), l = 3 == s.nodeType ? s.length :s.childNodes.length;
n.setEnd(s, l);
}
return n;
}
function l(e, t, n, r, i) {
var s, u, o = [], a = -1, l = -1, c = -1;
return it(e.childNodes, function(e, t) {
return "UL" === e.nodeName || "OL" === e.nodeName ? (a = t, s = e, !1) :void 0;
}), it(e.childNodes, function(e, n) {
rt(e) && (e.id == t.id + "_start" ? l = n :e.id == t.id + "_end" && (c = n));
}), 0 >= a || a > l && c > a ? (it(ot(e.childNodes), i), 0) :(u = W.clone(n, X), 
it(ot(e.childNodes), function(e, t) {
(a > l && a > t || l > a && t > a) && (o.push(e), e.parentNode.removeChild(e));
}), a > l ? e.insertBefore(u, s) :l > a && e.insertBefore(u, s.nextSibling), r.push(u), 
it(o, function(e) {
u.appendChild(e);
}), u);
}
function u(e, r, o) {
var u, f, a = [], h = !0;
u = p.inline || p.block, f = W.create(u), i(f), U.walk(e, function(e) {
function m(e) {
var v, C, x, w, _;
return _ = h, v = e.nodeName.toLowerCase(), C = e.parentNode.nodeName.toLowerCase(), 
1 === e.nodeType && et(e) && (_ = h, h = "true" === et(e), w = !0), k(v, "br") ? (g = 0, 
void (p.block && W.remove(e))) :p.wrapper && b(e, t, n) ? void (g = 0) :h && !w && p.block && !p.wrapper && s(v) && q(C, u) ? (e = W.rename(e, u), 
i(e), a.push(e), void (g = 0)) :p.selector && (it(d, function(t) {
"collapsed" in t && t.collapsed !== y || W.is(e, t.selector) && !c(e) && (i(e, t), 
x = !0);
}), !p.inline || x) ? void (g = 0) :void (!h || w || !q(u, v) || !q(C, u) || !o && 3 === e.nodeType && 1 === e.nodeValue.length && 65279 === e.nodeValue.charCodeAt(0) || c(e) || p.inline && $(e) ? "li" == v && r ? g = l(e, r, f, a, m) :(g = 0, 
it(ot(e.childNodes), m), w && (h = _), g = 0) :(g || (g = W.clone(f, X), e.parentNode.insertBefore(g, e), 
a.push(g)), g.appendChild(e)));
}
var g;
it(e, m);
}), p.wrap_links === !1 && it(a, function(e) {
function t(e) {
var n, r, i;
if ("A" === e.nodeName) {
for (r = W.clone(f, X), a.push(r), i = ot(e.childNodes), n = 0; n < i.length; n++) r.appendChild(i[n]);
e.appendChild(r);
}
it(ot(e.childNodes), t);
}
t(e);
}), it(a, function(e) {
function r(e) {
var t = 0;
return it(e.childNodes, function(e) {
A(e) || rt(e) || t++;
}), t;
}
function o(e) {
var t, n;
return it(e.childNodes, function(e) {
return 1 != e.nodeType || rt(e) || c(e) ? void 0 :(t = e, X);
}), t && !rt(t) && E(t, p) && (n = W.clone(t, X), i(n), W.replace(n, e, J), W.remove(t, 1)), 
n || e;
}
var s;
if (s = r(e), (a.length > 1 || !$(e)) && 0 === s) return void W.remove(e, 1);
if (p.inline || p.wrapper) {
if (p.exact || 1 !== s || (e = o(e)), it(d, function(t) {
it(W.select(t.inline, e), function(e) {
var r;
if (!rt(e)) {
if (t.wrap_links === !1) {
r = e.parentNode;
do if ("A" === r.nodeName) return; while (r = r.parentNode);
}
L(t, n, e, t.exact ? e :null);
}
});
}), b(e.parentNode, t, n)) return W.remove(e, 1), e = 0, J;
p.merge_with_parents && W.getParent(e.parentNode, function(r) {
return b(r, t, n) ? (W.remove(e, 1), e = 0, J) :void 0;
}), e && p.merge_siblings !== !1 && (e = P(H(e), e), e = P(e, H(e, J)));
}
});
}
var h, v, d = f(t), p = d[0], y = !r && V.isCollapsed();
if (p) if (r) r.nodeType ? (v = W.createRng(), v.setStartBefore(r), v.setEndAfter(r), 
u(D(v, d), null, !0)) :u(r, null, !0); else if (y && p.inline && !W.select("td.mce-item-selected,th.mce-item-selected").length) I("apply", t, n); else {
var C = a.selection.getNode();
j || !d[0].defaultBlock || W.getParent(C, W.isBlock) || g(d[0].defaultBlock), a.selection.setRng(o()), 
h = V.getBookmark(), u(D(V.getRng(J), d), h), p.styles && (p.styles.color || p.styles.textDecoration) && (at(C, m, "childNodes"), 
m(C)), V.moveToBookmark(h), F(V.getRng(J)), a.nodeChanged();
}
}
function v(e, t, n, r) {
function i(e) {
var n, r, o, a, s;
if (1 === e.nodeType && et(e) && (a = y, y = "true" === et(e), s = !0), n = ot(e.childNodes), 
y && !s) for (r = 0, o = p.length; o > r && !L(p[r], t, e, e); r++) ;
if (m.deep && n.length) {
for (r = 0, o = n.length; o > r; r++) i(n[r]);
s && (y = a);
}
}
function o(n) {
var i;
return it(l(n.parentNode).reverse(), function(n) {
var o;
i || "_start" == n.id || "_end" == n.id || (o = b(n, e, t, r), o && o.split !== !1 && (i = n));
}), i;
}
function s(e, n, r, i) {
var o, a, s, l, c, u;
if (e) {
for (u = e.parentNode, o = n.parentNode; o && o != u; o = o.parentNode) {
for (a = W.clone(o, X), c = 0; c < p.length; c++) if (L(p[c], t, a, a)) {
a = 0;
break;
}
a && (s && a.appendChild(s), l || (l = a), s = a);
}
!i || m.mixed && $(e) || (n = W.split(e, n)), s && (r.parentNode.insertBefore(s, r), 
l.appendChild(r));
}
return n;
}
function c(e) {
return s(o(e), e, e, !0);
}
function u(e) {
var t = W.get(e ? "_start" :"_end"), n = t[e ? "firstChild" :"lastChild"];
return rt(n) && (n = n[e ? "firstChild" :"lastChild"]), W.remove(t, !0), n;
}
function d(e) {
var t, n, r = e.commonAncestorContainer;
e = D(e, p, J), m.split && (t = O(e, J), n = O(e), t != n ? (/^(TR|TH|TD)$/.test(t.nodeName) && t.firstChild && (t = "TR" == t.nodeName ? t.firstChild.firstChild || t :t.firstChild || t), 
r && /^T(HEAD|BODY|FOOT|R)$/.test(r.nodeName) && /^(TH|TD)$/.test(n.nodeName) && n.firstChild && (n = n.firstChild || n), 
t = B(t, "span", {
id:"_start",
"data-mce-type":"bookmark"
}), n = B(n, "span", {
id:"_end",
"data-mce-type":"bookmark"
}), c(t), c(n), t = u(J), n = u()) :t = n = c(t), e.startContainer = t.parentNode, 
e.startOffset = K(t), e.endContainer = n.parentNode, e.endOffset = K(n) + 1), U.walk(e, function(e) {
it(e, function(e) {
i(e), 1 === e.nodeType && "underline" === a.dom.getStyle(e, "text-decoration") && e.parentNode && "underline" === h(e.parentNode) && L({
deep:!1,
exact:!0,
inline:"span",
styles:{
textDecoration:"underline"
}
}, null, e);
});
});
}
var g, v, p = f(e), m = p[0], y = !0;
return n ? void (n.nodeType ? (v = W.createRng(), v.setStartBefore(n), v.setEndAfter(n), 
d(v)) :d(n)) :void (V.isCollapsed() && m.inline && !W.select("td.mce-item-selected,th.mce-item-selected").length ? I("remove", e, t, r) :(g = V.getBookmark(), 
d(V.getRng(J)), V.moveToBookmark(g), m.inline && C(e, t, V.getStart()) && F(V.getRng(!0)), 
a.nodeChanged()));
}
function y(e, t, n) {
var r = f(e);
!C(e, t, n) || "toggle" in r[0] && !r[0].toggle ? g(e, t, n) :v(e, t, n);
}
function b(e, t, n, r) {
function i(e, t, i) {
var o, a, l, s = t[i];
if (t.onmatch) return t.onmatch(e, t, i);
if (s) if (s.length === Z) {
for (o in s) if (s.hasOwnProperty(o)) {
if (a = "attributes" === i ? W.getAttrib(e, o) :S(e, o), r && !a && !t.exact) return;
if ((!r || t.exact) && !k(a, T(R(s[o], n), o))) return;
}
} else for (l = 0; l < s.length; l++) if ("attributes" === i ? W.getAttrib(e, s[l]) :S(e, s[l])) return t;
return t;
}
var a, s, l, o = f(t);
if (o && e) for (s = 0; s < o.length; s++) if (a = o[s], E(e, a) && i(e, a, "attributes") && i(e, a, "styles")) {
if (l = a.classes) for (s = 0; s < l.length; s++) if (!W.hasClass(e, l[s])) return;
return a;
}
}
function C(e, t, n) {
function r(n) {
var r = W.getRoot();
return n === r ? !1 :(n = W.getParent(n, function(n) {
return n.parentNode === r || !!b(n, e, t, !0);
}), b(n, e, t));
}
var i;
return n ? r(n) :(n = V.getNode(), r(n) ? J :(i = V.getStart(), i != n && r(i) ? J :X));
}
function x(e, t) {
var n, r = [], i = {};
return n = V.getStart(), W.getParent(n, function(n) {
var o, a;
for (o = 0; o < e.length; o++) a = e[o], !i[a] && b(n, a, t) && (i[a] = !0, r.push(a));
}, W.getRoot()), r;
}
function w(e) {
var n, r, i, o, a, t = f(e);
if (t) for (n = V.getStart(), r = l(n), o = t.length - 1; o >= 0; o--) {
if (a = t[o].selector, !a || t[o].defaultBlock) return J;
for (i = r.length - 1; i >= 0; i--) if (W.is(r[i], a)) return J;
}
return X;
}
function _(e, t, n) {
var r;
return Q || (Q = {}, r = {}, a.on("NodeChange", function(e) {
var t = l(e.element), n = {};
it(Q, function(e, i) {
it(t, function(o) {
return b(o, i, {}, e.similar) ? (r[i] || (it(e, function(e) {
e(!0, {
node:o,
format:i,
parents:t
});
}), r[i] = e), n[i] = e, !1) :void 0;
});
}), it(r, function(i, o) {
n[o] || (delete r[o], it(i, function(n) {
n(!1, {
node:e.element,
format:o,
parents:t
});
}));
});
})), it(e.split(","), function(e) {
Q[e] || (Q[e] = [], Q[e].similar = n), Q[e].push(t);
}), this;
}
function N(e) {
return o.getCssText(a, e);
}
function E(e, t) {
return k(e, t.inline) ? J :k(e, t.block) ? J :t.selector ? 1 == e.nodeType && W.is(e, t.selector) :void 0;
}
function k(e, t) {
return e = e || "", t = t || "", e = "" + (e.nodeName || e), t = "" + (t.nodeName || t), 
e.toLowerCase() == t.toLowerCase();
}
function S(e, t) {
return T(W.getStyle(e, t), t);
}
function T(e, t) {
return ("color" == t || "backgroundColor" == t) && (e = W.toHex(e)), "fontWeight" == t && 700 == e && (e = "bold"), 
"fontFamily" == t && (e = e.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), "" + e;
}
function R(e, t) {
return "string" != typeof e ? e = e(t) :t && (e = e.replace(/%(\w+)/g, function(e, n) {
return t[n] || e;
})), e;
}
function A(e) {
return e && 3 === e.nodeType && /^([\t \r\n]+|)$/.test(e.nodeValue);
}
function B(e, t, n) {
var r = W.create(t, n);
return e.parentNode.insertBefore(r, e), r.appendChild(e), r;
}
function D(t, n, r) {
function i(e) {
function t(e) {
return "BR" == e.nodeName && e.getAttribute("data-mce-bogus") && !e.nextSibling;
}
var r, i, o, a, s;
if (r = i = e ? g :y, a = e ? "previousSibling" :"nextSibling", s = W.getRoot(), 
3 == r.nodeType && !A(r) && (e ? v > 0 :b < r.nodeValue.length)) return r;
for (;;) {
if (!n[0].block_expand && $(i)) return i;
for (o = i[a]; o; o = o[a]) if (!rt(o) && !A(o) && !t(o)) return i;
if (i.parentNode == s) {
r = i;
break;
}
i = i.parentNode;
}
return r;
}
function o(e, t) {
for (t === Z && (t = 3 === e.nodeType ? e.length :e.childNodes.length); e && e.hasChildNodes(); ) e = e.childNodes[t], 
e && (t = 3 === e.nodeType ? e.length :e.childNodes.length);
return {
node:e,
offset:t
};
}
function c(e) {
for (var t = e; t; ) {
if (1 === t.nodeType && et(t)) return "false" === et(t) ? t :e;
t = t.parentNode;
}
return e;
}
function u(t, n, i) {
function o(e, t) {
var n, o, a = e.nodeValue;
return "undefined" == typeof t && (t = i ? a.length :0), i ? (n = a.lastIndexOf(" ", t), 
o = a.lastIndexOf("\xa0", t), n = n > o ? n :o, -1 === n || r || n++) :(n = a.indexOf(" ", t), 
o = a.indexOf("\xa0", t), n = -1 !== n && (-1 === o || o > n) ? n :o), n;
}
var s, l, c, u;
if (3 === t.nodeType) {
if (c = o(t, n), -1 !== c) return {
container:t,
offset:c
};
u = t;
}
for (s = new e(t, W.getParent(t, $) || a.getBody()); l = s[i ? "prev" :"next"](); ) if (3 === l.nodeType) {
if (u = l, c = o(l), -1 !== c) return {
container:l,
offset:c
};
} else if ($(l)) break;
return u ? (n = i ? 0 :u.length, {
container:u,
offset:n
}) :void 0;
}
function d(e, r) {
var i, o, a, s;
for (3 == e.nodeType && 0 === e.nodeValue.length && e[r] && (e = e[r]), i = l(e), 
o = 0; o < i.length; o++) for (a = 0; a < n.length; a++) if (s = n[a], !("collapsed" in s && s.collapsed !== t.collapsed) && W.is(i[o], s.selector)) return i[o];
return e;
}
function f(e, t) {
var r, i = W.getRoot();
if (n[0].wrapper || (r = W.getParent(e, n[0].block, i)), r || (r = W.getParent(3 == e.nodeType ? e.parentNode :e, function(e) {
return e != i && s(e);
})), r && n[0].wrapper && (r = l(r, "ul,ol").reverse()[0] || r), !r) for (r = e; r[t] && !$(r[t]) && (r = r[t], 
!k(r, "br")); ) ;
return r || e;
}
var p, h, m, g = t.startContainer, v = t.startOffset, y = t.endContainer, b = t.endOffset;
if (1 == g.nodeType && g.hasChildNodes() && (p = g.childNodes.length - 1, g = g.childNodes[v > p ? p :v], 
3 == g.nodeType && (v = 0)), 1 == y.nodeType && y.hasChildNodes() && (p = y.childNodes.length - 1, 
y = y.childNodes[b > p ? p :b - 1], 3 == y.nodeType && (b = y.nodeValue.length)), 
g = c(g), y = c(y), (rt(g.parentNode) || rt(g)) && (g = rt(g) ? g :g.parentNode, 
g = g.nextSibling || g, 3 == g.nodeType && (v = 0)), (rt(y.parentNode) || rt(y)) && (y = rt(y) ? y :y.parentNode, 
y = y.previousSibling || y, 3 == y.nodeType && (b = y.length)), n[0].inline && (t.collapsed && (m = u(g, v, !0), 
m && (g = m.container, v = m.offset), m = u(y, b), m && (y = m.container, b = m.offset)), 
h = o(y, b), h.node)) {
for (;h.node && 0 === h.offset && h.node.previousSibling; ) h = o(h.node.previousSibling);
h.node && h.offset > 0 && 3 === h.node.nodeType && " " === h.node.nodeValue.charAt(h.offset - 1) && h.offset > 1 && (y = h.node, 
y.splitText(h.offset - 1));
}
return (n[0].inline || n[0].block_expand) && (n[0].inline && 3 == g.nodeType && 0 !== v || (g = i(!0)), 
n[0].inline && 3 == y.nodeType && b !== y.nodeValue.length || (y = i())), n[0].selector && n[0].expand !== X && !n[0].inline && (g = d(g, "previousSibling"), 
y = d(y, "nextSibling")), (n[0].block || n[0].selector) && (g = f(g, "previousSibling"), 
y = f(y, "nextSibling"), n[0].block && ($(g) || (g = i(!0)), $(y) || (y = i()))), 
1 == g.nodeType && (v = K(g), g = g.parentNode), 1 == y.nodeType && (b = K(y) + 1, 
y = y.parentNode), {
startContainer:g,
startOffset:v,
endContainer:y,
endOffset:b
};
}
function L(e, t, n, r) {
var i, o, a;
if (!E(n, e)) return X;
if ("all" != e.remove) for (it(e.styles, function(i, o) {
i = T(R(i, t), o), "number" == typeof o && (o = i, r = 0), (e.remove_similar || !r || k(S(r, o), i)) && W.setStyle(n, o, ""), 
a = 1;
}), a && "" === W.getAttrib(n, "style") && (n.removeAttribute("style"), n.removeAttribute("data-mce-style")), 
it(e.attributes, function(e, i) {
var o;
if (e = R(e, t), "number" == typeof i && (i = e, r = 0), !r || k(W.getAttrib(r, i), e)) {
if ("class" == i && (e = W.getAttrib(n, i), e && (o = "", it(e.split(/\s+/), function(e) {
/mce\w+/.test(e) && (o += (o ? " " :"") + e);
}), o))) return void W.setAttrib(n, i, o);
"class" == i && n.removeAttribute("className"), Y.test(i) && n.removeAttribute("data-mce-" + i), 
n.removeAttribute(i);
}
}), it(e.classes, function(e) {
e = R(e, t), (!r || W.hasClass(r, e)) && W.removeClass(n, e);
}), o = W.getAttribs(n), i = 0; i < o.length; i++) if (0 !== o[i].nodeName.indexOf("_")) return X;
return "none" != e.remove ? (M(n, e), J) :void 0;
}
function M(e, t) {
function n(e, t, n) {
return e = H(e, t, n), !e || "BR" == e.nodeName || $(e);
}
var i, r = e.parentNode;
t.block && (j ? r == W.getRoot() && (t.list_block && k(e, t.list_block) || it(ot(e.childNodes), function(e) {
q(j, e.nodeName.toLowerCase()) ? i ? i.appendChild(e) :(i = B(e, j), W.setAttribs(i, a.settings.forced_root_block_attrs)) :i = 0;
})) :$(e) && !$(r) && (n(e, X) || n(e.firstChild, J, 1) || e.insertBefore(W.create("br"), e.firstChild), 
n(e, J) || n(e.lastChild, X, 1) || e.appendChild(W.create("br")))), t.selector && t.inline && !k(t.inline, e) || W.remove(e, 1);
}
function H(e, t, n) {
if (e) for (t = t ? "nextSibling" :"previousSibling", e = n ? e :e[t]; e; e = e[t]) if (1 == e.nodeType || !A(e)) return e;
}
function P(e, t) {
function n(e, t) {
for (i = e; i; i = i[t]) {
if (3 == i.nodeType && 0 !== i.nodeValue.length) return e;
if (1 == i.nodeType && !rt(i)) return i;
}
return e;
}
var i, o, a = new r(W);
if (e && t && (e = n(e, "previousSibling"), t = n(t, "nextSibling"), a.compare(e, t))) {
for (i = e.nextSibling; i && i != t; ) o = i, i = i.nextSibling, e.appendChild(o);
return W.remove(t), it(ot(t.childNodes), function(t) {
e.appendChild(t);
}), e;
}
return t;
}
function O(t, n) {
var r, i, o;
return r = t[n ? "startContainer" :"endContainer"], i = t[n ? "startOffset" :"endOffset"], 
1 == r.nodeType && (o = r.childNodes.length - 1, !n && i && i--, r = r.childNodes[i > o ? o :i]), 
3 === r.nodeType && n && i >= r.nodeValue.length && (r = new e(r, a.getBody()).next() || r), 
3 !== r.nodeType || n || 0 !== i || (r = new e(r, a.getBody()).prev() || r), r;
}
function I(t, n, r, i) {
function o(e) {
var t = W.create("span", {
id:y,
"data-mce-bogus":!0,
style:C ? "color:red" :""
});
return e && t.appendChild(a.getDoc().createTextNode(G)), t;
}
function l(e, t) {
for (;e; ) {
if (3 === e.nodeType && e.nodeValue !== G || e.childNodes.length > 1) return !1;
t && 1 === e.nodeType && t.push(e), e = e.firstChild;
}
return !0;
}
function c(e) {
for (;e; ) {
if (e.id === y) return e;
e = e.parentNode;
}
}
function u(t) {
var n;
if (t) for (n = new e(t, t), t = n.current(); t; t = n.next()) if (3 === t.nodeType) return t;
}
function d(e, t) {
var n, r;
if (e) r = V.getRng(!0), l(e) ? (t !== !1 && (r.setStartBefore(e), r.setEndBefore(e)), 
W.remove(e)) :(n = u(e), n.nodeValue.charAt(0) === G && (n.deleteData(0, 1), r.startContainer == n && r.startOffset--, 
r.endContainer == n && r.endOffset--), W.remove(e, 1)), V.setRng(r); else if (e = c(V.getStart()), 
!e) for (;e = W.get(y); ) d(e, !1);
}
function p() {
var e, t, i, a, s, l, d;
e = V.getRng(!0), a = e.startOffset, l = e.startContainer, d = l.nodeValue, t = c(V.getStart()), 
t && (i = u(t)), d && a > 0 && a < d.length && /\w/.test(d.charAt(a)) && /\w/.test(d.charAt(a - 1)) ? (s = V.getBookmark(), 
e.collapse(!0), e = D(e, f(n)), e = U.split(e), g(n, r, e), V.moveToBookmark(s)) :(t && i.nodeValue === G ? g(n, r, t) :(t = o(!0), 
i = t.firstChild, e.insertNode(t), a = 1, g(n, r, t)), V.setCursorLocation(i, a));
}
function h() {
var t, a, l, c, u, d, h, m, e = V.getRng(!0), p = [];
for (t = e.startContainer, a = e.startOffset, u = t, 3 == t.nodeType && (a != t.nodeValue.length && (c = !0), 
u = u.parentNode); u; ) {
if (b(u, n, r, i)) {
d = u;
break;
}
u.nextSibling && (c = !0), p.push(u), u = u.parentNode;
}
if (d) if (c) l = V.getBookmark(), e.collapse(!0), e = D(e, f(n), !0), e = U.split(e), 
v(n, r, e), V.moveToBookmark(l); else {
for (m = o(), u = m, h = p.length - 1; h >= 0; h--) u.appendChild(W.clone(p[h], !1)), 
u = u.firstChild;
u.appendChild(W.doc.createTextNode(G)), u = u.firstChild;
var g = W.getParent(d, s);
g && W.isEmpty(g) ? d.parentNode.replaceChild(m, d) :W.insertAfter(m, d), V.setCursorLocation(u, 1), 
W.isEmpty(d) && W.remove(d);
}
}
function m() {
var e;
e = c(V.getStart()), e && !W.isEmpty(e) && at(e, function(e) {
1 != e.nodeType || e.id === y || W.isEmpty(e) || W.setAttrib(e, "data-mce-bogus", null);
}, "childNodes");
}
var y = "_mce_caret", C = a.settings.caret_debug;
a._hasCaretEvents || (nt = function() {
var t, e = [];
if (l(c(V.getStart()), e)) for (t = e.length; t--; ) W.setAttrib(e[t], "data-mce-bogus", "1");
}, tt = function(e) {
var t = e.keyCode;
d(), (8 == t || 37 == t || 39 == t) && d(c(V.getStart())), m();
}, a.on("SetContent", function(e) {
e.selection && m();
}), a._hasCaretEvents = !0), "apply" == t ? p() :h();
}
function F(t) {
var i, o, a, s, l, n = t.startContainer, r = t.startOffset;
if (3 == n.nodeType && r >= n.nodeValue.length && (r = K(n), n = n.parentNode, i = !0), 
1 == n.nodeType) for (s = n.childNodes, n = s[Math.min(r, s.length - 1)], o = new e(n, W.getParent(n, W.isBlock)), 
(r > s.length - 1 || i) && o.next(), a = o.current(); a; a = o.next()) if (3 == a.nodeType && !A(a)) return l = W.create("a", null, G), 
a.parentNode.insertBefore(l, a), t.setStart(a, 0), V.setRng(t), void W.remove(l);
}
var Q, Z, tt, nt, z = {}, W = a.dom, V = a.selection, U = new t(W), q = a.schema.isValidChild, $ = W.isBlock, j = a.settings.forced_root_block, K = W.nodeIndex, G = "\ufeff", Y = /^(src|href|style)$/, X = !1, J = !0, et = W.getContentEditable, rt = n.isBookmarkNode, it = i.each, ot = i.grep, at = i.walk, st = i.extend;
st(this, {
get:f,
register:p,
apply:g,
remove:v,
toggle:y,
match:C,
matchAll:x,
matchNode:b,
canApply:w,
formatChanged:_,
getCssText:N
}), u(), d(), a.on("BeforeGetContent", function() {
nt && nt();
}), a.on("mouseup keydown", function(e) {
tt && tt(e);
});
};
}), r(O, [ d, u, _ ], function(e, t, n) {
var i, r = t.trim;
return i = new RegExp([ "<span[^>]+data-mce-bogus[^>]+>[\u200b\ufeff]+<\\/span>", '\\s?data-mce-selected="[^"]+"' ].join("|"), "gi"), 
function(t) {
function o() {
var a, s, l, c, u, e = r(t.getContent({
format:"raw",
no_events:1
})), o = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g, d = t.schema;
for (e = e.replace(i, ""), u = d.getShortEndedElements(); c = o.exec(e); ) s = o.lastIndex, 
l = c[0].length, a = u[c[1]] ? s :n.findEndTag(d, e, s), e = e.substring(0, s - l) + e.substring(a), 
o.lastIndex = s - l;
return e;
}
function a(e) {
s.typing = !1, s.add({}, e);
}
var u, d, s = this, l = 0, c = [], f = 0;
return t.on("init", function() {
s.add();
}), t.on("BeforeExecCommand", function(e) {
var t = e.command;
"Undo" != t && "Redo" != t && "mceRepaint" != t && s.beforeChange();
}), t.on("ExecCommand", function(e) {
var t = e.command;
"Undo" != t && "Redo" != t && "mceRepaint" != t && a(e);
}), t.on("ObjectResizeStart", function() {
s.beforeChange();
}), t.on("SaveContent ObjectResized blur", a), t.on("DragEnd", a), t.on("KeyUp", function(n) {
var r = n.keyCode;
(r >= 33 && 36 >= r || r >= 37 && 40 >= r || 45 == r || 13 == r || n.ctrlKey) && (a(), 
t.nodeChanged()), (46 == r || 8 == r || e.mac && (91 == r || 93 == r)) && t.nodeChanged(), 
d && s.typing && (t.isDirty() || (t.isNotDirty = !c[0] || o() == c[0].content, t.isNotDirty || t.fire("change", {
level:c[0],
lastLevel:null
})), t.fire("TypingUndo"), d = !1, t.nodeChanged());
}), t.on("KeyDown", function(e) {
var t = e.keyCode;
return t >= 33 && 36 >= t || t >= 37 && 40 >= t || 45 == t ? void (s.typing && a(e)) :void ((16 > t || t > 20) && 224 != t && 91 != t && !s.typing && (s.beforeChange(), 
s.typing = !0, s.add({}, e), d = !0));
}), t.on("MouseDown", function(e) {
s.typing && a(e);
}), t.addShortcut("ctrl+z", "", "Undo"), t.addShortcut("ctrl+y,ctrl+shift+z", "", "Redo"), 
t.on("AddUndo Undo Redo ClearUndos", function(e) {
e.isDefaultPrevented() || t.nodeChanged();
}), e.ie ? t.on("MouseUp", function(e) {
e.isDefaultPrevented() || (t.once("SelectionChange", function() {
t.dom.isChildOf(t.selection.getStart(), t.getBody()) && t.nodeChanged();
}), t.nodeChanged());
}) :(t.on("MouseUp", function() {
t.nodeChanged();
}), t.on("Click", function(e) {
e.isDefaultPrevented() || setTimeout(function() {
t.nodeChanged();
}, 0);
})), s = {
data:c,
typing:!1,
beforeChange:function() {
f || (u = t.selection.getBookmark(2, !0));
},
add:function(e, n) {
var r, a, i = t.settings;
if (e = e || {}, e.content = o(), f || t.removed) return null;
if (a = c[l], t.fire("BeforeAddUndo", {
level:e,
lastLevel:a,
originalEvent:n
}).isDefaultPrevented()) return null;
if (a && a.content == e.content) return null;
if (c[l] && (c[l].beforeBookmark = u), i.custom_undo_redo_levels && c.length > i.custom_undo_redo_levels) {
for (r = 0; r < c.length - 1; r++) c[r] = c[r + 1];
c.length--, l = c.length;
}
e.bookmark = t.selection.getBookmark(2, !0), l < c.length - 1 && (c.length = l + 1), 
c.push(e), l = c.length - 1;
var s = {
level:e,
lastLevel:a,
originalEvent:n
};
return t.fire("AddUndo", s), l > 0 && (t.isNotDirty = !1, t.fire("change", s)), 
e;
},
undo:function() {
var e;
return s.typing && (s.add(), s.typing = !1), l > 0 && (e = c[--l], 0 === l && (t.isNotDirty = !0), 
t.setContent(e.content, {
format:"raw"
}), t.selection.moveToBookmark(e.beforeBookmark), t.fire("undo", {
level:e
})), e;
},
redo:function() {
var e;
return l < c.length - 1 && (e = c[++l], t.setContent(e.content, {
format:"raw"
}), t.selection.moveToBookmark(e.bookmark), t.fire("redo", {
level:e
})), e;
},
clear:function() {
c = [], l = 0, s.typing = !1, t.fire("ClearUndos");
},
hasUndo:function() {
return l > 0 || s.typing && c[0] && o() != c[0].content;
},
hasRedo:function() {
return l < c.length - 1 && !this.typing;
},
transact:function(e) {
s.beforeChange();
try {
f++, e();
} finally {
f--;
}
s.add();
}
};
};
}), r(I, [ h, B, d ], function(e, t, n) {
var r = n.ie && n.ie < 11;
return function(i) {
function o(o) {
function f(e) {
return e && a.isBlock(e) && !/^(TD|TH|CAPTION|FORM)$/.test(e.nodeName) && !/^(fixed|absolute)/i.test(e.style.position) && "true" !== a.getContentEditable(e);
}
function p(e) {
var t;
a.isBlock(e) && (t = s.getRng(), e.appendChild(a.create("span", null, "\xa0")), 
s.select(e), e.lastChild.outerHTML = "", s.setRng(t));
}
function h(e) {
var r, t = e, n = [];
if (t) {
for (;t = t.firstChild; ) {
if (a.isBlock(t)) return;
1 != t.nodeType || d[t.nodeName.toLowerCase()] || n.push(t);
}
for (r = n.length; r--; ) t = n[r], !t.hasChildNodes() || t.firstChild == t.lastChild && "" === t.firstChild.nodeValue ? a.remove(t) :"A" == t.nodeName && " " === (t.innerText || t.textContent) && a.remove(t);
}
}
function m(t) {
function r(e) {
for (;e; ) {
if (1 == e.nodeType || 3 == e.nodeType && e.data && /[\r\n\s]/.test(e.data)) return e;
e = e.nextSibling;
}
}
var i, o, l, u, c = t;
if (t) {
if (n.ie && n.ie < 9 && A && A.firstChild && A.firstChild == A.lastChild && "BR" == A.firstChild.tagName && a.remove(A.firstChild), 
/^(LI|DT|DD)$/.test(t.nodeName)) {
var f = r(t.firstChild);
f && /^(UL|OL|DL)$/.test(f.nodeName) && t.insertBefore(a.doc.createTextNode("\xa0"), t.firstChild);
}
if (l = a.createRng(), n.ie || t.normalize(), t.hasChildNodes()) {
for (i = new e(t, t); o = i.current(); ) {
if (3 == o.nodeType) {
l.setStart(o, 0), l.setEnd(o, 0);
break;
}
if (d[o.nodeName.toLowerCase()]) {
l.setStartBefore(o), l.setEndBefore(o);
break;
}
c = o, o = i.next();
}
o || (l.setStart(c, 0), l.setEnd(c, 0));
} else "BR" == t.nodeName ? t.nextSibling && a.isBlock(t.nextSibling) ? ((!B || 9 > B) && (u = a.create("br"), 
t.parentNode.insertBefore(u, t)), l.setStartBefore(t), l.setEndBefore(t)) :(l.setStartAfter(t), 
l.setEndAfter(t)) :(l.setStart(t, 0), l.setEnd(t, 0));
s.setRng(l), a.remove(u), s.scrollIntoView(t);
}
}
function g(e) {
var t = l.forced_root_block;
t && t.toLowerCase() === e.tagName.toLowerCase() && a.setAttribs(e, l.forced_root_block_attrs);
}
function v(e) {
var n, i, o, t = T, s = u.getTextInlineElements();
if (e || "TABLE" == P ? (n = a.create(e || I), g(n)) :n = A.cloneNode(!1), o = n, 
l.keep_styles !== !1) do if (s[t.nodeName]) {
if ("_mce_caret" == t.id) continue;
i = t.cloneNode(!1), a.setAttrib(i, "id", ""), n.hasChildNodes() ? (i.appendChild(n.firstChild), 
n.appendChild(i)) :(o = i, n.appendChild(i));
} while (t = t.parentNode);
return r || (o.innerHTML = '<br data-mce-bogus="1">'), n;
}
function y(t) {
var n, r, i;
if (3 == T.nodeType && (t ? R > 0 :R < T.nodeValue.length)) return !1;
if (T.parentNode == A && F && !t) return !0;
if (t && 1 == T.nodeType && T == A.firstChild) return !0;
if ("TABLE" === T.nodeName || T.previousSibling && "TABLE" == T.previousSibling.nodeName) return F && !t || !F && t;
for (n = new e(T, A), 3 == T.nodeType && (t && 0 === R ? n.prev() :t || R != T.nodeValue.length || n.next()); r = n.current(); ) {
if (1 === r.nodeType) {
if (!r.getAttribute("data-mce-bogus") && (i = r.nodeName.toLowerCase(), d[i] && "br" !== i)) return !1;
} else if (3 === r.nodeType && !/^[ \t\r\n]*$/.test(r.nodeValue)) return !1;
t ? n.prev() :n.next();
}
return !0;
}
function b(e, t) {
var n, r, o, s, l, c, d = I || "P";
if (r = a.getParent(e, a.isBlock), c = i.getBody().nodeName.toLowerCase(), !r || !f(r)) {
if (r = r || S, !r.hasChildNodes()) return n = a.create(d), g(n), r.appendChild(n), 
E.setStart(n, 0), E.setEnd(n, 0), n;
for (s = e; s.parentNode != r; ) s = s.parentNode;
for (;s && !a.isBlock(s); ) o = s, s = s.previousSibling;
if (o && u.isValidChild(c, d.toLowerCase())) {
for (n = a.create(d), g(n), o.parentNode.insertBefore(n, o), s = o; s && !a.isBlock(s); ) l = s.nextSibling, 
n.appendChild(s), s = l;
E.setStart(e, t), E.setEnd(e, t);
}
}
return e;
}
function C() {
function e(e) {
for (var t = H[e ? "firstChild" :"lastChild"]; t && 1 != t.nodeType; ) t = t[e ? "nextSibling" :"previousSibling"];
return t === A;
}
function t() {
var e = H.parentNode;
return /^(LI|DT|DD)$/.test(e.nodeName) ? e :H;
}
var n = H.parentNode.nodeName;
/^(OL|UL|LI)$/.test(n) && (I = "LI"), L = I ? v(I) :a.create("BR"), e(!0) && e() ? "LI" == n ? a.insertAfter(L, t()) :a.replace(L, H) :e(!0) ? "LI" == n ? (a.insertAfter(L, t()), 
L.appendChild(a.doc.createTextNode(" ")), L.appendChild(H)) :H.parentNode.insertBefore(L, H) :e() ? (a.insertAfter(L, t()), 
p(L)) :(H = t(), k = E.cloneRange(), k.setStartAfter(A), k.setEndAfter(H), M = k.extractContents(), 
"LI" == I && "LI" == M.firstChild.nodeName ? (L = M.firstChild, a.insertAfter(M, H)) :(a.insertAfter(M, H), 
a.insertAfter(L, H))), a.remove(A), m(L), c.add();
}
function x() {
i.execCommand("InsertLineBreak", !1, o);
}
function w(e) {
do 3 === e.nodeType && (e.nodeValue = e.nodeValue.replace(/^[\r\n]+/, "")), e = e.firstChild; while (e);
}
function _(e) {
var n, r, t = a.getRoot();
for (n = e; n !== t && "false" !== a.getContentEditable(n); ) "true" === a.getContentEditable(n) && (r = n), 
n = n.parentNode;
return n !== t ? r :t;
}
function N(e) {
var t;
r || (e.normalize(), t = e.lastChild, (!t || /^(left|right)$/gi.test(a.getStyle(t, "float", !0))) && a.add(e, "br"));
}
var E, k, S, T, R, A, B, D, L, M, H, P, O, I, F;
if (E = s.getRng(!0), !o.isDefaultPrevented()) {
if (!E.collapsed) return void i.execCommand("Delete");
if (new t(a).normalize(E), T = E.startContainer, R = E.startOffset, I = (l.force_p_newlines ? "p" :"") || l.forced_root_block, 
I = I ? I.toUpperCase() :"", B = a.doc.documentMode, D = o.shiftKey, 1 == T.nodeType && T.hasChildNodes() && (F = R > T.childNodes.length - 1, 
T = T.childNodes[Math.min(R, T.childNodes.length - 1)] || T, R = F && 3 == T.nodeType ? T.nodeValue.length :0), 
S = _(T)) {
if (c.beforeChange(), !a.isBlock(S) && S != a.getRoot()) return void ((!I || D) && x());
if ((I && !D || !I && D) && (T = b(T, R)), A = a.getParent(T, a.isBlock), H = A ? a.getParent(A.parentNode, a.isBlock) :null, 
P = A ? A.nodeName.toUpperCase() :"", O = H ? H.nodeName.toUpperCase() :"", "LI" != O || o.ctrlKey || (A = H, 
P = O), /^(LI|DT|DD)$/.test(P)) {
if (!I && D) return void x();
if (a.isEmpty(A)) return void C();
}
if ("PRE" == P && l.br_in_pre !== !1) {
if (!D) return void x();
} else if (!I && !D && "LI" != P || I && D) return void x();
I && A === i.getBody() || (I = I || "P", y() ? (L = /^(H[1-6]|PRE|FIGURE)$/.test(P) && "HGROUP" != O ? v(I) :v(), 
l.end_container_on_empty_block && f(H) && a.isEmpty(A) ? L = a.split(H, A) :a.insertAfter(L, A), 
m(L)) :y(!0) ? (L = A.parentNode.insertBefore(v(), A), p(L), m(A)) :(k = E.cloneRange(), 
k.setEndAfter(A), M = k.extractContents(), w(M), L = M.firstChild, a.insertAfter(M, A), 
h(L), N(A), m(L)), a.setAttrib(L, "id", ""), i.fire("NewBlock", {
newBlock:L
}), c.add());
}
}
}
var a = i.dom, s = i.selection, l = i.settings, c = i.undoManager, u = i.schema, d = u.getNonEmptyElements();
i.on("keydown", function(e) {
13 == e.keyCode && o(e) !== !1 && e.preventDefault();
});
};
}), r(F, [], function() {
return function(e) {
function t() {
var l, c, u, d, f, p, h, g, v, y, b, C, t = i.getStart(), s = e.getBody(), m = -16777215;
if (C = n.forced_root_block, t && 1 === t.nodeType && C) {
for (;t && t != s; ) {
if (a[t.nodeName]) return;
t = t.parentNode;
}
if (l = i.getRng(), l.setStart) {
c = l.startContainer, u = l.startOffset, d = l.endContainer, f = l.endOffset;
try {
v = e.getDoc().activeElement === s;
} catch (x) {}
} else l.item && (t = l.item(0), l = e.getDoc().body.createTextRange(), l.moveToElementText(t)), 
v = l.parentElement().ownerDocument === e.getDoc(), y = l.duplicate(), y.collapse(!0), 
u = -1 * y.move("character", m), y.collapsed || (y = l.duplicate(), y.collapse(!1), 
f = -1 * y.move("character", m) - u);
for (t = s.firstChild, b = s.nodeName.toLowerCase(); t; ) if ((3 === t.nodeType || 1 == t.nodeType && !a[t.nodeName]) && o.isValidChild(b, C.toLowerCase())) {
if (3 === t.nodeType && 0 === t.nodeValue.length) {
h = t, t = t.nextSibling, r.remove(h);
continue;
}
p || (p = r.create(C, e.settings.forced_root_block_attrs), t.parentNode.insertBefore(p, t), 
g = !0), h = t, t = t.nextSibling, p.appendChild(h);
} else p = null, t = t.nextSibling;
if (g && v) {
if (l.setStart) l.setStart(c, u), l.setEnd(d, f), i.setRng(l); else try {
l = e.getDoc().body.createTextRange(), l.moveToElementText(s), l.collapse(!0), l.moveStart("character", u), 
f > 0 && l.moveEnd("character", f), l.select();
} catch (x) {}
e.nodeChanged();
}
}
}
var n = e.settings, r = e.dom, i = e.selection, o = e.schema, a = o.getBlockElements();
n.forced_root_block && e.on("NodeChange", t);
};
}), r(z, [ k, d, u, M, B, h ], function(e, n, r, i, o, a) {
var s = r.each, l = r.extend, c = r.map, u = r.inArray, d = r.explode, f = n.gecko, p = n.ie, h = n.ie && n.ie < 11, m = !0, g = !1;
return function(r) {
function v(e, t, n) {
var r;
return e = e.toLowerCase(), (r = T.exec[e]) ? (r(e, t, n), m) :g;
}
function y(e) {
var t;
return e = e.toLowerCase(), (t = T.state[e]) ? t(e) :-1;
}
function b(e) {
var t;
return e = e.toLowerCase(), (t = T.value[e]) ? t(e) :g;
}
function C(e, t) {
t = t || "exec", s(e, function(e, n) {
s(n.toLowerCase().split(","), function(n) {
T[t][n] = e;
});
});
}
function x(e, n, i) {
return n === t && (n = g), i === t && (i = null), r.getDoc().execCommand(e, n, i);
}
function w(e) {
return A.match(e);
}
function _(e, n) {
A.toggle(e, n ? {
value:n
} :t), r.nodeChanged();
}
function N(e) {
B = S.getBookmark(e);
}
function E() {
S.moveToBookmark(B);
}
var B, k = r.dom, S = r.selection, T = {
state:{},
exec:{},
value:{}
}, R = r.settings, A = r.formatter;
l(this, {
execCommand:v,
queryCommandState:y,
queryCommandValue:b,
addCommands:C
}), C({
"mceResetDesignMode,mceBeginUndoLevel":function() {},
"mceEndUndoLevel,mceAddUndoLevel":function() {
r.undoManager.add();
},
"Cut,Copy,Paste":function(e) {
var i, t = r.getDoc();
try {
x(e);
} catch (o) {
i = m;
}
if (i || !t.queryCommandSupported(e)) {
var a = r.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
n.mac && (a = a.replace(/Ctrl\+/g, "\u2318+")), r.windowManager.alert(a);
}
},
unlink:function() {
if (S.isCollapsed()) {
var e = S.getNode();
return void ("A" == e.tagName && r.dom.remove(e, !0));
}
A.remove("link");
},
"JustifyLeft,JustifyCenter,JustifyRight,JustifyFull":function(e) {
var t = e.substring(7);
"full" == t && (t = "justify"), s("left,center,right,justify".split(","), function(e) {
t != e && A.remove("align" + e);
}), _("align" + t), v("mceRepaint");
},
"InsertUnorderedList,InsertOrderedList":function(e) {
var t, n;
x(e), t = k.getParent(S.getNode(), "ol,ul"), t && (n = t.parentNode, /^(H[1-6]|P|ADDRESS|PRE)$/.test(n.nodeName) && (N(), 
k.split(n, t), E()));
},
"Bold,Italic,Underline,Strikethrough,Superscript,Subscript":function(e) {
_(e);
},
"ForeColor,HiliteColor,FontName":function(e, t, n) {
_(e, n);
},
FontSize:function(e, t, n) {
var r, i;
n >= 1 && 7 >= n && (i = d(R.font_size_style_values), r = d(R.font_size_classes), 
n = r ? r[n - 1] || n :i[n - 1] || n), _(e, n);
},
RemoveFormat:function(e) {
A.remove(e);
},
mceBlockQuote:function() {
_("blockquote");
},
FormatBlock:function(e, t, n) {
return _(n || "p");
},
mceCleanup:function() {
var e = S.getBookmark();
r.setContent(r.getContent({
cleanup:m
}), {
cleanup:m
}), S.moveToBookmark(e);
},
mceRemoveNode:function(e, t, n) {
var i = n || S.getNode();
i != r.getBody() && (N(), r.dom.remove(i, m), E());
},
mceSelectNodeDepth:function(e, t, n) {
var i = 0;
k.getParent(S.getNode(), function(e) {
return 1 == e.nodeType && i++ == n ? (S.select(e), g) :void 0;
}, r.getBody());
},
mceSelectNode:function(e, t, n) {
S.select(n);
},
mceInsertContent:function(t, n, o) {
function a(e) {
function t(e) {
return r[e] && 3 == r[e].nodeType;
}
var n, r, i;
return n = S.getRng(!0), r = n.startContainer, i = n.startOffset, 3 == r.nodeType && (i > 0 ? e = e.replace(/^&nbsp;/, " ") :t("previousSibling") || (e = e.replace(/^ /, "&nbsp;")), 
i < r.length ? e = e.replace(/&nbsp;(<br>|)$/, " ") :t("nextSibling") || (e = e.replace(/(&nbsp;| )(<br>|)$/, "&nbsp;"))), 
e;
}
function l(e) {
if (w) for (b = e.firstChild; b; b = b.walk(!0)) _[b.name] && b.attr("data-mce-new", "true");
}
function c() {
if (w) {
var e = r.getBody(), t = new i(k);
s(k.select("*[data-mce-new]"), function(n) {
n.removeAttribute("data-mce-new");
for (var r = n.parentNode; r && r != e; r = r.parentNode) t.compare(r, n) && k.remove(n, !0);
});
}
}
var u, d, f, h, m, g, v, y, b, C, x, w, _ = r.schema.getTextInlineElements();
"string" != typeof o && (w = o.merge, o = o.content), /^ | $/.test(o) && (o = a(o)), 
u = r.parser, d = new e({}, r.schema), x = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#200B;</span>', 
g = {
content:o,
format:"html",
selection:!0
}, r.fire("BeforeSetContent", g), o = g.content, -1 == o.indexOf("{$caret}") && (o += "{$caret}"), 
o = o.replace(/\{\$caret\}/, x), y = S.getRng();
var N = y.startContainer || (y.parentElement ? y.parentElement() :null), E = r.getBody();
N === E && S.isCollapsed() && k.isBlock(E.firstChild) && k.isEmpty(E.firstChild) && (y = k.createRng(), 
y.setStart(E.firstChild, 0), y.setEnd(E.firstChild, 0), S.setRng(y)), S.isCollapsed() || r.getDoc().execCommand("Delete", !1, null), 
f = S.getNode();
var T = {
context:f.nodeName.toLowerCase()
};
if (m = u.parse(o, T), l(m), b = m.lastChild, "mce_marker" == b.attr("id")) for (v = b, 
b = b.prev; b; b = b.walk(!0)) if (3 == b.type || !k.isBlock(b.name)) {
b.parent.insert(v, b, "br" === b.name);
break;
}
if (T.invalid) {
for (S.setContent(x), f = S.getNode(), h = r.getBody(), 9 == f.nodeType ? f = b = h :b = f; b !== h; ) f = b, 
b = b.parentNode;
o = f == h ? h.innerHTML :k.getOuterHTML(f), o = d.serialize(u.parse(o.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
return d.serialize(m);
}))), f == h ? k.setHTML(h, o) :k.setOuterHTML(f, o);
} else o = d.serialize(m), b = f.firstChild, C = f.lastChild, !b || b === C && "BR" === b.nodeName ? k.setHTML(f, o) :S.setContent(o);
c(), v = k.get("mce_marker"), S.scrollIntoView(v), y = k.createRng(), b = v.previousSibling, 
b && 3 == b.nodeType ? (y.setStart(b, b.nodeValue.length), p || (C = v.nextSibling, 
C && 3 == C.nodeType && (b.appendData(C.data), C.parentNode.removeChild(C)))) :(y.setStartBefore(v), 
y.setEndBefore(v)), k.remove(v), S.setRng(y), r.fire("SetContent", g), r.addVisual();
},
mceInsertRawHTML:function(e, t, n) {
S.setContent("tiny_mce_marker"), r.setContent(r.getContent().replace(/tiny_mce_marker/g, function() {
return n;
}));
},
mceToggleFormat:function(e, t, n) {
_(n);
},
mceSetContent:function(e, t, n) {
r.setContent(n);
},
"Indent,Outdent":function(e) {
var t, n, i;
t = R.indentation, n = /[a-z%]+$/i.exec(t), t = parseInt(t, 10), y("InsertUnorderedList") || y("InsertOrderedList") ? x(e) :(R.forced_root_block || k.getParent(S.getNode(), k.isBlock) || A.apply("div"), 
s(S.getSelectedBlocks(), function(o) {
if ("LI" != o.nodeName) {
var a = r.getParam("indent_use_margin", !1) ? "margin" :"padding";
a += "rtl" == k.getStyle(o, "direction", !0) ? "Right" :"Left", "outdent" == e ? (i = Math.max(0, parseInt(o.style[a] || 0, 10) - t), 
k.setStyle(o, a, i ? i + n :"")) :(i = parseInt(o.style[a] || 0, 10) + t + n, k.setStyle(o, a, i));
}
}));
},
mceRepaint:function() {
if (f) try {
N(m), S.getSel() && S.getSel().selectAllChildren(r.getBody()), S.collapse(m), E();
} catch (e) {}
},
InsertHorizontalRule:function() {
r.execCommand("mceInsertContent", !1, "<hr />");
},
mceToggleVisualAid:function() {
r.hasVisual = !r.hasVisual, r.addVisual();
},
mceReplaceContent:function(e, t, n) {
r.execCommand("mceInsertContent", !1, n.replace(/\{\$selection\}/g, S.getContent({
format:"text"
})));
},
mceInsertLink:function(e, t, n) {
var r;
"string" == typeof n && (n = {
href:n
}), r = k.getParent(S.getNode(), "a"), n.href = n.href.replace(" ", "%20"), r && n.href || A.remove("link"), 
n.href && A.apply("link", n, r);
},
selectAll:function() {
var t, e = k.getRoot();
S.getRng().setStart ? (t = k.createRng(), t.setStart(e, 0), t.setEnd(e, e.childNodes.length), 
S.setRng(t)) :(t = S.getRng(), t.item || (t.moveToElementText(e), t.select()));
},
"delete":function() {
x("Delete");
var e = r.getBody();
k.isEmpty(e) && (r.setContent(""), e.firstChild && k.isBlock(e.firstChild) ? r.selection.setCursorLocation(e.firstChild, 0) :r.selection.setCursorLocation(e, 0));
},
mceNewDocument:function() {
r.setContent("");
},
InsertLineBreak:function(e, t, n) {
function i() {
for (var t, e = new a(p, v), n = r.schema.getNonEmptyElements(); t = e.next(); ) if (n[t.nodeName.toLowerCase()] || t.length > 0) return !0;
}
var l, c, u, s = n, d = S.getRng(!0);
new o(k).normalize(d);
var f = d.startOffset, p = d.startContainer;
if (1 == p.nodeType && p.hasChildNodes()) {
var g = f > p.childNodes.length - 1;
p = p.childNodes[Math.min(f, p.childNodes.length - 1)] || p, f = g && 3 == p.nodeType ? p.nodeValue.length :0;
}
var v = k.getParent(p, k.isBlock), y = v ? v.nodeName.toUpperCase() :"", b = v ? k.getParent(v.parentNode, k.isBlock) :null, C = b ? b.nodeName.toUpperCase() :"", x = s && s.ctrlKey;
"LI" != C || x || (v = b, y = C), p && 3 == p.nodeType && f >= p.nodeValue.length && (h || i() || (l = k.create("br"), 
d.insertNode(l), d.setStartAfter(l), d.setEndAfter(l), c = !0)), l = k.create("br"), 
d.insertNode(l);
var w = k.doc.documentMode;
return h && "PRE" == y && (!w || 8 > w) && l.parentNode.insertBefore(k.doc.createTextNode("\r"), l), 
u = k.create("span", {}, "&nbsp;"), l.parentNode.insertBefore(u, l), S.scrollIntoView(u), 
k.remove(u), c ? (d.setStartBefore(l), d.setEndBefore(l)) :(d.setStartAfter(l), 
d.setEndAfter(l)), S.setRng(d), r.undoManager.add(), m;
}
}), C({
"JustifyLeft,JustifyCenter,JustifyRight,JustifyFull":function(e) {
var t = "align" + e.substring(7), n = S.isCollapsed() ? [ k.getParent(S.getNode(), k.isBlock) ] :S.getSelectedBlocks(), r = c(n, function(e) {
return !!A.matchNode(e, t);
});
return -1 !== u(r, m);
},
"Bold,Italic,Underline,Strikethrough,Superscript,Subscript":function(e) {
return w(e);
},
mceBlockQuote:function() {
return w("blockquote");
},
Outdent:function() {
var e;
if (R.inline_styles) {
if ((e = k.getParent(S.getStart(), k.isBlock)) && parseInt(e.style.paddingLeft, 10) > 0) return m;
if ((e = k.getParent(S.getEnd(), k.isBlock)) && parseInt(e.style.paddingLeft, 10) > 0) return m;
}
return y("InsertUnorderedList") || y("InsertOrderedList") || !R.inline_styles && !!k.getParent(S.getNode(), "BLOCKQUOTE");
},
"InsertUnorderedList,InsertOrderedList":function(e) {
var t = k.getParent(S.getNode(), "ul,ol");
return t && ("insertunorderedlist" === e && "UL" === t.tagName || "insertorderedlist" === e && "OL" === t.tagName);
}
}, "state"), C({
"FontSize,FontName":function(e) {
var n, t = 0;
return (n = k.getParent(S.getNode(), "span")) && (t = "fontsize" == e ? n.style.fontSize :n.style.fontFamily.replace(/, /g, ",").replace(/[\'\"]/g, "").toLowerCase()), 
t;
}
}, "value"), C({
Undo:function() {
r.undoManager.undo();
},
Redo:function() {
r.undoManager.redo();
}
});
};
}), r(W, [ u ], function(e) {
function t(e, o) {
var s, l, a = this;
if (e = r(e), o = a.settings = o || {}, s = o.base_uri, /^([\w\-]+):([^\/]{2})/i.test(e) || /^\s*#/.test(e)) return void (a.source = e);
var c = 0 === e.indexOf("//");
0 !== e.indexOf("/") || c || (e = (s ? s.protocol || "http" :"http") + "://mce_host" + e), 
/^[\w\-]*:?\/\//.test(e) || (l = o.base_uri ? o.base_uri.path :new t(location.href).directory, 
"" === o.base_uri.protocol ? e = "//mce_host" + a.toAbsPath(l, e) :(e = /([^#?]*)([#?]?.*)/.exec(e), 
e = (s && s.protocol || "http") + "://mce_host" + a.toAbsPath(l, e[1]) + e[2])), 
e = e.replace(/@@/g, "(mce_at)"), e = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(e), 
n(i, function(t, n) {
var r = e[n];
r && (r = r.replace(/\(mce_at\)/g, "@@")), a[t] = r;
}), s && (a.protocol || (a.protocol = s.protocol), a.userInfo || (a.userInfo = s.userInfo), 
a.port || "mce_host" !== a.host || (a.port = s.port), a.host && "mce_host" !== a.host || (a.host = s.host), 
a.source = ""), c && (a.protocol = "");
}
var n = e.each, r = e.trim, i = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" "), o = {
ftp:21,
http:80,
https:443,
mailto:25
};
return t.prototype = {
setPath:function(e) {
var t = this;
e = /^(.*?)\/?(\w+)?$/.exec(e), t.path = e[0], t.directory = e[1], t.file = e[2], 
t.source = "", t.getURI();
},
toRelative:function(e) {
var r, n = this;
if ("./" === e) return e;
if (e = new t(e, {
base_uri:n
}), "mce_host" != e.host && n.host != e.host && e.host || n.port != e.port || n.protocol != e.protocol && "" !== e.protocol) return e.getURI();
var i = n.getURI(), o = e.getURI();
return i == o || "/" == i.charAt(i.length - 1) && i.substr(0, i.length - 1) == o ? i :(r = n.toRelPath(n.path, e.path), 
e.query && (r += "?" + e.query), e.anchor && (r += "#" + e.anchor), r);
},
toAbsolute:function(e, n) {
return e = new t(e, {
base_uri:this
}), e.getURI(n && this.isSameOrigin(e));
},
isSameOrigin:function(e) {
if (this.host == e.host && this.protocol == e.protocol) {
if (this.port == e.port) return !0;
var t = o[this.protocol];
if (t && (this.port || t) == (e.port || t)) return !0;
}
return !1;
},
toRelPath:function(e, t) {
var n, o, a, r = 0, i = "";
if (e = e.substring(0, e.lastIndexOf("/")), e = e.split("/"), n = t.split("/"), 
e.length >= n.length) for (o = 0, a = e.length; a > o; o++) if (o >= n.length || e[o] != n[o]) {
r = o + 1;
break;
}
if (e.length < n.length) for (o = 0, a = n.length; a > o; o++) if (o >= e.length || e[o] != n[o]) {
r = o + 1;
break;
}
if (1 === r) return t;
for (o = 0, a = e.length - (r - 1); a > o; o++) i += "../";
for (o = r - 1, a = n.length; a > o; o++) i += o != r - 1 ? "/" + n[o] :n[o];
return i;
},
toAbsPath:function(e, t) {
var r, a, s, i = 0, o = [];
for (a = /\/$/.test(t) ? "/" :"", e = e.split("/"), t = t.split("/"), n(e, function(e) {
e && o.push(e);
}), e = o, r = t.length - 1, o = []; r >= 0; r--) 0 !== t[r].length && "." !== t[r] && (".." !== t[r] ? i > 0 ? i-- :o.push(t[r]) :i++);
return r = e.length - i, s = 0 >= r ? o.reverse().join("/") :e.slice(0, r).join("/") + "/" + o.reverse().join("/"), 
0 !== s.indexOf("/") && (s = "/" + s), a && s.lastIndexOf("/") !== s.length - 1 && (s += a), 
s;
},
getURI:function(e) {
var t, n = this;
return (!n.source || e) && (t = "", e || (t += n.protocol ? n.protocol + "://" :"//", 
n.userInfo && (t += n.userInfo + "@"), n.host && (t += n.host), n.port && (t += ":" + n.port)), 
n.path && (t += n.path), n.query && (t += "?" + n.query), n.anchor && (t += "#" + n.anchor), 
n.source = t), n.source;
}
}, t;
}), r(V, [ u ], function(e) {
function t() {}
var i, o, n = e.each, r = e.extend;
return t.extend = i = function(e) {
function t() {
var e, t, n, r = this;
if (!o && (r.init && r.init.apply(r, arguments), t = r.Mixins)) for (e = t.length; e--; ) n = t[e], 
n.init && n.init.apply(r, arguments);
}
function a() {
return this;
}
function s(e, t) {
return function() {
var i, n = this, r = n._super;
return n._super = c[e], i = t.apply(n, arguments), n._super = r, i;
};
}
var u, d, f, l = this, c = l.prototype;
o = !0, u = new l(), o = !1, e.Mixins && (n(e.Mixins, function(t) {
t = t;
for (var n in t) "init" !== n && (e[n] = t[n]);
}), c.Mixins && (e.Mixins = c.Mixins.concat(e.Mixins))), e.Methods && n(e.Methods.split(","), function(t) {
e[t] = a;
}), e.Properties && n(e.Properties.split(","), function(t) {
var n = "_" + t;
e[t] = function(e) {
var r, t = this;
return e !== r ? (t[n] = e, t) :t[n];
};
}), e.Statics && n(e.Statics, function(e, n) {
t[n] = e;
}), e.Defaults && c.Defaults && (e.Defaults = r({}, c.Defaults, e.Defaults));
for (d in e) f = e[d], u[d] = "function" == typeof f && c[d] ? s(d, f) :f;
return t.prototype = u, t.constructor = t, t.extend = i, t;
}, t;
}), r(U, [ u ], function(e) {
function t(e) {
function t() {
return !1;
}
function n() {
return !0;
}
function r(r, i) {
var a, s, l, d;
if (r = r.toLowerCase(), i = i || {}, i.type = r, i.target || (i.target = c), i.preventDefault || (i.preventDefault = function() {
i.isDefaultPrevented = n;
}, i.stopPropagation = function() {
i.isPropagationStopped = n;
}, i.stopImmediatePropagation = function() {
i.isImmediatePropagationStopped = n;
}, i.isDefaultPrevented = t, i.isPropagationStopped = t, i.isImmediatePropagationStopped = t), 
e.beforeFire && e.beforeFire(i), a = u[r]) for (s = 0, l = a.length; l > s; s++) {
if (a[s] = d = a[s], d.once && o(r, d), i.isImmediatePropagationStopped()) return i.stopPropagation(), 
i;
if (d.call(c, i) === !1) return i.preventDefault(), i;
}
return i;
}
function i(e, n, r) {
var i, o, a;
if (n === !1 && (n = t), n) for (o = e.toLowerCase().split(" "), a = o.length; a--; ) e = o[a], 
i = u[e], i || (i = u[e] = [], d(e, !0)), r ? i.unshift(n) :i.push(n);
return l;
}
function o(e, t) {
var n, r, i, o, a;
if (e) for (o = e.toLowerCase().split(" "), n = o.length; n--; ) {
if (e = o[n], r = u[e], !e) {
for (i in u) d(i, !1), delete u[i];
return l;
}
if (r) {
if (t) for (a = r.length; a--; ) r[a] === t && (r = r.slice(0, a).concat(r.slice(a + 1)), 
u[e] = r); else r.length = 0;
r.length || (d(e, !1), delete u[e]);
}
} else {
for (e in u) d(e, !1);
u = {};
}
return l;
}
function a(e, t, n) {
return t.once = !0, i(e, t, n);
}
function s(e) {
return e = e.toLowerCase(), !(!u[e] || 0 === u[e].length);
}
var c, d, l = this, u = {};
e = e || {}, c = e.scope || l, d = e.toggleEvent || t, l.fire = r, l.on = i, l.off = o, 
l.once = a, l.has = s;
}
var n = e.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate", " ");
return t.isNative = function(e) {
return !!n[e.toLowerCase()];
}, t;
}), r(q, [ V ], function(e) {
function t(e) {
for (var r, t = [], n = e.length; n--; ) r = e[n], r.__checked || (t.push(r), r.__checked = 1);
for (n = t.length; n--; ) delete t[n].__checked;
return t;
}
var o, n = /^([\w\\*]+)?(?:#([\w\\]+))?(?:\.([\w\\\.]+))?(?:\[\@?([\w\\]+)([\^\$\*!~]?=)([\w\\]+)\])?(?:\:(.+))?/i, r = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g, i = /^\s*|\s*$/g, a = e.extend({
init:function(e) {
function t(e) {
return e ? (e = e.toLowerCase(), function(t) {
return "*" === e || t.type === e;
}) :void 0;
}
function o(e) {
return e ? function(t) {
return t._name === e;
} :void 0;
}
function a(e) {
return e ? (e = e.split("."), function(t) {
for (var n = e.length; n--; ) if (!t.hasClass(e[n])) return !1;
return !0;
}) :void 0;
}
function s(e, t, n) {
return e ? function(r) {
var i = r[e] ? r[e]() :"";
return t ? "=" === t ? i === n :"*=" === t ? i.indexOf(n) >= 0 :"~=" === t ? (" " + i + " ").indexOf(" " + n + " ") >= 0 :"!=" === t ? i != n :"^=" === t ? 0 === i.indexOf(n) :"$=" === t ? i.substr(i.length - n.length) === n :!1 :!!n;
} :void 0;
}
function l(e) {
var t;
return e ? (e = /(?:not\((.+)\))|(.+)/i.exec(e), e[1] ? (t = u(e[1], []), function(e) {
return !d(e, t);
}) :(e = e[2], function(t, n, r) {
return "first" === e ? 0 === n :"last" === e ? n === r - 1 :"even" === e ? n % 2 === 0 :"odd" === e ? n % 2 === 1 :t[e] ? t[e]() :!1;
})) :void 0;
}
function c(e, r, c) {
function u(e) {
e && r.push(e);
}
var d;
return d = n.exec(e.replace(i, "")), u(t(d[1])), u(o(d[2])), u(a(d[3])), u(s(d[4], d[5], d[6])), 
u(l(d[7])), r.psuedo = !!d[7], r.direct = c, r;
}
function u(e, t) {
var i, o, a, n = [];
do if (r.exec(""), o = r.exec(e), o && (e = o[3], n.push(o[1]), o[2])) {
i = o[3];
break;
} while (o);
for (i && u(i, t), e = [], a = 0; a < n.length; a++) ">" != n[a] && e.push(c(n[a], [], ">" === n[a - 1]));
return t.push(e), t;
}
var d = this.match;
this._selectors = u(e, []);
},
match:function(e, t) {
var n, r, i, o, a, s, l, c, u, d, f, p, h;
for (t = t || this._selectors, n = 0, r = t.length; r > n; n++) {
for (a = t[n], o = a.length, h = e, p = 0, i = o - 1; i >= 0; i--) for (c = a[i]; h; ) {
if (c.psuedo) for (f = h.parent().items(), u = d = f.length; u-- && f[u] !== h; ) ;
for (s = 0, l = c.length; l > s; s++) if (!c[s](h, u, d)) {
s = l + 1;
break;
}
if (s === l) {
p++;
break;
}
if (i === o - 1) break;
h = h.parent();
}
if (p === o) return !0;
}
return !1;
},
find:function(e) {
function n(e, t, i) {
var o, a, s, l, c, u = t[i];
for (o = 0, a = e.length; a > o; o++) {
for (c = e[o], s = 0, l = u.length; l > s; s++) if (!u[s](c, o, a)) {
s = l + 1;
break;
}
if (s === l) i == t.length - 1 ? r.push(c) :c.items && n(c.items(), t, i + 1); else if (u.direct) return;
c.items && n(c.items(), t, i);
}
}
var i, s, r = [], l = this._selectors;
if (e.items) {
for (i = 0, s = l.length; s > i; i++) n(e.items(), l[i], 0);
s > 1 && (r = t(r));
}
return o || (o = a.Collection), new o(r);
}
});
return a;
}), r($, [ u, q, V ], function(e, t, n) {
var r, i, o = Array.prototype.push, a = Array.prototype.slice;
return i = {
length:0,
init:function(e) {
e && this.add(e);
},
add:function(t) {
var n = this;
return e.isArray(t) ? o.apply(n, t) :t instanceof r ? n.add(t.toArray()) :o.call(n, t), 
n;
},
set:function(e) {
var r, t = this, n = t.length;
for (t.length = 0, t.add(e), r = t.length; n > r; r++) delete t[r];
return t;
},
filter:function(e) {
var i, o, s, l, n = this, a = [];
for ("string" == typeof e ? (e = new t(e), l = function(t) {
return e.match(t);
}) :l = e, i = 0, o = n.length; o > i; i++) s = n[i], l(s) && a.push(s);
return new r(a);
},
slice:function() {
return new r(a.apply(this, arguments));
},
eq:function(e) {
return -1 === e ? this.slice(e) :this.slice(e, +e + 1);
},
each:function(t) {
return e.each(this, t), this;
},
toArray:function() {
return e.toArray(this);
},
indexOf:function(e) {
for (var t = this, n = t.length; n-- && t[n] !== e; ) ;
return n;
},
reverse:function() {
return new r(e.toArray(this).reverse());
},
hasClass:function(e) {
return this[0] ? this[0].hasClass(e) :!1;
},
prop:function(e, t) {
var r, i, n = this;
return t !== r ? (n.each(function(n) {
n[e] && n[e](t);
}), n) :(i = n[0], i && i[e] ? i[e]() :void 0);
},
exec:function(t) {
var n = this, r = e.toArray(arguments).slice(1);
return n.each(function(e) {
e[t] && e[t].apply(e, r);
}), n;
},
remove:function() {
for (var e = this.length; e--; ) this[e].remove();
return this;
}
}, e.each("fire on off show hide addClass removeClass append prepend before after reflow".split(" "), function(t) {
i[t] = function() {
var n = e.toArray(arguments);
return this.each(function(e) {
t in e && e[t].apply(e, n);
}), this;
};
}), e.each("text name disabled active selected checked visible parent value data".split(" "), function(e) {
i[e] = function(t) {
return this.prop(e, t);
};
}), r = n.extend(i), t.Collection = r, r;
}), r(j, [ u, y ], function(e, t) {
var n = 0;
return {
id:function() {
return "mceu_" + n++;
},
createFragment:function(e) {
return t.DOM.createFragment(e);
},
getWindowSize:function() {
return t.DOM.getViewPort();
},
getSize:function(e) {
var t, n;
if (e.getBoundingClientRect) {
var r = e.getBoundingClientRect();
t = Math.max(r.width || r.right - r.left, e.offsetWidth), n = Math.max(r.height || r.bottom - r.bottom, e.offsetHeight);
} else t = e.offsetWidth, n = e.offsetHeight;
return {
width:t,
height:n
};
},
getPos:function(e, n) {
return t.DOM.getPos(e, n);
},
getViewPort:function(e) {
return t.DOM.getViewPort(e);
},
get:function(e) {
return document.getElementById(e);
},
addClass:function(e, n) {
return t.DOM.addClass(e, n);
},
removeClass:function(e, n) {
return t.DOM.removeClass(e, n);
},
hasClass:function(e, n) {
return t.DOM.hasClass(e, n);
},
toggleClass:function(e, n, r) {
return t.DOM.toggleClass(e, n, r);
},
css:function(e, n, r) {
return t.DOM.setStyle(e, n, r);
},
on:function(e, n, r, i) {
return t.DOM.bind(e, n, r, i);
},
off:function(e, n, r) {
return t.DOM.unbind(e, n, r);
},
fire:function(e, n, r) {
return t.DOM.fire(e, n, r);
},
innerHtml:function(e, n) {
t.DOM.setHTML(e, n);
}
};
}), r(K, [ V, u, U, $, j ], function(e, t, n, r, i) {
function o(e) {
return e._eventDispatcher || (e._eventDispatcher = new n({
scope:e,
toggleEvent:function(t, r) {
r && n.isNative(t) && (e._nativeEvents || (e._nativeEvents = {}), e._nativeEvents[t] = !0, 
e._rendered && e.bindPendingEvents());
}
})), e._eventDispatcher;
}
var a = {}, s = "onmousewheel" in document, l = !1, c = "mce-", u = e.extend({
Statics:{
elementIdCache:a,
classPrefix:c
},
isRtl:function() {
return u.rtl;
},
classPrefix:c,
init:function(e) {
var r, o, n = this;
if (n.settings = e = t.extend({}, n.Defaults, e), n._id = e.id || i.id(), n._text = n._name = "", 
n._width = n._height = 0, n._aria = {
role:e.role
}, r = e.classes) for (r = r.split(" "), r.map = {}, o = r.length; o--; ) r.map[r[o]] = !0;
n._classes = r || [], n.visible(!0), t.each("title text width height name classes visible disabled active value".split(" "), function(t) {
var i, r = e[t];
r !== i ? n[t](r) :n["_" + t] === i && (n["_" + t] = !1);
}), n.on("click", function() {
return n.disabled() ? !1 :void 0;
}), e.classes && t.each(e.classes.split(" "), function(e) {
n.addClass(e);
}), n.settings = e, n._borderBox = n.parseBox(e.border), n._paddingBox = n.parseBox(e.padding), 
n._marginBox = n.parseBox(e.margin), e.hidden && n.hide();
},
Properties:"parent,title,text,width,height,disabled,active,name,value",
Methods:"renderHtml",
getContainerElm:function() {
return document.body;
},
getParentCtrl:function(e) {
for (var t, n = this.getRoot().controlIdLookup; e && n && !(t = n[e.id]); ) e = e.parentNode;
return t;
},
parseBox:function(e) {
var t, n = 10;
return e ? "number" == typeof e ? (e = e || 0, {
top:e,
left:e,
bottom:e,
right:e
}) :(e = e.split(" "), t = e.length, 1 === t ? e[1] = e[2] = e[3] = e[0] :2 === t ? (e[2] = e[0], 
e[3] = e[1]) :3 === t && (e[3] = e[1]), {
top:parseInt(e[0], n) || 0,
right:parseInt(e[1], n) || 0,
bottom:parseInt(e[2], n) || 0,
left:parseInt(e[3], n) || 0
}) :void 0;
},
borderBox:function() {
return this._borderBox;
},
paddingBox:function() {
return this._paddingBox;
},
marginBox:function() {
return this._marginBox;
},
measureBox:function(e, t) {
function n(t) {
var n = document.defaultView;
return n ? (t = t.replace(/[A-Z]/g, function(e) {
return "-" + e;
}), n.getComputedStyle(e, null).getPropertyValue(t)) :e.currentStyle[t];
}
function r(e) {
var t = parseFloat(n(e), 10);
return isNaN(t) ? 0 :t;
}
return {
top:r(t + "TopWidth"),
right:r(t + "RightWidth"),
bottom:r(t + "BottomWidth"),
left:r(t + "LeftWidth")
};
},
initLayoutRect:function() {
var n, r, a, s, l, c, u, d, f, p, e = this, t = e.settings, o = e.getEl();
n = e._borderBox = e._borderBox || e.measureBox(o, "border"), e._paddingBox = e._paddingBox || e.measureBox(o, "padding"), 
e._marginBox = e._marginBox || e.measureBox(o, "margin"), p = i.getSize(o), d = t.minWidth, 
f = t.minHeight, l = d || p.width, c = f || p.height, a = t.width, s = t.height, 
u = t.autoResize, u = "undefined" != typeof u ? u :!a && !s, a = a || l, s = s || c;
var h = n.left + n.right, m = n.top + n.bottom, g = t.maxWidth || 65535, v = t.maxHeight || 65535;
return e._layoutRect = r = {
x:t.x || 0,
y:t.y || 0,
w:a,
h:s,
deltaW:h,
deltaH:m,
contentW:a - h,
contentH:s - m,
innerW:a - h,
innerH:s - m,
startMinWidth:d || 0,
startMinHeight:f || 0,
minW:Math.min(l, g),
minH:Math.min(c, v),
maxW:g,
maxH:v,
autoResize:u,
scrollW:0
}, e._lastLayoutRect = {}, r;
},
layoutRect:function(e) {
var r, i, o, a, s, l, t = this, n = t._layoutRect;
return n || (n = t.initLayoutRect()), e ? (o = n.deltaW, a = n.deltaH, e.x !== s && (n.x = e.x), 
e.y !== s && (n.y = e.y), e.minW !== s && (n.minW = e.minW), e.minH !== s && (n.minH = e.minH), 
i = e.w, i !== s && (i = i < n.minW ? n.minW :i, i = i > n.maxW ? n.maxW :i, n.w = i, 
n.innerW = i - o), i = e.h, i !== s && (i = i < n.minH ? n.minH :i, i = i > n.maxH ? n.maxH :i, 
n.h = i, n.innerH = i - a), i = e.innerW, i !== s && (i = i < n.minW - o ? n.minW - o :i, 
i = i > n.maxW - o ? n.maxW - o :i, n.innerW = i, n.w = i + o), i = e.innerH, i !== s && (i = i < n.minH - a ? n.minH - a :i, 
i = i > n.maxH - a ? n.maxH - a :i, n.innerH = i, n.h = i + a), e.contentW !== s && (n.contentW = e.contentW), 
e.contentH !== s && (n.contentH = e.contentH), r = t._lastLayoutRect, (r.x !== n.x || r.y !== n.y || r.w !== n.w || r.h !== n.h) && (l = u.repaintControls, 
l && l.map && !l.map[t._id] && (l.push(t), l.map[t._id] = !0), r.x = n.x, r.y = n.y, 
r.w = n.w, r.h = n.h), t) :n;
},
repaint:function() {
var t, n, r, i, s, l, e = this, o = 0, a = 0;
l = document.createRange ? function(e) {
return e;
} :Math.round, t = e.getEl().style, r = e._layoutRect, s = e._lastRepaintRect || {}, 
i = e._borderBox, o = i.left + i.right, a = i.top + i.bottom, r.x !== s.x && (t.left = l(r.x) + "px", 
s.x = r.x), r.y !== s.y && (t.top = l(r.y) + "px", s.y = r.y), r.w !== s.w && (t.width = l(r.w - o) + "px", 
s.w = r.w), r.h !== s.h && (t.height = l(r.h - a) + "px", s.h = r.h), e._hasBody && r.innerW !== s.innerW && (n = e.getEl("body").style, 
n.width = l(r.innerW) + "px", s.innerW = r.innerW), e._hasBody && r.innerH !== s.innerH && (n = n || e.getEl("body").style, 
n.height = l(r.innerH) + "px", s.innerH = r.innerH), e._lastRepaintRect = s, e.fire("repaint", {}, !1);
},
on:function(e, t) {
function n(e) {
var t, n;
return "string" != typeof e ? e :function(i) {
return t || r.parentsAndSelf().each(function(r) {
var i = r.settings.callbacks;
return i && (t = i[e]) ? (n = r, !1) :void 0;
}), t.call(n, i);
};
}
var r = this;
return o(r).on(e, n(t)), r;
},
off:function(e, t) {
return o(this).off(e, t), this;
},
fire:function(e, t, n) {
var r = this;
if (t = t || {}, t.control || (t.control = r), t = o(r).fire(e, t), n !== !1 && r.parent) for (var i = r.parent(); i && !t.isPropagationStopped(); ) i.fire(e, t, !1), 
i = i.parent();
return t;
},
hasEventListeners:function(e) {
return o(this).has(e);
},
parents:function(e) {
var n, t = this, i = new r();
for (n = t.parent(); n; n = n.parent()) i.add(n);
return e && (i = i.filter(e)), i;
},
parentsAndSelf:function(e) {
return new r(this).add(this.parents(e));
},
next:function() {
var e = this.parent().items();
return e[e.indexOf(this) + 1];
},
prev:function() {
var e = this.parent().items();
return e[e.indexOf(this) - 1];
},
findCommonAncestor:function(e, t) {
for (var n; e; ) {
for (n = t; n && e != n; ) n = n.parent();
if (e == n) break;
e = e.parent();
}
return e;
},
hasClass:function(e, t) {
var n = this._classes[t || "control"];
return e = this.classPrefix + e, n && !!n.map[e];
},
addClass:function(e, t) {
var r, i, n = this;
return e = this.classPrefix + e, r = n._classes[t || "control"], r || (r = [], r.map = {}, 
n._classes[t || "control"] = r), r.map[e] || (r.map[e] = e, r.push(e), n._rendered && (i = n.getEl(t), 
i && (i.className = r.join(" ")))), n;
},
removeClass:function(e, t) {
var r, i, o, n = this;
if (e = this.classPrefix + e, r = n._classes[t || "control"], r && r.map[e]) for (delete r.map[e], 
i = r.length; i--; ) r[i] === e && r.splice(i, 1);
return n._rendered && (o = n.getEl(t), o && (o.className = r.join(" "))), n;
},
toggleClass:function(e, t, n) {
var r = this;
return t ? r.addClass(e, n) :r.removeClass(e, n), r;
},
classes:function(e) {
var t = this._classes[e || "control"];
return t ? t.join(" ") :"";
},
innerHtml:function(e) {
return i.innerHtml(this.getEl(), e), this;
},
getEl:function(e, t) {
var n, r = e ? this._id + "-" + e :this._id;
return n = a[r] = (t === !0 ? null :a[r]) || i.get(r);
},
visible:function(e) {
var n, t = this;
return "undefined" != typeof e ? (t._visible !== e && (t._rendered && (t.getEl().style.display = e ? "" :"none"), 
t._visible = e, n = t.parent(), n && (n._lastRect = null), t.fire(e ? "show" :"hide")), 
t) :t._visible;
},
show:function() {
return this.visible(!0);
},
hide:function() {
return this.visible(!1);
},
focus:function() {
try {
this.getEl().focus();
} catch (e) {}
return this;
},
blur:function() {
return this.getEl().blur(), this;
},
aria:function(e, t) {
var n = this, r = n.getEl(n.ariaTarget);
return "undefined" == typeof t ? n._aria[e] :(n._aria[e] = t, n._rendered && r.setAttribute("role" == e ? e :"aria-" + e, t), 
n);
},
encode:function(e, t) {
return t !== !1 && (e = this.translate(e)), (e || "").replace(/[&<>"]/g, function(e) {
return "&#" + e.charCodeAt(0) + ";";
});
},
translate:function(e) {
return u.translate ? u.translate(e) :e;
},
before:function(e) {
var t = this, n = t.parent();
return n && n.insert(e, n.items().indexOf(t), !0), t;
},
after:function(e) {
var t = this, n = t.parent();
return n && n.insert(e, n.items().indexOf(t)), t;
},
remove:function() {
var r, o, e = this, t = e.getEl(), n = e.parent();
if (e.items) {
var s = e.items().toArray();
for (o = s.length; o--; ) s[o].remove();
}
n && n.items && (r = [], n.items().each(function(t) {
t !== e && r.push(t);
}), n.items().set(r), n._lastRect = null), e._eventsRoot && e._eventsRoot == e && i.off(t);
var l = e.getRoot().controlIdLookup;
if (l && delete l[e._id], delete a[e._id], t && t.parentNode) {
var c = t.getElementsByTagName("*");
for (o = c.length; o--; ) delete a[c[o].id];
t.parentNode.removeChild(t);
}
return e._rendered = !1, e;
},
renderBefore:function(e) {
var t = this;
return e.parentNode.insertBefore(i.createFragment(t.renderHtml()), e), t.postRender(), 
t;
},
renderTo:function(e) {
var t = this;
return e = e || t.getContainerElm(), e.appendChild(i.createFragment(t.renderHtml())), 
t.postRender(), t;
},
postRender:function() {
var n, r, o, a, s, e = this, t = e.settings;
for (a in t) 0 === a.indexOf("on") && e.on(a.substr(2), t[a]);
if (e._eventsRoot) {
for (o = e.parent(); !s && o; o = o.parent()) s = o._eventsRoot;
if (s) for (a in s._nativeEvents) e._nativeEvents[a] = !0;
}
e.bindPendingEvents(), t.style && (n = e.getEl(), n && (n.setAttribute("style", t.style), 
n.style.cssText = t.style)), e._visible || i.css(e.getEl(), "display", "none"), 
e.settings.border && (r = e.borderBox(), i.css(e.getEl(), {
"border-top-width":r.top,
"border-right-width":r.right,
"border-bottom-width":r.bottom,
"border-left-width":r.left
}));
var l = e.getRoot();
l.controlIdLookup || (l.controlIdLookup = {}), l.controlIdLookup[e._id] = e;
for (var c in e._aria) e.aria(c, e._aria[c]);
e.fire("postrender", {}, !1);
},
scrollIntoView:function(e) {
function t(e, t) {
var n, r, i = e;
for (n = r = 0; i && i != t && i.nodeType; ) n += i.offsetLeft || 0, r += i.offsetTop || 0, 
i = i.offsetParent;
return {
x:n,
y:r
};
}
var i, o, a, s, l, c, n = this.getEl(), r = n.parentNode, u = t(n, r);
return i = u.x, o = u.y, a = n.offsetWidth, s = n.offsetHeight, l = r.clientWidth, 
c = r.clientHeight, "end" == e ? (i -= l - a, o -= c - s) :"center" == e && (i -= l / 2 - a / 2, 
o -= c / 2 - s / 2), r.scrollLeft = i, r.scrollTop = o, this;
},
bindPendingEvents:function() {
function e(e) {
var t = o.getParentCtrl(e.target);
t && t.fire(e.type, e);
}
function t() {
var e = d._lastHoverCtrl;
e && (e.fire("mouseleave", {
target:e.getEl()
}), e.parents().each(function(e) {
e.fire("mouseleave", {
target:e.getEl()
});
}), d._lastHoverCtrl = null);
}
function n(e) {
var i, a, s, t = o.getParentCtrl(e.target), n = d._lastHoverCtrl, r = 0;
if (t !== n) {
if (d._lastHoverCtrl = t, a = t.parents().toArray().reverse(), a.push(t), n) {
for (s = n.parents().toArray().reverse(), s.push(n), r = 0; r < s.length && a[r] === s[r]; r++) ;
for (i = s.length - 1; i >= r; i--) n = s[i], n.fire("mouseleave", {
target:n.getEl()
});
}
for (i = r; i < a.length; i++) t = a[i], t.fire("mouseenter", {
target:t.getEl()
});
}
}
function r(e) {
e.preventDefault(), "mousewheel" == e.type ? (e.deltaY = -1 / 40 * e.wheelDelta, 
e.wheelDeltaX && (e.deltaX = -1 / 40 * e.wheelDeltaX)) :(e.deltaX = 0, e.deltaY = e.detail), 
e = o.fire("wheel", e);
}
var a, c, u, d, f, p, o = this;
if (o._rendered = !0, f = o._nativeEvents) {
for (u = o.parents().toArray(), u.unshift(o), a = 0, c = u.length; !d && c > a; a++) d = u[a]._eventsRoot;
for (d || (d = u[u.length - 1] || o), o._eventsRoot = d, c = a, a = 0; c > a; a++) u[a]._eventsRoot = d;
var h = d._delegates;
h || (h = d._delegates = {});
for (p in f) {
if (!f) return !1;
"wheel" !== p || l ? ("mouseenter" === p || "mouseleave" === p ? d._hasMouseEnter || (i.on(d.getEl(), "mouseleave", t), 
i.on(d.getEl(), "mouseover", n), d._hasMouseEnter = 1) :h[p] || (i.on(d.getEl(), p, e), 
h[p] = !0), f[p] = !1) :s ? i.on(o.getEl(), "mousewheel", r) :i.on(o.getEl(), "DOMMouseScroll", r);
}
}
},
getRoot:function() {
for (var t, e = this, n = []; e; ) {
if (e.rootControl) {
t = e.rootControl;
break;
}
n.push(e), t = e, e = e.parent();
}
t || (t = this);
for (var r = n.length; r--; ) n[r].rootControl = t;
return t;
},
reflow:function() {
return this.repaint(), this;
}
});
return u;
}), r(G, [], function() {
var t, e = {};
return {
add:function(t, n) {
e[t.toLowerCase()] = n;
},
has:function(t) {
return !!e[t.toLowerCase()];
},
create:function(n, r) {
var i, o, a;
if (!t) {
a = tinymce.ui;
for (o in a) e[o.toLowerCase()] = a[o];
t = !0;
}
if ("string" == typeof n ? (r = r || {}, r.type = n) :(r = n, n = r.type), n = n.toLowerCase(), 
i = e[n], !i) throw new Error("Could not find control by type: " + n);
return i = new i(r), i.type = n, i;
}
};
}), r(Y, [], function() {
return function(e) {
function t(e) {
return e = e || b, e && e.getAttribute("role");
}
function n(e) {
for (var n, r = e || b; r = r.parentNode; ) if (n = t(r)) return n;
}
function r(e) {
var t = b;
return t ? t.getAttribute("aria-" + e) :void 0;
}
function i(e) {
var t = e.tagName.toUpperCase();
return "INPUT" == t || "TEXTAREA" == t;
}
function o(e) {
return i(e) && !e.hidden ? !0 :/^(button|menuitem|checkbox|tab|menuitemcheckbox|option|gridcell)$/.test(t(e)) ? !0 :!1;
}
function a(e) {
function t(e) {
if (1 == e.nodeType && "none" != e.style.display) {
o(e) && n.push(e);
for (var r = 0; r < e.childNodes.length; r++) t(e.childNodes[r]);
}
}
var n = [];
return t(e || y.getEl()), n;
}
function s(e) {
var t, n;
e = e || C, n = e.parents().toArray(), n.unshift(e);
for (var r = 0; r < n.length && (t = n[r], !t.settings.ariaRoot); r++) ;
return t;
}
function l(e) {
var t = s(e), n = a(t.getEl());
t.settings.ariaRemember && "lastAriaIndex" in t ? c(t.lastAriaIndex, n) :c(0, n);
}
function c(e, t) {
return 0 > e ? e = t.length - 1 :e >= t.length && (e = 0), t[e] && t[e].focus(), 
e;
}
function u(e, t) {
var n = -1, r = s();
t = t || a(r.getEl());
for (var i = 0; i < t.length; i++) t[i] === b && (n = i);
n += e, r.lastAriaIndex = c(n, t);
}
function d() {
var e = n();
"tablist" == e ? u(-1, a(b.parentNode)) :C.parent().submenu ? g() :u(-1);
}
function f() {
var e = t(), i = n();
"tablist" == i ? u(1, a(b.parentNode)) :"menuitem" == e && "menu" == i && r("haspopup") ? v() :u(1);
}
function p() {
u(-1);
}
function h() {
var e = t(), i = n();
"menuitem" == e && "menubar" == i ? v() :"button" == e && r("haspopup") ? v({
key:"down"
}) :u(1);
}
function m(e) {
var t = n();
if ("tablist" == t) {
var r = a(C.getEl("body"))[0];
r && r.focus();
} else u(e.shiftKey ? -1 :1);
}
function g() {
C.fire("cancel");
}
function v(e) {
e = e || {}, C.fire("click", {
target:b,
aria:e
});
}
var b, C, y = e.root;
return b = document.activeElement, C = y.getParentCtrl(b), y.on("keydown", function(e) {
function t(e, t) {
i(b) || t(e) !== !1 && e.preventDefault();
}
if (!e.isDefaultPrevented()) switch (e.keyCode) {
case 37:
t(e, d);
break;

case 39:
t(e, f);
break;

case 38:
t(e, p);
break;

case 40:
t(e, h);
break;

case 27:
g();
break;

case 14:
case 13:
case 32:
t(e, v);
break;

case 9:
m(e) !== !1 && e.preventDefault();
}
}), y.on("focusin", function(e) {
b = e.target, C = e.control;
}), {
focusFirst:l
};
};
}), r(X, [ K, $, q, G, Y, u, j ], function(e, t, n, r, i, o, a) {
var s = {};
return e.extend({
layout:"",
innerClass:"container-inner",
init:function(e) {
var n = this;
n._super(e), e = n.settings, n._fixed = e.fixed, n._items = new t(), n.isRtl() && n.addClass("rtl"), 
n.addClass("container"), n.addClass("container-body", "body"), e.containerCls && n.addClass(e.containerCls), 
n._layout = r.create((e.layout || n.layout) + "layout"), n.settings.items && n.add(n.settings.items), 
n._hasBody = !0;
},
items:function() {
return this._items;
},
find:function(e) {
return e = s[e] = s[e] || new n(e), e.find(this);
},
add:function(e) {
var t = this;
return t.items().add(t.create(e)).parent(t), t;
},
focus:function(e) {
var n, r, i, t = this;
return e && (r = t.keyboardNav || t.parents().eq(-1)[0].keyboardNav) ? void r.focusFirst(t) :(i = t.find("*"), 
t.statusbar && i.add(t.statusbar.items()), i.each(function(e) {
return e.settings.autofocus ? (n = null, !1) :void (e.canFocus && (n = n || e));
}), n && n.focus(), t);
},
replace:function(e, t) {
for (var n, r = this.items(), i = r.length; i--; ) if (r[i] === e) {
r[i] = t;
break;
}
i >= 0 && (n = t.getEl(), n && n.parentNode.removeChild(n), n = e.getEl(), n && n.parentNode.removeChild(n)), 
t.parent(this);
},
create:function(t) {
var i, n = this, a = [];
return o.isArray(t) || (t = [ t ]), o.each(t, function(t) {
t && (t instanceof e || ("string" == typeof t && (t = {
type:t
}), i = o.extend({}, n.settings.defaults, t), t.type = i.type = i.type || t.type || n.settings.defaultType || (i.defaults ? i.defaults.type :null), 
t = r.create(i)), a.push(t));
}), a;
},
renderNew:function() {
var e = this;
return e.items().each(function(t, n) {
var r, i;
t.parent(e), t._rendered || (r = e.getEl("body"), i = a.createFragment(t.renderHtml()), 
r.hasChildNodes() && n <= r.childNodes.length - 1 ? r.insertBefore(i, r.childNodes[n]) :r.appendChild(i), 
t.postRender());
}), e._layout.applyClasses(e), e._lastRect = null, e;
},
append:function(e) {
return this.add(e).renderNew();
},
prepend:function(e) {
var t = this;
return t.items().set(t.create(e).concat(t.items().toArray())), t.renderNew();
},
insert:function(e, t, n) {
var i, o, a, r = this;
return e = r.create(e), i = r.items(), !n && t < i.length - 1 && (t += 1), t >= 0 && t < i.length && (o = i.slice(0, t).toArray(), 
a = i.slice(t).toArray(), i.set(o.concat(e, a))), r.renderNew();
},
fromJSON:function(e) {
var t = this;
for (var n in e) t.find("#" + n).value(e[n]);
return t;
},
toJSON:function() {
var e = this, t = {};
return e.find("*").each(function(e) {
var n = e.name(), r = e.value();
n && "undefined" != typeof r && (t[n] = r);
}), t;
},
preRender:function() {},
renderHtml:function() {
var e = this, t = e._layout, n = this.settings.role;
return e.preRender(), t.preRender(e), '<div id="' + e._id + '" class="' + e.classes() + '"' + (n ? ' role="' + this.settings.role + '"' :"") + '><div id="' + e._id + '-body" class="' + e.classes("body") + '">' + (e.settings.html || "") + t.renderHtml(e) + "</div></div>";
},
postRender:function() {
var t, e = this;
return e.items().exec("postRender"), e._super(), e._layout.postRender(e), e._rendered = !0, 
e.settings.style && a.css(e.getEl(), e.settings.style), e.settings.border && (t = e.borderBox(), 
a.css(e.getEl(), {
"border-top-width":t.top,
"border-right-width":t.right,
"border-bottom-width":t.bottom,
"border-left-width":t.left
})), e.parent() || (e.keyboardNav = new i({
root:e
})), e;
},
initLayoutRect:function() {
var e = this, t = e._super();
return e._layout.recalc(e), t;
},
recalc:function() {
var e = this, t = e._layoutRect, n = e._lastRect;
return n && n.w == t.w && n.h == t.h ? void 0 :(e._layout.recalc(e), t = e.layoutRect(), 
e._lastRect = {
x:t.x,
y:t.y,
w:t.w,
h:t.h
}, !0);
},
reflow:function() {
var t;
if (this.visible()) {
for (e.repaintControls = [], e.repaintControls.map = {}, this.recalc(), t = e.repaintControls.length; t--; ) e.repaintControls[t].repaint();
"flow" !== this.settings.layout && "stack" !== this.settings.layout && this.repaint(), 
e.repaintControls = [];
}
return this;
}
});
}), r(J, [ j ], function(e) {
function t() {
var t, n, r, i, o, a, s, l, e = document, c = Math.max;
return t = e.documentElement, n = e.body, r = c(t.scrollWidth, n.scrollWidth), i = c(t.clientWidth, n.clientWidth), 
o = c(t.offsetWidth, n.offsetWidth), a = c(t.scrollHeight, n.scrollHeight), s = c(t.clientHeight, n.clientHeight), 
l = c(t.offsetHeight, n.offsetHeight), {
width:o > r ? i :r,
height:l > a ? s :a
};
}
return function(n, r) {
function i() {
return a.getElementById(r.handle || n);
}
var o, s, l, c, u, d, f, a = document;
r = r || {}, l = function(n) {
var p, h, l = t();
n.preventDefault(), s = n.button, p = i(), d = n.screenX, f = n.screenY, h = window.getComputedStyle ? window.getComputedStyle(p, null).getPropertyValue("cursor") :p.runtimeStyle.cursor, 
o = a.createElement("div"), e.css(o, {
position:"absolute",
top:0,
left:0,
width:l.width,
height:l.height,
zIndex:2147483647,
opacity:1e-4,
cursor:h
}), a.body.appendChild(o), e.on(a, "mousemove", u), e.on(a, "mouseup", c), r.start(n);
}, u = function(e) {
return e.button !== s ? c(e) :(e.deltaX = e.screenX - d, e.deltaY = e.screenY - f, 
e.preventDefault(), void r.drag(e));
}, c = function(t) {
e.off(a, "mousemove", u), e.off(a, "mouseup", c), o.parentNode.removeChild(o), r.stop && r.stop(t);
}, this.destroy = function() {
e.off(i());
}, e.on(i(), "mousedown", l);
};
}), r(Q, [ j, J ], function(e, t) {
return {
init:function() {
var e = this;
e.on("repaint", e.renderScroll);
},
renderScroll:function() {
function n() {
function t(t, a, s, l, c, u) {
var d, f, p, h, m, g, v, y, b;
if (f = i.getEl("scroll" + t)) {
if (y = a.toLowerCase(), b = s.toLowerCase(), i.getEl("absend") && e.css(i.getEl("absend"), y, i.layoutRect()[l] - 1), 
!c) return void e.css(f, "display", "none");
e.css(f, "display", "block"), d = i.getEl("body"), p = i.getEl("scroll" + t + "t"), 
h = d["client" + s] - 2 * o, h -= n && r ? f["client" + u] :0, m = d["scroll" + s], 
g = h / m, v = {}, v[y] = d["offset" + a] + o, v[b] = h, e.css(f, v), v = {}, v[y] = d["scroll" + a] * g, 
v[b] = h * g, e.css(p, v);
}
}
var n, r, a;
a = i.getEl("body"), n = a.scrollWidth > a.clientWidth, r = a.scrollHeight > a.clientHeight, 
t("h", "Left", "Width", "contentW", n, "Height"), t("v", "Top", "Height", "contentH", r, "Width");
}
function r() {
function n(n, r, a, s, l) {
var c, u = i._id + "-scroll" + n, d = i.classPrefix;
i.getEl().appendChild(e.createFragment('<div id="' + u + '" class="' + d + "scrollbar " + d + "scrollbar-" + n + '"><div id="' + u + 't" class="' + d + 'scrollbar-thumb"></div></div>')), 
i.draghelper = new t(u + "t", {
start:function() {
c = i.getEl("body")["scroll" + r], e.addClass(e.get(u), d + "active");
},
drag:function(e) {
var t, u, d, f, p = i.layoutRect();
u = p.contentW > p.innerW, d = p.contentH > p.innerH, f = i.getEl("body")["client" + a] - 2 * o, 
f -= u && d ? i.getEl("scroll" + n)["client" + l] :0, t = f / i.getEl("body")["scroll" + a], 
i.getEl("body")["scroll" + r] = c + e["delta" + s] / t;
},
stop:function() {
e.removeClass(e.get(u), d + "active");
}
});
}
i.addClass("scroll"), n("v", "Top", "Height", "Y", "Width"), n("h", "Left", "Width", "X", "Height");
}
var i = this, o = 2;
i.settings.autoScroll && (i._hasScroll || (i._hasScroll = !0, r(), i.on("wheel", function(e) {
var t = i.getEl("body");
t.scrollLeft += 10 * (e.deltaX || 0), t.scrollTop += 10 * e.deltaY, n();
}), e.on(i.getEl("body"), "scroll", n)), n());
}
};
}), r(Z, [ X, Q ], function(e, t) {
return e.extend({
Defaults:{
layout:"fit",
containerCls:"panel"
},
Mixins:[ t ],
renderHtml:function() {
var e = this, t = e._layout, n = e.settings.html;
return e.preRender(), t.preRender(e), "undefined" == typeof n ? n = '<div id="' + e._id + '-body" class="' + e.classes("body") + '">' + t.renderHtml(e) + "</div>" :("function" == typeof n && (n = n.call(e)), 
e._hasBody = !1), '<div id="' + e._id + '" class="' + e.classes() + '" hidefocus="1" tabindex="-1" role="group">' + (e._preBodyHtml || "") + n + "</div>";
}
});
}), r(et, [ j ], function(e) {
function t(t, n, r) {
var i, o, a, s, l, c, u, d, f, p;
return f = e.getViewPort(), o = e.getPos(n), a = o.x, s = o.y, t._fixed && (a -= f.x, 
s -= f.y), i = t.getEl(), p = e.getSize(i), l = p.width, c = p.height, p = e.getSize(n), 
u = p.width, d = p.height, r = (r || "").split(""), "b" === r[0] && (s += d), "r" === r[1] && (a += u), 
"c" === r[0] && (s += Math.round(d / 2)), "c" === r[1] && (a += Math.round(u / 2)), 
"b" === r[3] && (s -= c), "r" === r[4] && (a -= l), "c" === r[3] && (s -= Math.round(c / 2)), 
"c" === r[4] && (a -= Math.round(l / 2)), {
x:a,
y:s,
w:l,
h:c
};
}
return {
testMoveRel:function(n, r) {
for (var i = e.getViewPort(), o = 0; o < r.length; o++) {
var a = t(this, n, r[o]);
if (this._fixed) {
if (a.x > 0 && a.x + a.w < i.w && a.y > 0 && a.y + a.h < i.h) return r[o];
} else if (a.x > i.x && a.x + a.w < i.w + i.x && a.y > i.y && a.y + a.h < i.h + i.y) return r[o];
}
return r[0];
},
moveRel:function(e, n) {
"string" != typeof n && (n = this.testMoveRel(e, n));
var r = t(this, e, n);
return this.moveTo(r.x, r.y);
},
moveBy:function(e, t) {
var n = this, r = n.layoutRect();
return n.moveTo(r.x + e, r.y + t), n;
},
moveTo:function(t, n) {
function r(e, t, n) {
return 0 > e ? 0 :e + n > t ? (e = t - n, 0 > e ? 0 :e) :e;
}
var i = this;
if (i.settings.constrainToViewport) {
var o = e.getViewPort(window), a = i.layoutRect();
t = r(t, o.w + o.x, a.w), n = r(n, o.h + o.y, a.h);
}
return i._rendered ? i.layoutRect({
x:t,
y:n
}).repaint() :(i.settings.x = t, i.settings.y = n), i.fire("move", {
x:t,
y:n
}), i;
}
};
}), r(tt, [ j ], function(e) {
return {
resizeToContent:function() {
this._layoutRect.autoResize = !0, this._lastRect = null, this.reflow();
},
resizeTo:function(t, n) {
if (1 >= t || 1 >= n) {
var r = e.getWindowSize();
t = 1 >= t ? t * r.w :t, n = 1 >= n ? n * r.h :n;
}
return this._layoutRect.autoResize = !1, this.layoutRect({
minW:t,
minH:n,
w:t,
h:n
}).reflow();
},
resizeBy:function(e, t) {
var n = this, r = n.layoutRect();
return n.resizeTo(r.w + e, r.h + t);
}
};
}), r(nt, [ Z, et, tt, j ], function(e, t, n, r) {
function i() {
function e(e, t) {
for (;e; ) {
if (e == t) return !0;
e = e.parent();
}
}
c || (c = function(t) {
if (2 != t.button) for (var n = f.length; n--; ) {
var r = f[n], i = r.getParentCtrl(t.target);
if (r.settings.autohide) {
if (i && (e(i, r) || r.parent() === i)) continue;
t = r.fire("autohide", {
target:t.target
}), t.isDefaultPrevented() || r.hide();
}
}
}, r.on(document, "click", c));
}
function o() {
u || (u = function() {
var e;
for (e = f.length; e--; ) s(f[e]);
}, r.on(window, "scroll", u));
}
function a() {
d || (d = function() {
m.hideAll();
}, r.on(window, "resize", d));
}
function s(e) {
function t(t, n) {
for (var r, i = 0; i < f.length; i++) if (f[i] != e) for (r = f[i].parent(); r && (r = r.parent()); ) r == e && f[i].fixed(t).moveBy(0, n).repaint();
}
var n = r.getViewPort().y;
e.settings.autofix && (e._fixed ? e._autoFixY > n && (e.fixed(!1).layoutRect({
y:e._autoFixY
}).repaint(), t(!1, e._autoFixY - n)) :(e._autoFixY = e.layoutRect().y, e._autoFixY < n && (e.fixed(!0).layoutRect({
y:0
}).repaint(), t(!0, n - e._autoFixY))));
}
function l(e) {
var t;
for (t = f.length; t--; ) f[t] === e && f.splice(t, 1);
for (t = p.length; t--; ) p[t] === e && p.splice(t, 1);
}
var c, u, d, h, f = [], p = [], m = e.extend({
Mixins:[ t, n ],
init:function(e) {
function t() {
var e, i, t = m.zIndex || 65535;
if (p.length) for (e = 0; e < p.length; e++) p[e].modal && (t++, i = p[e]), p[e].getEl().style.zIndex = t, 
p[e].zIndex = t, t++;
var o = document.getElementById(n.classPrefix + "modal-block");
i ? r.css(o, "z-index", i.zIndex - 1) :o && (o.parentNode.removeChild(o), h = !1), 
m.currentZIndex = t;
}
var n = this;
n._super(e), n._eventsRoot = n, n.addClass("floatpanel"), e.autohide && (i(), a(), 
f.push(n)), e.autofix && (o(), n.on("move", function() {
s(this);
})), n.on("postrender show", function(e) {
if (e.control == n) {
var i, o = n.classPrefix;
n.modal && !h && (i = r.createFragment('<div id="' + o + 'modal-block" class="' + o + "reset " + o + 'fade"></div>'), 
i = i.firstChild, n.getContainerElm().appendChild(i), setTimeout(function() {
r.addClass(i, o + "in"), r.addClass(n.getEl(), o + "in");
}, 0), h = !0), p.push(n), t();
}
}), n.on("close hide", function(e) {
if (e.control == n) {
for (var r = p.length; r--; ) p[r] === n && p.splice(r, 1);
t();
}
}), n.on("show", function() {
n.parents().each(function(e) {
return e._fixed ? (n.fixed(!0), !1) :void 0;
});
}), e.popover && (n._preBodyHtml = '<div class="' + n.classPrefix + 'arrow"></div>', 
n.addClass("popover").addClass("bottom").addClass(n.isRtl() ? "end" :"start"));
},
fixed:function(e) {
var t = this;
if (t._fixed != e) {
if (t._rendered) {
var n = r.getViewPort();
e ? t.layoutRect().y -= n.y :t.layoutRect().y += n.y;
}
t.toggleClass("fixed", e), t._fixed = e;
}
return t;
},
show:function() {
var t, e = this, n = e._super();
for (t = f.length; t-- && f[t] !== e; ) ;
return -1 === t && f.push(e), n;
},
hide:function() {
return l(this), this._super();
},
hideAll:function() {
m.hideAll();
},
close:function() {
var e = this;
return e.fire("close"), e.remove();
},
remove:function() {
l(this), this._super();
},
postRender:function() {
var e = this;
return e.settings.bodyRole && this.getEl("body").setAttribute("role", e.settings.bodyRole), 
e._super();
}
});
return m.hideAll = function() {
for (var e = f.length; e--; ) {
var t = f[e];
t && t.settings.autohide && (t.hide(), f.splice(e, 1));
}
}, m;
}), r(rt, [ nt, Z, j, J ], function(e, t, n, r) {
var i = e.extend({
modal:!0,
Defaults:{
border:1,
layout:"flex",
containerCls:"panel",
role:"dialog",
callbacks:{
submit:function() {
this.fire("submit", {
data:this.toJSON()
});
},
close:function() {
this.close();
}
}
},
init:function(e) {
var n = this;
n._super(e), n.isRtl() && n.addClass("rtl"), n.addClass("window"), n._fixed = !0, 
e.buttons && (n.statusbar = new t({
layout:"flex",
border:"1 0 0 0",
spacing:3,
padding:10,
align:"center",
pack:n.isRtl() ? "start" :"end",
defaults:{
type:"button"
},
items:e.buttons
}), n.statusbar.addClass("foot"), n.statusbar.parent(n)), n.on("click", function(e) {
-1 != e.target.className.indexOf(n.classPrefix + "close") && n.close();
}), n.on("cancel", function() {
n.close();
}), n.aria("describedby", n.describedBy || n._id + "-none"), n.aria("label", e.title), 
n._fullscreen = !1;
},
recalc:function() {
var r, i, o, a, e = this, t = e.statusbar;
e._fullscreen && (e.layoutRect(n.getWindowSize()), e.layoutRect().contentH = e.layoutRect().innerH), 
e._super(), r = e.layoutRect(), e.settings.title && !e._fullscreen && (i = r.headerW, 
i > r.w && (o = r.x - Math.max(0, i / 2), e.layoutRect({
w:i,
x:o
}), a = !0)), t && (t.layoutRect({
w:e.layoutRect().innerW
}).recalc(), i = t.layoutRect().minW + r.deltaW, i > r.w && (o = r.x - Math.max(0, i - r.w), 
e.layoutRect({
w:i,
x:o
}), a = !0)), a && e.recalc();
},
initLayoutRect:function() {
var i, e = this, t = e._super(), r = 0;
if (e.settings.title && !e._fullscreen) {
i = e.getEl("head");
var o = n.getSize(i);
t.headerW = o.width, t.headerH = o.height, r += t.headerH;
}
e.statusbar && (r += e.statusbar.layoutRect().h), t.deltaH += r, t.minH += r, t.h += r;
var a = n.getWindowSize();
return t.x = Math.max(0, a.w / 2 - t.w / 2), t.y = Math.max(0, a.h / 2 - t.h / 2), 
t;
},
renderHtml:function() {
var e = this, t = e._layout, n = e._id, r = e.classPrefix, i = e.settings, o = "", a = "", s = i.html;
return e.preRender(), t.preRender(e), i.title && (o = '<div id="' + n + '-head" class="' + r + 'window-head"><div id="' + n + '-title" class="' + r + 'title">' + e.encode(i.title) + '</div><button type="button" class="' + r + 'close" aria-hidden="true">\xd7</button><div id="' + n + '-dragh" class="' + r + 'dragh"></div></div>'), 
i.url && (s = '<iframe src="' + i.url + '" tabindex="-1"></iframe>'), "undefined" == typeof s && (s = t.renderHtml(e)), 
e.statusbar && (a = e.statusbar.renderHtml()), '<div id="' + n + '" class="' + e.classes() + '" hidefocus="1"><div class="' + e.classPrefix + 'reset" role="application">' + o + '<div id="' + n + '-body" class="' + e.classes("body") + '">' + s + "</div>" + a + "</div></div>";
},
fullscreen:function(e) {
var i, a, t = this, r = document.documentElement, o = t.classPrefix;
if (e != t._fullscreen) if (n.on(window, "resize", function() {
var e;
if (t._fullscreen) if (i) t._timer || (t._timer = setTimeout(function() {
var e = n.getWindowSize();
t.moveTo(0, 0).resizeTo(e.w, e.h), t._timer = 0;
}, 50)); else {
e = new Date().getTime();
var r = n.getWindowSize();
t.moveTo(0, 0).resizeTo(r.w, r.h), new Date().getTime() - e > 50 && (i = !0);
}
}), a = t.layoutRect(), t._fullscreen = e, e) {
t._initial = {
x:a.x,
y:a.y,
w:a.w,
h:a.h
}, t._borderBox = t.parseBox("0"), t.getEl("head").style.display = "none", a.deltaH -= a.headerH + 2, 
n.addClass(r, o + "fullscreen"), n.addClass(document.body, o + "fullscreen"), t.addClass("fullscreen");
var s = n.getWindowSize();
t.moveTo(0, 0).resizeTo(s.w, s.h);
} else t._borderBox = t.parseBox(t.settings.border), t.getEl("head").style.display = "", 
a.deltaH += a.headerH, n.removeClass(r, o + "fullscreen"), n.removeClass(document.body, o + "fullscreen"), 
t.removeClass("fullscreen"), t.moveTo(t._initial.x, t._initial.y).resizeTo(t._initial.w, t._initial.h);
return t.reflow();
},
postRender:function() {
var t, e = this;
setTimeout(function() {
e.addClass("in");
}, 0), e._super(), e.statusbar && e.statusbar.postRender(), e.focus(), this.dragHelper = new r(e._id + "-dragh", {
start:function() {
t = {
x:e.layoutRect().x,
y:e.layoutRect().y
};
},
drag:function(n) {
e.moveTo(t.x + n.deltaX, t.y + n.deltaY);
}
}), e.on("submit", function(t) {
t.isDefaultPrevented() || e.close();
});
},
submit:function() {
return this.fire("submit", {
data:this.toJSON()
});
},
remove:function() {
var e = this, t = e.classPrefix;
e.dragHelper.destroy(), e._super(), e.statusbar && this.statusbar.remove(), e._fullscreen && (n.removeClass(document.documentElement, t + "fullscreen"), 
n.removeClass(document.body, t + "fullscreen"));
},
getContentWindow:function() {
var e = this.getEl().getElementsByTagName("iframe")[0];
return e ? e.contentWindow :null;
}
});
return i;
}), r(it, [ rt ], function(e) {
var t = e.extend({
init:function(e) {
e = {
border:1,
padding:20,
layout:"flex",
pack:"center",
align:"center",
containerCls:"panel",
autoScroll:!0,
buttons:{
type:"button",
text:"Ok",
action:"ok"
},
items:{
type:"label",
multiline:!0,
maxWidth:500,
maxHeight:200
}
}, this._super(e);
},
Statics:{
OK:1,
OK_CANCEL:2,
YES_NO:3,
YES_NO_CANCEL:4,
msgBox:function(n) {
var r, i = n.callback || function() {};
switch (n.buttons) {
case t.OK_CANCEL:
r = [ {
type:"button",
text:"Ok",
subtype:"primary",
onClick:function(e) {
e.control.parents()[1].close(), i(!0);
}
}, {
type:"button",
text:"Cancel",
onClick:function(e) {
e.control.parents()[1].close(), i(!1);
}
} ];
break;

case t.YES_NO:
r = [ {
type:"button",
text:"Ok",
subtype:"primary",
onClick:function(e) {
e.control.parents()[1].close(), i(!0);
}
} ];
break;

case t.YES_NO_CANCEL:
r = [ {
type:"button",
text:"Ok",
subtype:"primary",
onClick:function(e) {
e.control.parents()[1].close();
}
} ];
break;

default:
r = [ {
type:"button",
text:"Ok",
subtype:"primary",
onClick:function(e) {
e.control.parents()[1].close(), i(!0);
}
} ];
}
return new e({
padding:20,
x:n.x,
y:n.y,
minWidth:300,
minHeight:100,
layout:"flex",
pack:"center",
align:"center",
buttons:r,
title:n.title,
role:"alertdialog",
items:{
type:"label",
multiline:!0,
maxWidth:500,
maxHeight:200,
text:n.text
},
onPostRender:function() {
this.aria("describedby", this.items()[0]._id);
},
onClose:n.onClose,
onCancel:function() {
i(!1);
}
}).renderTo(document.body).reflow();
},
alert:function(e, n) {
return "string" == typeof e && (e = {
text:e
}), e.callback = n, t.msgBox(e);
},
confirm:function(e, n) {
return "string" == typeof e && (e = {
text:e
}), e.callback = n, e.buttons = t.OK_CANCEL, t.msgBox(e);
}
}
});
return t;
}), r(ot, [ rt, it ], function(e, t) {
return function(n) {
function r() {
return o.length ? o[o.length - 1] :void 0;
}
var i = this, o = [];
i.windows = o, i.open = function(t, r) {
var i;
return n.editorManager.activeEditor = n, t.title = t.title || " ", t.url = t.url || t.file, 
t.url && (t.width = parseInt(t.width || 320, 10), t.height = parseInt(t.height || 240, 10)), 
t.body && (t.items = {
defaults:t.defaults,
type:t.bodyType || "form",
items:t.body
}), t.url || t.buttons || (t.buttons = [ {
text:"Ok",
subtype:"primary",
onclick:function() {
i.find("form")[0].submit();
}
}, {
text:"Cancel",
onclick:function() {
i.close();
}
} ]), i = new e(t), o.push(i), i.on("close", function() {
for (var e = o.length; e--; ) o[e] === i && o.splice(e, 1);
n.focus();
}), t.data && i.on("postRender", function() {
this.find("*").each(function(e) {
var n = e.name();
n in t.data && e.value(t.data[n]);
});
}), i.features = t || {}, i.params = r || {}, n.nodeChanged(), i.renderTo().reflow();
}, i.alert = function(e, r, i) {
t.alert(e, function() {
r ? r.call(i || this) :n.focus();
});
}, i.confirm = function(e, n, r) {
t.confirm(e, function(e) {
n.call(r || this, e);
});
}, i.close = function() {
r() && r().close();
}, i.getParams = function() {
return r() ? r().params :null;
}, i.setParams = function(e) {
r() && (r().params = e);
}, i.getWindows = function() {
return o;
};
};
}), r(at, [ R, B, x, g, d, u ], function(e, t, n, r, i, o) {
return function(a) {
function s(e, t) {
try {
a.getDoc().execCommand(e, !1, t);
} catch (n) {}
}
function l() {
var e = a.getDoc().documentMode;
return e ? e :6;
}
function c(e) {
return e.isDefaultPrevented();
}
function u() {
function t(e) {
var t = new i(function() {});
o.each(a.getBody().getElementsByTagName("*"), function(e) {
"SPAN" == e.tagName && e.setAttribute("mce-data-marked", 1), !e.hasAttribute("data-mce-style") && e.hasAttribute("style") && a.dom.setAttrib(e, "style", e.getAttribute("style"));
}), t.observe(a.getDoc(), {
childList:!0,
attributes:!0,
subtree:!0,
attributeFilter:[ "style" ]
}), a.getDoc().execCommand(e ? "ForwardDelete" :"Delete", !1, null);
var n = a.selection.getRng(), r = n.startContainer.parentNode;
o.each(t.takeRecords(), function(e) {
if (q.isChildOf(e.target, a.getBody())) {
if ("style" == e.attributeName) {
var t = e.target.getAttribute("data-mce-style");
t ? e.target.setAttribute("style", t) :e.target.removeAttribute("style");
}
o.each(e.addedNodes, function(e) {
if ("SPAN" == e.nodeName && !e.getAttribute("mce-data-marked")) {
var t, i;
e == r && (t = n.startOffset, i = e.firstChild), q.remove(e, !0), i && (n.setStart(i, t), 
n.setEnd(i, t), a.selection.setRng(n));
}
});
}
}), t.disconnect(), o.each(a.dom.select("span[mce-data-marked]"), function(e) {
e.removeAttribute("mce-data-marked");
});
}
var s, l, n = a.getDoc(), r = "data:text/mce-internal,", i = window.MutationObserver;
i || (s = !0, i = function() {
function e(e) {
var t = e.relatedNode || e.target;
n.push({
target:t,
addedNodes:[ t ]
});
}
function t(e) {
var t = e.relatedNode || e.target;
n.push({
target:t,
attributeName:e.attrName
});
}
var r, n = [];
this.observe = function(n) {
r = n, r.addEventListener("DOMSubtreeModified", e, !1), r.addEventListener("DOMNodeInsertedIntoDocument", e, !1), 
r.addEventListener("DOMNodeInserted", e, !1), r.addEventListener("DOMAttrModified", t, !1);
}, this.disconnect = function() {
r.removeEventListener("DOMSubtreeModified", e, !1), r.removeEventListener("DOMNodeInsertedIntoDocument", e, !1), 
r.removeEventListener("DOMNodeInserted", e, !1), r.removeEventListener("DOMAttrModified", t, !1);
}, this.takeRecords = function() {
return n;
};
}), a.on("keydown", function(n) {
var r = n.keyCode == U, i = e.metaKeyPressed(n);
if (!c(n) && (r || n.keyCode == V)) {
var o = a.selection.getRng(), s = o.startContainer, l = o.startOffset;
if (!i && o.collapsed && 3 == s.nodeType && (r ? l < s.data.length :l > 0)) return;
n.preventDefault(), i && a.selection.getSel().modify("extend", r ? "forward" :"backward", "word"), 
t(r);
}
}), a.on("keypress", function(n) {
c(n) || $.isCollapsed() || !n.charCode || e.metaKeyPressed(n) || (n.preventDefault(), 
t(!0), a.selection.setContent(String.fromCharCode(n.charCode)));
}), a.addCommand("Delete", function() {
t();
}), a.addCommand("ForwardDelete", function() {
t(!0);
}), s || (a.on("dragstart", function(e) {
var t;
a.selection.isCollapsed() && "IMG" == e.target.tagName && $.select(e.target), l = $.getRng(), 
t = a.selection.getContent(), t.length > 0 && e.dataTransfer.setData("URL", "data:text/mce-internal," + escape(t));
}), a.on("drop", function(e) {
if (!c(e)) {
var i = e.dataTransfer.getData("URL");
if (!i || -1 == i.indexOf(r) || !n.caretRangeFromPoint) return;
i = unescape(i.substr(r.length)), n.caretRangeFromPoint && (e.preventDefault(), 
window.setTimeout(function() {
var r = n.caretRangeFromPoint(e.x, e.y);
l && ($.setRng(l), l = null), t(), $.setRng(r), a.insertContent(i);
}, 0));
}
}), a.on("cut", function(e) {
!c(e) && e.clipboardData && (e.preventDefault(), e.clipboardData.clearData(), e.clipboardData.setData("text/html", a.selection.getContent()), 
e.clipboardData.setData("text/plain", a.selection.getContent({
format:"text"
})), t(!0));
}));
}
function d() {
function e(e) {
var t = q.create("body"), n = e.cloneContents();
return t.appendChild(n), $.serializer.serialize(t, {
format:"html"
});
}
function n(n) {
if (!n.setStart) {
if (n.item) return !1;
var r = n.duplicate();
return r.moveToElementText(a.getBody()), t.compareRanges(n, r);
}
var i = e(n), o = q.createRng();
o.selectNode(a.getBody());
var s = e(o);
return i === s;
}
a.on("keydown", function(e) {
var r, i, t = e.keyCode;
if (!c(e) && (t == U || t == V)) {
if (r = a.selection.isCollapsed(), i = a.getBody(), r && !q.isEmpty(i)) return;
if (!r && !n(a.selection.getRng())) return;
e.preventDefault(), a.setContent(""), i.firstChild && q.isBlock(i.firstChild) ? a.selection.setCursorLocation(i.firstChild, 0) :a.selection.setCursorLocation(i, 0), 
a.nodeChanged();
}
});
}
function f() {
a.on("keydown", function(t) {
!c(t) && 65 == t.keyCode && e.metaKeyPressed(t) && (t.preventDefault(), a.execCommand("SelectAll"));
});
}
function p() {
a.settings.content_editable || (q.bind(a.getDoc(), "focusin", function() {
$.setRng($.getRng());
}), q.bind(a.getDoc(), "mousedown", function(e) {
e.target == a.getDoc().documentElement && (a.getBody().focus(), $.setRng($.getRng()));
}));
}
function h() {
a.on("keydown", function(e) {
if (!c(e) && e.keyCode === V) {
if (!a.getBody().getElementsByTagName("hr").length) return;
if ($.isCollapsed() && 0 === $.getRng(!0).startOffset) {
var t = $.getNode(), n = t.previousSibling;
if ("HR" == t.nodeName) return q.remove(t), void e.preventDefault();
n && n.nodeName && "hr" === n.nodeName.toLowerCase() && (q.remove(n), e.preventDefault());
}
}
});
}
function m() {
window.Range.prototype.getClientRects || a.on("mousedown", function(e) {
if (!c(e) && "HTML" === e.target.nodeName) {
var t = a.getBody();
t.blur(), setTimeout(function() {
t.focus();
}, 0);
}
});
}
function g() {
a.on("click", function(e) {
e = e.target, /^(IMG|HR)$/.test(e.nodeName) && $.getSel().setBaseAndExtent(e, 0, e, 1), 
"A" == e.nodeName && q.hasClass(e, "mce-item-anchor") && $.select(e), a.nodeChanged();
});
}
function v() {
function e() {
var e = q.getAttribs($.getStart().cloneNode(!1));
return function() {
var t = $.getStart();
t !== a.getBody() && (q.setAttrib(t, "style", null), W(e, function(e) {
t.setAttributeNode(e.cloneNode(!0));
}));
};
}
function t() {
return !$.isCollapsed() && q.getParent($.getStart(), q.isBlock) != q.getParent($.getEnd(), q.isBlock);
}
a.on("keypress", function(n) {
var r;
return c(n) || 8 != n.keyCode && 46 != n.keyCode || !t() ? void 0 :(r = e(), a.getDoc().execCommand("delete", !1, null), 
r(), n.preventDefault(), !1);
}), q.bind(a.getDoc(), "cut", function(n) {
var r;
!c(n) && t() && (r = e(), setTimeout(function() {
r();
}, 0));
});
}
function y() {
var e, n;
a.on("selectionchange", function() {
n && (clearTimeout(n), n = 0), n = window.setTimeout(function() {
if (!a.removed) {
var n = $.getRng();
e && t.compareRanges(n, e) || (a.nodeChanged(), e = n);
}
}, 50);
});
}
function b() {
document.body.setAttribute("role", "application");
}
function C() {
a.on("keydown", function(e) {
if (!c(e) && e.keyCode === V && $.isCollapsed() && 0 === $.getRng(!0).startOffset) {
var t = $.getNode().previousSibling;
if (t && t.nodeName && "table" === t.nodeName.toLowerCase()) return e.preventDefault(), 
!1;
}
});
}
function x() {
l() > 7 || (s("RespectVisibilityInDesign", !0), a.contentStyles.push(".mceHideBrInPre pre br {display: none}"), 
q.addClass(a.getBody(), "mceHideBrInPre"), K.addNodeFilter("pre", function(e) {
for (var r, i, o, a, t = e.length; t--; ) for (r = e[t].getAll("br"), i = r.length; i--; ) o = r[i], 
a = o.prev, a && 3 === a.type && "\n" != a.value.charAt(a.value - 1) ? a.value += "\n" :o.parent.insert(new n("#text", 3), o, !0).value = "\n";
}), G.addNodeFilter("pre", function(e) {
for (var n, r, i, o, t = e.length; t--; ) for (n = e[t].getAll("br"), r = n.length; r--; ) i = n[r], 
o = i.prev, o && 3 == o.type && (o.value = o.value.replace(/\r?\n$/, ""));
}));
}
function w() {
q.bind(a.getBody(), "mouseup", function() {
var e, t = $.getNode();
"IMG" == t.nodeName && ((e = q.getStyle(t, "width")) && (q.setAttrib(t, "width", e.replace(/[^0-9%]+/g, "")), 
q.setStyle(t, "width", "")), (e = q.getStyle(t, "height")) && (q.setAttrib(t, "height", e.replace(/[^0-9%]+/g, "")), 
q.setStyle(t, "height", "")));
});
}
function _() {
a.on("keydown", function(t) {
var n, r, i, o, s;
if (!c(t) && t.keyCode == e.BACKSPACE && (n = $.getRng(), r = n.startContainer, 
i = n.startOffset, o = q.getRoot(), s = r, n.collapsed && 0 === i)) {
for (;s && s.parentNode && s.parentNode.firstChild == s && s.parentNode != o; ) s = s.parentNode;
"BLOCKQUOTE" === s.tagName && (a.formatter.toggle("blockquote", null, s), n = q.createRng(), 
n.setStart(r, 0), n.setEnd(r, 0), $.setRng(n));
}
});
}
function N() {
function e() {
a._refreshContentEditable(), s("StyleWithCSS", !1), s("enableInlineTableEditing", !1), 
j.object_resizing || s("enableObjectResizing", !1);
}
j.readonly || a.on("BeforeExecCommand MouseDown", e);
}
function E() {
function e() {
W(q.select("a"), function(e) {
var t = e.parentNode, n = q.getRoot();
if (t.lastChild === e) {
for (;t && !q.isBlock(t); ) {
if (t.parentNode.lastChild !== t || t === n) return;
t = t.parentNode;
}
q.add(t, "br", {
"data-mce-bogus":1
});
}
});
}
a.on("SetContent ExecCommand", function(t) {
("setcontent" == t.type || "mceInsertLink" === t.command) && e();
});
}
function k() {
j.forced_root_block && a.on("init", function() {
s("DefaultParagraphSeparator", j.forced_root_block);
});
}
function S() {
a.on("Undo Redo SetContent", function(e) {
e.initial || a.execCommand("mceRepaint");
});
}
function T() {
a.on("keydown", function(e) {
var t;
c(e) || e.keyCode != V || (t = a.getDoc().selection.createRange(), t && t.item && (e.preventDefault(), 
a.undoManager.beforeChange(), q.remove(t.item(0)), a.undoManager.add()));
});
}
function R() {
var e;
l() >= 10 && (e = "", W("p div h1 h2 h3 h4 h5 h6".split(" "), function(t, n) {
e += (n > 0 ? "," :"") + t + ":empty";
}), a.contentStyles.push(e + "{padding-right: 1px !important}"));
}
function A() {
l() < 9 && (K.addNodeFilter("noscript", function(e) {
for (var n, r, t = e.length; t--; ) n = e[t], r = n.firstChild, r && n.attr("data-mce-innertext", r.value);
}), G.addNodeFilter("noscript", function(e) {
for (var i, o, a, t = e.length; t--; ) i = e[t], o = e[t].firstChild, o ? o.value = r.decode(o.value) :(a = i.attributes.map["data-mce-innertext"], 
a && (i.attr("data-mce-innertext", null), o = new n("#text", 3), o.value = a, o.raw = !0, 
i.append(o)));
}));
}
function B() {
function e(e, t) {
var n = i.createTextRange();
try {
n.moveToPoint(e, t);
} catch (r) {
n = null;
}
return n;
}
function t(t) {
var r;
t.button ? (r = e(t.x, t.y), r && (r.compareEndPoints("StartToStart", a) > 0 ? r.setEndPoint("StartToStart", a) :r.setEndPoint("EndToEnd", a), 
r.select())) :n();
}
function n() {
var e = r.selection.createRange();
a && !e.item && 0 === e.compareEndPoints("StartToEnd", e) && a.select(), q.unbind(r, "mouseup", n), 
q.unbind(r, "mousemove", t), a = o = 0;
}
var o, a, s, r = q.doc, i = r.body;
r.documentElement.unselectable = !0, q.bind(r, "mousedown contextmenu", function(i) {
if ("HTML" === i.target.nodeName) {
if (o && n(), s = r.documentElement, s.scrollHeight > s.clientHeight) return;
o = 1, a = e(i.x, i.y), a && (q.bind(r, "mouseup", n), q.bind(r, "mousemove", t), 
q.getRoot().focus(), a.select());
}
});
}
function D() {
a.on("keyup focusin mouseup", function(t) {
65 == t.keyCode && e.metaKeyPressed(t) || $.normalize();
}, !0);
}
function L() {
a.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
}
function M() {
a.inline || a.on("keydown", function() {
document.activeElement == document.body && a.getWin().focus();
});
}
function H() {
a.inline || (a.contentStyles.push("body {min-height: 150px}"), a.on("click", function(e) {
"HTML" == e.target.nodeName && (a.getBody().focus(), a.selection.normalize(), a.nodeChanged());
}));
}
function P() {
i.mac && a.on("keydown", function(t) {
!e.metaKeyPressed(t) || 37 != t.keyCode && 39 != t.keyCode || (t.preventDefault(), 
a.selection.getSel().modify("move", 37 == t.keyCode ? "backward" :"forward", "word"));
});
}
function O() {
s("AutoUrlDetect", !1);
}
function I() {
a.inline || a.on("focus blur beforegetcontent", function() {
var e = a.dom.create("br");
a.getBody().appendChild(e), e.parentNode.removeChild(e);
}, !0);
}
function F() {
a.on("click", function(e) {
var t = e.target;
do if ("A" === t.tagName) return void e.preventDefault(); while (t = t.parentNode);
}), a.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
}
function z() {
a.on("init", function() {
a.dom.bind(a.getBody(), "submit", function(e) {
e.preventDefault();
});
});
}
var W = o.each, V = e.BACKSPACE, U = e.DELETE, q = a.dom, $ = a.selection, j = a.settings, K = a.parser, G = a.serializer, Y = i.gecko, X = i.ie, J = i.webkit;
_(), d(), D(), J && (u(), p(), g(), k(), z(), C(), i.iOS ? (y(), M(), H(), F()) :f()), 
X && i.ie < 11 && (h(), b(), x(), w(), T(), R(), A(), B()), i.ie >= 11 && (H(), 
I(), C()), i.ie && (f(), O()), Y && (h(), m(), v(), N(), E(), S(), L(), P(), C());
};
}), r(st, [ U ], function(e) {
function t(t) {
return t._eventDispatcher || (t._eventDispatcher = new e({
scope:t,
toggleEvent:function(n, r) {
e.isNative(n) && t.toggleNativeEvent && t.toggleNativeEvent(n, r);
}
})), t._eventDispatcher;
}
return {
fire:function(e, n, r) {
var i = this;
if (i.removed && "remove" !== e) return n;
if (n = t(i).fire(e, n, r), r !== !1 && i.parent) for (var o = i.parent(); o && !n.isPropagationStopped(); ) o.fire(e, n, !1), 
o = o.parent();
return n;
},
on:function(e, n, r) {
return t(this).on(e, n, r);
},
off:function(e, n) {
return t(this).off(e, n);
},
once:function(e, n) {
return t(this).once(e, n);
},
hasEventListeners:function(e) {
return t(this).has(e);
}
};
}), r(lt, [ st, y, u ], function(e, t, n) {
function r(e, t) {
return "selectionchange" == t ? e.getDoc() :!e.inline && /^mouse|click|contextmenu|drop|dragover|dragend/.test(t) ? e.getDoc() :e.getBody();
}
function i(e, t) {
var n = e.settings.event_root, i = e.editorManager, a = i.eventRootElm || r(e, t);
if (n) {
if (i.rootEvents || (i.rootEvents = {}, i.on("RemoveEditor", function() {
i.activeEditor || (o.unbind(a), delete i.rootEvents);
})), i.rootEvents[t]) return;
a == e.getBody() && (a = o.select(n)[0], i.eventRootElm = a), i.rootEvents[t] = !0, 
o.bind(a, t, function(e) {
for (var n = e.target, r = i.editors, a = r.length; a--; ) {
var s = r[a].getBody();
(s === n || o.isChildOf(n, s)) && (r[a].hidden || r[a].fire(t, e));
}
});
} else e.dom.bind(a, t, function(n) {
e.hidden || e.fire(t, n);
});
}
var o = t.DOM, a = {
bindPendingEventDelegates:function() {
var e = this;
n.each(e._pendingNativeEvents, function(t) {
i(e, t);
});
},
toggleNativeEvent:function(e, t) {
var n = this;
n.settings.readonly || "focus" != e && "blur" != e && (t ? n.initialized ? i(n, e) :n._pendingNativeEvents ? n._pendingNativeEvents.push(e) :n._pendingNativeEvents = [ e ] :n.initialized && n.dom.unbind(r(n, e), e));
}
};
return a = n.extend({}, e, a);
}), r(ct, [ u, d ], function(e, t) {
var n = e.each, r = e.explode, i = {
f9:120,
f10:121,
f11:122
};
return function(o) {
var a = this, s = {};
o.on("keyup keypress keydown", function(e) {
(e.altKey || e.ctrlKey || e.metaKey) && n(s, function(n) {
var r = t.mac ? e.metaKey :e.ctrlKey;
return n.ctrl == r && n.alt == e.altKey && n.shift == e.shiftKey ? e.keyCode == n.keyCode || e.charCode && e.charCode == n.charCode ? (e.preventDefault(), 
"keydown" == e.type && n.func.call(n.scope), !0) :void 0 :void 0;
});
}), a.add = function(t, a, l, c) {
var u;
return u = l, "string" == typeof l ? l = function() {
o.execCommand(u, !1, null);
} :e.isArray(u) && (l = function() {
o.execCommand(u[0], u[1], u[2]);
}), n(r(t.toLowerCase()), function(e) {
var t = {
func:l,
scope:c || o,
desc:o.translate(a),
alt:!1,
ctrl:!1,
shift:!1
};
n(r(e, "+"), function(e) {
switch (e) {
case "alt":
case "ctrl":
case "shift":
t[e] = !0;
break;

default:
/^[0-9]{2,}$/.test(e) ? t.keyCode = parseInt(e, 10) :(t.charCode = e.charCodeAt(0), 
t.keyCode = i[e] || e.toUpperCase().charCodeAt(0));
}
}), s[(t.ctrl ? "ctrl" :"") + "," + (t.alt ? "alt" :"") + "," + (t.shift ? "shift" :"") + "," + t.keyCode] = t;
}), !0;
};
};
}), r(ut, [ y, f, C, x, S, k, L, P, O, I, F, z, W, b, l, ot, w, N, at, d, u, lt, ct ], function(e, n, r, i, o, a, s, l, c, u, d, f, p, h, m, g, v, y, b, C, x, w, _) {
function N(e, t, i) {
var a, s, o = this;
a = o.documentBaseUrl = i.documentBaseURL, s = i.baseURI, o.settings = t = T({
id:e,
theme:"modern",
delta_width:0,
delta_height:0,
popup_css:"",
plugins:"",
document_base_url:a,
add_form_submit_trigger:!0,
submit_patch:!0,
add_unload_trigger:!0,
convert_urls:!0,
relative_urls:!0,
remove_script_host:!0,
object_resizing:!0,
doctype:"<!DOCTYPE html>",
visual:!0,
font_size_style_values:"xx-small,x-small,small,medium,large,x-large,xx-large",
font_size_legacy_values:"xx-small,small,medium,large,x-large,xx-large,300%",
forced_root_block:"p",
hidden_input:!0,
padd_empty_editor:!0,
render_ui:!0,
indentation:"30px",
inline_styles:!0,
convert_fonts_to_spans:!0,
indent:"simple",
indent_before:"p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist",
indent_after:"p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist",
validate:!0,
entity_encoding:"named",
url_converter:o.convertURL,
url_converter_scope:o,
ie7_compat:!0
}, t), r.language = t.language || "en", r.languageLoad = t.language_load, r.baseURL = i.baseURL, 
o.id = t.id = e, o.isNotDirty = !0, o.plugins = {}, o.documentBaseURI = new p(t.document_base_url || a, {
base_uri:s
}), o.baseURI = s, o.contentCSS = [], o.contentStyles = [], o.shortcuts = new _(o), 
o.execCommands = {}, o.queryStateCommands = {}, o.queryValueCommands = {}, o.loadedCSS = {}, 
o.suffix = i.suffix, o.editorManager = i, o.inline = t.inline, i.fire("SetupEditor", o), 
o.execCallback("setup", o), o.$ = n.overrideDefaults(function() {
return {
context:o.inline ? o.getBody() :o.getDoc(),
element:o.getBody()
};
});
}
var E = e.DOM, k = r.ThemeManager, S = r.PluginManager, T = x.extend, R = x.each, A = x.explode, B = x.inArray, D = x.trim, L = x.resolve, M = m.Event, H = C.gecko, P = C.ie;
return N.prototype = {
render:function() {
function e() {
E.unbind(window, "ready", e), n.render();
}
function t() {
var e = h.ScriptLoader;
if (r.language && "en" != r.language && !r.language_url && (r.language_url = n.editorManager.baseURL + "/langs/" + r.language + ".js"), 
r.language_url && e.add(r.language_url), r.theme && "function" != typeof r.theme && "-" != r.theme.charAt(0) && !k.urls[r.theme]) {
var t = r.theme_url;
t = t ? n.documentBaseURI.toAbsolute(t) :"themes/" + r.theme + "/theme" + o + ".js", 
k.load(r.theme, t);
}
x.isArray(r.plugins) && (r.plugins = r.plugins.join(" ")), R(r.external_plugins, function(e, t) {
S.load(t, e), r.plugins += " " + t;
}), R(r.plugins.split(/[ ,]/), function(e) {
if (e = D(e), e && !S.urls[e]) if ("-" == e.charAt(0)) {
e = e.substr(1, e.length);
var t = S.dependencies(e);
R(t, function(e) {
var t = {
prefix:"plugins/",
resource:e,
suffix:"/plugin" + o + ".js"
};
e = S.createUrl(t, e), S.load(e.resource, e);
});
} else S.load(e, {
prefix:"plugins/",
resource:e,
suffix:"/plugin" + o + ".js"
});
}), e.loadQueue(function() {
n.removed || n.init();
});
}
var n = this, r = n.settings, i = n.id, o = n.suffix;
if (!M.domLoaded) return void E.bind(window, "ready", e);
if (n.getElement() && C.contentEditable) {
r.inline ? n.inline = !0 :(n.orgVisibility = n.getElement().style.visibility, n.getElement().style.visibility = "hidden");
var a = n.getElement().form || E.getParent(i, "form");
a && (n.formElement = a, r.hidden_input && !/TEXTAREA|INPUT/i.test(n.getElement().nodeName) && (E.insertAfter(E.create("input", {
type:"hidden",
name:i
}), i), n.hasHiddenInput = !0), n.formEventDelegate = function(e) {
n.fire(e.type, e);
}, E.bind(a, "submit reset", n.formEventDelegate), n.on("reset", function() {
n.setContent(n.startContent, {
format:"raw"
});
}), !r.submit_patch || a.submit.nodeType || a.submit.length || a._mceOldSubmit || (a._mceOldSubmit = a.submit, 
a.submit = function() {
return n.editorManager.triggerSave(), n.isNotDirty = !0, a._mceOldSubmit(a);
})), n.windowManager = new g(n), "xml" == r.encoding && n.on("GetContent", function(e) {
e.save && (e.content = E.encode(e.content));
}), r.add_form_submit_trigger && n.on("submit", function() {
n.initialized && n.save();
}), r.add_unload_trigger && (n._beforeUnload = function() {
!n.initialized || n.destroyed || n.isHidden() || n.save({
format:"raw",
no_events:!0,
set_dirty:!1
});
}, n.editorManager.on("BeforeUnload", n._beforeUnload)), t();
}
},
init:function() {
function e(n) {
var i, o, r = S.get(n);
i = S.urls[n] || t.documentBaseUrl.replace(/\/$/, ""), n = D(n), r && -1 === B(m, n) && (R(S.dependencies(n), function(t) {
e(t);
}), o = new r(t, i, t.$), t.plugins[n] = o, o.init && (o.init(t, i), m.push(n)));
}
var i, o, a, s, l, c, u, d, f, p, h, t = this, n = t.settings, r = t.getElement(), m = [];
if (t.rtl = this.editorManager.i18n.rtl, t.editorManager.add(t), n.aria_label = n.aria_label || E.getAttrib(r, "aria-label", t.getLang("aria.rich_text_area")), 
n.theme && ("function" != typeof n.theme ? (n.theme = n.theme.replace(/-/, ""), 
c = k.get(n.theme), t.theme = new c(t, k.urls[n.theme]), t.theme.init && t.theme.init(t, k.urls[n.theme] || t.documentBaseUrl.replace(/\/$/, ""), t.$)) :t.theme = n.theme), 
R(n.plugins.replace(/\-/g, "").split(/[ ,]/), e), n.render_ui && t.theme && (t.orgDisplay = r.style.display, 
"function" != typeof n.theme ? (i = n.width || r.style.width || r.offsetWidth, o = n.height || r.style.height || r.offsetHeight, 
a = n.min_height || 100, p = /^[0-9\.]+(|px)$/i, p.test("" + i) && (i = Math.max(parseInt(i, 10), 100)), 
p.test("" + o) && (o = Math.max(parseInt(o, 10), a)), l = t.theme.renderUI({
targetNode:r,
width:i,
height:o,
deltaWidth:n.delta_width,
deltaHeight:n.delta_height
}), n.content_editable || (E.setStyles(l.sizeContainer || l.editorContainer, {
wi2dth:i,
h2eight:o
}), o = (l.iframeHeight || o) + ("number" == typeof o ? l.deltaHeight || 0 :""), 
a > o && (o = a))) :(l = n.theme(t, r), l.editorContainer.nodeType && (l.editorContainer = l.editorContainer.id = l.editorContainer.id || t.id + "_parent"), 
l.iframeContainer.nodeType && (l.iframeContainer = l.iframeContainer.id = l.iframeContainer.id || t.id + "_iframecontainer"), 
o = l.iframeHeight || r.offsetHeight), t.editorContainer = l.editorContainer), n.content_css && R(A(n.content_css), function(e) {
t.contentCSS.push(t.documentBaseURI.toAbsolute(e));
}), n.content_style && t.contentStyles.push(n.content_style), n.content_editable) return r = s = l = null, 
t.initContentBody();
for (t.iframeHTML = n.doctype + "<html><head>", n.document_base_url != t.documentBaseUrl && (t.iframeHTML += '<base href="' + t.documentBaseURI.getURI() + '" />'), 
!C.caretAfter && n.ie7_compat && (t.iframeHTML += '<meta http-equiv="X-UA-Compatible" content="IE=7" />'), 
t.iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />', 
h = 0; h < t.contentCSS.length; h++) {
var g = t.contentCSS[h];
t.iframeHTML += '<link type="text/css" rel="stylesheet" href="' + g + '" />', t.loadedCSS[g] = !0;
}
d = n.body_id || "tinymce", -1 != d.indexOf("=") && (d = t.getParam("body_id", "", "hash"), 
d = d[t.id] || d), f = n.body_class || "", -1 != f.indexOf("=") && (f = t.getParam("body_class", "", "hash"), 
f = f[t.id] || ""), t.iframeHTML += '</head><body id="' + d + '" class="mce-content-body ' + f + '" onload="window.parent.tinymce.get(\'' + t.id + "').fire('load');\"><br></body></html>";
var v = 'javascript:(function(){document.open();document.domain="' + document.domain + '";var ed = window.parent.tinymce.get("' + t.id + '");document.write(ed.iframeHTML);document.close();ed.initContentBody(true);})()';
if (document.domain != location.hostname && (u = v), s = E.add(l.iframeContainer, "iframe", {
id:t.id + "_ifr",
src:u || 'javascript:""',
frameBorder:"0",
allowTransparency:"true",
title:t.editorManager.translate("Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help"),
style:{
width:"100%",
height:o,
display:"block"
}
}), P) try {
t.getDoc();
} catch (y) {
s.src = u = v;
}
t.contentAreaContainer = l.iframeContainer, l.editorContainer && (E.get(l.editorContainer).style.display = t.orgDisplay), 
E.get(t.id).style.display = "none", E.setAttrib(t.id, "aria-hidden", !0), u || t.initContentBody(), 
r = s = l = null;
},
initContentBody:function(t) {
var h, m, n = this, r = n.settings, a = E.get(n.id), p = n.getDoc();
r.inline || (n.getElement().style.visibility = n.orgVisibility), t || r.content_editable || (p.open(), 
p.write(n.iframeHTML), p.close()), r.content_editable && (n.on("remove", function() {
var e = this.getBody();
E.removeClass(e, "mce-content-body"), E.removeClass(e, "mce-edit-focus"), E.setAttrib(e, "contentEditable", null);
}), E.addClass(a, "mce-content-body"), n.contentDocument = p = r.content_document || document, 
n.contentWindow = r.content_window || window, n.bodyElement = a, r.content_document = r.content_window = null, 
r.root_name = a.nodeName.toLowerCase()), h = n.getBody(), h.disabled = !0, r.readonly || (n.inline && "static" == E.getStyle(h, "position", !0) && (h.style.position = "relative"), 
h.contentEditable = n.getParam("content_editable_state", !0)), h.disabled = !1, 
n.schema = new v(r), n.dom = new e(p, {
keep_values:!0,
url_converter:n.convertURL,
url_converter_scope:n,
hex_colors:r.force_hex_style_colors,
class_filter:r.class_filter,
update_styles:!0,
root_element:r.content_editable ? n.id :null,
collect:r.content_editable,
schema:n.schema,
onSetAttrib:function(e) {
n.fire("SetAttrib", e);
}
}), n.parser = new y(r, n.schema), n.parser.addAttributeFilter("src,href,style,tabindex", function(e, t) {
for (var i, a, s, r = e.length, o = n.dom; r--; ) i = e[r], a = i.attr(t), s = "data-mce-" + t, 
i.attributes.map[s] || ("style" === t ? (a = o.serializeStyle(o.parseStyle(a), i.name), 
a.length || (a = null), i.attr(s, a), i.attr(t, a)) :"tabindex" === t ? (i.attr(s, a), 
i.attr(t, null)) :i.attr(s, n.convertURL(a, t, i.name)));
}), n.parser.addNodeFilter("script", function(e) {
for (var n, t = e.length; t--; ) n = e[t], n.attr("type", "mce-" + (n.attr("type") || "no/type"));
}), n.parser.addNodeFilter("#cdata", function(e) {
for (var n, t = e.length; t--; ) n = e[t], n.type = 8, n.name = "#comment", n.value = "[CDATA[" + n.value + "]]";
}), n.parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", function(e) {
for (var r, t = e.length, o = n.schema.getNonEmptyElements(); t--; ) r = e[t], r.isEmpty(o) && (r.empty().append(new i("br", 1)).shortEnded = !0);
}), n.serializer = new o(r, n), n.selection = new s(n.dom, n.getWin(), n.serializer, n), 
n.formatter = new l(n), n.undoManager = new c(n), n.forceBlocks = new d(n), n.enterKey = new u(n), 
n.editorCommands = new f(n), n.fire("PreInit"), r.browser_spellcheck || r.gecko_spellcheck || (p.body.spellcheck = !1, 
E.setAttrib(h, "spellcheck", "false")), n.fire("PostRender"), n.quirks = b(n), r.directionality && (h.dir = r.directionality), 
r.nowrap && (h.style.whiteSpace = "nowrap"), r.protect && n.on("BeforeSetContent", function(e) {
R(r.protect, function(t) {
e.content = e.content.replace(t, function(e) {
return "<!--mce:protected " + escape(e) + "-->";
});
});
}), n.on("SetContent", function() {
n.addVisual(n.getBody());
}), r.padd_empty_editor && n.on("PostProcess", function(e) {
e.content = e.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\s|\u00a0|)<\/p>[\r\n]*|<br \/>[\r\n]*)$/, "");
}), n.load({
initial:!0,
format:"html"
}), n.startContent = n.getContent({
format:"raw"
}), n.initialized = !0, n.bindPendingEventDelegates(), n.fire("init"), n.focus(!0), 
n.nodeChanged({
initial:!0
}), n.execCallback("init_instance_callback", n), n.contentStyles.length > 0 && (m = "", 
R(n.contentStyles, function(e) {
m += e + "\r\n";
}), n.dom.addStyle(m)), R(n.contentCSS, function(e) {
n.loadedCSS[e] || (n.dom.loadCSS(e), n.loadedCSS[e] = !0);
}), r.auto_focus && setTimeout(function() {
var e = n.editorManager.get(r.auto_focus);
e.selection.select(e.getBody(), 1), e.selection.collapse(1), e.getBody().focus(), 
e.getWin().focus();
}, 100), a = p = h = null;
},
focus:function(e) {
var t, o, a, l, n = this, r = n.selection, i = n.settings.content_editable, s = n.getDoc();
if (!e) {
if (o = r.getRng(), o.item && (a = o.item(0)), n._refreshContentEditable(), i || (C.opera || n.getBody().focus(), 
n.getWin().focus()), H || i) {
if (l = n.getBody(), l.setActive) try {
l.setActive();
} catch (c) {
l.focus();
} else l.focus();
i && r.normalize();
}
a && a.ownerDocument == s && (o = s.body.createControlRange(), o.addElement(a), 
o.select());
}
n.editorManager.activeEditor != n && ((t = n.editorManager.activeEditor) && t.fire("deactivate", {
relatedTarget:n
}), n.fire("activate", {
relatedTarget:t
})), n.editorManager.activeEditor = n;
},
execCallback:function(e) {
var r, t = this, n = t.settings[e];
return n ? (t.callbackLookup && (r = t.callbackLookup[e]) && (n = r.func, r = r.scope), 
"string" == typeof n && (r = n.replace(/\.\w+$/, ""), r = r ? L(r) :0, n = L(n), 
t.callbackLookup = t.callbackLookup || {}, t.callbackLookup[e] = {
func:n,
scope:r
}), n.apply(r || t, Array.prototype.slice.call(arguments, 1))) :void 0;
},
translate:function(e) {
var t = this.settings.language || "en", n = this.editorManager.i18n;
return e ? n.data[t + "." + e] || e.replace(/\{\#([^\}]+)\}/g, function(e, r) {
return n.data[t + "." + r] || "{#" + r + "}";
}) :"";
},
getLang:function(e, n) {
return this.editorManager.i18n.data[(this.settings.language || "en") + "." + e] || (n !== t ? n :"{#" + e + "}");
},
getParam:function(e, t, n) {
var i, r = e in this.settings ? this.settings[e] :t;
return "hash" === n ? (i = {}, "string" == typeof r ? R(r.split(r.indexOf("=") > 0 ? /[;,](?![^=;,]*(?:[;,]|$))/ :","), function(e) {
e = e.split("="), i[D(e[0])] = D(e.length > 1 ? e[1] :e);
}) :i = r, i) :r;
},
nodeChanged:function(e) {
var r, i, o, t = this, n = t.selection;
!t.initialized || t.settings.disable_nodechange || t.settings.readonly || (o = t.getBody(), 
r = n.getStart() || o, r = P && r.ownerDocument != t.getDoc() ? t.getBody() :r, 
"IMG" == r.nodeName && n.isCollapsed() && (r = r.parentNode), i = [], t.dom.getParent(r, function(e) {
return e === o ? !0 :void i.push(e);
}), e = e || {}, e.element = r, e.parents = i, t.fire("NodeChange", e));
},
addButton:function(e, t) {
var n = this;
t.cmd && (t.onclick = function() {
n.execCommand(t.cmd);
}), t.text || t.icon || (t.icon = e), n.buttons = n.buttons || {}, t.tooltip = t.tooltip || t.title, 
n.buttons[e] = t;
},
addMenuItem:function(e, t) {
var n = this;
t.cmd && (t.onclick = function() {
n.execCommand(t.cmd);
}), n.menuItems = n.menuItems || {}, n.menuItems[e] = t;
},
addCommand:function(e, t, n) {
this.execCommands[e] = {
func:t,
scope:n || this
};
},
addQueryStateHandler:function(e, t, n) {
this.queryStateCommands[e] = {
func:t,
scope:n || this
};
},
addQueryValueHandler:function(e, t, n) {
this.queryValueCommands[e] = {
func:t,
scope:n || this
};
},
addShortcut:function(e, t, n, r) {
this.shortcuts.add(e, t, n, r);
},
execCommand:function(e, t, n, r) {
var a, i = this, o = 0;
if (/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(e) || r && r.skip_focus || i.focus(), 
r = T({}, r), r = i.fire("BeforeExecCommand", {
command:e,
ui:t,
value:n
}), r.isDefaultPrevented()) return !1;
if ((a = i.execCommands[e]) && a.func.call(a.scope, t, n) !== !0) return i.fire("ExecCommand", {
command:e,
ui:t,
value:n
}), !0;
if (R(i.plugins, function(r) {
return r.execCommand && r.execCommand(e, t, n) ? (i.fire("ExecCommand", {
command:e,
ui:t,
value:n
}), o = !0, !1) :void 0;
}), o) return o;
if (i.theme && i.theme.execCommand && i.theme.execCommand(e, t, n)) return i.fire("ExecCommand", {
command:e,
ui:t,
value:n
}), !0;
if (i.editorCommands.execCommand(e, t, n)) return i.fire("ExecCommand", {
command:e,
ui:t,
value:n
}), !0;
try {
o = i.getDoc().execCommand(e, t, n);
} catch (s) {}
return o ? (i.fire("ExecCommand", {
command:e,
ui:t,
value:n
}), !0) :!1;
},
queryCommandState:function(e) {
var n, r, t = this;
if (!t._isHidden()) {
if ((n = t.queryStateCommands[e]) && (r = n.func.call(n.scope), r === !0 || r === !1)) return r;
if (r = t.editorCommands.queryCommandState(e), -1 !== r) return r;
try {
return t.getDoc().queryCommandState(e);
} catch (i) {}
}
},
queryCommandValue:function(e) {
var r, i, n = this;
if (!n._isHidden()) {
if ((r = n.queryValueCommands[e]) && (i = r.func.call(r.scope), i !== !0)) return i;
if (i = n.editorCommands.queryCommandValue(e), i !== t) return i;
try {
return n.getDoc().queryCommandValue(e);
} catch (o) {}
}
},
show:function() {
var e = this;
e.hidden && (e.hidden = !1, e.inline ? e.getBody().contentEditable = !0 :(E.show(e.getContainer()), 
E.hide(e.id)), e.load(), e.fire("show"));
},
hide:function() {
var e = this, t = e.getDoc();
e.hidden || (P && t && !e.inline && t.execCommand("SelectAll"), e.save(), e.inline ? (e.getBody().contentEditable = !1, 
e == e.editorManager.focusedEditor && (e.editorManager.focusedEditor = null)) :(E.hide(e.getContainer()), 
E.setStyle(e.id, "display", e.orgDisplay)), e.hidden = !0, e.fire("hide"));
},
isHidden:function() {
return !!this.hidden;
},
setProgressState:function(e, t) {
this.fire("ProgressState", {
state:e,
time:t
});
},
load:function(e) {
var i, n = this, r = n.getElement();
return r ? (e = e || {}, e.load = !0, i = n.setContent(r.value !== t ? r.value :r.innerHTML, e), 
e.element = r, e.no_events || n.fire("LoadContent", e), e.element = r = null, i) :void 0;
},
save:function(e) {
var r, i, t = this, n = t.getElement();
return n && t.initialized ? (e = e || {}, e.save = !0, e.element = n, r = e.content = t.getContent(e), 
e.no_events || t.fire("SaveContent", e), r = e.content, /TEXTAREA|INPUT/i.test(n.nodeName) ? n.value = r :(t.inline || (n.innerHTML = r), 
(i = E.getParent(t.id, "form")) && R(i.elements, function(e) {
return e.name == t.id ? (e.value = r, !1) :void 0;
})), e.element = n = null, e.set_dirty !== !1 && (t.isNotDirty = !0), r) :void 0;
},
setContent:function(e, t) {
var i, n = this, r = n.getBody();
return t = t || {}, t.format = t.format || "html", t.set = !0, t.content = e, t.no_events || n.fire("BeforeSetContent", t), 
e = t.content, 0 === e.length || /^\s+$/.test(e) ? (i = n.settings.forced_root_block, 
i && n.schema.isValidChild(r.nodeName.toLowerCase(), i.toLowerCase()) ? (e = P && 11 > P ? "" :'<br data-mce-bogus="1">', 
e = n.dom.createHTML(i, n.settings.forced_root_block_attrs, e)) :P || (e = '<br data-mce-bogus="1">'), 
r.innerHTML = e, n.fire("SetContent", t)) :("raw" !== t.format && (e = new a({}, n.schema).serialize(n.parser.parse(e, {
isRootContent:!0
}))), t.content = D(e), n.dom.setHTML(r, t.content), t.no_events || n.fire("SetContent", t)), 
t.content;
},
getContent:function(e) {
var n, t = this, r = t.getBody();
return e = e || {}, e.format = e.format || "html", e.get = !0, e.getInner = !0, 
e.no_events || t.fire("BeforeGetContent", e), n = "raw" == e.format ? r.innerHTML :"text" == e.format ? r.innerText || r.textContent :t.serializer.serialize(r, e), 
e.content = "text" != e.format ? D(n) :n, e.no_events || t.fire("GetContent", e), 
e.content;
},
insertContent:function(e, t) {
t && (e = T({
content:e
}, t)), this.execCommand("mceInsertContent", !1, e);
},
isDirty:function() {
return !this.isNotDirty;
},
getContainer:function() {
var e = this;
return e.container || (e.container = E.get(e.editorContainer || e.id + "_parent")), 
e.container;
},
getContentAreaContainer:function() {
return this.contentAreaContainer;
},
getElement:function() {
return E.get(this.settings.content_element || this.id);
},
getWin:function() {
var t, e = this;
return e.contentWindow || (t = E.get(e.id + "_ifr"), t && (e.contentWindow = t.contentWindow)), 
e.contentWindow;
},
getDoc:function() {
var t, e = this;
return e.contentDocument || (t = e.getWin(), t && (e.contentDocument = t.document)), 
e.contentDocument;
},
getBody:function() {
return this.bodyElement || this.getDoc().body;
},
convertURL:function(e, t, n) {
var r = this, i = r.settings;
return i.urlconverter_callback ? r.execCallback("urlconverter_callback", e, n, !0, t) :!i.convert_urls || n && "LINK" == n.nodeName || 0 === e.indexOf("file:") || 0 === e.length ? e :i.relative_urls ? r.documentBaseURI.toRelative(e) :e = r.documentBaseURI.toAbsolute(e, i.remove_script_host);
},
addVisual:function(e) {
var o, n = this, r = n.settings, i = n.dom;
e = e || n.getBody(), n.hasVisual === t && (n.hasVisual = r.visual), R(i.select("table,a", e), function(e) {
var t;
switch (e.nodeName) {
case "TABLE":
return o = r.visual_table_class || "mce-item-table", t = i.getAttrib(e, "border"), 
void (t && "0" != t || (n.hasVisual ? i.addClass(e, o) :i.removeClass(e, o)));

case "A":
return void (i.getAttrib(e, "href", !1) || (t = i.getAttrib(e, "name") || e.id, 
o = r.visual_anchor_class || "mce-item-anchor", t && (n.hasVisual ? i.addClass(e, o) :i.removeClass(e, o))));
}
}), n.fire("VisualAid", {
element:e,
hasVisual:n.hasVisual
});
},
remove:function() {
var e = this;
if (!e.removed) {
e.save(), e.removed = 1, e.hasHiddenInput && E.remove(e.getElement().nextSibling), 
e.inline || (P && 10 > P && e.getDoc().execCommand("SelectAll", !1, null), E.setStyle(e.id, "display", e.orgDisplay), 
e.getBody().onload = null, M.unbind(e.getWin()), M.unbind(e.getDoc()));
var t = e.getContainer();
M.unbind(e.getBody()), M.unbind(t), e.fire("remove"), e.editorManager.remove(e), 
E.remove(t), e.destroy();
}
},
destroy:function(e) {
var n, t = this;
if (!t.destroyed) {
if (!e && !t.removed) return void t.remove();
e && H && (M.unbind(t.getDoc()), M.unbind(t.getWin()), M.unbind(t.getBody())), e || (t.editorManager.off("beforeunload", t._beforeUnload), 
t.theme && t.theme.destroy && t.theme.destroy(), t.selection.destroy(), t.dom.destroy()), 
n = t.formElement, n && (n._mceOldSubmit && (n.submit = n._mceOldSubmit, n._mceOldSubmit = null), 
E.unbind(n, "submit reset", t.formEventDelegate)), t.contentAreaContainer = t.formElement = t.container = t.editorContainer = null, 
t.settings.content_element = t.bodyElement = t.contentDocument = t.contentWindow = null, 
t.selection && (t.selection = t.selection.win = t.selection.dom = t.selection.dom.doc = null), 
t.destroyed = 1;
}
},
_refreshContentEditable:function() {
var t, n, e = this;
e._isHidden() && (t = e.getBody(), n = t.parentNode, n.removeChild(t), n.appendChild(t), 
t.focus());
},
_isHidden:function() {
var e;
return H ? (e = this.selection.getSel(), !e || !e.rangeCount || 0 === e.rangeCount) :0;
}
}, T(N.prototype, w), N;
}), r(dt, [], function() {
var e = {};
return {
rtl:!1,
add:function(t, n) {
for (var r in n) e[r] = n[r];
this.rtl = this.rtl || "rtl" === e._dir;
},
translate:function(t) {
if ("undefined" == typeof t) return t;
if ("string" != typeof t && t.raw) return t.raw;
if (t.push) {
var n = t.slice(1);
t = (e[t[0]] || t[0]).replace(/\{([^\}]+)\}/g, function(e, t) {
return n[t];
});
}
return e[t] || t;
},
data:e
};
}), r(ft, [ y, d ], function(e, t) {
function n(e) {
function s() {
try {
return document.activeElement;
} catch (e) {
return document.body;
}
}
function l(e, t) {
if (t && t.startContainer) {
if (!e.isChildOf(t.startContainer, e.getRoot()) || !e.isChildOf(t.endContainer, e.getRoot())) return;
return {
startContainer:t.startContainer,
startOffset:t.startOffset,
endContainer:t.endContainer,
endOffset:t.endOffset
};
}
return t;
}
function c(e, t) {
var n;
return t.startContainer ? (n = e.getDoc().createRange(), n.setStart(t.startContainer, t.startOffset), 
n.setEnd(t.endContainer, t.endOffset)) :n = t, n;
}
function u(e) {
return !!a.getParent(e, n.isEditorUIElement);
}
function d(n) {
var d = n.editor;
d.on("init", function() {
(d.inline || t.ie) && (d.on("nodechange keyup", function() {
var e = document.activeElement;
e && e.id == d.id + "_ifr" && (e = d.getBody()), d.dom.isChildOf(e, d.getBody()) && (d.lastRng = d.selection.getRng());
}), t.webkit && !r && (r = function() {
var t = e.activeEditor;
if (t && t.selection) {
var n = t.selection.getRng();
n && !n.collapsed && (d.lastRng = n);
}
}, a.bind(document, "selectionchange", r)));
}), d.on("setcontent", function() {
d.lastRng = null;
}), d.on("mousedown", function() {
d.selection.lastFocusBookmark = null;
}), d.on("focusin", function() {
var t = e.focusedEditor;
d.selection.lastFocusBookmark && (d.selection.setRng(c(d, d.selection.lastFocusBookmark)), 
d.selection.lastFocusBookmark = null), t != d && (t && t.fire("blur", {
focusedEditor:d
}), e.activeEditor = d, e.focusedEditor = d, d.fire("focus", {
blurredEditor:t
}), d.focus(!0)), d.lastRng = null;
}), d.on("focusout", function() {
window.setTimeout(function() {
var t = e.focusedEditor;
u(s()) || t != d || (d.fire("blur", {
focusedEditor:null
}), e.focusedEditor = null, d.selection && (d.selection.lastFocusBookmark = null));
}, 0);
}), i || (i = function(t) {
var n = e.activeEditor;
n && t.target.ownerDocument == document && (n.selection && (n.selection.lastFocusBookmark = l(n.dom, n.lastRng)), 
u(t.target) || e.focusedEditor != n || (n.fire("blur", {
focusedEditor:null
}), e.focusedEditor = null));
}, a.bind(document, "focusin", i)), d.inline && !o && (o = function(t) {
var n = e.activeEditor;
if (n.inline && !n.dom.isChildOf(t.target, n.getBody())) {
var r = n.selection.getRng();
r.collapsed || (n.lastRng = r);
}
}, a.bind(document, "mouseup", o));
}
function f(t) {
e.focusedEditor == t.editor && (e.focusedEditor = null), e.activeEditor || (a.unbind(document, "selectionchange", r), 
a.unbind(document, "focusin", i), a.unbind(document, "mouseup", o), r = i = o = null);
}
e.on("AddEditor", d), e.on("RemoveEditor", f);
}
var r, i, o, a = e.DOM;
return n.isEditorUIElement = function(e) {
return -1 !== e.className.toString().indexOf("mce-");
}, n;
}), r(pt, [ ut, f, y, W, d, u, st, dt, ft ], function(e, t, n, r, i, o, a, s, l) {
function c(e) {
var n, t = v.editors;
delete t[e.id];
for (var r = 0; r < t.length; r++) if (t[r] == e) {
t.splice(r, 1), n = !0;
break;
}
return v.activeEditor == e && (v.activeEditor = t[0]), v.focusedEditor == e && (v.focusedEditor = null), 
n;
}
function u(e) {
return e && !(e.getContainer() || e.getBody()).parentNode && (c(e), e.destroy(!0), 
e = null), e;
}
var g, v, d = n.DOM, f = o.explode, p = o.each, h = o.extend, m = 0;
return v = {
$:t,
majorVersion:"4",
minorVersion:"1.0",
releaseDate:"2014-06-18",
editors:[],
i18n:s,
activeEditor:null,
setup:function() {
var t, n, o, a, e = this, i = "";
if (n = document.location.href, /^[^:]+:\/\/\/?[^\/]+\//.test(n) && (n = n.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), 
/[\/\\]$/.test(n) || (n += "/")), o = window.tinymce || window.tinyMCEPreInit) t = o.base || o.baseURL, 
i = o.suffix; else {
for (var s = document.getElementsByTagName("script"), c = 0; c < s.length; c++) if (a = s[c].src, 
/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(a)) {
-1 != a.indexOf(".min") && (i = ".min"), t = a.substring(0, a.lastIndexOf("/"));
break;
}
!t && document.currentScript && (a = document.currentScript.src, -1 != a.indexOf(".min") && (i = ".min"), 
t = a.substring(0, a.lastIndexOf("/")));
}
e.baseURL = new r(n).toAbsolute(t), e.documentBaseURL = n, e.baseURI = new r(e.baseURL), 
e.suffix = i, e.focusManager = new l(e);
},
init:function(t) {
function n(e) {
var t = e.id;
return t || (t = e.name, t = t && !d.get(t) ? e.name :d.uniqueId(), e.setAttribute("id", t)), 
t;
}
function r(t, n) {
if (!u(s.get(t))) {
var r = new e(t, n, s);
l.push(r), r.render();
}
}
function i(e, t, n) {
var r = e[t];
return r ? r.apply(n || this, Array.prototype.slice.call(arguments, 2)) :void 0;
}
function o(e, t) {
return t.constructor === RegExp ? t.test(e.className) :d.hasClass(e, t);
}
function a() {
var u, g;
if (d.unbind(window, "ready", a), i(t, "onpageload"), t.types) return void p(t.types, function(e) {
p(d.select(e.selector), function(i) {
r(n(i), h({}, t, e));
});
});
if (t.selector) return void p(d.select(t.selector), function(e) {
r(n(e), t);
});
switch (t.mode) {
case "exact":
u = t.elements || "", u.length > 0 && p(f(u), function(n) {
d.get(n) ? (c = new e(n, t, s), l.push(c), c.render()) :p(document.forms, function(e) {
p(e.elements, function(e) {
e.name === n && (n = "mce_editor_" + m++, d.setAttrib(e, "id", n), r(n, t));
});
});
});
break;

case "textareas":
case "specific_textareas":
p(d.select("textarea"), function(e) {
t.editor_deselector && o(e, t.editor_deselector) || (!t.editor_selector || o(e, t.editor_selector)) && r(n(e), t);
});
}
t.oninit && (u = g = 0, p(l, function(e) {
g++, e.initialized ? u++ :e.on("init", function() {
u++, u == g && i(t, "oninit");
}), u == g && i(t, "oninit");
}));
}
var c, s = this, l = [];
s.settings = t, d.bind(window, "ready", a);
},
get:function(e) {
return arguments.length ? e in this.editors ? this.editors[e] :null :this.editors;
},
add:function(e) {
var t = this, n = t.editors;
return n[e.id] = e, n.push(e), t.activeEditor = e, t.fire("AddEditor", {
editor:e
}), g || (g = function() {
t.fire("BeforeUnload");
}, d.bind(window, "beforeunload", g)), e;
},
createEditor:function(t, n) {
return this.add(new e(t, n, this));
},
remove:function(e) {
var n, i, t = this, r = t.editors;
if (e) return "string" == typeof e ? (e = e.selector || e, void p(d.select(e), function(e) {
t.remove(r[e.id]);
})) :(i = e, r[i.id] ? (c(i) && t.fire("RemoveEditor", {
editor:i
}), r.length || d.unbind(window, "beforeunload", g), i.remove(), i) :null);
for (n = r.length - 1; n >= 0; n--) t.remove(r[n]);
},
execCommand:function(t, n, r) {
var i = this, o = i.get(r);
switch (t) {
case "mceAddEditor":
return i.get(r) || new e(r, i.settings, i).render(), !0;

case "mceRemoveEditor":
return o && o.remove(), !0;

case "mceToggleEditor":
return o ? (o.isHidden() ? o.show() :o.hide(), !0) :(i.execCommand("mceAddEditor", 0, r), 
!0);
}
return i.activeEditor ? i.activeEditor.execCommand(t, n, r) :!1;
},
triggerSave:function() {
p(this.editors, function(e) {
e.save();
});
},
addI18n:function(e, t) {
s.add(e, t);
},
translate:function(e) {
return s.translate(e);
}
}, h(v, a), v.setup(), window.tinymce = window.tinyMCE = v, v;
}), r(ht, [ pt, u ], function(e, t) {
var n = t.each, r = t.explode;
e.on("AddEditor", function(e) {
var t = e.editor;
t.on("preInit", function() {
function e(e, t) {
n(t, function(t, n) {
t && s.setStyle(e, n, t);
}), s.rename(e, "span");
}
function i(e) {
s = t.dom, l.convert_fonts_to_spans && n(s.select("font,u,strike", e.node), function(e) {
o[e.nodeName.toLowerCase()](s, e);
});
}
var o, a, s, l = t.settings;
l.inline_styles && (a = r(l.font_size_legacy_values), o = {
font:function(t, n) {
e(n, {
backgroundColor:n.style.backgroundColor,
color:n.color,
fontFamily:n.face,
fontSize:a[parseInt(n.size, 10) - 1]
});
},
u:function(t, n) {
e(n, {
textDecoration:"underline"
});
},
strike:function(t, n) {
e(n, {
textDecoration:"line-through"
});
}
}, t.on("PreProcess SetContent", i));
});
});
}), r(mt, [], function() {
return {
send:function(e) {
function t() {
!e.async || 4 == n.readyState || r++ > 1e4 ? (e.success && 1e4 > r && 200 == n.status ? e.success.call(e.success_scope, "" + n.responseText, n, e) :e.error && e.error.call(e.error_scope, r > 1e4 ? "TIMED_OUT" :"GENERAL", n, e), 
n = null) :setTimeout(t, 10);
}
var n, r = 0;
if (e.scope = e.scope || this, e.success_scope = e.success_scope || e.scope, e.error_scope = e.error_scope || e.scope, 
e.async = e.async === !1 ? !1 :!0, e.data = e.data || "", n = new XMLHttpRequest()) {
if (n.overrideMimeType && n.overrideMimeType(e.content_type), n.open(e.type || (e.data ? "POST" :"GET"), e.url, e.async), 
e.crossDomain && (n.withCredentials = !0), e.content_type && n.setRequestHeader("Content-Type", e.content_type), 
n.setRequestHeader("X-Requested-With", "XMLHttpRequest"), n.send(e.data), !e.async) return t();
setTimeout(t, 10);
}
}
};
}), r(gt, [], function() {
function e(t, n) {
var r, i, o, a;
if (n = n || '"', null === t) return "null";
if (o = typeof t, "string" == o) return i = "\bb	t\nn\ff\rr\"\"''\\\\", n + t.replace(/([\u0080-\uFFFF\x00-\x1f\"\'\\])/g, function(e, t) {
return '"' === n && "'" === e ? e :(r = i.indexOf(t), r + 1 ? "\\" + i.charAt(r + 1) :(e = t.charCodeAt().toString(16), 
"\\u" + "0000".substring(e.length) + e));
}) + n;
if ("object" == o) {
if (t.hasOwnProperty && "[object Array]" === Object.prototype.toString.call(t)) {
for (r = 0, i = "["; r < t.length; r++) i += (r > 0 ? "," :"") + e(t[r], n);
return i + "]";
}
i = "{";
for (a in t) t.hasOwnProperty(a) && (i += "function" != typeof t[a] ? (i.length > 1 ? "," + n :n) + a + n + ":" + e(t[a], n) :"");
return i + "}";
}
return "" + t;
}
return {
serialize:e,
parse:function(e) {
try {
return window[String.fromCharCode(101) + "val"]("(" + e + ")");
} catch (t) {}
}
};
}), r(vt, [ gt, mt, u ], function(e, t, n) {
function r(e) {
this.settings = i({}, e), this.count = 0;
}
var i = n.extend;
return r.sendRPC = function(e) {
return new r().send(e);
}, r.prototype = {
send:function(n) {
var r = n.error, o = n.success;
n = i(this.settings, n), n.success = function(t, i) {
t = e.parse(t), "undefined" == typeof t && (t = {
error:"JSON Parse error."
}), t.error ? r.call(n.error_scope || n.scope, t.error, i) :o.call(n.success_scope || n.scope, t.result);
}, n.error = function(e, t) {
r && r.call(n.error_scope || n.scope, e, t);
}, n.data = e.serialize({
id:n.id || "c" + this.count++,
method:n.method,
params:n.params
}), n.content_type = "application/json", t.send(n);
}
}, r;
}), r(yt, [ y ], function(e) {
return {
callbacks:{},
count:0,
send:function(n) {
var r = this, i = e.DOM, o = n.count !== t ? n.count :r.count, a = "tinymce_jsonp_" + o;
r.callbacks[o] = function(e) {
i.remove(a), delete r.callbacks[o], n.callback(e);
}, i.add(i.doc.body, "script", {
id:a,
src:n.url,
type:"text/javascript"
}), r.count++;
}
};
}), r(bt, [], function() {
function e() {
s = [];
for (var e in a) s.push(e);
i.length = s.length;
}
function n() {
function n(e) {
var n, r;
return r = e !== t ? u + e :i.indexOf(",", u), -1 === r || r > i.length ? null :(n = i.substring(u, r), 
u = r + 1, n);
}
var r, i, s, u = 0;
if (a = {}, c) {
o.load(l), i = o.getAttribute(l) || "";
do {
var d = n();
if (null === d) break;
if (r = n(parseInt(d, 32) || 0), null !== r) {
if (d = n(), null === d) break;
s = n(parseInt(d, 32) || 0), r && (a[r] = s);
}
} while (null !== r);
e();
}
}
function r() {
var t, n = "";
if (c) {
for (var r in a) t = a[r], n += (n ? "," :"") + r.length.toString(32) + "," + r + "," + t.length.toString(32) + "," + t;
o.setAttribute(l, n);
try {
o.save(l);
} catch (i) {}
e();
}
}
var i, o, a, s, l, c;
try {
if (window.localStorage) return localStorage;
} catch (u) {}
return l = "tinymce", o = document.documentElement, c = !!o.addBehavior, c && o.addBehavior("#default#userData"), 
i = {
key:function(e) {
return s[e];
},
getItem:function(e) {
return e in a ? a[e] :null;
},
setItem:function(e, t) {
a[e] = "" + t, r();
},
removeItem:function(e) {
delete a[e], r();
},
clear:function() {
a = {}, r();
}
}, n(), i;
}), r(Ct, [ y, l, b, C, u, d ], function(e, t, n, r, i, o) {
var a = window.tinymce;
return a.DOM = e.DOM, a.ScriptLoader = n.ScriptLoader, a.PluginManager = r.PluginManager, 
a.ThemeManager = r.ThemeManager, a.dom = a.dom || {}, a.dom.Event = t.Event, i.each(i, function(e, t) {
a[t] = e;
}), i.each("isOpera isWebKit isIE isGecko isMac".split(" "), function(e) {
a[e] = o[e.substr(2).toLowerCase()];
}), {};
}), r(xt, [ V, u ], function(e, t) {
return e.extend({
Defaults:{
firstControlClass:"first",
lastControlClass:"last"
},
init:function(e) {
this.settings = t.extend({}, this.Defaults, e);
},
preRender:function(e) {
e.addClass(this.settings.containerClass, "body");
},
applyClasses:function(e) {
var r, i, o, t = this, n = t.settings;
r = e.items().filter(":visible"), i = n.firstControlClass, o = n.lastControlClass, 
r.each(function(e) {
e.removeClass(i).removeClass(o), n.controlClass && e.addClass(n.controlClass);
}), r.eq(0).addClass(i), r.eq(-1).addClass(o);
},
renderHtml:function(e) {
var r, t = this, n = t.settings, i = "";
return r = e.items(), r.eq(0).addClass(n.firstControlClass), r.eq(-1).addClass(n.lastControlClass), 
r.each(function(e) {
n.controlClass && e.addClass(n.controlClass), i += e.renderHtml();
}), i;
},
recalc:function() {},
postRender:function() {}
});
}), r(wt, [ xt ], function(e) {
return e.extend({
Defaults:{
containerClass:"abs-layout",
controlClass:"abs-layout-item"
},
recalc:function(e) {
e.items().filter(":visible").each(function(e) {
var t = e.settings;
e.layoutRect({
x:t.x,
y:t.y,
w:t.w,
h:t.h
}), e.recalc && e.recalc();
});
},
renderHtml:function(e) {
return '<div id="' + e._id + '-absend" class="' + e.classPrefix + 'abs-end"></div>' + this._super(e);
}
});
}), r(_t, [ K, et ], function(e, t) {
return e.extend({
Mixins:[ t ],
Defaults:{
classes:"widget tooltip tooltip-n"
},
text:function(e) {
var t = this;
return "undefined" != typeof e ? (t._value = e, t._rendered && (t.getEl().lastChild.innerHTML = t.encode(e)), 
t) :t._value;
},
renderHtml:function() {
var e = this, t = e.classPrefix;
return '<div id="' + e._id + '" class="' + e.classes() + '" role="presentation"><div class="' + t + 'tooltip-arrow"></div><div class="' + t + 'tooltip-inner">' + e.encode(e._text) + "</div></div>";
},
repaint:function() {
var t, n, e = this;
t = e.getEl().style, n = e._layoutRect, t.left = n.x + "px", t.top = n.y + "px", 
t.zIndex = 131070;
}
});
}), r(Nt, [ K, _t ], function(e, t) {
var n, r = e.extend({
init:function(e) {
var t = this;
t._super(e), e = t.settings, t.canFocus = !0, e.tooltip && r.tooltips !== !1 && (t.on("mouseenter", function(n) {
var r = t.tooltip().moveTo(-65535);
if (n.control == t) {
var i = r.text(e.tooltip).show().testMoveRel(t.getEl(), [ "bc-tc", "bc-tl", "bc-tr" ]);
r.toggleClass("tooltip-n", "bc-tc" == i), r.toggleClass("tooltip-nw", "bc-tl" == i), 
r.toggleClass("tooltip-ne", "bc-tr" == i), r.moveRel(t.getEl(), i);
} else r.hide();
}), t.on("mouseleave mousedown click", function() {
t.tooltip().hide();
})), t.aria("label", e.ariaLabel || e.tooltip);
},
tooltip:function() {
return n || (n = new t({
type:"tooltip"
}), n.renderTo()), n;
},
active:function(e) {
var n, t = this;
return e !== n && (t.aria("pressed", e), t.toggleClass("active", e)), t._super(e);
},
disabled:function(e) {
var n, t = this;
return e !== n && (t.aria("disabled", e), t.toggleClass("disabled", e)), t._super(e);
},
postRender:function() {
var e = this, t = e.settings;
e._rendered = !0, e._super(), e.parent() || !t.width && !t.height || (e.initLayoutRect(), 
e.repaint()), t.autofocus && e.focus();
},
remove:function() {
this._super(), n && (n.remove(), n = null);
}
});
return r;
}), r(Et, [ Nt ], function(e) {
return e.extend({
Defaults:{
classes:"widget btn",
role:"button"
},
init:function(e) {
var n, t = this;
t.on("click mousedown", function(e) {
e.preventDefault();
}), t._super(e), n = e.size, e.subtype && t.addClass(e.subtype), n && t.addClass("btn-" + n);
},
icon:function(e) {
var t = this, n = t.classPrefix;
if ("undefined" == typeof e) return t.settings.icon;
if (t.settings.icon = e, e = e ? n + "ico " + n + "i-" + t.settings.icon :"", t._rendered) {
var r = t.getEl().firstChild, i = r.getElementsByTagName("i")[0];
e ? (i && i == r.firstChild || (i = document.createElement("i"), r.insertBefore(i, r.firstChild)), 
i.className = e) :i && r.removeChild(i), t.text(t._text);
}
return t;
},
repaint:function() {
var e = this.getEl().firstChild.style;
e.width = e.height = "100%", this._super();
},
text:function(e) {
var t = this;
if (t._rendered) {
var n = t.getEl().lastChild.lastChild;
n && (n.data = t.translate(e));
}
return t._super(e);
},
renderHtml:function() {
var i, e = this, t = e._id, n = e.classPrefix, r = e.settings.icon;
return i = e.settings.image, i ? (r = "none", "string" != typeof i && (i = window.getSelection ? i[0] :i[1]), 
i = " style=\"background-image: url('" + i + "')\"") :i = "", r = e.settings.icon ? n + "ico " + n + "i-" + r :"", 
'<div id="' + t + '" class="' + e.classes() + '" tabindex="-1" aria-labelledby="' + t + '"><button role="presentation" type="button" tabindex="-1">' + (r ? '<i class="' + r + '"' + i + "></i>" :"") + (e._text ? (r ? "\xa0" :"") + e.encode(e._text) :"") + "</button></div>";
}
});
}), r(kt, [ X ], function(e) {
return e.extend({
Defaults:{
defaultType:"button",
role:"group"
},
renderHtml:function() {
var e = this, t = e._layout;
return e.addClass("btn-group"), e.preRender(), t.preRender(e), '<div id="' + e._id + '" class="' + e.classes() + '"><div id="' + e._id + '-body">' + (e.settings.html || "") + t.renderHtml(e) + "</div></div>";
}
});
}), r(St, [ Nt ], function(e) {
return e.extend({
Defaults:{
classes:"checkbox",
role:"checkbox",
checked:!1
},
init:function(e) {
var t = this;
t._super(e), t.on("click mousedown", function(e) {
e.preventDefault();
}), t.on("click", function(e) {
e.preventDefault(), t.disabled() || t.checked(!t.checked());
}), t.checked(t.settings.checked);
},
checked:function(e) {
var t = this;
return "undefined" != typeof e ? (e ? t.addClass("checked") :t.removeClass("checked"), 
t._checked = e, t.aria("checked", e), t) :t._checked;
},
value:function(e) {
return this.checked(e);
},
renderHtml:function() {
var e = this, t = e._id, n = e.classPrefix;
return '<div id="' + t + '" class="' + e.classes() + '" unselectable="on" aria-labelledby="' + t + '-al" tabindex="-1"><i class="' + n + "ico " + n + 'i-checkbox"></i><span id="' + t + '-al" class="' + n + 'label">' + e.encode(e._text) + "</span></div>";
}
});
}), r(Tt, [ Nt, G, j ], function(e, t, n) {
return e.extend({
init:function(e) {
var t = this;
t._super(e), t.addClass("combobox"), t.subinput = !0, t.ariaTarget = "inp", e = t.settings, 
e.menu = e.menu || e.values, e.menu && (e.icon = "caret"), t.on("click", function(n) {
for (var r = n.target, i = t.getEl(); r && r != i; ) r.id && -1 != r.id.indexOf("-open") && (t.fire("action"), 
e.menu && (t.showMenu(), n.aria && t.menu.items()[0].focus())), r = r.parentNode;
}), t.on("keydown", function(e) {
"INPUT" == e.target.nodeName && 13 == e.keyCode && t.parents().reverse().each(function(n) {
return e.preventDefault(), t.fire("change"), n.hasEventListeners("submit") && n.toJSON ? (n.fire("submit", {
data:n.toJSON()
}), !1) :void 0;
});
}), e.placeholder && (t.addClass("placeholder"), t.on("focusin", function() {
t._hasOnChange || (n.on(t.getEl("inp"), "change", function() {
t.fire("change");
}), t._hasOnChange = !0), t.hasClass("placeholder") && (t.getEl("inp").value = "", 
t.removeClass("placeholder"));
}), t.on("focusout", function() {
0 === t.value().length && (t.getEl("inp").value = e.placeholder, t.addClass("placeholder"));
}));
},
showMenu:function() {
var r, e = this, n = e.settings;
e.menu || (r = n.menu || [], r.length ? r = {
type:"menu",
items:r
} :r.type = r.type || "menu", e.menu = t.create(r).parent(e).renderTo(e.getContainerElm()), 
e.fire("createmenu"), e.menu.reflow(), e.menu.on("cancel", function(t) {
t.control === e.menu && e.focus();
}), e.menu.on("show hide", function(t) {
t.control.items().each(function(t) {
t.active(t.value() == e.value());
});
}).fire("show"), e.menu.on("select", function(t) {
e.value(t.control.value());
}), e.on("focusin", function(t) {
"INPUT" == t.target.tagName.toUpperCase() && e.menu.hide();
}), e.aria("expanded", !0)), e.menu.show(), e.menu.layoutRect({
w:e.layoutRect().w
}), e.menu.moveRel(e.getEl(), e.isRtl() ? [ "br-tr", "tr-br" ] :[ "bl-tl", "tl-bl" ]);
},
value:function(e) {
var t = this;
return "undefined" != typeof e ? (t._value = e, t.removeClass("placeholder"), t._rendered && (t.getEl("inp").value = e), 
t) :t._rendered ? (e = t.getEl("inp").value, e != t.settings.placeholder ? e :"") :t._value;
},
disabled:function(e) {
var t = this;
return t._rendered && "undefined" != typeof e && (t.getEl("inp").disabled = e), 
t._super(e);
},
focus:function() {
this.getEl("inp").focus();
},
repaint:function() {
var o, a, e = this, t = e.getEl(), r = e.getEl("open"), i = e.layoutRect();
o = r ? i.w - n.getSize(r).width - 10 :i.w - 10;
var s = document;
return s.all && (!s.documentMode || s.documentMode <= 8) && (a = e.layoutRect().h - 2 + "px"), 
n.css(t.firstChild, {
width:o,
lineHeight:a
}), e._super(), e;
},
postRender:function() {
var e = this;
return n.on(this.getEl("inp"), "change", function() {
e.fire("change");
}), e._super();
},
remove:function() {
n.off(this.getEl("inp")), this._super();
},
renderHtml:function() {
var o, a, e = this, t = e._id, n = e.settings, r = e.classPrefix, i = n.value || n.placeholder || "", s = "", l = "";
return "spellcheck" in n && (l += ' spellcheck="' + n.spellcheck + '"'), n.maxLength && (l += ' maxlength="' + n.maxLength + '"'), 
n.size && (l += ' size="' + n.size + '"'), n.subtype && (l += ' type="' + n.subtype + '"'), 
e.disabled() && (l += ' disabled="disabled"'), o = n.icon, o && "caret" != o && (o = r + "ico " + r + "i-" + n.icon), 
a = e._text, (o || a) && (s = '<div id="' + t + '-open" class="' + r + "btn " + r + 'open" tabIndex="-1" role="button"><button id="' + t + '-action" type="button" hidefocus="1" tabindex="-1">' + ("caret" != o ? '<i class="' + o + '"></i>' :'<i class="' + r + 'caret"></i>') + (a ? (o ? " " :"") + a :"") + "</button></div>", 
e.addClass("has-open")), '<div id="' + t + '" class="' + e.classes() + '"><input id="' + t + '-inp" class="' + r + "textbox " + r + 'placeholder" value="' + i + '" hidefocus="1"' + l + " />" + s + "</div>";
}
});
}), r(Rt, [ Tt ], function(e) {
return e.extend({
init:function(e) {
var t = this;
e.spellcheck = !1, e.icon = "none", t._super(e), t.addClass("colorbox"), t.on("change keyup postrender", function() {
t.repaintColor(t.value());
});
},
repaintColor:function(e) {
this.getEl().getElementsByTagName("i")[0].style.background = e;
},
value:function(e) {
var t = this;
return "undefined" != typeof e && t._rendered && t.repaintColor(e), t._super(e);
}
});
}), r(At, [ Et, nt ], function(e, t) {
return e.extend({
showPanel:function() {
var e = this, n = e.settings;
if (e.active(!0), e.panel) e.panel.show(); else {
var r = n.panel;
r.type && (r = {
layout:"grid",
items:r
}), r.role = r.role || "dialog", r.popover = !0, r.autohide = !0, r.ariaRoot = !0, 
e.panel = new t(r).on("hide", function() {
e.active(!1);
}).on("cancel", function(t) {
t.stopPropagation(), e.focus(), e.hidePanel();
}).parent(e).renderTo(e.getContainerElm()), e.panel.fire("show"), e.panel.reflow();
}
e.panel.moveRel(e.getEl(), n.popoverAlign || (e.isRtl() ? [ "bc-tr", "bc-tc" ] :[ "bc-tl", "bc-tc" ]));
},
hidePanel:function() {
var e = this;
e.panel && e.panel.hide();
},
postRender:function() {
var e = this;
return e.aria("haspopup", !0), e.on("click", function(t) {
t.control === e && (e.panel && e.panel.visible() ? e.hidePanel() :(e.showPanel(), 
e.panel.focus(!!t.aria)));
}), e._super();
}
});
}), r(Bt, [ At, y ], function(e, t) {
var n = t.DOM;
return e.extend({
init:function(e) {
this._super(e), this.addClass("colorbutton");
},
color:function(e) {
return e ? (this._color = e, this.getEl("preview").style.backgroundColor = e, this) :this._color;
},
renderHtml:function() {
var e = this, t = e._id, n = e.classPrefix, r = e.settings.icon ? n + "ico " + n + "i-" + e.settings.icon :"", i = e.settings.image ? " style=\"background-image: url('" + e.settings.image + "')\"" :"";
return '<div id="' + t + '" class="' + e.classes() + '" role="button" tabindex="-1" aria-haspopup="true"><button role="presentation" hidefocus="1" type="button" tabindex="-1">' + (r ? '<i class="' + r + '"' + i + "></i>" :"") + '<span id="' + t + '-preview" class="' + n + 'preview"></span>' + (e._text ? (r ? " " :"") + e._text :"") + '</button><button type="button" class="' + n + 'open" hidefocus="1" tabindex="-1"> <i class="' + n + 'caret"></i></button></div>';
},
postRender:function() {
var e = this, t = e.settings.onclick;
return e.on("click", function(r) {
r.aria && "down" == r.aria.key || r.control != e || n.getParent(r.target, "." + e.classPrefix + "open") || (r.stopImmediatePropagation(), 
t.call(e, r));
}), delete e.settings.onclick, e._super();
}
});
}), r(Dt, [], function() {
function e(e) {
function i(e, i, o) {
var a, s, l, c, u, d;
return a = 0, s = 0, l = 0, e /= 255, i /= 255, o /= 255, u = t(e, t(i, o)), d = n(e, n(i, o)), 
u == d ? (l = u, {
h:0,
s:0,
v:100 * l
}) :(c = e == u ? i - o :o == u ? e - i :o - e, a = e == u ? 3 :o == u ? 1 :5, a = 60 * (a - c / (d - u)), 
s = (d - u) / d, l = d, {
h:r(a),
s:r(100 * s),
v:r(100 * l)
});
}
function o(e, i, o) {
var a, s, l, c;
if (e = (parseInt(e, 10) || 0) % 360, i = parseInt(i, 10) / 100, o = parseInt(o, 10) / 100, 
i = n(0, t(i, 1)), o = n(0, t(o, 1)), 0 === i) return void (d = f = p = r(255 * o));
switch (a = e / 60, s = o * i, l = s * (1 - Math.abs(a % 2 - 1)), c = o - s, Math.floor(a)) {
case 0:
d = s, f = l, p = 0;
break;

case 1:
d = l, f = s, p = 0;
break;

case 2:
d = 0, f = s, p = l;
break;

case 3:
d = 0, f = l, p = s;
break;

case 4:
d = l, f = 0, p = s;
break;

case 5:
d = s, f = 0, p = l;
break;

default:
d = f = p = 0;
}
d = r(255 * (d + c)), f = r(255 * (f + c)), p = r(255 * (p + c));
}
function a() {
function e(e) {
return e = parseInt(e, 10).toString(16), e.length > 1 ? e :"0" + e;
}
return "#" + e(d) + e(f) + e(p);
}
function s() {
return {
r:d,
g:f,
b:p
};
}
function l() {
return i(d, f, p);
}
function c(e) {
var t;
return "object" == typeof e ? "r" in e ? (d = e.r, f = e.g, p = e.b) :"v" in e && o(e.h, e.s, e.v) :(t = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(e)) ? (d = parseInt(t[1], 10), 
f = parseInt(t[2], 10), p = parseInt(t[3], 10)) :(t = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(e)) ? (d = parseInt(t[1], 16), 
f = parseInt(t[2], 16), p = parseInt(t[3], 16)) :(t = /#([0-F])([0-F])([0-F])/gi.exec(e)) && (d = parseInt(t[1] + t[1], 16), 
f = parseInt(t[2] + t[2], 16), p = parseInt(t[3] + t[3], 16)), d = 0 > d ? 0 :d > 255 ? 255 :d, 
f = 0 > f ? 0 :f > 255 ? 255 :f, p = 0 > p ? 0 :p > 255 ? 255 :p, u;
}
var u = this, d = 0, f = 0, p = 0;
e && c(e), u.toRgb = s, u.toHsv = l, u.toHex = a, u.parse = c;
}
var t = Math.min, n = Math.max, r = Math.round;
return e;
}), r(Lt, [ Nt, J, j, Dt ], function(e, t, n, r) {
return e.extend({
Defaults:{
classes:"widget colorpicker"
},
init:function(e) {
this._super(e);
},
postRender:function() {
function e(e, t) {
var i, o, r = n.getPos(e);
return i = t.pageX - r.x, o = t.pageY - r.y, i = Math.max(0, Math.min(i / e.clientWidth, 1)), 
o = Math.max(0, Math.min(o / e.clientHeight, 1)), {
x:i,
y:o
};
}
function i(e, t) {
var i = (360 - e.h) / 360;
n.css(d, {
top:100 * i + "%"
}), t || n.css(p, {
left:e.s + "%",
top:100 - e.v + "%"
}), f.style.background = new r({
s:100,
v:100,
h:e.h
}).toHex(), s.color().parse({
s:e.s,
v:e.v,
h:e.h
});
}
function o(t) {
var n;
n = e(f, t), c.s = 100 * n.x, c.v = 100 * (1 - n.y), i(c), s.fire("change");
}
function a(t) {
var n;
n = e(u, t), c = l.toHsv(), c.h = 360 * (1 - n.y), i(c, !0), s.fire("change");
}
var c, u, d, f, p, s = this, l = s.color();
u = s.getEl("h"), d = s.getEl("hp"), f = s.getEl("sv"), p = s.getEl("svp"), s._repaint = function() {
c = l.toHsv(), i(c);
}, s._super(), s._svdraghelper = new t(s._id + "-sv", {
start:o,
drag:o
}), s._hdraghelper = new t(s._id + "-h", {
start:a,
drag:a
}), s._repaint();
},
rgb:function() {
return this.color().toRgb();
},
value:function(e) {
var t = this;
return arguments.length ? (t.color().parse(e), void (t._rendered && t._repaint())) :t.color().toHex();
},
color:function() {
return this._color || (this._color = new r()), this._color;
},
renderHtml:function() {
function e() {
var e, t, i, a, n = "";
for (i = "filter:progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=", 
a = o.split(","), e = 0, t = a.length - 1; t > e; e++) n += '<div class="' + r + 'colorpicker-h-chunk" style="height:' + 100 / t + "%;" + i + a[e] + ",endColorstr=" + a[e + 1] + ");-ms-" + i + a[e] + ",endColorstr=" + a[e + 1] + ')"></div>';
return n;
}
var i, t = this, n = t._id, r = t.classPrefix, o = "#ff0000,#ff0080,#ff00ff,#8000ff,#0000ff,#0080ff,#00ffff,#00ff80,#00ff00,#80ff00,#ffff00,#ff8000,#ff0000", a = "background: -ms-linear-gradient(top," + o + ");background: linear-gradient(to bottom," + o + ");";
return i = '<div id="' + n + '-h" class="' + r + 'colorpicker-h" style="' + a + '">' + e() + '<div id="' + n + '-hp" class="' + r + 'colorpicker-h-marker"></div></div>', 
'<div id="' + n + '" class="' + t.classes() + '"><div id="' + n + '-sv" class="' + r + 'colorpicker-sv"><div class="' + r + 'colorpicker-overlay1"><div class="' + r + 'colorpicker-overlay2"><div id="' + n + '-svp" class="' + r + 'colorpicker-selector1"><div class="' + r + 'colorpicker-selector2"></div></div></div></div></div>' + i + "</div>";
}
});
}), r(Mt, [ Nt ], function(e) {
return e.extend({
init:function(e) {
var t = this;
e.delimiter || (e.delimiter = "\xbb"), t._super(e), t.addClass("path"), t.canFocus = !0, 
t.on("click", function(e) {
var n, r = e.target;
(n = r.getAttribute("data-index")) && t.fire("select", {
value:t.data()[n],
index:n
});
});
},
focus:function() {
var e = this;
return e.getEl().firstChild.focus(), e;
},
data:function(e) {
var t = this;
return "undefined" != typeof e ? (t._data = e, t.update(), t) :t._data;
},
update:function() {
this.innerHtml(this._getPathHtml());
},
postRender:function() {
var e = this;
e._super(), e.data(e.settings.data);
},
renderHtml:function() {
var e = this;
return '<div id="' + e._id + '" class="' + e.classes() + '">' + e._getPathHtml() + "</div>";
},
_getPathHtml:function() {
var n, r, e = this, t = e._data || [], i = "", o = e.classPrefix;
for (n = 0, r = t.length; r > n; n++) i += (n > 0 ? '<div class="' + o + 'divider" aria-hidden="true"> ' + e.settings.delimiter + " </div>" :"") + '<div role="button" class="' + o + "path-item" + (n == r - 1 ? " " + o + "last" :"") + '" data-index="' + n + '" tabindex="-1" id="' + e._id + "-" + n + '" aria-level="' + n + '">' + t[n].name + "</div>";
return i || (i = '<div class="' + o + 'path-item">\xa0</div>'), i;
}
});
}), r(Ht, [ Mt, pt ], function(e, t) {
return e.extend({
postRender:function() {
function e(e) {
if (1 === e.nodeType) {
if ("BR" == e.nodeName || e.getAttribute("data-mce-bogus")) return !0;
if ("bookmark" === e.getAttribute("data-mce-type")) return !0;
}
return !1;
}
var n = this, r = t.activeEditor;
return n.on("select", function(t) {
var i, n = [], o = r.getBody();
for (r.focus(), i = r.selection.getStart(); i && i != o; ) e(i) || n.push(i), i = i.parentNode;
r.selection.select(n[n.length - 1 - t.index]), r.nodeChanged();
}), r.on("nodeChange", function(t) {
for (var i = [], o = t.parents, a = o.length; a--; ) if (1 == o[a].nodeType && !e(o[a])) {
var s = r.fire("ResolveName", {
name:o[a].nodeName.toLowerCase(),
target:o[a]
});
i.push({
name:s.name
});
}
n.data(i);
}), n._super();
}
});
}), r(Pt, [ X ], function(e) {
return e.extend({
Defaults:{
layout:"flex",
align:"center",
defaults:{
flex:1
}
},
renderHtml:function() {
var e = this, t = e._layout, n = e.classPrefix;
return e.addClass("formitem"), t.preRender(e), '<div id="' + e._id + '" class="' + e.classes() + '" hidefocus="1" tabindex="-1">' + (e.settings.title ? '<div id="' + e._id + '-title" class="' + n + 'title">' + e.settings.title + "</div>" :"") + '<div id="' + e._id + '-body" class="' + e.classes("body") + '">' + (e.settings.html || "") + t.renderHtml(e) + "</div></div>";
}
});
}), r(Ot, [ X, Pt, u ], function(e, t, n) {
return e.extend({
Defaults:{
containerCls:"form",
layout:"flex",
direction:"column",
align:"stretch",
flex:1,
padding:20,
labelGap:30,
spacing:10,
callbacks:{
submit:function() {
this.submit();
}
}
},
preRender:function() {
var e = this, r = e.items();
e.settings.formItemDefaults || (e.settings.formItemDefaults = {
layout:"flex",
autoResize:"overflow",
defaults:{
flex:1
}
}), r.each(function(r) {
var i, o = r.settings.label;
o && (i = new t(n.extend({
items:{
type:"label",
id:r._id + "-l",
text:o,
flex:0,
forId:r._id,
disabled:r.disabled()
}
}, e.settings.formItemDefaults)), i.type = "formitem", r.aria("labelledby", r._id + "-l"), 
"undefined" == typeof r.settings.flex && (r.settings.flex = 1), e.replace(r, i), 
i.add(r));
});
},
recalcLabels:function() {
var r, i, o, e = this, t = 0, n = [];
if (e.settings.labelGapCalc !== !1) for (o = "children" == e.settings.labelGapCalc ? e.find("formitem") :e.items(), 
o.filter("formitem").each(function(e) {
var r = e.items()[0], i = r.getEl().clientWidth;
t = i > t ? i :t, n.push(r);
}), i = e.settings.labelGap || 0, r = n.length; r--; ) n[r].settings.minWidth = t + i;
},
visible:function(e) {
var t = this._super(e);
return e === !0 && this._rendered && this.recalcLabels(), t;
},
submit:function() {
return this.fire("submit", {
data:this.toJSON()
});
},
postRender:function() {
var e = this;
e._super(), e.recalcLabels(), e.fromJSON(e.settings.data);
}
});
}), r(It, [ Ot ], function(e) {
return e.extend({
Defaults:{
containerCls:"fieldset",
layout:"flex",
direction:"column",
align:"stretch",
flex:1,
padding:"25 15 5 15",
labelGap:30,
spacing:10,
border:1
},
renderHtml:function() {
var e = this, t = e._layout, n = e.classPrefix;
return e.preRender(), t.preRender(e), '<fieldset id="' + e._id + '" class="' + e.classes() + '" hidefocus="1" tabindex="-1">' + (e.settings.title ? '<legend id="' + e._id + '-title" class="' + n + 'fieldset-title">' + e.settings.title + "</legend>" :"") + '<div id="' + e._id + '-body" class="' + e.classes("body") + '">' + (e.settings.html || "") + t.renderHtml(e) + "</div></fieldset>";
}
});
}), r(Ft, [ Tt, u ], function(e, t) {
return e.extend({
init:function(e) {
var o, a, s, n = this, r = tinymce.activeEditor, i = r.settings;
e.spellcheck = !1, s = i.file_picker_types || i.file_browser_callback_types, s && (s = t.makeMap(s, /[, ]/)), 
(!s || s[e.filetype]) && (a = i.file_picker_callback, !a || s && !s[e.filetype] ? (a = i.file_browser_callback, 
!a || s && !s[e.filetype] || (o = function() {
a(n.getEl("inp").id, n.value(), e.filetype, window);
})) :o = function() {
var i = n.fire("beforecall").meta;
i = t.extend({
filetype:e.filetype
}, i), a.call(r, function(e, t) {
n.value(e).fire("change", {
meta:t
});
}, n.value(), i);
}), o && (e.icon = "browse", e.onaction = o), n._super(e);
}
});
}), r(zt, [ wt ], function(e) {
return e.extend({
recalc:function(e) {
var t = e.layoutRect(), n = e.paddingBox();
e.items().filter(":visible").each(function(e) {
e.layoutRect({
x:n.left,
y:n.top,
w:t.innerW - n.right - n.left,
h:t.innerH - n.top - n.bottom
}), e.recalc && e.recalc();
});
}
});
}), r(Wt, [ wt ], function(e) {
return e.extend({
recalc:function(e) {
var t, n, r, i, o, a, s, l, c, u, d, f, p, h, m, g, y, b, C, x, w, _, N, E, k, S, T, R, A, B, D, L, M, H, P, O, I, F, v = [], z = Math.max, W = Math.min;
for (r = e.items().filter(":visible"), i = e.layoutRect(), o = e._paddingBox, a = e.settings, 
f = e.isRtl() ? a.direction || "row-reversed" :a.direction, s = a.align, l = e.isRtl() ? a.pack || "end" :a.pack, 
c = a.spacing || 0, ("row-reversed" == f || "column-reverse" == f) && (r = r.set(r.toArray().reverse()), 
f = f.split("-")[0]), "column" == f ? (k = "y", N = "h", E = "minH", S = "maxH", 
R = "innerH", T = "top", A = "deltaH", B = "contentH", P = "left", M = "w", D = "x", 
L = "innerW", H = "minW", O = "right", I = "deltaW", F = "contentW") :(k = "x", 
N = "w", E = "minW", S = "maxW", R = "innerW", T = "left", A = "deltaW", B = "contentW", 
P = "top", M = "h", D = "y", L = "innerH", H = "minH", O = "bottom", I = "deltaH", 
F = "contentH"), d = i[R] - o[T] - o[T], _ = u = 0, t = 0, n = r.length; n > t; t++) p = r[t], 
h = p.layoutRect(), m = p.settings, g = m.flex, d -= n - 1 > t ? c :0, g > 0 && (u += g, 
h[S] && v.push(p), h.flex = g), d -= h[E], y = o[P] + h[H] + o[O], y > _ && (_ = y);
if (x = {}, x[E] = 0 > d ? i[E] - d + i[A] :i[R] - d + i[A], x[H] = _ + i[I], x[B] = i[R] - d, 
x[F] = _, x.minW = W(x.minW, i.maxW), x.minH = W(x.minH, i.maxH), x.minW = z(x.minW, i.startMinWidth), 
x.minH = z(x.minH, i.startMinHeight), !i.autoResize || x.minW == i.minW && x.minH == i.minH) {
for (C = d / u, t = 0, n = v.length; n > t; t++) p = v[t], h = p.layoutRect(), b = h[S], 
y = h[E] + h.flex * C, y > b ? (d -= h[S] - h[E], u -= h.flex, h.flex = 0, h.maxFlexSize = b) :h.maxFlexSize = 0;
for (C = d / u, w = o[T], x = {}, 0 === u && ("end" == l ? w = d + o[T] :"center" == l ? (w = Math.round(i[R] / 2 - (i[R] - d) / 2) + o[T], 
0 > w && (w = o[T])) :"justify" == l && (w = o[T], c = Math.floor(d / (r.length - 1)))), 
x[D] = o[P], t = 0, n = r.length; n > t; t++) p = r[t], h = p.layoutRect(), y = h.maxFlexSize || h[E], 
"center" === s ? x[D] = Math.round(i[L] / 2 - h[M] / 2) :"stretch" === s ? (x[M] = z(h[H] || 0, i[L] - o[P] - o[O]), 
x[D] = o[P]) :"end" === s && (x[D] = i[L] - h[M] - o.top), h.flex > 0 && (y += h.flex * C), 
x[N] = y, x[k] = w, p.layoutRect(x), p.recalc && p.recalc(), w += y + c;
} else if (x.w = x.minW, x.h = x.minH, e.layoutRect(x), this.recalc(e), null === e._lastRect) {
var V = e.parent();
V && (V._lastRect = null, V.recalc());
}
}
});
}), r(Vt, [ xt ], function(e) {
return e.extend({
Defaults:{
containerClass:"flow-layout",
controlClass:"flow-layout-item",
endClass:"break"
},
recalc:function(e) {
e.items().filter(":visible").each(function(e) {
e.recalc && e.recalc();
});
}
});
}), r(Ut, [ K, Nt, nt, u, pt, d ], function(e, t, n, r, i, o) {
function a(e) {
function t(t, n) {
return function() {
var r = this;
e.on("nodeChange", function(i) {
var o = e.formatter, a = null;
s(i.parents, function(e) {
return s(t, function(t) {
return n ? o.matchNode(e, n, {
value:t.value
}) && (a = t.value) :o.matchNode(e, t.value) && (a = t.value), a ? !1 :void 0;
}), a ? !1 :void 0;
}), r.value(a);
});
};
}
function r(e) {
e = e.replace(/;$/, "").split(";");
for (var t = e.length; t--; ) e[t] = e[t].split("=");
return e;
}
function i() {
function t(e) {
var n = [];
return e ? (s(e, function(e) {
var o = {
text:e.title,
icon:e.icon
};
if (e.items) o.menu = t(e.items); else {
var a = e.format || "custom" + r++;
e.format || (e.name = a, i.push(e)), o.format = a, o.cmd = e.cmd;
}
n.push(o);
}), n) :void 0;
}
function n() {
var n;
return n = t(e.settings.style_formats_merge ? e.settings.style_formats ? o.concat(e.settings.style_formats) :o :e.settings.style_formats || o);
}
var r = 0, i = [], o = [ {
title:"Headings",
items:[ {
title:"Heading 1",
format:"h1"
}, {
title:"Heading 2",
format:"h2"
}, {
title:"Heading 3",
format:"h3"
}, {
title:"Heading 4",
format:"h4"
}, {
title:"Heading 5",
format:"h5"
}, {
title:"Heading 6",
format:"h6"
} ]
}, {
title:"Inline",
items:[ {
title:"Bold",
icon:"bold",
format:"bold"
}, {
title:"Italic",
icon:"italic",
format:"italic"
}, {
title:"Underline",
icon:"underline",
format:"underline"
}, {
title:"Strikethrough",
icon:"strikethrough",
format:"strikethrough"
}, {
title:"Superscript",
icon:"superscript",
format:"superscript"
}, {
title:"Subscript",
icon:"subscript",
format:"subscript"
}, {
title:"Code",
icon:"code",
format:"code"
} ]
}, {
title:"Blocks",
items:[ {
title:"Paragraph",
format:"p"
}, {
title:"Blockquote",
format:"blockquote"
}, {
title:"Div",
format:"div"
}, {
title:"Pre",
format:"pre"
} ]
}, {
title:"Alignment",
items:[ {
title:"Left",
icon:"alignleft",
format:"alignleft"
}, {
title:"Center",
icon:"aligncenter",
format:"aligncenter"
}, {
title:"Right",
icon:"alignright",
format:"alignright"
}, {
title:"Justify",
icon:"alignjustify",
format:"alignjustify"
} ]
} ];
return e.on("init", function() {
s(i, function(t) {
e.formatter.register(t.name, t);
});
}), {
type:"menu",
items:n(),
onPostRender:function(t) {
e.fire("renderFormatsMenu", {
control:t.control
});
},
itemDefaults:{
preview:!0,
textStyle:function() {
return this.settings.format ? e.formatter.getCssText(this.settings.format) :void 0;
},
onPostRender:function() {
var t = this;
t.parent().on("show", function() {
var n, r;
n = t.settings.format, n && (t.disabled(!e.formatter.canApply(n)), t.active(e.formatter.match(n))), 
r = t.settings.cmd, r && t.active(e.queryCommandState(r));
});
},
onclick:function() {
this.settings.format && l(this.settings.format), this.settings.cmd && e.execCommand(this.settings.cmd);
}
}
};
}
function o(t) {
return function() {
function n() {
return e.undoManager ? e.undoManager[t]() :!1;
}
var r = this;
t = "redo" == t ? "hasRedo" :"hasUndo", r.disabled(!n()), e.on("Undo Redo AddUndo TypingUndo ClearUndos", function() {
r.disabled(!n());
});
};
}
function a() {
var t = this;
e.on("VisualAid", function(e) {
t.active(e.hasVisual);
}), t.active(e.hasVisual);
}
function l(t) {
t.control && (t = t.control.value()), t && e.execCommand("mceToggleFormat", !1, t);
}
var c;
c = i(), s({
bold:"Bold",
italic:"Italic",
underline:"Underline",
strikethrough:"Strikethrough",
subscript:"Subscript",
superscript:"Superscript"
}, function(t, n) {
e.addButton(n, {
tooltip:t,
onPostRender:function() {
var t = this;
e.formatter ? e.formatter.formatChanged(n, function(e) {
t.active(e);
}) :e.on("init", function() {
e.formatter.formatChanged(n, function(e) {
t.active(e);
});
});
},
onclick:function() {
l(n);
}
});
}), s({
outdent:[ "Decrease indent", "Outdent" ],
indent:[ "Increase indent", "Indent" ],
cut:[ "Cut", "Cut" ],
copy:[ "Copy", "Copy" ],
paste:[ "Paste", "Paste" ],
help:[ "Help", "mceHelp" ],
selectall:[ "Select all", "SelectAll" ],
hr:[ "Insert horizontal rule", "InsertHorizontalRule" ],
removeformat:[ "Clear formatting", "RemoveFormat" ],
visualaid:[ "Visual aids", "mceToggleVisualAid" ],
newdocument:[ "New document", "mceNewDocument" ]
}, function(t, n) {
e.addButton(n, {
tooltip:t[0],
cmd:t[1]
});
}), s({
blockquote:[ "Blockquote", "mceBlockQuote" ],
numlist:[ "Numbered list", "InsertOrderedList" ],
bullist:[ "Bullet list", "InsertUnorderedList" ],
subscript:[ "Subscript", "Subscript" ],
superscript:[ "Superscript", "Superscript" ],
alignleft:[ "Align left", "JustifyLeft" ],
aligncenter:[ "Align center", "JustifyCenter" ],
alignright:[ "Align right", "JustifyRight" ],
alignjustify:[ "Justify", "JustifyFull" ]
}, function(t, n) {
e.addButton(n, {
tooltip:t[0],
cmd:t[1],
onPostRender:function() {
var t = this;
e.formatter ? e.formatter.formatChanged(n, function(e) {
t.active(e);
}) :e.on("init", function() {
e.formatter.formatChanged(n, function(e) {
t.active(e);
});
});
}
});
}), e.addButton("undo", {
tooltip:"Undo",
onPostRender:o("undo"),
cmd:"undo"
}), e.addButton("redo", {
tooltip:"Redo",
onPostRender:o("redo"),
cmd:"redo"
}), e.addMenuItem("newdocument", {
text:"New document",
shortcut:"Ctrl+N",
icon:"newdocument",
cmd:"mceNewDocument"
}), e.addMenuItem("undo", {
text:"Undo",
icon:"undo",
shortcut:"Ctrl+Z",
onPostRender:o("undo"),
cmd:"undo"
}), e.addMenuItem("redo", {
text:"Redo",
icon:"redo",
shortcut:"Ctrl+Y",
onPostRender:o("redo"),
cmd:"redo"
}), e.addMenuItem("visualaid", {
text:"Visual aids",
selectable:!0,
onPostRender:a,
cmd:"mceToggleVisualAid"
}), s({
cut:[ "Cut", "Cut", "Ctrl+X" ],
copy:[ "Copy", "Copy", "Ctrl+C" ],
paste:[ "Paste", "Paste", "Ctrl+V" ],
selectall:[ "Select all", "SelectAll", "Ctrl+A" ],
bold:[ "Bold", "Bold", "Ctrl+B" ],
italic:[ "Italic", "Italic", "Ctrl+I" ],
underline:[ "Underline", "Underline" ],
strikethrough:[ "Strikethrough", "Strikethrough" ],
subscript:[ "Subscript", "Subscript" ],
superscript:[ "Superscript", "Superscript" ],
removeformat:[ "Clear formatting", "RemoveFormat" ]
}, function(t, n) {
e.addMenuItem(n, {
text:t[0],
icon:n,
shortcut:t[2],
cmd:t[1]
});
}), e.on("mousedown", function() {
n.hideAll();
}), e.addButton("styleselect", {
type:"menubutton",
text:"Formats",
menu:c
}), e.addButton("formatselect", function() {
var n = [], i = r(e.settings.block_formats || "Paragraph=p;Address=address;Pre=pre;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6");
return s(i, function(t) {
n.push({
text:t[0],
value:t[1],
textStyle:function() {
return e.formatter.getCssText(t[1]);
}
});
}), {
type:"listbox",
text:i[0][0],
values:n,
fixedWidth:!0,
onselect:l,
onPostRender:t(n)
};
}), e.addButton("fontselect", function() {
var n = "Andale Mono=andale mono,times;Arial=arial,helvetica,sans-serif;Arial Black=arial black,avant garde;Book Antiqua=book antiqua,palatino;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier;Georgia=georgia,palatino;Helvetica=helvetica;Impact=impact,chicago;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco;Times New Roman=times new roman,times;Trebuchet MS=trebuchet ms,geneva;Verdana=verdana,geneva;Webdings=webdings;Wingdings=wingdings,zapf dingbats", i = [], o = r(e.settings.font_formats || n);
return s(o, function(e) {
i.push({
text:{
raw:e[0]
},
value:e[1],
textStyle:-1 == e[1].indexOf("dings") ? "font-family:" + e[1] :""
});
}), {
type:"listbox",
text:"Font Family",
tooltip:"Font Family",
values:i,
fixedWidth:!0,
onPostRender:t(i, "fontname"),
onselect:function(t) {
t.control.settings.value && e.execCommand("FontName", !1, t.control.settings.value);
}
};
}), e.addButton("fontsizeselect", function() {
var n = [], r = "8pt 10pt 12pt 14pt 18pt 24pt 36pt", i = e.settings.fontsize_formats || r;
return s(i.split(" "), function(e) {
var t = e, r = e, i = e.split("=");
i.length > 1 && (t = i[0], r = i[1]), n.push({
text:t,
value:r
});
}), {
type:"listbox",
text:"Font Sizes",
tooltip:"Font Sizes",
values:n,
fixedWidth:!0,
onPostRender:t(n, "fontsize"),
onclick:function(t) {
t.control.settings.value && e.execCommand("FontSize", !1, t.control.settings.value);
}
};
}), e.addMenuItem("formats", {
text:"Formats",
menu:c
});
}
var s = r.each;
i.on("AddEditor", function(t) {
t.editor.rtl && (e.rtl = !0), a(t.editor);
}), e.translate = function(e) {
return i.translate(e);
}, t.tooltips = !o.iOS;
}), r(qt, [ wt ], function(e) {
return e.extend({
recalc:function(e) {
var n, r, i, o, a, s, l, c, u, d, f, p, h, m, g, v, y, b, C, x, w, _, k, S, T, R, A, B, t = e.settings, N = [], E = [];
t = e.settings, i = e.items().filter(":visible"), o = e.layoutRect(), r = t.columns || Math.ceil(Math.sqrt(i.length)), 
n = Math.ceil(i.length / r), y = t.spacingH || t.spacing || 0, b = t.spacingV || t.spacing || 0, 
C = t.alignH || t.align, x = t.alignV || t.align, g = e._paddingBox, A = "reverseRows" in t ? t.reverseRows :e.isRtl(), 
C && "string" == typeof C && (C = [ C ]), x && "string" == typeof x && (x = [ x ]);
for (d = 0; r > d; d++) N.push(0);
for (f = 0; n > f; f++) E.push(0);
for (f = 0; n > f; f++) for (d = 0; r > d && (u = i[f * r + d]); d++) c = u.layoutRect(), 
k = c.minW, S = c.minH, N[d] = k > N[d] ? k :N[d], E[f] = S > E[f] ? S :E[f];
for (T = o.innerW - g.left - g.right, w = 0, d = 0; r > d; d++) w += N[d] + (d > 0 ? y :0), 
T -= (d > 0 ? y :0) + N[d];
for (R = o.innerH - g.top - g.bottom, _ = 0, f = 0; n > f; f++) _ += E[f] + (f > 0 ? b :0), 
R -= (f > 0 ? b :0) + E[f];
if (w += g.left + g.right, _ += g.top + g.bottom, l = {}, l.minW = w + (o.w - o.innerW), 
l.minH = _ + (o.h - o.innerH), l.contentW = l.minW - o.deltaW, l.contentH = l.minH - o.deltaH, 
l.minW = Math.min(l.minW, o.maxW), l.minH = Math.min(l.minH, o.maxH), l.minW = Math.max(l.minW, o.startMinWidth), 
l.minH = Math.max(l.minH, o.startMinHeight), !o.autoResize || l.minW == o.minW && l.minH == o.minH) {
o.autoResize && (l = e.layoutRect(l), l.contentW = l.minW - o.deltaW, l.contentH = l.minH - o.deltaH);
var D;
D = "start" == t.packV ? 0 :R > 0 ? Math.floor(R / n) :0;
var L = 0, M = t.flexWidths;
if (M) for (d = 0; d < M.length; d++) L += M[d]; else L = r;
var H = T / L;
for (d = 0; r > d; d++) N[d] += M ? M[d] * H :H;
for (h = g.top, f = 0; n > f; f++) {
for (p = g.left, s = E[f] + D, d = 0; r > d && (B = A ? f * r + r - 1 - d :f * r + d, 
u = i[B]); d++) m = u.settings, c = u.layoutRect(), a = Math.max(N[d], c.startMinWidth), 
c.x = p, c.y = h, v = m.alignH || (C ? C[d] || C[0] :null), "center" == v ? c.x = p + a / 2 - c.w / 2 :"right" == v ? c.x = p + a - c.w :"stretch" == v && (c.w = a), 
v = m.alignV || (x ? x[d] || x[0] :null), "center" == v ? c.y = h + s / 2 - c.h / 2 :"bottom" == v ? c.y = h + s - c.h :"stretch" == v && (c.h = s), 
u.layoutRect(c), p += a + y, u.recalc && u.recalc();
h += s + b;
}
} else if (l.w = l.minW, l.h = l.minH, e.layoutRect(l), this.recalc(e), null === e._lastRect) {
var P = e.parent();
P && (P._lastRect = null, P.recalc());
}
}
});
}), r($t, [ Nt ], function(e) {
return e.extend({
renderHtml:function() {
var e = this;
return e.addClass("iframe"), e.canFocus = !1, '<iframe id="' + e._id + '" class="' + e.classes() + '" tabindex="-1" src="' + (e.settings.url || "javascript:''") + '" frameborder="0"></iframe>';
},
src:function(e) {
this.getEl().src = e;
},
html:function(e, t) {
var n = this, r = this.getEl().contentWindow.document.body;
return r ? (r.innerHTML = e, t && t()) :setTimeout(function() {
n.html(e);
}, 0), this;
}
});
}), r(jt, [ Nt, j ], function(e, t) {
return e.extend({
init:function(e) {
var t = this;
t._super(e), t.addClass("widget"), t.addClass("label"), t.canFocus = !1, e.multiline && t.addClass("autoscroll"), 
e.strong && t.addClass("strong");
},
initLayoutRect:function() {
var e = this, n = e._super();
if (e.settings.multiline) {
var r = t.getSize(e.getEl());
r.width > n.maxW && (n.minW = n.maxW, e.addClass("multiline")), e.getEl().style.width = n.minW + "px", 
n.startMinH = n.h = n.minH = Math.min(n.maxH, t.getSize(e.getEl()).height);
}
return n;
},
repaint:function() {
var e = this;
return e.settings.multiline || (e.getEl().style.lineHeight = e.layoutRect().h + "px"), 
e._super();
},
text:function(e) {
var t = this;
return t._rendered && e && this.innerHtml(t.encode(e)), t._super(e);
},
renderHtml:function() {
var e = this, t = e.settings.forId;
return '<label id="' + e._id + '" class="' + e.classes() + '"' + (t ? ' for="' + t + '"' :"") + ">" + e.encode(e._text) + "</label>";
}
});
}), r(Kt, [ X ], function(e) {
return e.extend({
Defaults:{
role:"toolbar",
layout:"flow"
},
init:function(e) {
var t = this;
t._super(e), t.addClass("toolbar");
},
postRender:function() {
var e = this;
return e.items().addClass("toolbar-item"), e._super();
}
});
}), r(Gt, [ Kt ], function(e) {
return e.extend({
Defaults:{
role:"menubar",
containerCls:"menubar",
ariaRoot:!0,
defaults:{
type:"menubutton"
}
}
});
}), r(Yt, [ Et, G, Gt ], function(e, t, n) {
function r(e, t) {
for (;e; ) {
if (t === e) return !0;
e = e.parentNode;
}
return !1;
}
var i = e.extend({
init:function(e) {
var t = this;
t._renderOpen = !0, t._super(e), t.addClass("menubtn"), e.fixedWidth && t.addClass("fixed-width"), 
t.aria("haspopup", !0), t.hasPopup = !0;
},
showMenu:function() {
var r, e = this, n = e.settings;
return e.menu && e.menu.visible() ? e.hideMenu() :(e.menu || (r = n.menu || [], 
r.length ? r = {
type:"menu",
items:r
} :r.type = r.type || "menu", e.menu = t.create(r).parent(e).renderTo(), e.fire("createmenu"), 
e.menu.reflow(), e.menu.on("cancel", function(t) {
t.control.parent() === e.menu && (t.stopPropagation(), e.focus(), e.hideMenu());
}), e.menu.on("select", function() {
e.focus();
}), e.menu.on("show hide", function(t) {
t.control == e.menu && e.activeMenu("show" == t.type), e.aria("expanded", "show" == t.type);
}).fire("show")), e.menu.show(), e.menu.layoutRect({
w:e.layoutRect().w
}), void e.menu.moveRel(e.getEl(), e.isRtl() ? [ "br-tr", "tr-br" ] :[ "bl-tl", "tl-bl" ]));
},
hideMenu:function() {
var e = this;
e.menu && (e.menu.items().each(function(e) {
e.hideMenu && e.hideMenu();
}), e.menu.hide());
},
activeMenu:function(e) {
this.toggleClass("active", e);
},
renderHtml:function() {
var e = this, t = e._id, r = e.classPrefix, i = e.settings.icon ? r + "ico " + r + "i-" + e.settings.icon :"";
return e.aria("role", e.parent() instanceof n ? "menuitem" :"button"), '<div id="' + t + '" class="' + e.classes() + '" tabindex="-1" aria-labelledby="' + t + '"><button id="' + t + '-open" role="presentation" type="button" tabindex="-1">' + (i ? '<i class="' + i + '"></i>' :"") + "<span>" + (e._text ? (i ? "\xa0" :"") + e.encode(e._text) :"") + '</span> <i class="' + r + 'caret"></i></button></div>';
},
postRender:function() {
var e = this;
return e.on("click", function(t) {
t.control === e && r(t.target, e.getEl()) && (e.showMenu(), t.aria && e.menu.items()[0].focus());
}), e.on("mouseenter", function(t) {
var o, n = t.control, r = e.parent();
n && r && n instanceof i && n.parent() == r && (r.items().filter("MenuButton").each(function(e) {
e.hideMenu && e != n && (e.menu && e.menu.visible() && (o = !0), e.hideMenu());
}), o && (n.focus(), n.showMenu()));
}), e._super();
},
text:function(e) {
var n, r, t = this;
if (t._rendered) for (r = t.getEl("open").getElementsByTagName("span"), n = 0; n < r.length; n++) r[n].innerHTML = (t.settings.icon && e ? "\xa0" :"") + t.encode(e);
return this._super(e);
},
remove:function() {
this._super(), this.menu && this.menu.remove();
}
});
return i;
}), r(Xt, [ Yt ], function(e) {
return e.extend({
init:function(e) {
function t(r) {
for (var a = 0; a < r.length; a++) {
if (i = r[a].selected || e.value === r[a].value) {
o = o || r[a].text, n._value = r[a].value;
break;
}
r[a].menu && t(r[a].menu);
}
}
var r, i, o, a, n = this;
n._values = r = e.values, r && ("undefined" != typeof e.value && t(r), !i && r.length > 0 && (o = r[0].text, 
n._value = r[0].value), e.menu = r), e.text = e.text || o || r[0].text, n._super(e), 
n.addClass("listbox"), n.on("select", function(t) {
var r = t.control;
a && (t.lastControl = a), e.multiple ? r.active(!r.active()) :n.value(t.control.settings.value), 
a = r;
});
},
value:function(e) {
function t(e, n) {
e.items().each(function(e) {
i = e.value() === n, i && (o = o || e.text()), e.active(i), e.menu && t(e.menu, n);
});
}
function n(t) {
for (var r = 0; r < t.length; r++) i = t[r].value == e, i && (o = o || t[r].text), 
t[r].active = i, t[r].menu && n(t[r].menu);
}
var i, o, a, r = this;
return "undefined" != typeof e && (r.menu ? t(r.menu, e) :(a = r.settings.menu, 
n(a)), r.text(o || this.settings.text)), r._super(e);
}
});
}), r(Jt, [ Nt, G, d ], function(e, t, n) {
return e.extend({
Defaults:{
border:0,
role:"menuitem"
},
init:function(e) {
var t = this;
t.hasPopup = !0, t._super(e), e = t.settings, t.addClass("menu-item"), e.menu && t.addClass("menu-item-expand"), 
e.preview && t.addClass("menu-item-preview"), ("-" === t._text || "|" === t._text) && (t.addClass("menu-item-sep"), 
t.aria("role", "separator"), t._text = "-"), e.selectable && (t.aria("role", "menuitemcheckbox"), 
t.addClass("menu-item-checkbox"), e.icon = "selected"), e.preview || e.selectable || t.addClass("menu-item-normal"), 
t.on("mousedown", function(e) {
e.preventDefault();
}), e.menu && !e.ariaHideMenu && t.aria("haspopup", !0);
},
hasMenus:function() {
return !!this.settings.menu;
},
showMenu:function() {
var r, e = this, n = e.settings, i = e.parent();
if (i.items().each(function(t) {
t !== e && t.hideMenu();
}), n.menu) {
r = e.menu, r ? r.show() :(r = n.menu, r.length ? r = {
type:"menu",
items:r
} :r.type = r.type || "menu", i.settings.itemDefaults && (r.itemDefaults = i.settings.itemDefaults), 
r = e.menu = t.create(r).parent(e).renderTo(), r.reflow(), r.on("cancel", function(t) {
t.stopPropagation(), e.focus(), r.hide();
}), r.on("show hide", function(e) {
e.control.items().each(function(e) {
e.active(e.settings.selected);
});
}).fire("show"), r.on("hide", function(t) {
t.control === r && e.removeClass("selected");
}), r.submenu = !0), r._parentMenu = i, r.addClass("menu-sub");
var o = r.testMoveRel(e.getEl(), e.isRtl() ? [ "tl-tr", "bl-br", "tr-tl", "br-bl" ] :[ "tr-tl", "br-bl", "tl-tr", "bl-br" ]);
r.moveRel(e.getEl(), o), r.rel = o, o = "menu-sub-" + o, r.removeClass(r._lastRel), 
r.addClass(o), r._lastRel = o, e.addClass("selected"), e.aria("expanded", !0);
}
},
hideMenu:function() {
var e = this;
return e.menu && (e.menu.items().each(function(e) {
e.hideMenu && e.hideMenu();
}), e.menu.hide(), e.aria("expanded", !1)), e;
},
renderHtml:function() {
var e = this, t = e._id, r = e.settings, i = e.classPrefix, o = e.encode(e._text), a = e.settings.icon, s = "", l = r.shortcut;
return a && e.parent().addClass("menu-has-icons"), r.image && (a = "none", s = " style=\"background-image: url('" + r.image + "')\""), 
l && n.mac && (l = l.replace(/ctrl\+alt\+/i, "&#x2325;&#x2318;"), l = l.replace(/ctrl\+/i, "&#x2318;"), 
l = l.replace(/alt\+/i, "&#x2325;"), l = l.replace(/shift\+/i, "&#x21E7;")), a = i + "ico " + i + "i-" + (e.settings.icon || "none"), 
'<div id="' + t + '" class="' + e.classes() + '" tabindex="-1">' + ("-" !== o ? '<i class="' + a + '"' + s + "></i>\xa0" :"") + ("-" !== o ? '<span id="' + t + '-text" class="' + i + 'text">' + o + "</span>" :"") + (l ? '<div id="' + t + '-shortcut" class="' + i + 'menu-shortcut">' + l + "</div>" :"") + (r.menu ? '<div class="' + i + 'caret"></div>' :"") + "</div>";
},
postRender:function() {
var e = this, t = e.settings, n = t.textStyle;
if ("function" == typeof n && (n = n.call(this)), n) {
var r = e.getEl("text");
r && r.setAttribute("style", n);
}
return e.on("mouseenter click", function(n) {
n.control === e && (t.menu || "click" !== n.type ? (e.showMenu(), n.aria && e.menu.focus(!0)) :(e.fire("select"), 
e.parent().hideAll()));
}), e._super(), e;
},
active:function(e) {
return "undefined" != typeof e && this.aria("checked", e), this._super(e);
},
remove:function() {
this._super(), this.menu && this.menu.remove();
}
});
}), r(Qt, [ nt, Jt, u ], function(e, t, n) {
var r = e.extend({
Defaults:{
defaultType:"menuitem",
border:1,
layout:"stack",
role:"application",
bodyRole:"menu",
ariaRoot:!0
},
init:function(e) {
var t = this;
if (e.autohide = !0, e.constrainToViewport = !0, e.itemDefaults) for (var r = e.items, i = r.length; i--; ) r[i] = n.extend({}, e.itemDefaults, r[i]);
t._super(e), t.addClass("menu");
},
repaint:function() {
return this.toggleClass("menu-align", !0), this._super(), this.getEl().style.height = "", 
this.getEl("body").style.height = "", this;
},
cancel:function() {
var e = this;
e.hideAll(), e.fire("select");
},
hideAll:function() {
var e = this;
return this.find("menuitem").exec("hideMenu"), e._super();
},
preRender:function() {
var e = this;
return e.items().each(function(t) {
var n = t.settings;
return n.icon || n.selectable ? (e._hasIcons = !0, !1) :void 0;
}), e._super();
}
});
return r;
}), r(Zt, [ St ], function(e) {
return e.extend({
Defaults:{
classes:"radio",
role:"radio"
}
});
}), r(en, [ Nt, J ], function(e, t) {
return e.extend({
renderHtml:function() {
var e = this, t = e.classPrefix;
return e.addClass("resizehandle"), "both" == e.settings.direction && e.addClass("resizehandle-both"), 
e.canFocus = !1, '<div id="' + e._id + '" class="' + e.classes() + '"><i class="' + t + "ico " + t + 'i-resize"></i></div>';
},
postRender:function() {
var e = this;
e._super(), e.resizeDragHelper = new t(this._id, {
start:function() {
e.fire("ResizeStart");
},
drag:function(t) {
"both" != e.settings.direction && (t.deltaX = 0), e.fire("Resize", t);
},
stop:function() {
e.fire("ResizeEnd");
}
});
},
remove:function() {
return this.resizeDragHelper && this.resizeDragHelper.destroy(), this._super();
}
});
}), r(tn, [ Nt ], function(e) {
return e.extend({
renderHtml:function() {
var e = this;
return e.addClass("spacer"), e.canFocus = !1, '<div id="' + e._id + '" class="' + e.classes() + '"></div>';
}
});
}), r(nn, [ Yt, j ], function(e, t) {
return e.extend({
Defaults:{
classes:"widget btn splitbtn",
role:"button"
},
repaint:function() {
var i, o, e = this, n = e.getEl(), r = e.layoutRect();
return e._super(), i = n.firstChild, o = n.lastChild, t.css(i, {
width:r.w - t.getSize(o).width,
height:r.h - 2
}), t.css(o, {
height:r.h - 2
}), e;
},
activeMenu:function(e) {
var n = this;
t.toggleClass(n.getEl().lastChild, n.classPrefix + "active", e);
},
renderHtml:function() {
var e = this, t = e._id, n = e.classPrefix, r = e.settings.icon ? n + "ico " + n + "i-" + e.settings.icon :"";
return '<div id="' + t + '" class="' + e.classes() + '" role="button" tabindex="-1"><button type="button" hidefocus="1" tabindex="-1">' + (r ? '<i class="' + r + '"></i>' :"") + (e._text ? (r ? " " :"") + e._text :"") + '</button><button type="button" class="' + n + 'open" hidefocus="1" tabindex="-1">' + (e._menuBtnText ? (r ? "\xa0" :"") + e._menuBtnText :"") + ' <i class="' + n + 'caret"></i></button></div>';
},
postRender:function() {
var e = this, t = e.settings.onclick;
return e.on("click", function(e) {
var n = e.target;
if (e.control == this) for (;n; ) {
if (e.aria && "down" != e.aria.key || "BUTTON" == n.nodeName && -1 == n.className.indexOf("open")) return e.stopImmediatePropagation(), 
void t.call(this, e);
n = n.parentNode;
}
}), delete e.settings.onclick, e._super();
}
});
}), r(rn, [ Vt ], function(e) {
return e.extend({
Defaults:{
containerClass:"stack-layout",
controlClass:"stack-layout-item",
endClass:"break"
}
});
}), r(on, [ Z, j ], function(e, t) {
return e.extend({
Defaults:{
layout:"absolute",
defaults:{
type:"panel"
}
},
activateTab:function(e) {
var n;
this.activeTabId && (n = this.getEl(this.activeTabId), t.removeClass(n, this.classPrefix + "active"), 
n.setAttribute("aria-selected", "false")), this.activeTabId = "t" + e, n = this.getEl("t" + e), 
n.setAttribute("aria-selected", "true"), t.addClass(n, this.classPrefix + "active"), 
this.items()[e].show().fire("showtab"), this.reflow(), this.items().each(function(t, n) {
e != n && t.hide();
});
},
renderHtml:function() {
var e = this, t = e._layout, n = "", r = e.classPrefix;
return e.preRender(), t.preRender(e), e.items().each(function(t, i) {
var o = e._id + "-t" + i;
t.aria("role", "tabpanel"), t.aria("labelledby", o), n += '<div id="' + o + '" class="' + r + 'tab" unselectable="on" role="tab" aria-controls="' + t._id + '" aria-selected="false" tabIndex="-1">' + e.encode(t.settings.title) + "</div>";
}), '<div id="' + e._id + '" class="' + e.classes() + '" hidefocus="1" tabindex="-1"><div id="' + e._id + '-head" class="' + r + 'tabs" role="tablist">' + n + '</div><div id="' + e._id + '-body" class="' + e.classes("body") + '">' + t.renderHtml(e) + "</div></div>";
},
postRender:function() {
var e = this;
e._super(), e.settings.activeTab = e.settings.activeTab || 0, e.activateTab(e.settings.activeTab), 
this.on("click", function(t) {
var n = t.target.parentNode;
if (t.target.parentNode.id == e._id + "-head") for (var r = n.childNodes.length; r--; ) n.childNodes[r] == t.target && e.activateTab(r);
});
},
initLayoutRect:function() {
var n, r, i, e = this;
r = t.getSize(e.getEl("head")).width, r = 0 > r ? 0 :r, i = 0, e.items().each(function(e) {
r = Math.max(r, e.layoutRect().minW), i = Math.max(i, e.layoutRect().minH);
}), e.items().each(function(e) {
e.settings.x = 0, e.settings.y = 0, e.settings.w = r, e.settings.h = i, e.layoutRect({
x:0,
y:0,
w:r,
h:i
});
});
var o = t.getSize(e.getEl("head")).height;
return e.settings.minWidth = r, e.settings.minHeight = i + o, n = e._super(), n.deltaH += o, 
n.innerH = n.h - n.deltaH, n;
}
});
}), r(an, [ Nt, j ], function(e, t) {
return e.extend({
init:function(e) {
var t = this;
t._super(e), t._value = e.value || "", t.addClass("textbox"), e.multiline ? t.addClass("multiline") :t.on("keydown", function(e) {
13 == e.keyCode && t.parents().reverse().each(function(t) {
return e.preventDefault(), t.hasEventListeners("submit") && t.toJSON ? (t.fire("submit", {
data:t.toJSON()
}), !1) :void 0;
});
});
},
disabled:function(e) {
var t = this;
return t._rendered && "undefined" != typeof e && (t.getEl().disabled = e), t._super(e);
},
value:function(e) {
var t = this;
return "undefined" != typeof e ? (t._value = e, t._rendered && (t.getEl().value = e), 
t) :t._rendered ? t.getEl().value :t._value;
},
repaint:function() {
var t, n, r, a, e = this, i = 0, o = 0;
t = e.getEl().style, n = e._layoutRect, a = e._lastRepaintRect || {};
var s = document;
return !e.settings.multiline && s.all && (!s.documentMode || s.documentMode <= 8) && (t.lineHeight = n.h - o + "px"), 
r = e._borderBox, i = r.left + r.right + 8, o = r.top + r.bottom + (e.settings.multiline ? 8 :0), 
n.x !== a.x && (t.left = n.x + "px", a.x = n.x), n.y !== a.y && (t.top = n.y + "px", 
a.y = n.y), n.w !== a.w && (t.width = n.w - i + "px", a.w = n.w), n.h !== a.h && (t.height = n.h - o + "px", 
a.h = n.h), e._lastRepaintRect = a, e.fire("repaint", {}, !1), e;
},
renderHtml:function() {
var e = this, t = e._id, n = e.settings, r = e.encode(e._value, !1), i = "";
return "spellcheck" in n && (i += ' spellcheck="' + n.spellcheck + '"'), n.maxLength && (i += ' maxlength="' + n.maxLength + '"'), 
n.size && (i += ' size="' + n.size + '"'), n.subtype && (i += ' type="' + n.subtype + '"'), 
e.disabled() && (i += ' disabled="disabled"'), n.multiline ? '<textarea id="' + t + '" class="' + e.classes() + '" ' + (n.rows ? ' rows="' + n.rows + '"' :"") + ' hidefocus="1"' + i + ">" + r + "</textarea>" :'<input id="' + t + '" class="' + e.classes() + '" value="' + r + '" hidefocus="1"' + i + " />";
},
postRender:function() {
var e = this;
return t.on(e.getEl(), "change", function(t) {
e.fire("change", t);
}), e._super();
},
remove:function() {
t.off(this.getEl()), this._super();
}
});
}), r(sn, [ j, K ], function(e, t) {
return function(n, r) {
var o, i = this, a = t.classPrefix;
i.show = function(t) {
return i.hide(), o = !0, window.setTimeout(function() {
o && n.appendChild(e.createFragment('<div class="' + a + "throbber" + (r ? " " + a + "throbber-inline" :"") + '"></div>'));
}, t || 0), i;
}, i.hide = function() {
var e = n.lastChild;
return e && -1 != e.className.indexOf("throbber") && e.parentNode.removeChild(e), 
o = !1, i;
};
};
}), a([ l, c, u, d, f, p, h, m, g, y, b, C, x, w, _, N, E, k, S, T, R, A, D, L, M, P, O, I, F, z, W, V, U, q, $, j, K, G, Y, X, J, Q, Z, et, tt, nt, rt, it, ot, at, st, lt, ct, ut, dt, ft, pt, ht, mt, gt, vt, yt, bt, Ct, xt, wt, _t, Nt, Et, kt, St, Tt, Rt, At, Bt, Dt, Lt, Mt, Ht, Pt, Ot, It, Ft, zt, Wt, Vt, Ut, qt, $t, jt, Kt, Gt, Yt, Xt, Jt, Qt, Zt, en, tn, nn, rn, on, an, sn ]);
}(this), window.remove_editor = 0;

var MAX_REQUEST_SIZE = 10485760, MAX_AREA = 1e8;

window.remove_editor = 0;

var RESOURCES_PATH = "/assets/mxGraph/resources", RESOURCE_BASE = RESOURCES_PATH + "/grapheditor", STENCIL_PATH = "/assets/mxGraph/stencils", IMAGE_PATH = "/assets/mxGraph/images", STYLE_PATH = "/assets/mxGraph/styles", CSS_PATH = "/assets/mxGraph/styles", tapAndHoldStartsConnection = !0, showConnectorImg = !0, urlParams = function(url) {
var result = new Object(), idx = url.lastIndexOf("?");
if (idx > 0) for (var params = url.substring(idx + 1).split("&"), i = 0; i < params.length; i++) idx = params[i].indexOf("="), 
idx > 0 && (result[params[i].substring(0, idx)] = params[i].substring(idx + 1));
return result;
}(window.location.href);

"undefined" != typeof tinyMCE && (tinyMCE.baseURL = window.location.protocol + "//" + window.location.host + "/assets/tinymce", 
tinyMCE.init({
mode:"none",
theme:"advanced",
apply_source_formatting:!1,
plugins:"spellchecker,table,inlinepopups,paste",
theme_advanced_buttons1:"image,link,hr,|,cleanup,|,code",
theme_advanced_buttons2:"",
theme_advanced_buttons3:"",
theme_advanced_toolbar_location:"top",
theme_advanced_toolbar_align:"left",
theme_advanced_statusbar_location:"bottom",
theme_advanced_resizing:!1
})), mxLoadResources = !1, mxBasePath = "/assets/mxGraph/src", mxLanguage = urlParams.lang, 
mxLanguages = [ "de" ];

var mxClient = {
VERSION:"2.0.0.1",
IS_IE:0 <= navigator.userAgent.indexOf("MSIE"),
IS_IE6:0 <= navigator.userAgent.indexOf("MSIE 6"),
IS_QUIRKS:0 <= navigator.userAgent.indexOf("MSIE") && (null == document.documentMode || 5 == document.documentMode),
VML_PREFIX:"v",
OFFICE_PREFIX:"o",
IS_NS:0 <= navigator.userAgent.indexOf("Mozilla/") && 0 > navigator.userAgent.indexOf("MSIE"),
IS_OP:0 <= navigator.userAgent.indexOf("Opera/"),
IS_OT:0 > navigator.userAgent.indexOf("Presto/2.4.") && 0 > navigator.userAgent.indexOf("Presto/2.3.") && 0 > navigator.userAgent.indexOf("Presto/2.2.") && 0 > navigator.userAgent.indexOf("Presto/2.1.") && 0 > navigator.userAgent.indexOf("Presto/2.0.") && 0 > navigator.userAgent.indexOf("Presto/1."),
IS_SF:0 <= navigator.userAgent.indexOf("AppleWebKit/") && 0 > navigator.userAgent.indexOf("Chrome/"),
IS_GC:0 <= navigator.userAgent.indexOf("Chrome/"),
IS_MT:0 <= navigator.userAgent.indexOf("Firefox/") && 0 > navigator.userAgent.indexOf("Firefox/1.") && 0 > navigator.userAgent.indexOf("Firefox/2.") || 0 <= navigator.userAgent.indexOf("Iceweasel/") && 0 > navigator.userAgent.indexOf("Iceweasel/1.") && 0 > navigator.userAgent.indexOf("Iceweasel/2.") || 0 <= navigator.userAgent.indexOf("SeaMonkey/") && 0 > navigator.userAgent.indexOf("SeaMonkey/1.") || 0 <= navigator.userAgent.indexOf("Iceape/") && 0 > navigator.userAgent.indexOf("Iceape/1."),
IS_SVG:0 <= navigator.userAgent.indexOf("Firefox/") || 0 <= navigator.userAgent.indexOf("Iceweasel/") || 0 <= navigator.userAgent.indexOf("Seamonkey/") || 0 <= navigator.userAgent.indexOf("Iceape/") || 0 <= navigator.userAgent.indexOf("Galeon/") || 0 <= navigator.userAgent.indexOf("Epiphany/") || 0 <= navigator.userAgent.indexOf("AppleWebKit/") || 0 <= navigator.userAgent.indexOf("Gecko/") || 0 <= navigator.userAgent.indexOf("Opera/"),
NO_FO:!document.createElementNS || "[object SVGForeignObjectElement]" != document.createElementNS("http://www.w3.org/2000/svg", "foreignObject") || 0 <= navigator.userAgent.indexOf("Opera/"),
IS_VML:"MICROSOFT INTERNET EXPLORER" == navigator.appName.toUpperCase(),
IS_MAC:0 < navigator.userAgent.toUpperCase().indexOf("MACINTOSH"),
IS_TOUCH:"ontouchstart" in document.documentElement,
IS_POINTER:window.navigator.msPointerEnabled,
IS_LOCAL:0 > document.location.href.indexOf("http://") && 0 > document.location.href.indexOf("https://"),
isBrowserSupported:function() {
return mxClient.IS_VML || mxClient.IS_SVG;
},
link:function(a, b, c) {
if (c = c || document, mxClient.IS_IE6) c.write('<link rel="' + a + '" href="' + b + '" charset="ISO-8859-1" type="text/css"/>'); else {
var d = c.createElement("link");
d.setAttribute("rel", a), d.setAttribute("href", b), d.setAttribute("charset", "ISO-8859-1"), 
d.setAttribute("type", "text/css"), c.getElementsByTagName("head")[0].appendChild(d);
}
},
include:function(a) {
document.write('<script src="' + a + '"></script>');
},
dispose:function() {
for (var a = 0; a < mxEvent.objects.length; a++) null != mxEvent.objects[a].mxListenerList && mxEvent.removeAllListeners(mxEvent.objects[a]);
}
};

if (mxClient.IS_OP && mxClient.IS_OT ? mxClient.CSS_PREFIX = "O" :mxClient.IS_SF || mxClient.IS_GC ? mxClient.CSS_PREFIX = "Webkit" :mxClient.IS_MT ? mxClient.CSS_PREFIX = "Moz" :mxClient.IS_IE && 9 <= document.documentMode && (mxClient.CSS_PREFIX = "ms"), 
"undefined" == typeof mxLoadResources && (mxLoadResources = !0), "undefined" == typeof mxResourceExtension && (mxResourceExtension = ".txt"), 
"undefined" == typeof mxLoadStylesheets && (mxLoadStylesheets = !0), "undefined" != typeof mxBasePath && 0 < mxBasePath.length ? ("/" == mxBasePath.substring(mxBasePath.length - 1) && (mxBasePath = mxBasePath.substring(0, mxBasePath.length - 1)), 
mxClient.basePath = mxBasePath) :mxClient.basePath = ".", "undefined" != typeof mxImageBasePath && 0 < mxImageBasePath.length ? ("/" == mxImageBasePath.substring(mxImageBasePath.length - 1) && (mxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1)), 
mxClient.imageBasePath = mxImageBasePath) :mxClient.imageBasePath = mxClient.basePath + "/images", 
mxClient.language = "undefined" != typeof mxLanguage && null != mxLanguage ? mxLanguage :mxClient.IS_IE ? navigator.userLanguage :navigator.language, 
mxClient.defaultLanguage = "undefined" != typeof mxDefaultLanguage && null != mxDefaultLanguage ? mxDefaultLanguage :"en", 
mxLoadStylesheets && mxClient.link("stylesheet", mxClient.basePath + "/css/common.css"), 
"undefined" != typeof mxLanguages && null != mxLanguages && (mxClient.languages = mxLanguages), 
mxClient.IS_IE) {
if (9 <= document.documentMode) mxClient.IS_VML = !1, mxClient.IS_SVG = !0; else {
8 == document.documentMode ? (document.namespaces.add(mxClient.VML_PREFIX, "urn:schemas-microsoft-com:vml", "#default#VML"), 
document.namespaces.add(mxClient.OFFICE_PREFIX, "urn:schemas-microsoft-com:office:office", "#default#VML")) :(document.namespaces.add(mxClient.VML_PREFIX, "urn:schemas-microsoft-com:vml"), 
document.namespaces.add(mxClient.OFFICE_PREFIX, "urn:schemas-microsoft-com:office:office"));
var ss = document.createStyleSheet();
ss.cssText = mxClient.VML_PREFIX + "\\:*{behavior:url(#default#VML)}" + mxClient.OFFICE_PREFIX + "\\:*{behavior:url(#default#VML)}", 
mxLoadStylesheets && mxClient.link("stylesheet", mxClient.basePath + "/css/explorer.css");
}
window.attachEvent("onunload", mxClient.dispose);
}

var mxLog = {
consoleName:"Console",
TRACE:!1,
DEBUG:!0,
WARN:!0,
buffer:"",
init:function() {
if (null == mxLog.window && null != document.body) {
var a = mxLog.consoleName + " - mxGraph " + mxClient.VERSION, b = document.createElement("table");
b.setAttribute("width", "100%"), b.setAttribute("height", "100%");
var c = document.createElement("tbody"), d = document.createElement("tr"), e = document.createElement("td");
if (e.style.verticalAlign = "top", mxLog.textarea = document.createElement("textarea"), 
mxLog.textarea.setAttribute("readOnly", "true"), mxLog.textarea.style.height = "100%", 
mxLog.textarea.style.resize = "none", mxLog.textarea.value = mxLog.buffer, mxLog.textarea.style.width = mxClient.IS_NS && "BackCompat" != document.compatMode ? "99%" :"100%", 
e.appendChild(mxLog.textarea), d.appendChild(e), c.appendChild(d), d = document.createElement("tr"), 
mxLog.td = document.createElement("td"), mxLog.td.style.verticalAlign = "top", mxLog.td.setAttribute("height", "30px"), 
d.appendChild(mxLog.td), c.appendChild(d), b.appendChild(c), mxLog.addButton("Info", function() {
mxLog.info();
}), mxLog.addButton("DOM", function(a) {
a = mxUtils.getInnerHtml(document.body), mxLog.debug(a);
}), mxLog.addButton("Trace", function() {
mxLog.TRACE = !mxLog.TRACE, mxLog.TRACE ? mxLog.debug("Tracing enabled") :mxLog.debug("Tracing disabled");
}), mxLog.addButton("Copy", function() {
try {
mxUtils.copy(mxLog.textarea.value);
} catch (b) {
mxUtils.alert(b);
}
}), mxLog.addButton("Show", function() {
try {
mxUtils.popup(mxLog.textarea.value);
} catch (b) {
mxUtils.alert(b);
}
}), mxLog.addButton("Clear", function() {
mxLog.textarea.value = "";
}), d = c = 0, "number" == typeof window.innerWidth ? (c = window.innerHeight, d = window.innerWidth) :(c = document.documentElement.clientHeight || document.body.clientHeight, 
d = document.body.clientWidth), mxLog.window = new mxWindow(a, b, Math.max(0, d - 320), Math.max(0, c - 210), 300, 160), 
mxLog.window.setMaximizable(!0), mxLog.window.setScrollable(!1), mxLog.window.setResizable(!0), 
mxLog.window.setClosable(!0), mxLog.window.destroyOnClose = !1, (mxClient.IS_NS || mxClient.IS_IE) && !mxClient.IS_GC && !mxClient.IS_SF && "BackCompat" != document.compatMode) {
var f = mxLog.window.getElement(), a = function() {
mxLog.textarea.style.height = Math.max(0, f.offsetHeight - 70) + "px";
};
mxLog.window.addListener(mxEvent.RESIZE_END, a), mxLog.window.addListener(mxEvent.MAXIMIZE, a), 
mxLog.window.addListener(mxEvent.NORMALIZE, a), mxLog.textarea.style.height = "92px";
}
}
},
info:function() {
mxLog.writeln(mxUtils.toString(navigator));
},
addButton:function(a, b) {
var c = document.createElement("button");
mxUtils.write(c, a), mxEvent.addListener(c, "click", b), mxLog.td.appendChild(c);
},
isVisible:function() {
return null != mxLog.window ? mxLog.window.isVisible() :!1;
},
show:function() {
mxLog.setVisible(!0);
},
setVisible:function(a) {
null == mxLog.window && mxLog.init(), null != mxLog.window && mxLog.window.setVisible(a);
},
enter:function(a) {
return mxLog.TRACE ? (mxLog.writeln("Entering " + a), new Date().getTime()) :void 0;
},
leave:function(a, b) {
if (mxLog.TRACE) {
var c = 0 != b ? " (" + (new Date().getTime() - b) + " ms)" :"";
mxLog.writeln("Leaving " + a + c);
}
},
debug:function() {
mxLog.DEBUG && mxLog.writeln.apply(this, arguments);
},
warn:function() {
mxLog.WARN && mxLog.writeln.apply(this, arguments);
},
write:function() {
for (var a = "", b = 0; b < arguments.length; b++) a += arguments[b], b < arguments.length - 1 && (a += " ");
null != mxLog.textarea ? (mxLog.textarea.value += a, 0 <= navigator.userAgent.indexOf("Presto/2.5") && (mxLog.textarea.style.visibility = "hidden", 
mxLog.textarea.style.visibility = "visible"), mxLog.textarea.scrollTop = mxLog.textarea.scrollHeight) :mxLog.buffer += a;
},
writeln:function() {
for (var a = "", b = 0; b < arguments.length; b++) a += arguments[b], b < arguments.length - 1 && (a += " ");
mxLog.write(a + "\n");
}
}, mxObjectIdentity = {
FIELD_NAME:"mxObjectId",
counter:0,
get:function(a) {
if ("object" == typeof a && null == a[mxObjectIdentity.FIELD_NAME]) {
var b = mxUtils.getFunctionName(a.constructor);
a[mxObjectIdentity.FIELD_NAME] = b + "#" + mxObjectIdentity.counter++;
}
return a[mxObjectIdentity.FIELD_NAME];
},
clear:function(a) {
"object" == typeof a && delete a[mxObjectIdentity.FIELD_NAME];
}
};

mxDictionary.prototype.map = null, mxDictionary.prototype.clear = function() {
this.map = {};
}, mxDictionary.prototype.get = function(a) {
return a = mxObjectIdentity.get(a), this.map[a];
}, mxDictionary.prototype.put = function(a, b) {
var c = mxObjectIdentity.get(a), d = this.map[c];
return this.map[c] = b, d;
}, mxDictionary.prototype.remove = function(a) {
a = mxObjectIdentity.get(a);
var b = this.map[a];
return delete this.map[a], b;
}, mxDictionary.prototype.getKeys = function() {
var b, a = [];
for (b in this.map) a.push(b);
return a;
}, mxDictionary.prototype.getValues = function() {
var b, a = [];
for (b in this.map) a.push(this.map[b]);
return a;
}, mxDictionary.prototype.visit = function(a) {
for (var b in this.map) a(b, this.map[b]);
};

var mxResources = {
resources:[],
extension:mxResourceExtension,
resourcesEncoded:!1,
loadDefaultBundle:!0,
loadSpecialBundle:!0,
isLanguageSupported:function(a) {
return null != mxClient.languages ? 0 <= mxUtils.indexOf(mxClient.languages, a) :!0;
},
getDefaultBundle:function(a, b) {
return mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(b) ? a + mxResources.extension :null;
},
getSpecialBundle:function(a, b) {
if (null == mxClient.languages || !this.isLanguageSupported(b)) {
var c = b.indexOf("-");
c > 0 && (b = b.substring(0, c));
}
return mxResources.loadSpecialBundle && mxResources.isLanguageSupported(b) && b != mxClient.defaultLanguage ? a + "_" + b + mxResources.extension :null;
},
add:function(a, b) {
if (b = null != b ? b :mxClient.language.toLowerCase(), b != mxConstants.NONE) {
var c = mxResources.getDefaultBundle(a, b);
if (null != c) try {
var d = mxUtils.load(c);
d.isReady() && mxResources.parse(d.getText());
} catch (e) {}
if (c = mxResources.getSpecialBundle(a, b), null != c) try {
d = mxUtils.load(c), d.isReady() && mxResources.parse(d.getText());
} catch (f) {}
}
},
parse:function(a) {
if (null != a) {
a = a.split("\n");
for (var b = 0; b < a.length; b++) if ("#" != a[b].charAt(0)) {
var c = a[b].indexOf("=");
if (c > 0) {
var d = a[b].substring(0, c), e = a[b].length;
13 == a[b].charCodeAt(e - 1) && e--, c = a[b].substring(c + 1, e), this.resourcesEncoded ? (c = c.replace(/\\(?=u[a-fA-F\d]{4})/g, "%"), 
mxResources.resources[d] = unescape(c)) :mxResources.resources[d] = c;
}
}
}
},
get:function(a, b, c) {
if (a = mxResources.resources[a], null == a && (a = c), null != a && null != b) {
c = [];
for (var d = null, e = 0; e < a.length; e++) {
var f = a.charAt(e);
"{" == f ? d = "" :null != d && "}" == f ? (d = parseInt(d) - 1, d >= 0 && d < b.length && c.push(b[d]), 
d = null) :null != d ? d += f :c.push(f);
}
a = c.join("");
}
return a;
}
};

mxPoint.prototype.x = null, mxPoint.prototype.y = null, mxPoint.prototype.equals = function(a) {
return a.x == this.x && a.y == this.y;
}, mxPoint.prototype.clone = function() {
return mxUtils.clone(this);
}, mxRectangle.prototype = new mxPoint(), mxRectangle.prototype.constructor = mxRectangle, 
mxRectangle.prototype.width = null, mxRectangle.prototype.height = null, mxRectangle.prototype.setRect = function(a, b, c, d) {
this.x = a, this.y = b, this.width = c, this.height = d;
}, mxRectangle.prototype.getCenterX = function() {
return this.x + this.width / 2;
}, mxRectangle.prototype.getCenterY = function() {
return this.y + this.height / 2;
}, mxRectangle.prototype.add = function(a) {
if (null != a) {
var b = Math.min(this.x, a.x), c = Math.min(this.y, a.y), d = Math.max(this.x + this.width, a.x + a.width);
a = Math.max(this.y + this.height, a.y + a.height), this.x = b, this.y = c, this.width = d - b, 
this.height = a - c;
}
}, mxRectangle.prototype.grow = function(a) {
this.x -= a, this.y -= a, this.width += 2 * a, this.height += 2 * a;
}, mxRectangle.prototype.getPoint = function() {
return new mxPoint(this.x, this.y);
}, mxRectangle.prototype.equals = function(a) {
return a.x == this.x && a.y == this.y && a.width == this.width && a.height == this.height;
};

var mxEffects = {
animateChanges:function(a, b, c) {
var d = 0, e = function() {
for (var g = !1, h = 0; h < b.length; h++) {
var k = b[h];
if (k instanceof mxGeometryChange || k instanceof mxTerminalChange || k instanceof mxValueChange || k instanceof mxChildChange || k instanceof mxStyleChange) {
var l = a.getView().getState(k.cell || k.child, !1);
if (null != l) if (g = !0, k.constructor != mxGeometryChange || a.model.isEdge(k.cell)) mxUtils.setOpacity(l.shape.node, 100 * d / 10); else {
var m = a.getView().scale, n = (k.geometry.x - k.previous.x) * m, p = (k.geometry.y - k.previous.y) * m, q = (k.geometry.width - k.previous.width) * m, m = (k.geometry.height - k.previous.height) * m;
0 == d ? (l.x -= n, l.y -= p, l.width -= q, l.height -= m) :(l.x += n / 10, l.y += p / 10, 
l.width += q / 10, l.height += m / 10), a.cellRenderer.redraw(l), mxEffects.cascadeOpacity(a, k.cell, 100 * d / 10);
}
}
}
10 > d && g ? (d++, window.setTimeout(e, f)) :null != c && c();
}, f = 30;
e();
},
cascadeOpacity:function(a, b, c) {
for (var d = a.model.getChildCount(b), e = 0; d > e; e++) {
var f = a.model.getChildAt(b, e), g = a.getView().getState(f);
null != g && (mxUtils.setOpacity(g.shape.node, c), mxEffects.cascadeOpacity(a, f, c));
}
if (b = a.model.getEdges(b), null != b) for (e = 0; e < b.length; e++) d = a.getView().getState(b[e]), 
null != d && mxUtils.setOpacity(d.shape.node, c);
},
fadeOut:function(a, b, c, d, e, f) {
d = d || 40, e = e || 30;
var g = b || 100;
if (mxUtils.setOpacity(a, g), f || null == f) {
var h = function() {
g = Math.max(g - d, 0), mxUtils.setOpacity(a, g), g > 0 ? window.setTimeout(h, e) :(a.style.visibility = "hidden", 
c && a.parentNode && a.parentNode.removeChild(a));
};
window.setTimeout(h, e);
} else a.style.visibility = "hidden", c && a.parentNode && a.parentNode.removeChild(a);
}
}, mxUtils = {
errorResource:"none" != mxClient.language ? "error" :"",
closeResource:"none" != mxClient.language ? "close" :"",
errorImage:mxClient.imageBasePath + "/error.gif",
removeCursors:function(a) {
if (null != a.style && (a.style.cursor = ""), a = a.childNodes, null != a) for (var b = a.length, c = 0; b > c; c += 1) mxUtils.removeCursors(a[c]);
},
getCurrentStyle:function() {
return mxClient.IS_IE ? function(a) {
return null != a ? a.currentStyle :null;
} :function(a) {
return null != a ? window.getComputedStyle(a, "") :null;
};
}(),
hasScrollbars:function(a) {
return a = mxUtils.getCurrentStyle(a), null != a && ("scroll" == a.overflow || "auto" == a.overflow);
},
bind:function(a, b) {
return function() {
return b.apply(a, arguments);
};
},
eval:function(a) {
var b = null;
if (0 <= a.indexOf("function")) try {
eval("var _mxJavaScriptExpression=" + a), b = _mxJavaScriptExpression, _mxJavaScriptExpression = null;
} catch (c) {
mxLog.warn(c.message + " while evaluating " + a);
} else try {
b = eval(a);
} catch (d) {
mxLog.warn(d.message + " while evaluating " + a);
}
return b;
},
findNode:function(a, b, c) {
var d = a.getAttribute(b);
if (null != d && d == c) return a;
for (a = a.firstChild; null != a; ) {
if (d = mxUtils.findNode(a, b, c), null != d) return d;
a = a.nextSibling;
}
return null;
},
findNodeByAttribute:function() {
return 9 <= document.documentMode ? function(a, b, c) {
var d = null;
if (null != a) if (a.nodeType == mxConstants.NODETYPE_ELEMENT && a.getAttribute(b) == c) d = a; else for (a = a.firstChild; null != a && null == d; ) d = mxUtils.findNodeByAttribute(a, b, c), 
a = a.nextSibling;
return d;
} :mxClient.IS_IE ? function(a, b, c) {
return null == a ? null :a.ownerDocument.selectSingleNode("//*[@" + b + "='" + c + "']");
} :function(a, b, c) {
return null == a ? null :a.ownerDocument.evaluate("//*[@" + b + "='" + c + "']", a.ownerDocument, null, XPathResult.ANY_TYPE, null).iterateNext();
};
}(),
getFunctionName:function(a) {
var b = null;
if (null != a) if (null != a.name) b = a.name; else {
for (a = a.toString(), b = 9; " " == a.charAt(b); ) b++;
var c = a.indexOf("(", b), b = a.substring(b, c);
}
return b;
},
indexOf:function(a, b) {
if (null != a && null != b) for (var c = 0; c < a.length; c++) if (a[c] == b) return c;
return -1;
},
remove:function(a, b) {
var c = null;
if ("object" == typeof b) for (var d = mxUtils.indexOf(b, a); d >= 0; ) b.splice(d, 1), 
c = a, d = mxUtils.indexOf(b, a);
for (var e in b) b[e] == a && (delete b[e], c = a);
return c;
},
isNode:function(a, b, c, d) {
return null == a || isNaN(a.nodeType) || null != b && a.nodeName.toLowerCase() != b.toLowerCase() ? !1 :null == c || a.getAttribute(c) == d;
},
getChildNodes:function(a, b) {
b = b || mxConstants.NODETYPE_ELEMENT;
for (var c = [], d = a.firstChild; null != d; ) d.nodeType == b && c.push(d), d = d.nextSibling;
return c;
},
createXmlDocument:function() {
var a = null;
return document.implementation && document.implementation.createDocument ? a = document.implementation.createDocument("", "", null) :window.ActiveXObject && (a = new ActiveXObject("Microsoft.XMLDOM")), 
a;
},
parseXml:function() {
return mxClient.IS_IE && ("undefined" == typeof document.documentMode || 9 > document.documentMode) ? function(a) {
var b = mxUtils.createXmlDocument();
return b.async = "false", b.loadXML(a), b;
} :function(a) {
return new DOMParser().parseFromString(a, "text/xml");
};
}(),
clearSelection:function() {
return document.selection ? function() {
document.selection.empty();
} :window.getSelection ? function() {
window.getSelection().removeAllRanges();
} :void 0;
}(),
getPrettyXml:function(a, b, c) {
var d = [];
if (null != a) if (b = b || "  ", c = c || "", a.nodeType == mxConstants.NODETYPE_TEXT) d.push(a.nodeValue); else {
d.push(c + "<" + a.nodeName);
var e = a.attributes;
if (null != e) for (var f = 0; f < e.length; f++) {
var g = mxUtils.htmlEntities(e[f].nodeValue);
d.push(" " + e[f].nodeName + '="' + g + '"');
}
if (e = a.firstChild, null != e) {
for (d.push(">\n"); null != e; ) d.push(mxUtils.getPrettyXml(e, b, c + b)), e = e.nextSibling;
d.push(c + "</" + a.nodeName + ">\n");
} else d.push("/>\n");
}
return d.join("");
},
removeWhitespace:function(a, b) {
for (var c = b ? a.previousSibling :a.nextSibling; null != c && c.nodeType == mxConstants.NODETYPE_TEXT; ) {
var d = b ? c.previousSibling :c.nextSibling, e = mxUtils.getTextContent(c);
0 == mxUtils.trim(e).length && c.parentNode.removeChild(c), c = d;
}
},
htmlEntities:function(a, b) {
return a = (a || "").replace(/&/g, "&amp;"), a = a.replace(/"/g, "&quot;"), a = a.replace(/\'/g, "&#39;"), 
a = a.replace(/</g, "&lt;"), a = a.replace(/>/g, "&gt;"), (null == b || b) && (a = a.replace(/\n/g, "&#xa;")), 
a;
},
isVml:function(a) {
return null != a && "urn:schemas-microsoft-com:vml" == a.tagUrn;
},
getXml:function(a, b) {
var c = "";
return null != window.XMLSerializer ? c = new XMLSerializer().serializeToString(a) :null != a.xml && (c = a.xml.replace(/\r\n\t[\t]*/g, "").replace(/>\r\n/g, ">").replace(/\r\n/g, "\n")), 
c = c.replace(/\n/g, b || "&#xa;");
},
getTextContent:function(a) {
var b = "";
return null != a && (null != a.firstChild && (a = a.firstChild), b = a.nodeValue || ""), 
b;
},
getInnerHtml:function() {
return mxClient.IS_IE ? function(a) {
return null != a ? a.innerHTML :"";
} :function(a) {
return null != a ? new XMLSerializer().serializeToString(a) :"";
};
}(),
getOuterHtml:function() {
return mxClient.IS_IE ? function(a) {
if (null != a) {
if (null != a.outerHTML) return a.outerHTML;
var b = [];
b.push("<" + a.nodeName);
var c = a.attributes;
if (null != c) for (var d = 0; d < c.length; d++) {
var e = c[d].nodeValue;
null != e && 0 < e.length && (b.push(" "), b.push(c[d].nodeName), b.push('="'), 
b.push(e), b.push('"'));
}
return 0 == a.innerHTML.length ? b.push("/>") :(b.push(">"), b.push(a.innerHTML), 
b.push("</" + a.nodeName + ">")), b.join("");
}
return "";
} :function(a) {
return null != a ? new XMLSerializer().serializeToString(a) :"";
};
}(),
write:function(a, b) {
var c = a.ownerDocument.createTextNode(b);
return null != a && a.appendChild(c), c;
},
writeln:function(a, b) {
var c = a.ownerDocument.createTextNode(b);
return null != a && (a.appendChild(c), a.appendChild(document.createElement("br"))), 
c;
},
br:function(a, b) {
b = b || 1;
for (var c = null, d = 0; b > d; d++) null != a && (c = a.ownerDocument.createElement("br"), 
a.appendChild(c));
return c;
},
button:function(a, b, c) {
return c = null != c ? c :document, c = c.createElement("button"), mxUtils.write(c, a), 
mxEvent.addListener(c, "click", function(a) {
b(a);
}), c;
},
para:function(a, b) {
var c = document.createElement("p");
return mxUtils.write(c, b), null != a && a.appendChild(c), c;
},
addTransparentBackgroundFilter:function(a) {
a.style.filter += "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + mxClient.imageBasePath + "/transparent.gif', sizingMethod='scale')";
},
linkAction:function(a, b, c, d, e) {
return mxUtils.link(a, b, function() {
c.execute(d);
}, e);
},
linkInvoke:function(a, b, c, d, e, f) {
return mxUtils.link(a, b, function() {
c[d](e);
}, f);
},
link:function(a, b, c, d) {
var e = document.createElement("span");
return e.style.color = "blue", e.style.textDecoration = "underline", e.style.cursor = "pointer", 
null != d && (e.style.paddingLeft = d + "px"), mxEvent.addListener(e, "click", c), 
mxUtils.write(e, b), null != a && a.appendChild(e), e;
},
fit:function(a) {
var b = parseInt(a.offsetLeft), c = parseInt(a.offsetWidth), d = document.body, e = document.documentElement, f = (d.scrollLeft || e.scrollLeft) + (d.clientWidth || e.clientWidth);
b + c > f && (a.style.left = Math.max(d.scrollLeft || e.scrollLeft, f - c) + "px"), 
b = parseInt(a.offsetTop), c = parseInt(a.offsetHeight), f = (d.scrollTop || e.scrollTop) + Math.max(d.clientHeight || 0, e.clientHeight), 
b + c > f && (a.style.top = Math.max(d.scrollTop || e.scrollTop, f - c) + "px");
},
open:function(a) {
if (mxClient.IS_NS) {
try {
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
} catch (b) {
return mxUtils.alert("Permission to read file denied."), "";
}
var c = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
return c.initWithPath(a), c.exists() ? (a = Components.classes["@mozilla.org/network/file-input-stream;1"].createInstance(Components.interfaces.nsIFileInputStream), 
a.init(c, 1, 4, null), c = Components.classes["@mozilla.org/scriptableinputstream;1"].createInstance(Components.interfaces.nsIScriptableInputStream), 
c.init(a), c.read(c.available())) :(mxUtils.alert("File not found."), "");
}
return c = new ActiveXObject("Scripting.FileSystemObject").OpenTextFile(a, 1), a = c.readAll(), 
c.close(), a;
},
save:function(a, b) {
if (mxClient.IS_NS) {
try {
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
} catch (c) {
return mxUtils.alert("Permission to write file denied."), void 0;
}
var d = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
d.initWithPath(a), d.exists() || d.create(0, 420);
var e = Components.classes["@mozilla.org/network/file-output-stream;1"].createInstance(Components.interfaces.nsIFileOutputStream);
e.init(d, 34, 4, null), e.write(b, b.length), e.flush(), e.close();
} else d = new ActiveXObject("Scripting.FileSystemObject").CreateTextFile(a, !0), 
d.Write(b), d.Close();
},
saveAs:function(a) {
var b = document.createElement("iframe");
b.setAttribute("src", ""), b.style.visibility = "hidden", document.body.appendChild(b);
try {
if (mxClient.IS_NS) {
var c = b.contentDocument;
c.open(), c.write(a), c.close();
try {
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect"), b.focus(), 
saveDocument(c);
} catch (d) {
mxUtils.alert("Permission to save document denied.");
}
} else c = b.contentWindow.document, c.write(a), c.execCommand("SaveAs", !1, document.location);
} finally {
document.body.removeChild(b);
}
},
copy:function(a) {
if (window.clipboardData) window.clipboardData.setData("Text", a); else {
netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
var b = Components.classes["@mozilla.org/widget/clipboard;1"].createInstance(Components.interfaces.nsIClipboard);
if (b) {
var c = Components.classes["@mozilla.org/widget/transferable;1"].createInstance(Components.interfaces.nsITransferable);
if (c) {
c.addDataFlavor("text/unicode");
var d = Components.classes["@mozilla.org/supports-string;1"].createInstance(Components.interfaces.nsISupportsString);
d.data = a, c.setTransferData("text/unicode", d, 2 * a.length), b.setData(c, null, Components.interfaces.nsIClipboard.kGlobalClipboard);
}
}
}
},
load:function(a) {
return a = new mxXmlRequest(a, null, "GET", !1), a.send(), a;
},
get:function(a, b, c) {
return new mxXmlRequest(a, null, "GET").send(b, c);
},
post:function(a, b, c, d) {
return new mxXmlRequest(a, b).send(c, d);
},
submit:function(a, b, c, d) {
return new mxXmlRequest(a, b).simulate(c, d);
},
loadInto:function(a, b, c) {
mxClient.IS_IE ? b.onreadystatechange = function() {
4 == b.readyState && c();
} :b.addEventListener("load", c, !1), b.load(a);
},
getValue:function(a, b, c) {
return a = null != a ? a[b] :null, null == a && (a = c), a;
},
getNumber:function(a, b, c) {
return a = null != a ? a[b] :null, null == a && (a = c || 0), Number(a);
},
getColor:function(a, b, c) {
return a = null != a ? a[b] :null, null == a ? a = c :a == mxConstants.NONE && (a = null), 
a;
},
clone:function(a, b, c) {
c = null != c ? c :!1;
var d = null;
if (null != a && "function" == typeof a.constructor) {
var e, d = new a.constructor();
for (e in a) e != mxObjectIdentity.FIELD_NAME && (null == b || 0 > mxUtils.indexOf(b, e)) && (d[e] = c || "object" != typeof a[e] ? a[e] :mxUtils.clone(a[e]));
}
return d;
},
equalPoints:function(a, b) {
if (null == a && null != b || null != a && null == b || null != a && null != b && a.length != b.length) return !1;
if (null != a && null != b) for (var c = 0; c < a.length; c++) if (a[c] == b[c] || null != a[c] && !a[c].equals(b[c])) return !1;
return !0;
},
equalEntries:function(a, b) {
if (null == a && null != b || null != a && null == b || null != a && null != b && a.length != b.length) return !1;
if (null != a && null != b) for (var c in a) if (a[c] != b[c]) return !1;
return !0;
},
extend:function(a, b) {
var c = function() {};
c.prototype = b.prototype, a.prototype = new c(), a.prototype.constructor = a;
},
toString:function(a) {
var c, b = "";
for (c in a) try {
if (null == a[c]) b += c + " = [null]\n"; else if ("function" == typeof a[c]) b += c + " => [Function]\n"; else if ("object" == typeof a[c]) var d = mxUtils.getFunctionName(a[c].constructor), b = b + (c + " => [" + d + "]\n"); else b += c + " = " + a[c] + "\n";
} catch (e) {
b += c + "=" + e.message;
}
return b;
},
toRadians:function(a) {
return Math.PI * a / 180;
},
arcToCurves:function(a, b, c, d, e, f, g, h, k) {
if (h -= a, k -= b, 0 === c || 0 === d) return p;
c = Math.abs(c), d = Math.abs(d);
var l = -h / 2, m = -k / 2, n = Math.cos(e * Math.PI / 180), p = Math.sin(e * Math.PI / 180);
e = n * l + p * m;
var l = -1 * p * l + n * m, m = e * e, q = l * l, s = c * c, r = d * d, t = m / s + q / r;
t > 1 ? (c *= Math.sqrt(t), d *= Math.sqrt(t), f = 0) :(t = 1, f === g && (t = -1), 
f = t * Math.sqrt((s * r - s * q - r * m) / (s * q + r * m))), m = f * c * l / d, 
q = -1 * f * d * e / c, h = n * m - p * q + h / 2, k = p * m + n * q + k / 2, s = Math.atan2((l - q) / d, (e - m) / c) - Math.atan2(0, 1), 
f = s >= 0 ? s :2 * Math.PI + s, s = Math.atan2((-l - q) / d, (-e - m) / c) - Math.atan2((l - q) / d, (e - m) / c), 
e = s >= 0 ? s :2 * Math.PI + s, 0 == g && e > 0 ? e -= 2 * Math.PI :0 != g && 0 > e && (e += 2 * Math.PI), 
g = 2 * e / Math.PI, g = Math.ceil(0 > g ? -1 * g :g), e /= g, l = 8 / 3 * Math.sin(e / 4) * Math.sin(e / 4) / Math.sin(e / 2), 
m = n * c, n *= d, c *= p, d *= p;
for (var u = Math.cos(f), v = Math.sin(f), q = -l * (m * v + d * u), s = -l * (c * v - n * u), t = r = 0, p = [], w = 0; g > w; ++w) {
f += e;
var u = Math.cos(f), v = Math.sin(f), r = m * u - d * v + h, t = c * u + n * v + k, y = -l * (m * v + d * u), u = -l * (c * v - n * u), v = 6 * w;
p[v] = Number(q + a), p[v + 1] = Number(s + b), p[v + 2] = Number(r - y + a), p[v + 3] = Number(t - u + b), 
p[v + 4] = Number(r + a), p[v + 5] = Number(t + b), q = r + y, s = t + u;
}
return p;
},
getBoundingBox:function(a, b) {
var c = null;
if (null != a && null != b && 0 != b) {
var d = mxUtils.toRadians(b), c = Math.cos(d), e = Math.sin(d), f = new mxPoint(a.x + a.width / 2, a.y + a.height / 2), g = new mxPoint(a.x, a.y), d = new mxPoint(a.x + a.width, a.y), h = new mxPoint(d.x, a.y + a.height), k = new mxPoint(a.x, h.y), g = mxUtils.getRotatedPoint(g, c, e, f), d = mxUtils.getRotatedPoint(d, c, e, f), h = mxUtils.getRotatedPoint(h, c, e, f), k = mxUtils.getRotatedPoint(k, c, e, f), c = new mxRectangle(g.x, g.y, 0, 0);
c.add(new mxRectangle(d.x, d.y, 0, 0)), c.add(new mxRectangle(h.x, h.y, 0, 0)), 
c.add(new mxRectangle(k.x, k.y, 0, 0));
}
return c;
},
getRotatedPoint:function(a, b, c, d) {
d = null != d ? d :new mxPoint();
var e = a.x - d.x;
return a = a.y - d.y, new mxPoint(e * b - a * c + d.x, a * b + e * c + d.y);
},
getPortConstraints:function(a, b, c, d) {
return a = mxUtils.getValue(a.style, mxConstants.STYLE_PORT_CONSTRAINT, null), null == a ? d :(d = a.toString(), 
a = mxConstants.DIRECTION_MASK_NONE, 0 <= d.indexOf(mxConstants.DIRECTION_NORTH) && (a |= mxConstants.DIRECTION_MASK_NORTH), 
0 <= d.indexOf(mxConstants.DIRECTION_WEST) && (a |= mxConstants.DIRECTION_MASK_WEST), 
0 <= d.indexOf(mxConstants.DIRECTION_SOUTH) && (a |= mxConstants.DIRECTION_MASK_SOUTH), 
0 <= d.indexOf(mxConstants.DIRECTION_EAST) && (a |= mxConstants.DIRECTION_MASK_EAST), 
a);
},
reversePortConstraints:function(a) {
var b = 0, b = (a & mxConstants.DIRECTION_MASK_WEST) << 3, b = b | (a & mxConstants.DIRECTION_MASK_NORTH) << 1, b = b | (a & mxConstants.DIRECTION_MASK_SOUTH) >> 1;
return b |= (a & mxConstants.DIRECTION_MASK_EAST) >> 3;
},
findNearestSegment:function(a, b, c) {
var d = -1;
if (0 < a.absolutePoints.length) for (var e = a.absolutePoints[0], f = null, g = 1; g < a.absolutePoints.length; g++) {
var h = a.absolutePoints[g], e = mxUtils.ptSegDistSq(e.x, e.y, h.x, h.y, b, c);
(null == f || f > e) && (f = e, d = g - 1), e = h;
}
return d;
},
rectangleIntersectsSegment:function(a, b, c) {
var d = a.y, e = a.x, f = d + a.height, g = e + a.width;
a = b.x;
var h = c.x;
if (b.x > c.x && (a = c.x, h = b.x), h > g && (h = g), e > a && (a = e), a > h) return !1;
var e = b.y, g = c.y, k = c.x - b.x;
return 1e-7 < Math.abs(k) && (c = (c.y - b.y) / k, b = b.y - c * b.x, e = c * a + b, 
g = c * h + b), e > g && (b = g, g = e, e = b), g > f && (g = f), d > e && (e = d), 
e > g ? !1 :!0;
},
contains:function(a, b, c) {
return a.x <= b && a.x + a.width >= b && a.y <= c && a.y + a.height >= c;
},
intersects:function(a, b) {
var c = a.width, d = a.height, e = b.width, f = b.height;
if (0 >= e || 0 >= f || 0 >= c || 0 >= d) return !1;
var g = a.x, h = a.y, k = b.x, l = b.y, e = e + k, f = f + l, c = c + g, d = d + h;
return (k > e || e > g) && (l > f || f > h) && (g > c || c > k) && (h > d || d > l);
},
intersectsHotspot:function(a, b, c, d, e, f) {
if (d = null != d ? d :1, e = null != e ? e :0, f = null != f ? f :0, d > 0) {
var g = a.getCenterX(), h = a.getCenterY(), k = a.width, l = a.height, m = mxUtils.getValue(a.style, mxConstants.STYLE_STARTSIZE) * a.view.scale;
return m > 0 && (mxUtils.getValue(a.style, mxConstants.STYLE_HORIZONTAL, !0) ? (h = a.y + m / 2, 
l = m) :(g = a.x + m / 2, k = m)), k = Math.max(e, k * d), l = Math.max(e, l * d), 
f > 0 && (k = Math.min(k, f), l = Math.min(l, f)), d = new mxRectangle(g - k / 2, h - l / 2, k, l), 
g = mxUtils.toRadians(mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION) || 0), 
0 != g && (e = Math.cos(-g), f = Math.sin(-g), g = new mxPoint(a.getCenterX(), a.getCenterY()), 
a = mxUtils.getRotatedPoint(new mxPoint(b, c), e, f, g), b = a.x, c = a.y), mxUtils.contains(d, b, c);
}
return !0;
},
getOffset:function(a, b) {
var c = 0, d = 0;
if (null != b && b) var e = document.body, f = document.documentElement, c = c + (e.scrollLeft || f.scrollLeft), d = d + (e.scrollTop || f.scrollTop);
for (;a.offsetParent; ) c += a.offsetLeft, d += a.offsetTop, a = a.offsetParent;
return new mxPoint(c, d);
},
getScrollOrigin:function(a) {
for (var b = document.body, c = document.documentElement, d = new mxPoint(b.scrollLeft || c.scrollLeft, b.scrollTop || c.scrollTop); null != a && a != b && a != c; ) !isNaN(a.scrollLeft) && !isNaN(a.scrollTop) && (d.x += a.scrollLeft, 
d.y += a.scrollTop), a = a.parentNode;
return d;
},
convertPoint:function(a, b, c) {
var d = mxUtils.getScrollOrigin(a);
return a = mxUtils.getOffset(a), a.x -= d.x, a.y -= d.y, new mxPoint(b - a.x, c - a.y);
},
ltrim:function(a, b) {
return a.replace(RegExp("^[" + (b || "\\s") + "]+", "g"), "");
},
rtrim:function(a, b) {
return a.replace(RegExp("[" + (b || "\\s") + "]+$", "g"), "");
},
trim:function(a, b) {
return mxUtils.ltrim(mxUtils.rtrim(a, b), b);
},
isNumeric:function(a) {
return null != a && (null == a.length || 0 < a.length && 0 > a.indexOf("0x") && 0 > a.indexOf("0X")) && !isNaN(a);
},
mod:function(a, b) {
return (a % b + b) % b;
},
intersection:function(a, b, c, d, e, f, g, h) {
var k = (h - f) * (c - a) - (g - e) * (d - b);
return g = ((g - e) * (b - f) - (h - f) * (a - e)) / k, e = ((c - a) * (b - f) - (d - b) * (a - e)) / k, 
g >= 0 && 1 >= g && e >= 0 && 1 >= e ? new mxPoint(a + g * (c - a), b + g * (d - b)) :null;
},
ptSegDistSq:function(a, b, c, d, e, f) {
return c -= a, d -= b, e -= a, f -= b, 0 >= e * c + f * d ? c = 0 :(e = c - e, f = d - f, 
a = e * c + f * d, c = 0 >= a ? 0 :a * a / (c * c + d * d)), e = e * e + f * f - c, 
0 > e && (e = 0), e;
},
relativeCcw:function(a, b, c, d, e, f) {
return c -= a, d -= b, e -= a, f -= b, a = e * d - f * c, 0 == a && (a = e * c + f * d, 
a > 0 && (a = (e - c) * c + (f - d) * d, 0 > a && (a = 0))), 0 > a ? -1 :a > 0 ? 1 :0;
},
animateChanges:function() {
mxEffects.animateChanges.apply(this, arguments);
},
cascadeOpacity:function() {
mxEffects.cascadeOpacity.apply(this, arguments);
},
fadeOut:function() {
mxEffects.fadeOut.apply(this, arguments);
},
setOpacity:function(a, b) {
mxUtils.isVml(a) ? a.style.filter = b >= 100 ? null :"alpha(opacity=" + b / 5 + ")" :mxClient.IS_IE && ("undefined" == typeof document.documentMode || 9 > document.documentMode) ? a.style.filter = b >= 100 ? null :"alpha(opacity=" + b + ")" :a.style.opacity = b / 100;
},
createImage:function(a) {
var b = null;
return mxClient.IS_IE6 && "CSS1Compat" != document.compatMode ? (b = document.createElement(mxClient.VML_PREFIX + ":image"), 
b.setAttribute("src", a), b.style.borderStyle = "none") :(b = document.createElement("img"), 
b.setAttribute("src", a), b.setAttribute("border", "0")), b;
},
sortCells:function(a, b) {
b = null != b ? b :!0;
var c = new mxDictionary();
return a.sort(function(a, e) {
var f = c.get(a);
null == f && (f = mxCellPath.create(a).split(mxCellPath.PATH_SEPARATOR), c.put(a, f));
var g = c.get(e);
return null == g && (g = mxCellPath.create(e).split(mxCellPath.PATH_SEPARATOR), 
c.put(e, g)), f = mxCellPath.compare(f, g), 0 == f ? 0 :f > 0 == b ? 1 :-1;
}), a;
},
getStylename:function(a) {
return null != a && (a = a.split(";")[0], 0 > a.indexOf("=")) ? a :"";
},
getStylenames:function(a) {
var b = [];
if (null != a) {
a = a.split(";");
for (var c = 0; c < a.length; c++) 0 > a[c].indexOf("=") && b.push(a[c]);
}
return b;
},
indexOfStylename:function(a, b) {
if (null != a && null != b) for (var c = a.split(";"), d = 0, e = 0; e < c.length; e++) {
if (c[e] == b) return d;
d += c[e].length + 1;
}
return -1;
},
addStylename:function(a, b) {
return 0 > mxUtils.indexOfStylename(a, b) && (null == a ? a = "" :0 < a.length && ";" != a.charAt(a.length - 1) && (a += ";"), 
a += b), a;
},
removeStylename:function(a, b) {
var c = [];
if (null != a) for (var d = a.split(";"), e = 0; e < d.length; e++) d[e] != b && c.push(d[e]);
return c.join(";");
},
removeAllStylenames:function(a) {
var b = [];
if (null != a) {
a = a.split(";");
for (var c = 0; c < a.length; c++) 0 <= a[c].indexOf("=") && b.push(a[c]);
}
return b.join(";");
},
setCellStyles:function(a, b, c, d) {
if (null != b && 0 < b.length) {
a.beginUpdate();
try {
for (var e = 0; e < b.length; e++) if (null != b[e]) {
var f = mxUtils.setStyle(a.getStyle(b[e]), c, d);
a.setStyle(b[e], f);
}
} finally {
a.endUpdate();
}
}
},
setStyle:function(a, b, c) {
var d = null != c && ("undefined" == typeof c.length || 0 < c.length);
if (null == a || 0 == a.length) d && (a = b + "=" + c); else {
var e = a.indexOf(b + "=");
0 > e ? d && (d = ";" == a.charAt(a.length - 1) ? "" :";", a = a + d + b + "=" + c) :(b = d ? b + "=" + c :"", 
c = a.indexOf(";", e), d || c++, a = a.substring(0, e) + b + (c > e ? a.substring(c) :""));
}
return a;
},
setCellStyleFlags:function(a, b, c, d, e) {
if (null != b && 0 < b.length) {
a.beginUpdate();
try {
for (var f = 0; f < b.length; f++) if (null != b[f]) {
var g = mxUtils.setStyleFlag(a.getStyle(b[f]), c, d, e);
a.setStyle(b[f], g);
}
} finally {
a.endUpdate();
}
}
},
setStyleFlag:function(a, b, c, d) {
if (null == a || 0 == a.length) a = d || null == d ? b + "=" + c :b + "=0"; else {
var e = a.indexOf(b + "=");
if (0 > e) e = ";" == a.charAt(a.length - 1) ? "" :";", a = d || null == d ? a + e + b + "=" + c :a + e + b + "=0"; else {
var f = a.indexOf(";", e), g = "", g = 0 > f ? a.substring(e + b.length + 1) :a.substring(e + b.length + 1, f), g = null == d ? parseInt(g) ^ c :d ? parseInt(g) | c :parseInt(g) & ~c;
a = a.substring(0, e) + b + "=" + g + (f >= 0 ? a.substring(f) :"");
}
}
return a;
},
getAlignmentAsPoint:function(a, b) {
var c = 0, d = 0;
return a == mxConstants.ALIGN_CENTER ? c = -.5 :a == mxConstants.ALIGN_RIGHT && (c = -1), 
b == mxConstants.ALIGN_MIDDLE ? d = -.5 :b == mxConstants.ALIGN_BOTTOM && (d = -1), 
new mxPoint(c, d);
},
getSizeForString:function(a, b, c, d) {
b = null != b ? b :mxConstants.DEFAULT_FONTSIZE, c = null != c ? c :mxConstants.DEFAULT_FONTFAMILY;
var e = document.createElement("div");
return e.style.fontFamily = c, e.style.fontSize = Math.round(b) + "px", e.style.lineHeight = Math.round(b * mxConstants.LINE_HEIGHT) + "px", 
e.style.position = "absolute", e.style.visibility = "hidden", e.style.display = mxClient.IS_QUIRKS ? "inline" :"inline-block", 
e.style.zoom = "1", null != d ? (e.style.width = d + "px", e.style.whiteSpace = "normal") :e.style.whiteSpace = "nowrap", 
e.innerHTML = a, document.body.appendChild(e), a = new mxRectangle(0, 0, e.offsetWidth, e.offsetHeight), 
document.body.removeChild(e), a;
},
getViewXml:function(a, b, c, d, e) {
d = null != d ? d :0, e = null != e ? e :0, b = null != b ? b :1, null == c && (c = [ a.getModel().getRoot() ]);
var f = a.getView(), g = null, h = f.isEventsEnabled();
f.setEventsEnabled(!1);
var k = f.drawPane, l = f.overlayPane;
a.dialect == mxConstants.DIALECT_SVG ? (f.drawPane = document.createElementNS(mxConstants.NS_SVG, "g"), 
f.canvas.appendChild(f.drawPane), f.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g")) :(f.drawPane = f.drawPane.cloneNode(!1), 
f.canvas.appendChild(f.drawPane), f.overlayPane = f.overlayPane.cloneNode(!1)), 
f.canvas.appendChild(f.overlayPane);
var m = f.getTranslate();
f.translate = new mxPoint(d, e), b = new mxTemporaryCellStates(a.getView(), b, c);
try {
g = new mxCodec().encode(a.getView());
} finally {
b.destroy(), f.translate = m, f.canvas.removeChild(f.drawPane), f.canvas.removeChild(f.overlayPane), 
f.drawPane = k, f.overlayPane = l, f.setEventsEnabled(h);
}
return g;
},
getScaleForPageCount:function(a, b, c, d) {
if (1 > a) return 1;
c = null != c ? c :mxConstants.PAGE_FORMAT_A4_PORTRAIT, d = null != d ? d :0;
var e = c.width - 2 * d;
c = c.height - 2 * d, d = b.getGraphBounds().clone(), b = b.getView().getScale(), 
d.width /= b, d.height /= b, b = d.width, c = b / d.height / (e / c), d = Math.sqrt(a);
var f = Math.sqrt(c);
if (c = d * f, d /= f, 1 > c && d > a) {
var g = d / a;
d = a, c /= g;
}
for (1 > d && c > a && (g = c / a, c = a, d /= g), g = Math.ceil(c) * Math.ceil(d), 
f = 0; g > a; ) {
var g = Math.floor(c) / c, h = Math.floor(d) / d;
if (1 == g && (g = Math.floor(c - 1) / c), 1 == h && (h = Math.floor(d - 1) / d), 
g = g > h ? g :h, c *= g, d *= g, g = Math.ceil(c) * Math.ceil(d), f++, f > 10) break;
}
return .99999 * (e * c / b);
},
show:function(a, b, c, d) {
c = null != c ? c :0, d = null != d ? d :0, null == b ? b = window.open().document :b.open();
var e = a.getGraphBounds();
if (c = -e.x + c, d = -e.y + d, mxClient.IS_IE) {
for (var e = "<html><head>", f = document.getElementsByTagName("base"), g = 0; g < f.length; g++) e += f[g].outerHTML;
for (e += "<style>", g = 0; g < document.styleSheets.length; g++) try {
e += document.styleSheets(g).cssText;
} catch (h) {}
e += "</style></head>", e += "<body>", e += a.container.innerHTML, e += "</body>", 
e += "<html>", b.writeln(e), b.close(), a = b.body.getElementsByTagName("DIV")[0], 
null != a && (a.style.position = "absolute", a.style.left = c + "px", a.style.top = d + "px");
} else {
for (b.writeln("<html"), b.writeln("<head>"), f = document.getElementsByTagName("base"), 
g = 0; g < f.length; g++) b.writeln(mxUtils.getOuterHtml(f[g]));
for (f = document.getElementsByTagName("link"), g = 0; g < f.length; g++) b.writeln(mxUtils.getOuterHtml(f[g]));
for (f = document.getElementsByTagName("style"), g = 0; g < f.length; g++) b.writeln(mxUtils.getOuterHtml(f[g]));
for (b.writeln("</head>"), b.writeln("</html>"), b.close(), null == b.body && b.documentElement.appendChild(b.createElement("body")), 
b.body.style.overflow = "auto", a = a.container.firstChild; null != a; ) g = a.cloneNode(!0), 
b.body.appendChild(g), a = a.nextSibling;
a = b.getElementsByTagName("g")[0], null != a && (a.setAttribute("transform", "translate(" + c + "," + d + ")"), 
c = a.ownerSVGElement, c.setAttribute("width", e.width + Math.max(e.x, 0) + 3), 
c.setAttribute("height", e.height + Math.max(e.y, 0) + 3));
}
return mxUtils.removeCursors(b.body), b;
},
printScreen:function(a) {
var b = window.open();
mxUtils.show(a, b.document), a = function() {
b.focus(), b.print(), b.close();
}, mxClient.IS_GC ? b.setTimeout(a, 500) :a();
},
popup:function(a, b) {
if (b) {
var c = document.createElement("div");
c.style.overflow = "scroll", c.style.width = "636px", c.style.height = "460px";
var d = document.createElement("pre");
d.innerHTML = mxUtils.htmlEntities(a, !1).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;"), 
c.appendChild(d), c = new mxWindow("Popup Window", c, document.body.clientWidth / 2 - 320, (document.body.clientHeight || document.documentElement.clientHeight) / 2 - 240, 640, 480, !1, !0), 
c.setClosable(!0), c.setVisible(!0);
} else mxClient.IS_NS ? (c = window.open(), c.document.writeln("<pre>" + mxUtils.htmlEntities(a) + "</pre"), 
c.document.close()) :(c = window.open(), d = c.document.createElement("pre"), d.innerHTML = mxUtils.htmlEntities(a, !1).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;"), 
c.document.body.appendChild(d));
},
alert:function(a) {
alert(a);
},
prompt:function(a, b) {
return prompt(a, b);
},
confirm:function(a) {
return confirm(a);
},
error:function(a, b, c, d) {
var e = document.createElement("div");
e.style.padding = "20px";
var f = document.createElement("img");
f.setAttribute("src", d || mxUtils.errorImage), f.setAttribute("valign", "bottom"), 
f.style.verticalAlign = "middle", e.appendChild(f), e.appendChild(document.createTextNode("\xa0")), 
e.appendChild(document.createTextNode("\xa0")), e.appendChild(document.createTextNode("\xa0")), 
mxUtils.write(e, a), a = document.body.clientWidth, d = document.body.clientHeight || document.documentElement.clientHeight;
var g = new mxWindow(mxResources.get(mxUtils.errorResource) || mxUtils.errorResource, e, (a - b) / 2, d / 4, b, null, !1, !0);
return c && (mxUtils.br(e), b = document.createElement("p"), c = document.createElement("button"), 
mxClient.IS_IE ? c.style.cssText = "float:right" :c.setAttribute("style", "float:right"), 
mxEvent.addListener(c, "click", function() {
g.destroy();
}), mxUtils.write(c, mxResources.get(mxUtils.closeResource) || mxUtils.closeResource), 
b.appendChild(c), e.appendChild(b), mxUtils.br(e), g.setClosable(!0)), g.setVisible(!0), 
g;
},
makeDraggable:function(a, b, c, d, e, f, g, h, k, l) {
return a = new mxDragSource(a, c), a.dragOffset = new mxPoint(null != e ? e :0, null != f ? f :mxConstants.TOOLTIP_VERTICAL_OFFSET), 
a.autoscroll = g, a.setGuidesEnabled(!1), null != k && (a.highlightDropTargets = k), 
null != l && (a.getDropTarget = l), a.getGraphForEvent = function(a) {
return "function" == typeof b ? b(a) :b;
}, null != d && (a.createDragElement = function() {
return d.cloneNode(!0);
}, h && (a.createPreviewElement = function(a) {
var b = d.cloneNode(!0), c = parseInt(b.style.width), e = parseInt(b.style.height);
return b.style.width = Math.round(c * a.view.scale) + "px", b.style.height = Math.round(e * a.view.scale) + "px", 
b;
})), a;
}
}, mxConstants = {
DEFAULT_HOTSPOT:.3,
MIN_HOTSPOT_SIZE:8,
MAX_HOTSPOT_SIZE:0,
RENDERING_HINT_EXACT:"exact",
RENDERING_HINT_FASTER:"faster",
RENDERING_HINT_FASTEST:"fastest",
DIALECT_SVG:"svg",
DIALECT_VML:"vml",
DIALECT_MIXEDHTML:"mixedHtml",
DIALECT_PREFERHTML:"preferHtml",
DIALECT_STRICTHTML:"strictHtml",
NS_SVG:"http://www.w3.org/2000/svg",
NS_XHTML:"http://www.w3.org/1999/xhtml",
NS_XLINK:"http://www.w3.org/1999/xlink",
SHADOWCOLOR:"gray",
SHADOW_OFFSET_X:2,
SHADOW_OFFSET_Y:3,
SHADOW_OPACITY:1,
NODETYPE_ELEMENT:1,
NODETYPE_ATTRIBUTE:2,
NODETYPE_TEXT:3,
NODETYPE_CDATA:4,
NODETYPE_ENTITY_REFERENCE:5,
NODETYPE_ENTITY:6,
NODETYPE_PROCESSING_INSTRUCTION:7,
NODETYPE_COMMENT:8,
NODETYPE_DOCUMENT:9,
NODETYPE_DOCUMENTTYPE:10,
NODETYPE_DOCUMENT_FRAGMENT:11,
NODETYPE_NOTATION:12,
TOOLTIP_VERTICAL_OFFSET:16,
DEFAULT_VALID_COLOR:"#00FF00",
DEFAULT_INVALID_COLOR:"#FF0000",
HIGHLIGHT_STROKEWIDTH:3,
CURSOR_MOVABLE_VERTEX:"move",
CURSOR_MOVABLE_EDGE:"move",
CURSOR_LABEL_HANDLE:"default",
CURSOR_BEND_HANDLE:"pointer",
CURSOR_CONNECT:"pointer",
HIGHLIGHT_COLOR:"#00FF00",
CONNECT_TARGET_COLOR:"#0000FF",
INVALID_CONNECT_TARGET_COLOR:"#FF0000",
DROP_TARGET_COLOR:"#0000FF",
VALID_COLOR:"#00FF00",
INVALID_COLOR:"#FF0000",
EDGE_SELECTION_COLOR:"#00FF00",
VERTEX_SELECTION_COLOR:"#00FF00",
VERTEX_SELECTION_STROKEWIDTH:1,
EDGE_SELECTION_STROKEWIDTH:1,
VERTEX_SELECTION_DASHED:!0,
EDGE_SELECTION_DASHED:!0,
GUIDE_COLOR:"#FF0000",
GUIDE_STROKEWIDTH:1,
OUTLINE_COLOR:"#0099FF",
OUTLINE_STROKEWIDTH:mxClient.IS_IE ? 2 :3,
HANDLE_SIZE:7,
LABEL_HANDLE_SIZE:4,
HANDLE_FILLCOLOR:"#00FF00",
HANDLE_STROKECOLOR:"black",
LABEL_HANDLE_FILLCOLOR:"yellow",
CONNECT_HANDLE_FILLCOLOR:"#0000FF",
LOCKED_HANDLE_FILLCOLOR:"#FF0000",
OUTLINE_HANDLE_FILLCOLOR:"#00FFFF",
OUTLINE_HANDLE_STROKECOLOR:"#0033FF",
DEFAULT_FONTFAMILY:"Arial,Helvetica",
DEFAULT_FONTSIZE:11,
LINE_HEIGHT:1.2,
DEFAULT_FONTSTYLE:0,
DEFAULT_STARTSIZE:40,
DEFAULT_MARKERSIZE:6,
DEFAULT_IMAGESIZE:24,
ENTITY_SEGMENT:30,
RECTANGLE_ROUNDING_FACTOR:.15,
LINE_ARCSIZE:20,
ARROW_SPACING:10,
ARROW_WIDTH:30,
ARROW_SIZE:30,
PAGE_FORMAT_A4_PORTRAIT:new mxRectangle(0, 0, 826, 1169),
PAGE_FORMAT_A4_LANDSCAPE:new mxRectangle(0, 0, 1169, 826),
PAGE_FORMAT_LETTER_PORTRAIT:new mxRectangle(0, 0, 850, 1100),
PAGE_FORMAT_LETTER_LANDSCAPE:new mxRectangle(0, 0, 1100, 850),
NONE:"none",
STYLE_PERIMETER:"perimeter",
STYLE_SOURCE_PORT:"sourcePort",
STYLE_TARGET_PORT:"targetPort",
STYLE_PORT_CONSTRAINT:"portConstraint",
STYLE_OPACITY:"opacity",
STYLE_TEXT_OPACITY:"textOpacity",
STYLE_OVERFLOW:"overflow",
STYLE_ORTHOGONAL:"orthogonal",
STYLE_EXIT_X:"exitX",
STYLE_EXIT_Y:"exitY",
STYLE_EXIT_PERIMETER:"exitPerimeter",
STYLE_ENTRY_X:"entryX",
STYLE_ENTRY_Y:"entryY",
STYLE_ENTRY_PERIMETER:"entryPerimeter",
STYLE_WHITE_SPACE:"whiteSpace",
STYLE_ROTATION:"rotation",
STYLE_FILLCOLOR:"fillColor",
STYLE_SWIMLANE_FILLCOLOR:"swimlaneFillColor",
STYLE_GRADIENTCOLOR:"gradientColor",
STYLE_GRADIENT_DIRECTION:"gradientDirection",
STYLE_STROKECOLOR:"strokeColor",
STYLE_SEPARATORCOLOR:"separatorColor",
STYLE_STROKEWIDTH:"strokeWidth",
STYLE_ALIGN:"align",
STYLE_VERTICAL_ALIGN:"verticalAlign",
STYLE_LABEL_POSITION:"labelPosition",
STYLE_VERTICAL_LABEL_POSITION:"verticalLabelPosition",
STYLE_IMAGE_ASPECT:"imageAspect",
STYLE_IMAGE_ALIGN:"imageAlign",
STYLE_IMAGE_VERTICAL_ALIGN:"imageVerticalAlign",
STYLE_GLASS:"glass",
STYLE_IMAGE:"image",
STYLE_IMAGE_WIDTH:"imageWidth",
STYLE_IMAGE_HEIGHT:"imageHeight",
STYLE_IMAGE_BACKGROUND:"imageBackground",
STYLE_IMAGE_BORDER:"imageBorder",
STYLE_FLIPH:"flipH",
STYLE_FLIPV:"flipV",
STYLE_NOLABEL:"noLabel",
STYLE_NOEDGESTYLE:"noEdgeStyle",
STYLE_LABEL_BACKGROUNDCOLOR:"labelBackgroundColor",
STYLE_LABEL_BORDERCOLOR:"labelBorderColor",
STYLE_LABEL_PADDING:"labelPadding",
STYLE_INDICATOR_SHAPE:"indicatorShape",
STYLE_INDICATOR_IMAGE:"indicatorImage",
STYLE_INDICATOR_COLOR:"indicatorColor",
STYLE_INDICATOR_STROKECOLOR:"indicatorStrokeColor",
STYLE_INDICATOR_GRADIENTCOLOR:"indicatorGradientColor",
STYLE_INDICATOR_SPACING:"indicatorSpacing",
STYLE_INDICATOR_WIDTH:"indicatorWidth",
STYLE_INDICATOR_HEIGHT:"indicatorHeight",
STYLE_INDICATOR_DIRECTION:"indicatorDirection",
STYLE_SHADOW:"shadow",
STYLE_SEGMENT:"segment",
STYLE_ENDARROW:"endArrow",
STYLE_STARTARROW:"startArrow",
STYLE_ENDSIZE:"endSize",
STYLE_STARTSIZE:"startSize",
STYLE_SWIMLANE_LINE:"swimlaneLine",
STYLE_ENDFILL:"endFill",
STYLE_STARTFILL:"startFill",
STYLE_DASHED:"dashed",
STYLE_DASH_PATTERN:"dashPattern",
STYLE_ROUNDED:"rounded",
STYLE_CURVED:"curved",
STYLE_ARCSIZE:"arcSize",
STYLE_SMOOTH:"smooth",
STYLE_SOURCE_PERIMETER_SPACING:"sourcePerimeterSpacing",
STYLE_TARGET_PERIMETER_SPACING:"targetPerimeterSpacing",
STYLE_PERIMETER_SPACING:"perimeterSpacing",
STYLE_SPACING:"spacing",
STYLE_SPACING_TOP:"spacingTop",
STYLE_SPACING_LEFT:"spacingLeft",
STYLE_SPACING_BOTTOM:"spacingBottom",
STYLE_SPACING_RIGHT:"spacingRight",
STYLE_HORIZONTAL:"horizontal",
STYLE_DIRECTION:"direction",
STYLE_ELBOW:"elbow",
STYLE_FONTCOLOR:"fontColor",
STYLE_FONTFAMILY:"fontFamily",
STYLE_FONTSIZE:"fontSize",
STYLE_FONTSTYLE:"fontStyle",
STYLE_AUTOSIZE:"autosize",
STYLE_FOLDABLE:"foldable",
STYLE_EDITABLE:"editable",
STYLE_BENDABLE:"bendable",
STYLE_MOVABLE:"movable",
STYLE_RESIZABLE:"resizable",
STYLE_ROTATABLE:"rotatable",
STYLE_CLONEABLE:"cloneable",
STYLE_DELETABLE:"deletable",
STYLE_SHAPE:"shape",
STYLE_EDGE:"edgeStyle",
STYLE_LOOP:"loopStyle",
STYLE_ROUTING_CENTER_X:"routingCenterX",
STYLE_ROUTING_CENTER_Y:"routingCenterY",
FONT_BOLD:1,
FONT_ITALIC:2,
FONT_UNDERLINE:4,
FONT_SHADOW:8,
SHAPE_RECTANGLE:"rectangle",
SHAPE_ELLIPSE:"ellipse",
SHAPE_DOUBLE_ELLIPSE:"doubleEllipse",
SHAPE_RHOMBUS:"rhombus",
SHAPE_LINE:"line",
SHAPE_IMAGE:"image",
SHAPE_ARROW:"arrow",
SHAPE_LABEL:"label",
SHAPE_CYLINDER:"cylinder",
SHAPE_SWIMLANE:"swimlane",
SHAPE_CONNECTOR:"connector",
SHAPE_ACTOR:"actor",
SHAPE_CLOUD:"cloud",
SHAPE_TRIANGLE:"triangle",
SHAPE_HEXAGON:"hexagon",
ARROW_CLASSIC:"classic",
ARROW_BLOCK:"block",
ARROW_OPEN:"open",
ARROW_OVAL:"oval",
ARROW_DIAMOND:"diamond",
ARROW_DIAMOND_THIN:"diamondThin",
ALIGN_LEFT:"left",
ALIGN_CENTER:"center",
ALIGN_RIGHT:"right",
ALIGN_TOP:"top",
ALIGN_MIDDLE:"middle",
ALIGN_BOTTOM:"bottom",
DIRECTION_NORTH:"north",
DIRECTION_SOUTH:"south",
DIRECTION_EAST:"east",
DIRECTION_WEST:"west",
DIRECTION_MASK_NONE:0,
DIRECTION_MASK_WEST:1,
DIRECTION_MASK_NORTH:2,
DIRECTION_MASK_SOUTH:4,
DIRECTION_MASK_EAST:8,
DIRECTION_MASK_ALL:15,
ELBOW_VERTICAL:"vertical",
ELBOW_HORIZONTAL:"horizontal",
EDGESTYLE_ELBOW:"elbowEdgeStyle",
EDGESTYLE_ENTITY_RELATION:"entityRelationEdgeStyle",
EDGESTYLE_LOOP:"loopEdgeStyle",
EDGESTYLE_SIDETOSIDE:"sideToSideEdgeStyle",
EDGESTYLE_TOPTOBOTTOM:"topToBottomEdgeStyle",
EDGESTYLE_ORTHOGONAL:"orthogonalEdgeStyle",
EDGESTYLE_SEGMENT:"segmentEdgeStyle",
PERIMETER_ELLIPSE:"ellipsePerimeter",
PERIMETER_RECTANGLE:"rectanglePerimeter",
PERIMETER_RHOMBUS:"rhombusPerimeter",
PERIMETER_TRIANGLE:"trianglePerimeter"
};

mxEventObject.prototype.name = null, mxEventObject.prototype.properties = null, 
mxEventObject.prototype.consumed = !1, mxEventObject.prototype.getName = function() {
return this.name;
}, mxEventObject.prototype.getProperties = function() {
return this.properties;
}, mxEventObject.prototype.getProperty = function(a) {
return this.properties[a];
}, mxEventObject.prototype.isConsumed = function() {
return this.consumed;
}, mxEventObject.prototype.consume = function() {
this.consumed = !0;
}, mxMouseEvent.prototype.consumed = !1, mxMouseEvent.prototype.evt = null, mxMouseEvent.prototype.graphX = null, 
mxMouseEvent.prototype.graphY = null, mxMouseEvent.prototype.state = null, mxMouseEvent.prototype.getEvent = function() {
return this.evt;
}, mxMouseEvent.prototype.getSource = function() {
return mxEvent.getSource(this.evt);
}, mxMouseEvent.prototype.isSource = function(a) {
if (null != a) for (var b = this.getSource(); null != b; ) {
if (b == a.node) return !0;
b = b.parentNode;
}
return !1;
}, mxMouseEvent.prototype.getX = function() {
return mxEvent.getClientX(this.getEvent());
}, mxMouseEvent.prototype.getY = function() {
return mxEvent.getClientY(this.getEvent());
}, mxMouseEvent.prototype.getGraphX = function() {
return this.graphX;
}, mxMouseEvent.prototype.getGraphY = function() {
return this.graphY;
}, mxMouseEvent.prototype.getState = function() {
return this.state;
}, mxMouseEvent.prototype.getCell = function() {
var a = this.getState();
return null != a ? a.cell :null;
}, mxMouseEvent.prototype.isPopupTrigger = function() {
return mxEvent.isPopupTrigger(this.getEvent());
}, mxMouseEvent.prototype.isConsumed = function() {
return this.consumed;
}, mxMouseEvent.prototype.consume = function(a) {
(null != a ? a :1) && this.evt.preventDefault && this.evt.preventDefault(), this.evt.returnValue = !1, 
this.consumed = !0;
}, mxEventSource.prototype.eventListeners = null, mxEventSource.prototype.eventsEnabled = !0, 
mxEventSource.prototype.eventSource = null, mxEventSource.prototype.isEventsEnabled = function() {
return this.eventsEnabled;
}, mxEventSource.prototype.setEventsEnabled = function(a) {
this.eventsEnabled = a;
}, mxEventSource.prototype.getEventSource = function() {
return this.eventSource;
}, mxEventSource.prototype.setEventSource = function(a) {
this.eventSource = a;
}, mxEventSource.prototype.addListener = function(a, b) {
null == this.eventListeners && (this.eventListeners = []), this.eventListeners.push(a), 
this.eventListeners.push(b);
}, mxEventSource.prototype.removeListener = function(a) {
if (null != this.eventListeners) for (var b = 0; b < this.eventListeners.length; ) this.eventListeners[b + 1] == a ? this.eventListeners.splice(b, 2) :b += 2;
}, mxEventSource.prototype.fireEvent = function(a, b) {
if (null != this.eventListeners && this.isEventsEnabled()) {
null == a && (a = new mxEventObject()), null == b && (b = this.getEventSource()), 
null == b && (b = this);
for (var c = [ b, a ], d = 0; d < this.eventListeners.length; d += 2) {
var e = this.eventListeners[d];
(null == e || e == a.getName()) && this.eventListeners[d + 1].apply(this, c);
}
}
};

var mxEvent = {
objects:[],
addListener:function() {
var a = function(a, c, d) {
null == a.mxListenerList && (a.mxListenerList = [], mxEvent.objects.push(a)), a.mxListenerList.push({
name:c,
f:d
});
};
return window.addEventListener ? function(b, c, d) {
b.addEventListener(c, d, !1), a(b, c, d);
} :function(b, c, d) {
b.attachEvent("on" + c, d), a(b, c, d);
};
}(),
removeListener:function() {
var a = function(a, c, d) {
if (null != a.mxListenerList) {
c = a.mxListenerList.length;
for (var e = 0; c > e; e++) if (a.mxListenerList[e].f == d) {
a.mxListenerList.splice(e, 1);
break;
}
0 == a.mxListenerList.length && (a.mxListenerList = null);
}
};
return window.removeEventListener ? function(b, c, d) {
b.removeEventListener(c, d, !1), a(b, c, d);
} :function(b, c, d) {
b.detachEvent("on" + c, d), a(b, c, d);
};
}(),
removeAllListeners:function(a) {
var b = a.mxListenerList;
if (null != b) for (;0 < b.length; ) {
var c = b[0];
mxEvent.removeListener(a, c.name, c.f);
}
},
addGestureListeners:function(a, b, c, d) {
null != b && mxEvent.addListener(a, mxClient.IS_POINTER ? "MSPointerDown" :"mousedown", b), 
null != c && mxEvent.addListener(a, mxClient.IS_POINTER ? "MSPointerMove" :"mousemove", c), 
null != d && mxEvent.addListener(a, mxClient.IS_POINTER ? "MSPointerUp" :"mouseup", d), 
!mxClient.IS_POINTER && mxClient.IS_TOUCH && (null != b && mxEvent.addListener(a, "touchstart", b), 
null != c && mxEvent.addListener(a, "touchmove", c), null != d && mxEvent.addListener(a, "touchend", d));
},
removeGestureListeners:function(a, b, c, d) {
null != b && mxEvent.removeListener(a, mxClient.IS_POINTER ? "MSPointerDown" :"mousedown", b), 
null != c && mxEvent.removeListener(a, mxClient.IS_POINTER ? "MSPointerMove" :"mousemove", c), 
null != d && mxEvent.removeListener(a, mxClient.IS_POINTER ? "MSPointerUp" :"mouseup", d), 
!mxClient.IS_POINTER && mxClient.IS_TOUCH && (null != b && mxEvent.removeListener(a, "touchstart", b), 
null != c && mxEvent.removeListener(a, "touchmove", c), null != d && mxEvent.removeListener(a, "touchend", d));
},
redirectMouseEvents:function(a, b, c, d, e, f, g) {
var h = function(a) {
return "function" == typeof c ? c(a) :c;
};
mxEvent.addGestureListeners(a, function(a) {
null != d ? d(a) :mxEvent.isConsumed(a) || b.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a, h(a)));
}, function(a) {
null != e ? e(a) :mxEvent.isConsumed(a) || b.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(a, h(a)));
}, function(a) {
null != f ? f(a) :mxEvent.isConsumed(a) || b.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(a, h(a)));
}), mxEvent.addListener(a, "dblclick", function(a) {
if (null != g) g(a); else if (!mxEvent.isConsumed(a)) {
var c = h(a);
b.dblClick(a, null != c ? c.cell :null);
}
});
},
release:function(a) {
if (null != a && (mxEvent.removeAllListeners(a), a = a.childNodes, null != a)) for (var b = a.length, c = 0; b > c; c += 1) mxEvent.release(a[c]);
},
addMouseWheelListener:function(a) {
if (null != a) {
var b = function(b) {
null == b && (b = window.event);
var d = 0, d = !mxClient.IS_NS || mxClient.IS_SF || mxClient.IS_GC ? b.wheelDelta / 120 :-b.detail / 2;
0 != d && a(b, d > 0);
};
mxClient.IS_NS ? mxEvent.addListener(window, mxClient.IS_SF || mxClient.IS_GC ? "mousewheel" :"DOMMouseScroll", b) :mxEvent.addListener(document, "mousewheel", b);
}
},
disableContextMenu:function() {
return mxClient.IS_IE && ("undefined" == typeof document.documentMode || 9 > document.documentMode) ? function(a) {
mxEvent.addListener(a, "contextmenu", function() {
return !1;
});
} :function(a) {
a.setAttribute("oncontextmenu", "return false;");
};
}(),
getSource:function(a) {
return null != a.srcElement ? a.srcElement :a.target;
},
isConsumed:function(a) {
return null != a.isConsumed && a.isConsumed;
},
isLeftMouseButton:function(a) {
return a.button == (mxClient.IS_IE && ("undefined" == typeof document.documentMode || 9 > document.documentMode) ? 1 :0);
},
isRightMouseButton:function(a) {
return 2 == a.button;
},
isPopupTrigger:function(a) {
return mxEvent.isRightMouseButton(a) || mxEvent.isShiftDown(a) && !mxEvent.isControlDown(a);
},
isShiftDown:function(a) {
return null != a ? a.shiftKey :!1;
},
isAltDown:function(a) {
return null != a ? a.altKey :!1;
},
isControlDown:function(a) {
return null != a ? a.ctrlKey :!1;
},
isMetaDown:function(a) {
return null != a ? a.metaKey :!1;
},
getMainEvent:function(a) {
return "touchstart" != a.type && "touchmove" != a.type || null == a.touches || null == a.touches[0] ? "touchend" == a.type && null != a.changedTouches && null != a.changedTouches[0] && (a = a.changedTouches[0]) :a = a.touches[0], 
a;
},
getClientX:function(a) {
return mxEvent.getMainEvent(a).clientX;
},
getClientY:function(a) {
return mxEvent.getMainEvent(a).clientY;
},
consume:function(a, b, c) {
c = null != c ? c :!0, (null != b ? b :1) && (a.preventDefault ? (c && a.stopPropagation(), 
a.preventDefault()) :c && (a.cancelBubble = !0)), a.isConsumed = !0, a.returnValue = !1;
},
LABEL_HANDLE:-1,
ROTATION_HANDLE:-2,
MOUSE_DOWN:"mouseDown",
MOUSE_MOVE:"mouseMove",
MOUSE_UP:"mouseUp",
ACTIVATE:"activate",
RESIZE_START:"resizeStart",
RESIZE:"resize",
RESIZE_END:"resizeEnd",
MOVE_START:"moveStart",
MOVE:"move",
MOVE_END:"moveEnd",
PAN_START:"panStart",
PAN:"pan",
PAN_END:"panEnd",
MINIMIZE:"minimize",
NORMALIZE:"normalize",
MAXIMIZE:"maximize",
HIDE:"hide",
SHOW:"show",
CLOSE:"close",
DESTROY:"destroy",
REFRESH:"refresh",
SIZE:"size",
SELECT:"select",
FIRED:"fired",
GET:"get",
RECEIVE:"receive",
CONNECT:"connect",
DISCONNECT:"disconnect",
SUSPEND:"suspend",
RESUME:"resume",
MARK:"mark",
SESSION:"session",
ROOT:"root",
POST:"post",
OPEN:"open",
SAVE:"save",
BEFORE_ADD_VERTEX:"beforeAddVertex",
ADD_VERTEX:"addVertex",
AFTER_ADD_VERTEX:"afterAddVertex",
DONE:"done",
EXECUTE:"execute",
EXECUTED:"executed",
BEGIN_UPDATE:"beginUpdate",
START_EDIT:"startEdit",
END_UPDATE:"endUpdate",
END_EDIT:"endEdit",
BEFORE_UNDO:"beforeUndo",
UNDO:"undo",
REDO:"redo",
CHANGE:"change",
NOTIFY:"notify",
LAYOUT_CELLS:"layoutCells",
CLICK:"click",
SCALE:"scale",
TRANSLATE:"translate",
SCALE_AND_TRANSLATE:"scaleAndTranslate",
UP:"up",
DOWN:"down",
ADD:"add",
REMOVE:"remove",
CLEAR:"clear",
ADD_CELLS:"addCells",
CELLS_ADDED:"cellsAdded",
MOVE_CELLS:"moveCells",
CELLS_MOVED:"cellsMoved",
RESIZE_CELLS:"resizeCells",
CELLS_RESIZED:"cellsResized",
TOGGLE_CELLS:"toggleCells",
CELLS_TOGGLED:"cellsToggled",
ORDER_CELLS:"orderCells",
CELLS_ORDERED:"cellsOrdered",
REMOVE_CELLS:"removeCells",
CELLS_REMOVED:"cellsRemoved",
GROUP_CELLS:"groupCells",
UNGROUP_CELLS:"ungroupCells",
REMOVE_CELLS_FROM_PARENT:"removeCellsFromParent",
FOLD_CELLS:"foldCells",
CELLS_FOLDED:"cellsFolded",
ALIGN_CELLS:"alignCells",
LABEL_CHANGED:"labelChanged",
CONNECT_CELL:"connectCell",
CELL_CONNECTED:"cellConnected",
SPLIT_EDGE:"splitEdge",
FLIP_EDGE:"flipEdge",
START_EDITING:"startEditing",
ADD_OVERLAY:"addOverlay",
REMOVE_OVERLAY:"removeOverlay",
UPDATE_CELL_SIZE:"updateCellSize",
ESCAPE:"escape",
CLICK:"click",
DOUBLE_CLICK:"doubleClick",
START:"start",
RESET:"reset"
};

mxXmlRequest.prototype.url = null, mxXmlRequest.prototype.params = null, mxXmlRequest.prototype.method = null, 
mxXmlRequest.prototype.async = null, mxXmlRequest.prototype.binary = !1, mxXmlRequest.prototype.username = null, 
mxXmlRequest.prototype.password = null, mxXmlRequest.prototype.request = null, mxXmlRequest.prototype.isBinary = function() {
return this.binary;
}, mxXmlRequest.prototype.setBinary = function(a) {
this.binary = a;
}, mxXmlRequest.prototype.getText = function() {
return this.request.responseText;
}, mxXmlRequest.prototype.isReady = function() {
return 4 == this.request.readyState;
}, mxXmlRequest.prototype.getDocumentElement = function() {
var a = this.getXml();
return null != a ? a.documentElement :null;
}, mxXmlRequest.prototype.getXml = function() {
var a = this.request.responseXML;
return (9 <= document.documentMode || null == a || null == a.documentElement) && (a = mxUtils.parseXml(this.request.responseText)), 
a;
}, mxXmlRequest.prototype.getText = function() {
return this.request.responseText;
}, mxXmlRequest.prototype.getStatus = function() {
return this.request.status;
}, mxXmlRequest.prototype.create = function() {
return window.XMLHttpRequest ? function() {
var a = new XMLHttpRequest();
return this.isBinary() && a.overrideMimeType && a.overrideMimeType("text/plain; charset=x-user-defined"), 
a;
} :"undefined" != typeof ActiveXObject ? function() {
return new ActiveXObject("Microsoft.XMLHTTP");
} :void 0;
}(), mxXmlRequest.prototype.send = function(a) {
this.request = this.create(), null != this.request && (null != a && (this.request.onreadystatechange = mxUtils.bind(this, function() {
this.isReady() && (a(this), this.onreadystatechaange = null);
})), this.request.open(this.method, this.url, this.async, this.username, this.password), 
this.setRequestHeaders(this.request, this.params), this.request.send(this.params));
}, mxXmlRequest.prototype.setRequestHeaders = function(a, b) {
null != b && a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
}, mxXmlRequest.prototype.simulate = function(a, b) {
a = a || document;
var c = null;
a == document && (c = window.onbeforeunload, window.onbeforeunload = null);
var d = a.createElement("form");
d.setAttribute("method", this.method), d.setAttribute("action", this.url), null != b && d.setAttribute("target", b), 
d.style.display = "none", d.style.visibility = "hidden";
for (var e = 0 < this.params.indexOf("&") ? this.params.split("&") :this.params.split(), f = 0; f < e.length; f++) {
var g = e[f].indexOf("=");
if (g > 0) {
var h = e[f].substring(0, g), k = e[f].substring(g + 1), g = a.createElement("textarea");
g.setAttribute("name", h), k = k.replace(/\n/g, "&#xa;"), h = a.createTextNode(k), 
g.appendChild(h), d.appendChild(g);
}
}
a.body.appendChild(d), d.submit(), a.body.removeChild(d), null != c && (window.onbeforeunload = c);
};

var mxClipboard = {
STEPSIZE:10,
insertCount:1,
cells:null,
isEmpty:function() {
return null == mxClipboard.cells;
},
cut:function(a, b) {
return b = mxClipboard.copy(a, b), mxClipboard.insertCount = 0, mxClipboard.removeCells(a, b), 
b;
},
removeCells:function(a, b) {
a.removeCells(b);
},
copy:function(a, b) {
b = b || a.getSelectionCells();
var c = a.getExportableCells(b);
return mxClipboard.insertCount = 1, mxClipboard.cells = a.cloneCells(c), c;
},
paste:function(a) {
if (null != mxClipboard.cells) {
var b = a.getImportableCells(mxClipboard.cells), c = mxClipboard.insertCount * mxClipboard.STEPSIZE, d = a.getDefaultParent(), b = a.importCells(b, c, c, d);
mxClipboard.insertCount++, a.setSelectionCells(b);
}
}
};

mxWindow.prototype = new mxEventSource(), mxWindow.prototype.constructor = mxWindow, 
mxWindow.prototype.closeImage = mxClient.imageBasePath + "/close.gif", mxWindow.prototype.minimizeImage = mxClient.imageBasePath + "/minimize.gif", 
mxWindow.prototype.normalizeImage = mxClient.imageBasePath + "/normalize.gif", mxWindow.prototype.maximizeImage = mxClient.imageBasePath + "/maximize.gif", 
mxWindow.prototype.resizeImage = mxClient.imageBasePath + "/resize.gif", mxWindow.prototype.visible = !1, 
mxWindow.prototype.content = !1, mxWindow.prototype.minimumSize = new mxRectangle(0, 0, 50, 40), 
mxWindow.prototype.title = !1, mxWindow.prototype.content = !1, mxWindow.prototype.destroyOnClose = !0, 
mxWindow.prototype.init = function(a, b, c, d, e) {
e = null != e ? e :"mxWindow", this.div = document.createElement("div"), this.div.className = e, 
this.div.style.left = a + "px", this.div.style.top = b + "px", this.table = document.createElement("table"), 
this.table.className = e, null != c && (mxClient.IS_IE || (this.div.style.width = c + "px"), 
this.table.style.width = c + "px"), null != d && (mxClient.IS_IE || (this.div.style.height = d + "px"), 
this.table.style.height = d + "px"), a = document.createElement("tbody"), b = document.createElement("tr"), 
this.title = document.createElement("td"), this.title.className = e + "Title", b.appendChild(this.title), 
a.appendChild(b), b = document.createElement("tr"), this.td = document.createElement("td"), 
this.td.className = e + "Pane", this.contentWrapper = document.createElement("div"), 
this.contentWrapper.className = e + "Pane", this.contentWrapper.style.width = "100%", 
this.contentWrapper.appendChild(this.content), (mxClient.IS_IE || "DIV" != this.content.nodeName.toUpperCase()) && (this.contentWrapper.style.height = "100%"), 
this.td.appendChild(this.contentWrapper), b.appendChild(this.td), a.appendChild(b), 
this.table.appendChild(a), this.div.appendChild(this.table), e = mxUtils.bind(this, function() {
this.activate();
}), mxEvent.addGestureListeners(this.title, e), mxEvent.addGestureListeners(this.table, e), 
this.hide();
}, mxWindow.prototype.setTitle = function(a) {
for (var b = this.title.firstChild; null != b; ) {
var c = b.nextSibling;
b.nodeType == mxConstants.NODETYPE_TEXT && b.parentNode.removeChild(b), b = c;
}
mxUtils.write(this.title, a || "");
}, mxWindow.prototype.setScrollable = function(a) {
0 > navigator.userAgent.indexOf("Presto/2.5") && (this.contentWrapper.style.overflow = a ? "auto" :"hidden");
}, mxWindow.prototype.activate = function() {
if (mxWindow.activeWindow != this) {
var a = mxUtils.getCurrentStyle(this.getElement()), a = null != a ? a.zIndex :3;
if (mxWindow.activeWindow) {
var b = mxWindow.activeWindow.getElement();
null != b && null != b.style && (b.style.zIndex = a);
}
b = mxWindow.activeWindow, this.getElement().style.zIndex = parseInt(a) + 1, mxWindow.activeWindow = this, 
this.fireEvent(new mxEventObject(mxEvent.ACTIVATE, "previousWindow", b));
}
}, mxWindow.prototype.getElement = function() {
return this.div;
}, mxWindow.prototype.fit = function() {
mxUtils.fit(this.div);
}, mxWindow.prototype.isResizable = function() {
return null != this.resize ? "none" != this.resize.style.display :!1;
}, mxWindow.prototype.setResizable = function(a) {
a ? null == this.resize ? (this.resize = document.createElement("img"), this.resize.style.position = "absolute", 
this.resize.style.bottom = "2px", this.resize.style.right = "2px", this.resize.setAttribute("src", mxClient.imageBasePath + "/resize.gif"), 
this.resize.style.cursor = "nw-resize", mxEvent.addGestureListeners(this.resize, mxUtils.bind(this, function(a) {
this.activate();
var c = mxEvent.getClientX(a), d = mxEvent.getClientY(a), e = this.div.offsetWidth, f = this.div.offsetHeight, g = mxUtils.bind(this, function(a) {
var b = mxEvent.getClientX(a) - c, g = mxEvent.getClientY(a) - d;
this.setSize(e + b, f + g), this.fireEvent(new mxEventObject(mxEvent.RESIZE, "event", a)), 
mxEvent.consume(a);
}), h = mxUtils.bind(this, function(a) {
mxEvent.removeGestureListeners(document, null, g, h), this.fireEvent(new mxEventObject(mxEvent.RESIZE_END, "event", a)), 
mxEvent.consume(a);
});
mxEvent.addGestureListeners(document, null, g, h), this.fireEvent(new mxEventObject(mxEvent.RESIZE_START, "event", a)), 
mxEvent.consume(a);
}), null, null), this.div.appendChild(this.resize), mxClient.IS_POINTER && (this.resize.style.msTouchAction = "none")) :this.resize.style.display = "inline" :null != this.resize && (this.resize.style.display = "none");
}, mxWindow.prototype.setSize = function(a, b) {
a = Math.max(this.minimumSize.width, a), b = Math.max(this.minimumSize.height, b), 
mxClient.IS_IE || (this.div.style.width = a + "px", this.div.style.height = b + "px"), 
this.table.style.width = a + "px", this.table.style.height = b + "px", mxClient.IS_IE || (this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - 2 + "px");
}, mxWindow.prototype.setMinimizable = function(a) {
this.minimize.style.display = a ? "" :"none";
}, mxWindow.prototype.getMinimumSize = function() {
return new mxRectangle(0, 0, 0, this.title.offsetHeight);
}, mxWindow.prototype.installMinimizeHandler = function() {
this.minimize = document.createElement("img"), this.minimize.setAttribute("src", this.minimizeImage), 
this.minimize.setAttribute("align", "right"), this.minimize.setAttribute("title", "Minimize"), 
this.minimize.style.cursor = "pointer", this.minimize.style.marginRight = "1px", 
this.minimize.style.display = "none", this.title.appendChild(this.minimize);
var a = !1, b = null, c = null, d = mxUtils.bind(this, function(d) {
if (this.activate(), a) a = !1, this.minimize.setAttribute("src", this.minimizeImage), 
this.minimize.setAttribute("title", "Minimize"), this.contentWrapper.style.display = "", 
this.maximize.style.display = b, mxClient.IS_IE || (this.div.style.height = c), 
this.table.style.height = c, null != this.resize && (this.resize.style.visibility = ""), 
this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", d)); else {
a = !0, this.minimize.setAttribute("src", this.normalizeImage), this.minimize.setAttribute("title", "Normalize"), 
this.contentWrapper.style.display = "none", b = this.maximize.style.display, this.maximize.style.display = "none", 
c = this.table.style.height;
var f = this.getMinimumSize();
0 < f.height && (mxClient.IS_IE || (this.div.style.height = f.height + "px"), this.table.style.height = f.height + "px"), 
0 < f.width && (mxClient.IS_IE || (this.div.style.width = f.width + "px"), this.table.style.width = f.width + "px"), 
null != this.resize && (this.resize.style.visibility = "hidden"), this.fireEvent(new mxEventObject(mxEvent.MINIMIZE, "event", d));
}
mxEvent.consume(d);
});
mxEvent.addGestureListeners(this.minimize, d);
}, mxWindow.prototype.setMaximizable = function(a) {
this.maximize.style.display = a ? "" :"none";
}, mxWindow.prototype.installMaximizeHandler = function() {
this.maximize = document.createElement("img"), this.maximize.setAttribute("src", this.maximizeImage), 
this.maximize.setAttribute("align", "right"), this.maximize.setAttribute("title", "Maximize"), 
this.maximize.style.cursor = "default", this.maximize.style.marginLeft = "1px", 
this.maximize.style.cursor = "pointer", this.maximize.style.display = "none", this.title.appendChild(this.maximize);
var a = !1, b = null, c = null, d = null, e = null, f = mxUtils.bind(this, function(f) {
if (this.activate(), "none" != this.maximize.style.display) {
if (a) a = !1, this.maximize.setAttribute("src", this.maximizeImage), this.maximize.setAttribute("title", "Maximize"), 
this.contentWrapper.style.display = "", this.minimize.style.visibility = "", this.div.style.left = b + "px", 
this.div.style.top = c + "px", mxClient.IS_IE || (this.div.style.height = d, this.div.style.width = e, 
h = mxUtils.getCurrentStyle(this.contentWrapper), "auto" != h.overflow && null == this.resize) || (this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - 2 + "px"), 
this.table.style.height = d, this.table.style.width = e, null != this.resize && (this.resize.style.visibility = ""), 
this.fireEvent(new mxEventObject(mxEvent.NORMALIZE, "event", f)); else {
if (a = !0, this.maximize.setAttribute("src", this.normalizeImage), this.maximize.setAttribute("title", "Normalize"), 
this.contentWrapper.style.display = "", this.minimize.style.visibility = "hidden", 
b = parseInt(this.div.style.left), c = parseInt(this.div.style.top), d = this.table.style.height, 
e = this.table.style.width, this.div.style.left = "0px", this.div.style.top = "0px", 
mxClient.IS_IE || (this.div.style.height = document.body.clientHeight - 2 + "px", 
this.div.style.width = document.body.clientWidth - 2 + "px"), this.table.style.width = document.body.clientWidth - 2 + "px", 
this.table.style.height = document.body.clientHeight - 2 + "px", null != this.resize && (this.resize.style.visibility = "hidden"), 
!mxClient.IS_IE) {
var h = mxUtils.getCurrentStyle(this.contentWrapper);
("auto" == h.overflow || null != this.resize) && (this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - 2 + "px");
}
this.fireEvent(new mxEventObject(mxEvent.MAXIMIZE, "event", f));
}
mxEvent.consume(f);
}
});
mxEvent.addGestureListeners(this.maximize, f), mxEvent.addListener(this.title, "dblclick", f);
}, mxWindow.prototype.installMoveHandler = function() {
this.title.style.cursor = "move", mxEvent.addGestureListeners(this.title, mxUtils.bind(this, function(a) {
var b = mxEvent.getClientX(a), c = mxEvent.getClientY(a), d = this.getX(), e = this.getY(), f = mxUtils.bind(this, function(a) {
var f = mxEvent.getClientX(a) - b, g = mxEvent.getClientY(a) - c;
this.setLocation(d + f, e + g), this.fireEvent(new mxEventObject(mxEvent.MOVE, "event", a)), 
mxEvent.consume(a);
}), g = mxUtils.bind(this, function(a) {
mxEvent.removeGestureListeners(document, null, f, g), this.fireEvent(new mxEventObject(mxEvent.MOVE_END, "event", a)), 
mxEvent.consume(a);
});
mxEvent.addGestureListeners(document, null, f, g), this.fireEvent(new mxEventObject(mxEvent.MOVE_START, "event", a)), 
mxEvent.consume(a);
})), mxClient.IS_POINTER && (this.title.style.msTouchAction = "none");
}, mxWindow.prototype.setLocation = function(a, b) {
this.div.style.left = a + "px", this.div.style.top = b + "px";
}, mxWindow.prototype.getX = function() {
return parseInt(this.div.style.left);
}, mxWindow.prototype.getY = function() {
return parseInt(this.div.style.top);
}, mxWindow.prototype.installCloseHandler = function() {
this.closeImg = document.createElement("img"), this.closeImg.setAttribute("src", this.closeImage), 
this.closeImg.setAttribute("align", "right"), this.closeImg.setAttribute("title", "Close"), 
this.closeImg.style.marginLeft = "2px", this.closeImg.style.cursor = "pointer", 
this.closeImg.style.display = "none", this.title.insertBefore(this.closeImg, this.title.firstChild), 
mxEvent.addGestureListeners(this.closeImg, mxUtils.bind(this, function(a) {
this.fireEvent(new mxEventObject(mxEvent.CLOSE, "event", a)), this.destroyOnClose ? this.destroy() :this.setVisible(!1), 
mxEvent.consume(a);
}));
}, mxWindow.prototype.setImage = function(a) {
this.image = document.createElement("img"), this.image.setAttribute("src", a), this.image.setAttribute("align", "left"), 
this.image.style.marginRight = "4px", this.image.style.marginLeft = "0px", this.image.style.marginTop = "-2px", 
this.title.insertBefore(this.image, this.title.firstChild);
}, mxWindow.prototype.setClosable = function(a) {
this.closeImg.style.display = a ? "" :"none";
}, mxWindow.prototype.isVisible = function() {
return null != this.div ? "hidden" != this.div.style.visibility :!1;
}, mxWindow.prototype.setVisible = function(a) {
null != this.div && this.isVisible() != a && (a ? this.show() :this.hide());
}, mxWindow.prototype.show = function() {
this.div.style.visibility = "", this.activate();
var a = mxUtils.getCurrentStyle(this.contentWrapper);
mxClient.IS_IE || "auto" != a.overflow && null == this.resize || (this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - 2 + "px"), 
this.fireEvent(new mxEventObject(mxEvent.SHOW));
}, mxWindow.prototype.hide = function() {
this.div.style.visibility = "hidden", this.fireEvent(new mxEventObject(mxEvent.HIDE));
}, mxWindow.prototype.destroy = function() {
this.fireEvent(new mxEventObject(mxEvent.DESTROY)), null != this.div && (mxEvent.release(this.div), 
this.div.parentNode.removeChild(this.div), this.div = null), this.contentWrapper = this.content = this.title = null;
}, mxForm.prototype.table = null, mxForm.prototype.body = !1, mxForm.prototype.getTable = function() {
return this.table;
}, mxForm.prototype.addButtons = function(a, b) {
var c = document.createElement("tr"), d = document.createElement("td");
c.appendChild(d);
var d = document.createElement("td"), e = document.createElement("button");
mxUtils.write(e, mxResources.get("ok") || "OK"), d.appendChild(e), mxEvent.addListener(e, "click", function() {
a();
}), e = document.createElement("button"), mxUtils.write(e, mxResources.get("cancel") || "Cancel"), 
d.appendChild(e), mxEvent.addListener(e, "click", function() {
b();
}), c.appendChild(d), this.body.appendChild(c);
}, mxForm.prototype.addText = function(a, b) {
var c = document.createElement("input");
return c.setAttribute("type", "text"), c.value = b, this.addField(a, c);
}, mxForm.prototype.addCheckbox = function(a, b) {
var c = document.createElement("input");
return c.setAttribute("type", "checkbox"), this.addField(a, c), b && (c.checked = !0), 
c;
}, mxForm.prototype.addTextarea = function(a, b, c) {
var d = document.createElement("textarea");
return mxClient.IS_NS && c--, d.setAttribute("rows", c || 2), d.value = b, this.addField(a, d);
}, mxForm.prototype.addCombo = function(a, b, c) {
var d = document.createElement("select");
return null != c && d.setAttribute("size", c), b && d.setAttribute("multiple", "true"), 
this.addField(a, d);
}, mxForm.prototype.addOption = function(a, b, c, d) {
var e = document.createElement("option");
mxUtils.writeln(e, b), e.setAttribute("value", c), d && e.setAttribute("selected", d), 
a.appendChild(e);
}, mxForm.prototype.addField = function(a, b) {
var c = document.createElement("tr"), d = document.createElement("td");
return mxUtils.write(d, a), c.appendChild(d), d = document.createElement("td"), 
d.appendChild(b), c.appendChild(d), this.body.appendChild(c), b;
}, mxImage.prototype.src = null, mxImage.prototype.width = null, mxImage.prototype.height = null, 
mxDivResizer.prototype.resizeWidth = !0, mxDivResizer.prototype.resizeHeight = !0, 
mxDivResizer.prototype.handlingResize = !1, mxDivResizer.prototype.resize = function() {
var a = this.getDocumentWidth(), b = this.getDocumentHeight(), c = parseInt(this.div.style.left), d = parseInt(this.div.style.right), e = parseInt(this.div.style.top), f = parseInt(this.div.style.bottom);
this.resizeWidth && !isNaN(c) && !isNaN(d) && c >= 0 && d >= 0 && a - d - c > 0 && (this.div.style.width = a - d - c + "px"), 
this.resizeHeight && !isNaN(e) && !isNaN(f) && e >= 0 && f >= 0 && b - e - f > 0 && (this.div.style.height = b - e - f + "px");
}, mxDivResizer.prototype.getDocumentWidth = function() {
return document.body.clientWidth;
}, mxDivResizer.prototype.getDocumentHeight = function() {
return document.body.clientHeight;
}, mxDragSource.prototype.element = null, mxDragSource.prototype.dropHandler = null, 
mxDragSource.prototype.dragOffset = null, mxDragSource.prototype.dragElement = null, 
mxDragSource.prototype.previewElement = null, mxDragSource.prototype.enabled = !0, 
mxDragSource.prototype.currentGraph = null, mxDragSource.prototype.currentDropTarget = null, 
mxDragSource.prototype.currentPoint = null, mxDragSource.prototype.currentGuide = null, 
mxDragSource.prototype.currentHighlight = null, mxDragSource.prototype.autoscroll = !0, 
mxDragSource.prototype.guidesEnabled = !0, mxDragSource.prototype.gridEnabled = !0, 
mxDragSource.prototype.highlightDropTargets = !0, mxDragSource.prototype.dragElementZIndex = 100, 
mxDragSource.prototype.dragElementOpacity = 70, mxDragSource.prototype.isEnabled = function() {
return this.enabled;
}, mxDragSource.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxDragSource.prototype.isGuidesEnabled = function() {
return this.guidesEnabled;
}, mxDragSource.prototype.setGuidesEnabled = function(a) {
this.guidesEnabled = a;
}, mxDragSource.prototype.isGridEnabled = function() {
return this.gridEnabled;
}, mxDragSource.prototype.setGridEnabled = function(a) {
this.gridEnabled = a;
}, mxDragSource.prototype.getGraphForEvent = function() {
return null;
}, mxDragSource.prototype.getDropTarget = function(a, b, c) {
return a.getCellAt(b, c);
}, mxDragSource.prototype.createDragElement = function() {
return this.element.cloneNode(!0);
}, mxDragSource.prototype.createPreviewElement = function() {
return null;
}, mxDragSource.prototype.mouseDown = function(a) {
this.enabled && !mxEvent.isConsumed(a) && null == this.mouseMoveHandler && (this.startDrag(a), 
this.mouseMoveHandler = mxUtils.bind(this, this.mouseMove), this.mouseUpHandler = mxUtils.bind(this, this.mouseUp), 
mxEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler), 
mxEvent.consume(a, !0, !1));
}, mxDragSource.prototype.startDrag = function(a) {
this.dragElement = this.createDragElement(a), this.dragElement.style.position = "absolute", 
this.dragElement.style.zIndex = this.dragElementZIndex, mxUtils.setOpacity(this.dragElement, this.dragElementOpacity);
}, mxDragSource.prototype.stopDrag = function() {
null != this.dragElement && (null != this.dragElement.parentNode && this.dragElement.parentNode.removeChild(this.dragElement), 
this.dragElement = null);
}, mxDragSource.prototype.graphContainsEvent = function(a, b) {
var c = mxEvent.getClientX(b), d = mxEvent.getClientY(b), e = mxUtils.getOffset(a.container), f = mxUtils.getScrollOrigin();
return c >= e.x - f.x && d >= e.y - f.y && c <= e.x - f.x + a.container.offsetWidth && d <= e.y - f.y + a.container.offsetHeight;
}, mxDragSource.prototype.mouseMove = function(a) {
var b = this.getGraphForEvent(a);
if (null != b && !this.graphContainsEvent(b, a) && (b = null), b != this.currentGraph && (null != this.currentGraph && this.dragExit(this.currentGraph), 
this.currentGraph = b, null != this.currentGraph && this.dragEnter(this.currentGraph)), 
null != this.currentGraph && this.dragOver(this.currentGraph, a), null == this.dragElement || null != this.previewElement && "visible" == this.previewElement.style.visibility) null != this.dragElement && (this.dragElement.style.visibility = "hidden"); else {
var b = mxEvent.getClientX(a), c = mxEvent.getClientY(a);
null == this.dragElement.parentNode && document.body.appendChild(this.dragElement), 
this.dragElement.style.visibility = "visible", null != this.dragOffset && (b += this.dragOffset.x, 
c += this.dragOffset.y), b += document.body.scrollLeft || document.documentElement.scrollLeft, 
c += document.body.scrollTop || document.documentElement.scrollTop, this.dragElement.style.left = b + "px", 
this.dragElement.style.top = c + "px";
}
mxEvent.consume(a);
}, mxDragSource.prototype.mouseUp = function(a) {
if (null != this.currentGraph) {
if (null != this.currentPoint && (null == this.previewElement || "hidden" != this.previewElement.style.visibility)) {
var b = this.currentGraph.view.scale, c = this.currentGraph.view.translate;
this.drop(this.currentGraph, a, this.currentDropTarget, this.currentPoint.x / b - c.x, this.currentPoint.y / b - c.y);
}
this.dragExit(this.currentGraph);
}
this.stopDrag(a), mxEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler), 
this.currentGraph = this.mouseUpHandler = this.mouseMoveHandler = null, mxEvent.consume(a);
}, mxDragSource.prototype.dragEnter = function(a) {
a.isMouseDown = !0, this.previewElement = this.createPreviewElement(a), this.isGuidesEnabled() && null != this.previewElement && (this.currentGuide = new mxGuide(a, a.graphHandler.getGuideStates())), 
this.highlightDropTargets && (this.currentHighlight = new mxCellHighlight(a, mxConstants.DROP_TARGET_COLOR));
}, mxDragSource.prototype.dragExit = function(a) {
this.currentPoint = this.currentDropTarget = null, a.isMouseDown = !1, null != this.previewElement && (null != this.previewElement.parentNode && this.previewElement.parentNode.removeChild(this.previewElement), 
this.previewElement = null), null != this.currentGuide && (this.currentGuide.destroy(), 
this.currentGuide = null), null != this.currentHighlight && (this.currentHighlight.destroy(), 
this.currentHighlight = null);
}, mxDragSource.prototype.dragOver = function(a, b) {
var c = mxUtils.getOffset(a.container), d = mxUtils.getScrollOrigin(a.container), e = mxEvent.getClientX(b) - c.x + d.x, c = mxEvent.getClientY(b) - c.y + d.y;
if (a.autoScroll && (null == this.autoscroll || this.autoscroll) && a.scrollPointToVisible(e, c, a.autoExtend), 
null != this.currentHighlight && a.isDropEnabled() && (this.currentDropTarget = this.getDropTarget(a, e, c), 
d = a.getView().getState(this.currentDropTarget), this.currentHighlight.highlight(d)), 
null != this.previewElement) {
null == this.previewElement.parentNode && (a.container.appendChild(this.previewElement), 
this.previewElement.style.zIndex = "3", this.previewElement.style.position = "absolute");
var d = this.isGridEnabled() && a.isGridEnabledEvent(b), f = !0;
if (null != this.currentGuide && this.currentGuide.isEnabledForEvent(b)) var f = parseInt(this.previewElement.style.width), g = parseInt(this.previewElement.style.height), f = new mxRectangle(0, 0, f, g), c = new mxPoint(e, c), c = this.currentGuide.move(f, c, d), f = !1, e = c.x, c = c.y; else if (d) var d = a.view.scale, g = a.view.translate, h = a.gridSize / 2, e = (a.snap(e / d - g.x - h) + g.x) * d, c = (a.snap(c / d - g.y - h) + g.y) * d;
null != this.currentGuide && f && this.currentGuide.hide(), null != this.previewOffset && (e += this.previewOffset.x, 
c += this.previewOffset.y), this.previewElement.style.left = Math.round(e) + "px", 
this.previewElement.style.top = Math.round(c) + "px", this.previewElement.style.visibility = "visible";
}
this.currentPoint = new mxPoint(e, c);
}, mxDragSource.prototype.drop = function(a, b, c, d, e) {
this.dropHandler(a, b, c, d, e), a.container.focus();
}, mxToolbar.prototype = new mxEventSource(), mxToolbar.prototype.constructor = mxToolbar, 
mxToolbar.prototype.container = null, mxToolbar.prototype.enabled = !0, mxToolbar.prototype.noReset = !1, 
mxToolbar.prototype.updateDefaultMode = !0, mxToolbar.prototype.addItem = function(a, b, c, d, e, f) {
var g = document.createElement(null != b ? "img" :"button"), h = e || (null != f ? "mxToolbarMode" :"mxToolbarItem");
return g.className = h, g.setAttribute("src", b), null != a && (null != b ? g.setAttribute("title", a) :mxUtils.write(g, a)), 
this.container.appendChild(g), null != c && (mxEvent.addListener(g, "click", c), 
mxClient.IS_TOUCH && mxEvent.addListener(g, "touchend", c)), a = mxUtils.bind(this, function() {
null != d ? g.setAttribute("src", b) :g.style.backgroundColor = "";
}), mxEvent.addGestureListeners(g, mxUtils.bind(this, function(a) {
if (null != d ? g.setAttribute("src", d) :g.style.backgroundColor = "gray", null != f) {
null == this.menu && (this.menu = new mxPopupMenu(), this.menu.init());
var b = this.currentImg;
this.menu.isMenuShowing() && this.menu.hideMenu(), b != g && (this.currentImg = g, 
this.menu.factoryMethod = f, b = new mxPoint(g.offsetLeft, g.offsetTop + g.offsetHeight), 
this.menu.popup(b.x, b.y, null, a), this.menu.isMenuShowing() && (g.className = h + "Selected", 
this.menu.hideMenu = function() {
mxPopupMenu.prototype.hideMenu.apply(this), g.className = h, this.currentImg = null;
}));
}
}), null, a), mxEvent.addListener(g, "mouseout", a), g;
}, mxToolbar.prototype.addCombo = function(a) {
var b = document.createElement("div");
b.style.display = "inline", b.className = "mxToolbarComboContainer";
var c = document.createElement("select");
return c.className = a || "mxToolbarCombo", b.appendChild(c), this.container.appendChild(b), 
c;
}, mxToolbar.prototype.addActionCombo = function(a, b) {
var c = document.createElement("select");
return c.className = b || "mxToolbarCombo", this.addOption(c, a, null), mxEvent.addListener(c, "change", function(a) {
var b = c.options[c.selectedIndex];
c.selectedIndex = 0, null != b.funct && b.funct(a);
}), this.container.appendChild(c), c;
}, mxToolbar.prototype.addOption = function(a, b, c) {
var d = document.createElement("option");
return mxUtils.writeln(d, b), "function" == typeof c ? d.funct = c :d.setAttribute("value", c), 
a.appendChild(d), d;
}, mxToolbar.prototype.addSwitchMode = function(a, b, c, d, e) {
var f = document.createElement("img");
return f.initialClassName = e || "mxToolbarMode", f.className = f.initialClassName, 
f.setAttribute("src", b), f.altIcon = d, null != a && f.setAttribute("title", a), 
mxEvent.addListener(f, "click", mxUtils.bind(this, function(a) {
a = this.selectedMode.altIcon, null != a ? (this.selectedMode.altIcon = this.selectedMode.getAttribute("src"), 
this.selectedMode.setAttribute("src", a)) :this.selectedMode.className = this.selectedMode.initialClassName, 
this.updateDefaultMode && (this.defaultMode = f), this.selectedMode = f, a = f.altIcon, 
null != a ? (f.altIcon = f.getAttribute("src"), f.setAttribute("src", a)) :f.className = f.initialClassName + "Selected", 
this.fireEvent(new mxEventObject(mxEvent.SELECT)), c();
})), this.container.appendChild(f), null == this.defaultMode && (this.defaultMode = f, 
this.selectMode(f), c()), f;
}, mxToolbar.prototype.addMode = function(a, b, c, d, e, f) {
f = null != f ? f :!0;
var g = document.createElement(null != b ? "img" :"button");
return g.initialClassName = e || "mxToolbarMode", g.className = g.initialClassName, 
g.setAttribute("src", b), g.altIcon = d, null != a && g.setAttribute("title", a), 
this.enabled && f && (mxEvent.addListener(g, "click", mxUtils.bind(this, function() {
this.selectMode(g, c), this.noReset = !1;
})), mxEvent.addListener(g, "dblclick", mxUtils.bind(this, function() {
this.selectMode(g, c), this.noReset = !0;
})), null == this.defaultMode && (this.defaultMode = g, this.defaultFunction = c, 
this.selectMode(g, c))), this.container.appendChild(g), g;
}, mxToolbar.prototype.selectMode = function(a, b) {
if (this.selectedMode != a) {
if (null != this.selectedMode) {
var c = this.selectedMode.altIcon;
null != c ? (this.selectedMode.altIcon = this.selectedMode.getAttribute("src"), 
this.selectedMode.setAttribute("src", c)) :this.selectedMode.className = this.selectedMode.initialClassName;
}
this.selectedMode = a, c = this.selectedMode.altIcon, null != c ? (this.selectedMode.altIcon = this.selectedMode.getAttribute("src"), 
this.selectedMode.setAttribute("src", c)) :this.selectedMode.className = this.selectedMode.initialClassName + "Selected", 
this.fireEvent(new mxEventObject(mxEvent.SELECT, "function", b));
}
}, mxToolbar.prototype.resetMode = function(a) {
(a || !this.noReset) && this.selectedMode != this.defaultMode && this.selectMode(this.defaultMode, this.defaultFunction);
}, mxToolbar.prototype.addSeparator = function(a) {
return this.addItem(null, a, null);
}, mxToolbar.prototype.addBreak = function() {
mxUtils.br(this.container);
}, mxToolbar.prototype.addLine = function() {
var a = document.createElement("hr");
a.style.marginRight = "6px", a.setAttribute("size", "1"), this.container.appendChild(a);
}, mxToolbar.prototype.destroy = function() {
mxEvent.release(this.container), this.selectedMode = this.defaultFunction = this.defaultMode = this.container = null, 
null != this.menu && this.menu.destroy();
}, mxSession.prototype = new mxEventSource(), mxSession.prototype.constructor = mxSession, 
mxSession.prototype.model = null, mxSession.prototype.urlInit = null, mxSession.prototype.urlPoll = null, 
mxSession.prototype.urlNotify = null, mxSession.prototype.codec = null, mxSession.prototype.linefeed = "&#xa;", 
mxSession.prototype.escapePostData = !0, mxSession.prototype.significantRemoteChanges = !0, 
mxSession.prototype.sent = 0, mxSession.prototype.received = 0, mxSession.prototype.debug = !1, 
mxSession.prototype.connected = !1, mxSession.prototype.suspended = !1, mxSession.prototype.polling = !1, 
mxSession.prototype.start = function() {
this.debug ? (this.connected = !0, this.fireEvent(new mxEventObject(mxEvent.CONNECT))) :this.connected || this.get(this.urlInit, mxUtils.bind(this, function() {
this.connected = !0, this.fireEvent(new mxEventObject(mxEvent.CONNECT)), this.poll();
}));
}, mxSession.prototype.suspend = function() {
this.connected && !this.suspended && (this.suspended = !0, this.fireEvent(new mxEventObject(mxEvent.SUSPEND)));
}, mxSession.prototype.resume = function() {
this.connected && this.suspended && (this.suspended = !1, this.fireEvent(new mxEventObject(mxEvent.RESUME)), 
this.polling || this.poll());
}, mxSession.prototype.stop = function(a) {
this.connected && (this.connected = !1), this.fireEvent(new mxEventObject(mxEvent.DISCONNECT, "reason", a));
}, mxSession.prototype.poll = function() {
this.connected && !this.suspended && null != this.urlPoll ? (this.polling = !0, 
this.get(this.urlPoll, mxUtils.bind(this, function() {
this.poll();
}))) :this.polling = !1;
}, mxSession.prototype.notify = function(a, b, c) {
null != a && 0 < a.length && (null != this.urlNotify && (this.debug ? (mxLog.show(), 
mxLog.debug("mxSession.notify: " + this.urlNotify + " xml=" + a)) :(a = "<message><delta>" + a + "</delta></message>", 
this.escapePostData && (a = encodeURIComponent(a)), mxUtils.post(this.urlNotify, "xml=" + a, b, c))), 
this.sent += a.length, this.fireEvent(new mxEventObject(mxEvent.NOTIFY, "url", this.urlNotify, "xml", a)));
}, mxSession.prototype.get = function(a, b, c) {
if ("undefined" != typeof mxUtils) {
var d = mxUtils.bind(this, function(a) {
null != c ? c(a) :this.stop(a);
});
mxUtils.get(a, mxUtils.bind(this, function(c) {
if ("undefined" != typeof mxUtils) if (c.isReady() && 404 != c.getStatus()) {
if (this.received += c.getText().length, this.fireEvent(new mxEventObject(mxEvent.GET, "url", a, "request", c)), 
this.isValidResponse(c)) {
if (0 < c.getText().length) {
var f = c.getDocumentElement();
null == f ? d("Invalid response: " + c.getText()) :this.receive(f);
}
null != b && b(c);
}
} else d("Response not ready");
}), function() {
d("Transmission error");
});
}
}, mxSession.prototype.isValidResponse = function(a) {
return 0 > a.getText().indexOf("<?php");
}, mxSession.prototype.encodeChanges = function(a, b) {
for (var c = "", d = b ? -1 :1, e = b ? a.length - 1 :0; e >= 0 && e < a.length; e += d) var f = this.codec.encode(a[e]), c = c + mxUtils.getXml(f, this.linefeed);
return c;
}, mxSession.prototype.receive = function(a) {
if (null != a && a.nodeType == mxConstants.NODETYPE_ELEMENT) {
var b = a.getAttribute("namespace");
for (null != b && (this.model.prefix = b + "-"), b = a.firstChild; null != b; ) {
var c = b.nodeName.toLowerCase();
"state" == c ? this.processState(b) :"delta" == c && this.processDelta(b), b = b.nextSibling;
}
this.fireEvent(new mxEventObject(mxEvent.RECEIVE, "node", a));
}
}, mxSession.prototype.processState = function(a) {
new mxCodec(a.ownerDocument).decode(a.firstChild, this.model);
}, mxSession.prototype.processDelta = function(a) {
for (a = a.firstChild; null != a; ) "edit" == a.nodeName && this.processEdit(a), 
a = a.nextSibling;
}, mxSession.prototype.processEdit = function(a) {
if (a = this.decodeChanges(a), 0 < a.length) {
var b = this.createUndoableEdit(a);
this.model.fireEvent(new mxEventObject(mxEvent.CHANGE, "edit", b, "changes", a)), 
this.model.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", b)), this.fireEvent(new mxEventObject(mxEvent.FIRED, "edit", b));
}
}, mxSession.prototype.createUndoableEdit = function(a) {
var b = new mxUndoableEdit(this.model, this.significantRemoteChanges);
return b.changes = a, b.notify = function() {
b.source.fireEvent(new mxEventObject(mxEvent.CHANGE, "edit", b, "changes", b.changes)), 
b.source.fireEvent(new mxEventObject(mxEvent.NOTIFY, "edit", b, "changes", b.changes));
}, b;
}, mxSession.prototype.decodeChanges = function(a) {
this.codec.document = a.ownerDocument;
var b = [];
for (a = a.firstChild; null != a; ) {
var c = this.decodeChange(a);
null != c && b.push(c), a = a.nextSibling;
}
return b;
}, mxSession.prototype.decodeChange = function(a) {
var b = null;
return a.nodeType == mxConstants.NODETYPE_ELEMENT && (b = "mxRootChange" == a.nodeName ? new mxCodec(a.ownerDocument).decode(a) :this.codec.decode(a), 
null != b && (b.model = this.model, b.execute(), "mxChildChange" == a.nodeName && null == b.parent && this.cellRemoved(b.child))), 
b;
}, mxSession.prototype.cellRemoved = function(a) {
this.codec.putObject(a.getId(), a);
for (var c = this.model.getChildCount(a), d = 0; c > d; d++) this.cellRemoved(this.model.getChildAt(a, d));
}, mxUndoableEdit.prototype.source = null, mxUndoableEdit.prototype.changes = null, 
mxUndoableEdit.prototype.significant = null, mxUndoableEdit.prototype.undone = !1, 
mxUndoableEdit.prototype.redone = !1, mxUndoableEdit.prototype.isEmpty = function() {
return 0 == this.changes.length;
}, mxUndoableEdit.prototype.isSignificant = function() {
return this.significant;
}, mxUndoableEdit.prototype.add = function(a) {
this.changes.push(a);
}, mxUndoableEdit.prototype.notify = function() {}, mxUndoableEdit.prototype.die = function() {}, 
mxUndoableEdit.prototype.undo = function() {
if (!this.undone) {
this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
for (var a = this.changes.length - 1; a >= 0; a--) {
var b = this.changes[a];
null != b.execute ? b.execute() :null != b.undo && b.undo(), this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", b));
}
this.undone = !0, this.redone = !1, this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
}
this.notify();
}, mxUndoableEdit.prototype.redo = function() {
if (!this.redone) {
this.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));
for (var a = this.changes.length, b = 0; a > b; b++) {
var c = this.changes[b];
null != c.execute ? c.execute() :null != c.redo && c.redo(), this.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", c));
}
this.undone = !1, this.redone = !0, this.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));
}
this.notify();
}, mxUndoManager.prototype = new mxEventSource(), mxUndoManager.prototype.constructor = mxUndoManager, 
mxUndoManager.prototype.size = null, mxUndoManager.prototype.history = null, mxUndoManager.prototype.indexOfNextAdd = 0, 
mxUndoManager.prototype.isEmpty = function() {
return 0 == this.history.length;
}, mxUndoManager.prototype.clear = function() {
this.history = [], this.indexOfNextAdd = 0, this.fireEvent(new mxEventObject(mxEvent.CLEAR));
}, mxUndoManager.prototype.canUndo = function() {
return 0 < this.indexOfNextAdd;
}, mxUndoManager.prototype.undo = function() {
for (;0 < this.indexOfNextAdd; ) {
var a = this.history[--this.indexOfNextAdd];
if (a.undo(), a.isSignificant()) {
this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", a));
break;
}
}
}, mxUndoManager.prototype.canRedo = function() {
return this.indexOfNextAdd < this.history.length;
}, mxUndoManager.prototype.redo = function() {
for (var a = this.history.length; this.indexOfNextAdd < a; ) {
var b = this.history[this.indexOfNextAdd++];
if (b.redo(), b.isSignificant()) {
this.fireEvent(new mxEventObject(mxEvent.REDO, "edit", b));
break;
}
}
}, mxUndoManager.prototype.undoableEditHappened = function(a) {
this.trim(), 0 < this.size && this.size == this.history.length && this.history.shift(), 
this.history.push(a), this.indexOfNextAdd = this.history.length, this.fireEvent(new mxEventObject(mxEvent.ADD, "edit", a));
}, mxUndoManager.prototype.trim = function() {
if (this.history.length > this.indexOfNextAdd) for (var a = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd), b = 0; b < a.length; b++) a[b].die();
};

var mxUrlConverter = function() {
var b = !0, c = null, d = null;
return {
isEnabled:function() {
return b;
},
setEnabled:function(a) {
b = a;
},
getBaseUrl:function() {
return c;
},
setBaseUrl:function(a) {
c = a;
},
getBaseDomain:function() {
return c;
},
setBaseDomain:function(a) {
c = a;
},
isRelativeUrl:function(a) {
return "http://" != a.substring(0, 7) && "https://" != a.substring(0, 8) && "data:image" != a.substring(0, 10);
},
convert:function(a) {
if (b && this.isRelativeUrl(a)) {
if (null == c) {
d = location.protocol + "//" + location.host, c = d + location.pathname;
var f = c.lastIndexOf("/");
f > 0 && (c = c.substring(0, f + 1));
}
a = "/" == a.charAt(0) ? d + a :c + a;
}
return a;
}
};
};

mxPanningManager.prototype.damper = 1 / 6, mxPanningManager.prototype.delay = 10, 
mxPanningManager.prototype.handleMouseOut = !0, mxPanningManager.prototype.border = 0, 
mxPopupMenu.prototype = new mxEventSource(), mxPopupMenu.prototype.constructor = mxPopupMenu, 
mxPopupMenu.prototype.submenuImage = mxClient.imageBasePath + "/submenu.gif", mxPopupMenu.prototype.zIndex = 10006, 
mxPopupMenu.prototype.factoryMethod = null, mxPopupMenu.prototype.useLeftButtonForPopup = !1, 
mxPopupMenu.prototype.enabled = !0, mxPopupMenu.prototype.itemCount = 0, mxPopupMenu.prototype.autoExpand = !1, 
mxPopupMenu.prototype.smartSeparators = !1, mxPopupMenu.prototype.labels = !0, mxPopupMenu.prototype.init = function() {
this.table = document.createElement("table"), this.table.className = "mxPopupMenu", 
this.tbody = document.createElement("tbody"), this.table.appendChild(this.tbody), 
this.div = document.createElement("div"), this.div.className = "mxPopupMenu", this.div.style.display = "inline", 
this.div.style.zIndex = this.zIndex, this.div.appendChild(this.table), mxEvent.disableContextMenu(this.div);
}, mxPopupMenu.prototype.isEnabled = function() {
return this.enabled;
}, mxPopupMenu.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxPopupMenu.prototype.isPopupTrigger = function(a) {
return a.isPopupTrigger() || this.useLeftButtonForPopup && mxEvent.isLeftMouseButton(a.getEvent());
}, mxPopupMenu.prototype.addItem = function(a, b, c, d, e, f) {
d = d || this, this.itemCount++, d.willAddSeparator && (d.containsItems && this.addSeparator(d, !0), 
d.willAddSeparator = !1), d.containsItems = !0;
var g = document.createElement("tr");
g.className = "mxPopupMenuItem";
var h = document.createElement("td");
return h.className = "mxPopupMenuIcon", null != b ? (e = document.createElement("img"), 
e.src = b, h.appendChild(e)) :null != e && (b = document.createElement("div"), b.className = e, 
h.appendChild(b)), g.appendChild(h), this.labels && (h = document.createElement("td"), 
h.className = "mxPopupMenuItem" + (null == f || f ? "" :" disabled"), mxUtils.write(h, a), 
h.align = "left", g.appendChild(h), a = document.createElement("td"), a.className = "mxPopupMenuItem" + (null == f || f ? "" :" disabled"), 
a.style.paddingRight = "6px", a.style.textAlign = "right", g.appendChild(a), null == d.div && this.createSubmenu(d)), 
d.tbody.appendChild(g), (null == f || f) && (mxEvent.addGestureListeners(g, mxUtils.bind(this, function(a) {
this.eventReceiver = g, d.activeRow != g && d.activeRow != d && (null != d.activeRow && null != d.activeRow.div.parentNode && this.hideSubmenu(d), 
null != g.div && (this.showSubmenu(d, g), d.activeRow = g)), mxEvent.consume(a);
}), mxUtils.bind(this, function() {
d.activeRow != g && d.activeRow != d && (null != d.activeRow && null != d.activeRow.div.parentNode && this.hideSubmenu(d), 
this.autoExpand && null != g.div && (this.showSubmenu(d, g), d.activeRow = g)), 
g.className = "mxPopupMenuItemHover";
}), mxUtils.bind(this, function(a) {
this.eventReceiver == g && (d.activeRow != g && this.hideMenu(), null != c && c(a)), 
this.eventReceiver = null, mxEvent.consume(a);
})), mxEvent.addListener(g, "mouseout", mxUtils.bind(this, function() {
g.className = "mxPopupMenuItem";
}))), g;
}, mxPopupMenu.prototype.createSubmenu = function(a) {
a.table = document.createElement("table"), a.table.className = "mxPopupMenu", a.tbody = document.createElement("tbody"), 
a.table.appendChild(a.tbody), a.div = document.createElement("div"), a.div.className = "mxPopupMenu", 
a.div.style.position = "absolute", a.div.style.display = "inline", a.div.style.zIndex = this.zIndex, 
a.div.appendChild(a.table);
var b = document.createElement("img");
b.setAttribute("src", this.submenuImage), td = a.firstChild.nextSibling.nextSibling, 
td.appendChild(b);
}, mxPopupMenu.prototype.showSubmenu = function(a, b) {
if (null != b.div) {
b.div.style.left = a.div.offsetLeft + b.offsetLeft + b.offsetWidth - 1 + "px", b.div.style.top = a.div.offsetTop + b.offsetTop + "px", 
document.body.appendChild(b.div);
var c = parseInt(b.div.offsetLeft), d = parseInt(b.div.offsetWidth), e = document.body, f = document.documentElement;
c + d > (e.scrollLeft || f.scrollLeft) + (e.clientWidth || f.clientWidth) && (b.div.style.left = a.div.offsetLeft - d + (mxClient.IS_IE ? 6 :-6) + "px"), 
mxUtils.fit(b.div);
}
}, mxPopupMenu.prototype.addSeparator = function(a, b) {
if (a = a || this, this.smartSeparators && !b) a.willAddSeparator = !0; else if (null != a.tbody) {
a.willAddSeparator = !1;
var c = document.createElement("tr"), d = document.createElement("td");
d.className = "mxPopupMenuIcon", d.style.padding = "0 0 0 0px", c.appendChild(d), 
d = document.createElement("td"), d.style.padding = "0 0 0 0px", d.setAttribute("colSpan", "2");
var e = document.createElement("hr");
e.setAttribute("size", "1"), d.appendChild(e), c.appendChild(d), a.tbody.appendChild(c);
}
}, mxPopupMenu.prototype.popup = function(a, b, c, d) {
if (null != this.div && null != this.tbody && null != this.factoryMethod) {
for (this.div.style.left = a + "px", this.div.style.top = b + "px"; null != this.tbody.firstChild; ) mxEvent.release(this.tbody.firstChild), 
this.tbody.removeChild(this.tbody.firstChild);
this.itemCount = 0, this.factoryMethod(this, c, d), 0 < this.itemCount && (this.showMenu(), 
this.fireEvent(new mxEventObject(mxEvent.SHOW)));
}
}, mxPopupMenu.prototype.isMenuShowing = function() {
return null != this.div && this.div.parentNode == document.body;
}, mxPopupMenu.prototype.showMenu = function() {
9 <= document.documentMode && (this.div.style.filter = "none"), document.body.appendChild(this.div), 
mxUtils.fit(this.div);
}, mxPopupMenu.prototype.hideMenu = function() {
null != this.div && (null != this.div.parentNode && this.div.parentNode.removeChild(this.div), 
this.hideSubmenu(this), this.containsItems = !1);
}, mxPopupMenu.prototype.hideSubmenu = function(a) {
null != a.activeRow && (this.hideSubmenu(a.activeRow), null != a.activeRow.div.parentNode && a.activeRow.div.parentNode.removeChild(a.activeRow.div), 
a.activeRow = null);
}, mxPopupMenu.prototype.destroy = function() {
null != this.div && (mxEvent.release(this.div), null != this.div.parentNode && this.div.parentNode.removeChild(this.div), 
this.div = null);
}, mxAutoSaveManager.prototype = new mxEventSource(), mxAutoSaveManager.prototype.constructor = mxAutoSaveManager, 
mxAutoSaveManager.prototype.graph = null, mxAutoSaveManager.prototype.autoSaveDelay = 10, 
mxAutoSaveManager.prototype.autoSaveThrottle = 2, mxAutoSaveManager.prototype.autoSaveThreshold = 5, 
mxAutoSaveManager.prototype.ignoredChanges = 0, mxAutoSaveManager.prototype.lastSnapshot = 0, 
mxAutoSaveManager.prototype.enabled = !0, mxAutoSaveManager.prototype.changeHandler = null, 
mxAutoSaveManager.prototype.isEnabled = function() {
return this.enabled;
}, mxAutoSaveManager.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxAutoSaveManager.prototype.setGraph = function(a) {
null != this.graph && this.graph.getModel().removeListener(this.changeHandler), 
this.graph = a, null != this.graph && this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
}, mxAutoSaveManager.prototype.save = function() {}, mxAutoSaveManager.prototype.graphModelChanged = function(a) {
a = (new Date().getTime() - this.lastSnapshot) / 1e3, a > this.autoSaveDelay || this.ignoredChanges >= this.autoSaveThreshold && a > this.autoSaveThrottle ? (this.save(), 
this.reset()) :this.ignoredChanges++;
}, mxAutoSaveManager.prototype.reset = function() {
this.lastSnapshot = new Date().getTime(), this.ignoredChanges = 0;
}, mxAutoSaveManager.prototype.destroy = function() {
this.setGraph(null);
}, mxAnimation.prototype = new mxEventSource(), mxAnimation.prototype.constructor = mxAnimation, 
mxAnimation.prototype.delay = null, mxAnimation.prototype.thread = null, mxAnimation.prototype.startAnimation = function() {
null == this.thread && (this.thread = window.setInterval(mxUtils.bind(this, this.updateAnimation), this.delay));
}, mxAnimation.prototype.updateAnimation = function() {
this.fireEvent(new mxEventObject(mxEvent.EXECUTE));
}, mxAnimation.prototype.stopAnimation = function() {
null != this.thread && (window.clearInterval(this.thread), this.thread = null, this.fireEvent(new mxEventObject(mxEvent.DONE)));
}, mxMorphing.prototype = new mxAnimation(), mxMorphing.prototype.constructor = mxMorphing, 
mxMorphing.prototype.graph = null, mxMorphing.prototype.steps = null, mxMorphing.prototype.step = 0, 
mxMorphing.prototype.ease = null, mxMorphing.prototype.cells = null, mxMorphing.prototype.updateAnimation = function() {
var a = new mxCellStatePreview(this.graph);
if (null != this.cells) for (var b = 0; b < this.cells.length; b++) this.animateCell(cells[b], a, !1); else this.animateCell(this.graph.getModel().getRoot(), a, !0);
this.show(a), (a.isEmpty() || this.step++ >= this.steps) && this.stopAnimation();
}, mxMorphing.prototype.show = function(a) {
a.show();
}, mxMorphing.prototype.animateCell = function(a, b, c) {
var d = this.graph.getView().getState(a), e = null;
if (null != d && (e = this.getDelta(d), this.graph.getModel().isVertex(a) && (0 != e.x || 0 != e.y))) {
var f = this.graph.view.getTranslate(), g = this.graph.view.getScale();
e.x += f.x * g, e.y += f.y * g, b.moveState(d, -e.x / this.ease, -e.y / this.ease);
}
if (c && !this.stopRecursion(d, e)) for (d = this.graph.getModel().getChildCount(a), 
e = 0; d > e; e++) this.animateCell(this.graph.getModel().getChildAt(a, e), b, c);
}, mxMorphing.prototype.stopRecursion = function(a, b) {
return null != b && (0 != b.x || 0 != b.y);
}, mxMorphing.prototype.getDelta = function(a) {
var b = this.getOriginForCell(a.cell), c = this.graph.getView().getTranslate(), d = this.graph.getView().getScale();
return a = new mxPoint(a.x / d - c.x, a.y / d - c.y), new mxPoint((b.x - a.x) * d, (b.y - a.y) * d);
}, mxMorphing.prototype.getOriginForCell = function(a) {
var b = null;
return null != a && (b = this.getOriginForCell(this.graph.getModel().getParent(a)), 
a = this.graph.getCellGeometry(a), null != a && (b.x += a.x, b.y += a.y)), null == b && (b = this.graph.view.getTranslate(), 
b = new mxPoint(-b.x, -b.y)), b;
}, mxImageBundle.prototype.images = null, mxImageBundle.prototype.images = null, 
mxImageBundle.prototype.putImage = function(a, b, c) {
this.images[a] = {
value:b,
fallback:c
};
}, mxImageBundle.prototype.getImage = function(a) {
var b = null;
return null != a && (a = this.images[a], null != a && (b = this.alt ? a.fallback :a.value)), 
b;
}, mxImageExport.prototype.includeOverlays = !1, mxImageExport.prototype.drawState = function(a, b) {
null != a && (this.visitStatesRecursive(a, b, this.drawCellState), this.includeOverlays && this.visitStatesRecursive(a, b, this.drawOverlays));
}, mxImageExport.prototype.visitStatesRecursive = function(a, b, c) {
if (null != a) {
c(a, b);
for (var d = a.view.graph, e = d.model.getChildCount(a.cell), f = 0; e > f; f++) {
var g = d.view.getState(d.model.getChildAt(a.cell, f));
this.visitStatesRecursive(g, b, c);
}
}
}, mxImageExport.prototype.drawCellState = function(a, b) {
a.shape instanceof mxShape && (b.save(), a.shape.paint(b), b.restore()), null != a.text && (b.save(), 
a.text.paint(b), b.restore());
}, mxImageExport.prototype.drawOverlays = function(a, b) {
null != a.overlays && a.overlays.visit(function(a, d) {
d instanceof mxShape && d.paint(b);
});
}, mxAbstractCanvas2D.prototype.state = null, mxAbstractCanvas2D.prototype.states = null, 
mxAbstractCanvas2D.prototype.path = null, mxAbstractCanvas2D.prototype.rotateHtml = !0, 
mxAbstractCanvas2D.prototype.lastX = 0, mxAbstractCanvas2D.prototype.lastY = 0, 
mxAbstractCanvas2D.prototype.moveOp = "M", mxAbstractCanvas2D.prototype.lineOp = "L", 
mxAbstractCanvas2D.prototype.quadOp = "Q", mxAbstractCanvas2D.prototype.curveOp = "C", 
mxAbstractCanvas2D.prototype.closeOp = "Z", mxAbstractCanvas2D.prototype.pointerEvents = !1, 
mxAbstractCanvas2D.prototype.createUrlConverter = function() {
return new mxUrlConverter();
}, mxAbstractCanvas2D.prototype.reset = function() {
this.state = this.createState(), this.states = [];
}, mxAbstractCanvas2D.prototype.createState = function() {
return {
dx:0,
dy:0,
scale:1,
alpha:1,
fillColor:null,
fillAlpha:1,
gradientColor:null,
gradientAlpha:1,
gradientDirection:null,
strokeColor:null,
strokeWidth:1,
dashed:!1,
dashPattern:"3 3",
lineCap:"flat",
lineJoin:"miter",
miterLimit:10,
fontColor:"#000000",
fontBackgroundColor:null,
fontBorderColor:null,
fontSize:mxConstants.DEFAULT_FONTSIZE,
fontFamily:mxConstants.DEFAULT_FONTFAMILY,
fontStyle:0,
shadow:!1,
shadowColor:mxConstants.SHADOWCOLOR,
shadowAlpha:mxConstants.SHADOW_OPACITY,
shadowDx:mxConstants.SHADOW_OFFSET_X,
shadowDy:mxConstants.SHADOW_OFFSET_Y,
rotation:0,
rotationCx:0,
rotationCy:0
};
}, mxAbstractCanvas2D.prototype.format = function(a) {
return Math.round(parseFloat(a));
}, mxAbstractCanvas2D.prototype.addOp = function() {
if (null != this.path && (this.path.push(arguments[0]), 2 < arguments.length)) for (var a = this.state, b = 2; b < arguments.length; b += 2) this.lastX = arguments[b - 1], 
this.lastY = arguments[b], this.path.push(this.format((this.lastX + a.dx) * a.scale)), 
this.path.push(this.format((this.lastY + a.dy) * a.scale));
}, mxAbstractCanvas2D.prototype.rotatePoint = function(a, b, c, d, e) {
return c *= Math.PI / 180, mxUtils.getRotatedPoint(new mxPoint(a, b), Math.cos(c), Math.sin(c), new mxPoint(d, e));
}, mxAbstractCanvas2D.prototype.save = function() {
this.states.push(this.state), this.state = mxUtils.clone(this.state);
}, mxAbstractCanvas2D.prototype.restore = function() {
this.state = this.states.pop();
}, mxAbstractCanvas2D.prototype.scale = function(a) {
this.state.scale *= a, this.state.strokeWidth *= a;
}, mxAbstractCanvas2D.prototype.translate = function(a, b) {
this.state.dx += a, this.state.dy += b;
}, mxAbstractCanvas2D.prototype.setAlpha = function(a) {
this.state.alpha = a;
}, mxAbstractCanvas2D.prototype.setFillColor = function(a) {
a == mxConstants.NONE && (a = null), this.state.fillColor = a, this.state.gradientColor = null;
}, mxAbstractCanvas2D.prototype.setGradient = function(a, b, c, d, e, f, g, h, k) {
c = this.state, c.fillColor = a, c.fillAlpha = null != h ? h :1, c.gradientColor = b, 
c.gradientAlpha = null != k ? k :1, c.gradientDirection = g;
}, mxAbstractCanvas2D.prototype.setStrokeColor = function(a) {
a == mxConstants.NONE && (a = null), this.state.strokeColor = a;
}, mxAbstractCanvas2D.prototype.setStrokeWidth = function(a) {
this.state.strokeWidth = a;
}, mxAbstractCanvas2D.prototype.setDashed = function(a) {
this.state.dashed = a;
}, mxAbstractCanvas2D.prototype.setDashPattern = function(a) {
this.state.dashPattern = a;
}, mxAbstractCanvas2D.prototype.setLineCap = function(a) {
this.state.lineCap = a;
}, mxAbstractCanvas2D.prototype.setLineJoin = function(a) {
this.state.lineJoin = a;
}, mxAbstractCanvas2D.prototype.setMiterLimit = function(a) {
this.state.miterLimit = a;
}, mxAbstractCanvas2D.prototype.setFontColor = function(a) {
a == mxConstants.NONE && (a = null), this.state.fontColor = a;
}, mxAbstractCanvas2D.prototype.setFontBackgroundColor = function(a) {
a == mxConstants.NONE && (a = null), this.state.fontBackgroundColor = a;
}, mxAbstractCanvas2D.prototype.setFontBorderColor = function(a) {
a == mxConstants.NONE && (a = null), this.state.fontBorderColor = a;
}, mxAbstractCanvas2D.prototype.setFontSize = function(a) {
this.state.fontSize = a;
}, mxAbstractCanvas2D.prototype.setFontFamily = function(a) {
this.state.fontFamily = a;
}, mxAbstractCanvas2D.prototype.setFontStyle = function(a) {
null == a && (a = 0), this.state.fontStyle = a;
}, mxAbstractCanvas2D.prototype.setShadow = function(a) {
this.state.shadow = a;
}, mxAbstractCanvas2D.prototype.setShadowColor = function(a) {
a == mxConstants.NONE && (a = null), this.state.shadowColor = a;
}, mxAbstractCanvas2D.prototype.setShadowAlpha = function(a) {
this.state.shadowAlpha = a;
}, mxAbstractCanvas2D.prototype.setShadowOffset = function(a, b) {
this.state.shadowDx = a, this.state.shadowDy = b;
}, mxAbstractCanvas2D.prototype.begin = function() {
this.lastY = this.lastX = 0, this.path = [];
}, mxAbstractCanvas2D.prototype.moveTo = function(a, b) {
this.addOp(this.moveOp, a, b);
}, mxAbstractCanvas2D.prototype.lineTo = function(a, b) {
this.addOp(this.lineOp, a, b);
}, mxAbstractCanvas2D.prototype.quadTo = function(a, b, c, d) {
this.addOp(this.quadOp, a, b, c, d);
}, mxAbstractCanvas2D.prototype.curveTo = function(a, b, c, d, e, f) {
this.addOp(this.curveOp, a, b, c, d, e, f);
}, mxAbstractCanvas2D.prototype.arcTo = function(a, b, c, d, e, f, g) {
for (a = mxUtils.arcToCurves(this.lastX, this.lastY, a, b, c, d, e, f, g), b = 0; b < a.length; b += 6) this.curveTo(a[b], a[b + 1], a[b + 2], a[b + 3], a[b + 4], a[b + 5]);
}, mxAbstractCanvas2D.prototype.close = function() {
this.addOp(this.closeOp);
}, mxAbstractCanvas2D.prototype.end = function() {}, mxUtils.extend(mxXmlCanvas2D, mxAbstractCanvas2D), 
mxXmlCanvas2D.prototype.textEnabled = !0, mxXmlCanvas2D.prototype.compressed = !0, 
mxXmlCanvas2D.prototype.writeDefaults = function() {
var a;
a = this.createElement("fontfamily"), a.setAttribute("family", mxConstants.DEFAULT_FONTFAMILY), 
this.root.appendChild(a), a = this.createElement("fontsize"), a.setAttribute("size", mxConstants.DEFAULT_FONTSIZE), 
this.root.appendChild(a), a = this.createElement("shadowcolor"), a.setAttribute("color", mxConstants.SHADOWCOLOR), 
this.root.appendChild(a), a = this.createElement("shadowalpha"), a.setAttribute("alpha", mxConstants.SHADOW_OPACITY), 
this.root.appendChild(a), a = this.createElement("shadowoffset"), a.setAttribute("dx", mxConstants.SHADOW_OFFSET_X), 
a.setAttribute("dy", mxConstants.SHADOW_OFFSET_Y), this.root.appendChild(a);
}, mxXmlCanvas2D.prototype.format = function(a) {
return parseFloat(parseFloat(a).toFixed(2));
}, mxXmlCanvas2D.prototype.createElement = function(a) {
return this.root.ownerDocument.createElement(a);
}, mxXmlCanvas2D.prototype.save = function() {
this.compressed && mxAbstractCanvas2D.prototype.save.apply(this, arguments), this.root.appendChild(this.createElement("save"));
}, mxXmlCanvas2D.prototype.restore = function() {
this.compressed && mxAbstractCanvas2D.prototype.restore.apply(this, arguments), 
this.root.appendChild(this.createElement("restore"));
}, mxXmlCanvas2D.prototype.scale = function(a) {
if (this.compressed) {
if (this.state.scale == a) return;
mxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);
}
var b = this.createElement("scale");
b.setAttribute("scale", a), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.translate = function(a, b) {
var c = this.createElement("translate");
c.setAttribute("dx", this.format(a)), c.setAttribute("dy", this.format(b)), this.root.appendChild(c);
}, mxXmlCanvas2D.prototype.rotate = function(a, b, c, d, e) {
var f = this.createElement("rotate");
(0 != a || b || c) && (f.setAttribute("theta", this.format(a)), f.setAttribute("flipH", b ? "1" :"0"), 
f.setAttribute("flipV", c ? "1" :"0"), f.setAttribute("cx", this.format(d)), f.setAttribute("cy", this.format(e)), 
this.root.appendChild(f));
}, mxXmlCanvas2D.prototype.setAlpha = function(a) {
if (this.compressed) {
if (this.state.alpha == a) return;
mxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);
}
var b = this.createElement("alpha");
b.setAttribute("alpha", this.format(a)), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setFillColor = function(a) {
if (a == mxConstants.NONE && (a = null), this.compressed) {
if (this.state.fillColor == a) return;
mxAbstractCanvas2D.prototype.setFillColor.apply(this, arguments);
}
var b = this.createElement("fillcolor");
b.setAttribute("color", null != a ? a :mxConstants.NONE), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setGradient = function(a, b, c, d, e, f, g, h, k) {
if (null != a && null != b) {
mxAbstractCanvas2D.prototype.setGradient.apply(this, arguments);
var l = this.createElement("gradient");
l.setAttribute("c1", a), l.setAttribute("c2", b), l.setAttribute("x", this.format(c)), 
l.setAttribute("y", this.format(d)), l.setAttribute("w", this.format(e)), l.setAttribute("h", this.format(f)), 
null != g && l.setAttribute("direction", g), null != h && l.setAttribute("alpha1", h), 
null != k && l.setAttribute("alpha2", k), this.root.appendChild(l);
}
}, mxXmlCanvas2D.prototype.setStrokeColor = function(a) {
if (a == mxConstants.NONE && (a = null), this.compressed) {
if (this.state.strokeColor == a) return;
mxAbstractCanvas2D.prototype.setStrokeColor.apply(this, arguments);
}
var b = this.createElement("strokecolor");
b.setAttribute("color", null != a ? a :mxConstants.NONE), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setStrokeWidth = function(a) {
if (this.compressed) {
if (this.state.strokeWidth == a) return;
mxAbstractCanvas2D.prototype.setStrokeWidth.apply(this, arguments);
}
var b = this.createElement("strokewidth");
b.setAttribute("width", this.format(a)), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setDashed = function(a) {
if (this.compressed) {
if (this.state.dashed == a) return;
mxAbstractCanvas2D.prototype.setDashed.apply(this, arguments);
}
var b = this.createElement("dashed");
b.setAttribute("dashed", a ? "1" :"0"), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setDashPattern = function(a) {
if (this.compressed) {
if (this.state.dashPattern == a) return;
mxAbstractCanvas2D.prototype.setDashPattern.apply(this, arguments);
}
var b = this.createElement("dashpattern");
b.setAttribute("pattern", a), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setLineCap = function(a) {
if (this.compressed) {
if (this.state.lineCap == a) return;
mxAbstractCanvas2D.prototype.setLineCap.apply(this, arguments);
}
var b = this.createElement("linecap");
b.setAttribute("cap", a), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setLineJoin = function(a) {
if (this.compressed) {
if (this.state.lineJoin == a) return;
mxAbstractCanvas2D.prototype.setLineJoin.apply(this, arguments);
}
var b = this.createElement("linejoin");
b.setAttribute("join", a), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setMiterLimit = function(a) {
if (this.compressed) {
if (this.state.miterLimit == a) return;
mxAbstractCanvas2D.prototype.setMiterLimit.apply(this, arguments);
}
var b = this.createElement("miterlimit");
b.setAttribute("limit", a), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setFontColor = function(a) {
if (this.textEnabled) {
if (a == mxConstants.NONE && (a = null), this.compressed) {
if (this.state.fontColor == a) return;
mxAbstractCanvas2D.prototype.setFontColor.apply(this, arguments);
}
var b = this.createElement("fontcolor");
b.setAttribute("color", null != a ? a :mxConstants.NONE), this.root.appendChild(b);
}
}, mxXmlCanvas2D.prototype.setFontBackgroundColor = function(a) {
if (this.textEnabled) {
if (a == mxConstants.NONE && (a = null), this.compressed) {
if (this.state.fontBackgroundColor == a) return;
mxAbstractCanvas2D.prototype.setFontBackgroundColor.apply(this, arguments);
}
var b = this.createElement("fontbackgroundcolor");
b.setAttribute("color", null != a ? a :mxConstants.NONE), this.root.appendChild(b);
}
}, mxXmlCanvas2D.prototype.setFontBorderColor = function(a) {
if (this.textEnabled) {
if (a == mxConstants.NONE && (a = null), this.compressed) {
if (this.state.fontBorderColor == a) return;
mxAbstractCanvas2D.prototype.setFontBorderColor.apply(this, arguments);
}
var b = this.createElement("fontbordercolor");
b.setAttribute("color", null != a ? a :mxConstants.NONE), this.root.appendChild(b);
}
}, mxXmlCanvas2D.prototype.setFontSize = function(a) {
if (this.textEnabled) {
if (this.compressed) {
if (this.state.fontSize == a) return;
mxAbstractCanvas2D.prototype.setFontSize.apply(this, arguments);
}
var b = this.createElement("fontsize");
b.setAttribute("size", a), this.root.appendChild(b);
}
}, mxXmlCanvas2D.prototype.setFontFamily = function(a) {
if (this.textEnabled) {
if (this.compressed) {
if (this.state.fontFamily == a) return;
mxAbstractCanvas2D.prototype.setFontFamily.apply(this, arguments);
}
var b = this.createElement("fontfamily");
b.setAttribute("family", a), this.root.appendChild(b);
}
}, mxXmlCanvas2D.prototype.setFontStyle = function(a) {
if (this.textEnabled) {
if (null == a && (a = 0), this.compressed) {
if (this.state.fontStyle == a) return;
mxAbstractCanvas2D.prototype.setFontStyle.apply(this, arguments);
}
var b = this.createElement("fontstyle");
b.setAttribute("style", a), this.root.appendChild(b);
}
}, mxXmlCanvas2D.prototype.setShadow = function(a) {
if (this.compressed) {
if (this.state.shadow == a) return;
mxAbstractCanvas2D.prototype.setShadow.apply(this, arguments);
}
var b = this.createElement("shadow");
b.setAttribute("enabled", a ? "1" :"0"), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setShadowColor = function(a) {
if (this.compressed) {
if (a == mxConstants.NONE && (a = null), this.state.shadowColor == a) return;
mxAbstractCanvas2D.prototype.setShadowColor.apply(this, arguments);
}
var b = this.createElement("shadowcolor");
b.setAttribute("color", null != a ? a :mxConstants.NONE), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setShadowAlpha = function(a) {
if (this.compressed) {
if (this.state.shadowAlpha == a) return;
mxAbstractCanvas2D.prototype.setShadowAlpha.apply(this, arguments);
}
var b = this.createElement("shadowalpha");
b.setAttribute("alpha", a), this.root.appendChild(b);
}, mxXmlCanvas2D.prototype.setShadowOffset = function(a, b) {
if (this.compressed) {
if (this.state.shadowDx == a && this.state.shadowDy == b) return;
mxAbstractCanvas2D.prototype.setShadowOffset.apply(this, arguments);
}
var c = this.createElement("shadowoffset");
c.setAttribute("dx", a), c.setAttribute("dy", b), this.root.appendChild(c);
}, mxXmlCanvas2D.prototype.rect = function(a, b, c, d) {
var e = this.createElement("rect");
e.setAttribute("x", this.format(a)), e.setAttribute("y", this.format(b)), e.setAttribute("w", this.format(c)), 
e.setAttribute("h", this.format(d)), this.root.appendChild(e);
}, mxXmlCanvas2D.prototype.roundrect = function(a, b, c, d, e, f) {
var g = this.createElement("roundrect");
g.setAttribute("x", this.format(a)), g.setAttribute("y", this.format(b)), g.setAttribute("w", this.format(c)), 
g.setAttribute("h", this.format(d)), g.setAttribute("dx", this.format(e)), g.setAttribute("dy", this.format(f)), 
this.root.appendChild(g);
}, mxXmlCanvas2D.prototype.ellipse = function(a, b, c, d) {
var e = this.createElement("ellipse");
e.setAttribute("x", this.format(a)), e.setAttribute("y", this.format(b)), e.setAttribute("w", this.format(c)), 
e.setAttribute("h", this.format(d)), this.root.appendChild(e);
}, mxXmlCanvas2D.prototype.image = function(a, b, c, d, e, f, g, h) {
e = this.converter.convert(e);
var k = this.createElement("image");
k.setAttribute("x", this.format(a)), k.setAttribute("y", this.format(b)), k.setAttribute("w", this.format(c)), 
k.setAttribute("h", this.format(d)), k.setAttribute("src", e), k.setAttribute("aspect", f ? "1" :"0"), 
k.setAttribute("flipH", g ? "1" :"0"), k.setAttribute("flipV", h ? "1" :"0"), this.root.appendChild(k);
}, mxXmlCanvas2D.prototype.begin = function() {
this.root.appendChild(this.createElement("begin")), this.lastY = this.lastX = 0;
}, mxXmlCanvas2D.prototype.moveTo = function(a, b) {
var c = this.createElement("move");
c.setAttribute("x", this.format(a)), c.setAttribute("y", this.format(b)), this.root.appendChild(c), 
this.lastX = a, this.lastY = b;
}, mxXmlCanvas2D.prototype.lineTo = function(a, b) {
var c = this.createElement("line");
c.setAttribute("x", this.format(a)), c.setAttribute("y", this.format(b)), this.root.appendChild(c), 
this.lastX = a, this.lastY = b;
}, mxXmlCanvas2D.prototype.quadTo = function(a, b, c, d) {
var e = this.createElement("quad");
e.setAttribute("x1", this.format(a)), e.setAttribute("y1", this.format(b)), e.setAttribute("x2", this.format(c)), 
e.setAttribute("y2", this.format(d)), this.root.appendChild(e), this.lastX = c, 
this.lastY = d;
}, mxXmlCanvas2D.prototype.curveTo = function(a, b, c, d, e, f) {
var g = this.createElement("curve");
g.setAttribute("x1", this.format(a)), g.setAttribute("y1", this.format(b)), g.setAttribute("x2", this.format(c)), 
g.setAttribute("y2", this.format(d)), g.setAttribute("x3", this.format(e)), g.setAttribute("y3", this.format(f)), 
this.root.appendChild(g), this.lastX = e, this.lastY = f;
}, mxXmlCanvas2D.prototype.close = function() {
this.root.appendChild(this.createElement("close"));
}, mxXmlCanvas2D.prototype.text = function(a, b, c, d, e, f, g, h, k, l, m, n) {
if (this.textEnabled && null != e) {
mxUtils.isNode(e) && (e = mxUtils.getOuterHtml(e));
var p = this.createElement("text");
p.setAttribute("x", this.format(a)), p.setAttribute("y", this.format(b)), p.setAttribute("w", this.format(c)), 
p.setAttribute("h", this.format(d)), p.setAttribute("str", e), null != f && p.setAttribute("align", f), 
null != g && p.setAttribute("valign", g), p.setAttribute("wrap", h ? "1" :"0"), 
null == k && (k = ""), p.setAttribute("format", k), null != l && p.setAttribute("overflow", l), 
null != m && p.setAttribute("clip", m ? "1" :"0"), null != n && p.setAttribute("rotation", n), 
this.root.appendChild(p);
}
}, mxXmlCanvas2D.prototype.stroke = function() {
this.root.appendChild(this.createElement("stroke"));
}, mxXmlCanvas2D.prototype.fill = function() {
this.root.appendChild(this.createElement("fill"));
}, mxXmlCanvas2D.prototype.fillAndStroke = function() {
this.root.appendChild(this.createElement("fillstroke"));
}, mxUtils.extend(mxSvgCanvas2D, mxAbstractCanvas2D), mxSvgCanvas2D.prototype.node = null, 
mxSvgCanvas2D.prototype.matchHtmlAlignment = !0, mxSvgCanvas2D.prototype.textEnabled = !0, 
mxSvgCanvas2D.prototype.foEnabled = !0, mxSvgCanvas2D.prototype.foAltText = "[Object]", 
mxSvgCanvas2D.prototype.strokeTolerance = 0, mxSvgCanvas2D.prototype.refCount = 0, 
mxSvgCanvas2D.prototype.blockImagePointerEvents = !1, mxSvgCanvas2D.prototype.reset = function() {
mxAbstractCanvas2D.prototype.reset.apply(this, arguments), this.gradients = [];
}, mxSvgCanvas2D.prototype.createStyle = function(a) {
return a = this.createElement("style"), a.setAttribute("type", "text/css"), mxUtils.write(a, "svg{font-family:" + mxConstants.DEFAULT_FONTFAMILY + ";font-size:" + mxConstants.DEFAULT_FONTSIZE + ";fill:none;stroke-miterlimit:10}"), 
a;
}, mxSvgCanvas2D.prototype.createElement = function(a, b) {
if (null != this.root.ownerDocument.createElementNS) return this.root.ownerDocument.createElementNS(b || mxConstants.NS_SVG, a);
var c = this.root.ownerDocument.createElement(a);
return null != b && c.setAttribute("xmlns", b), c;
}, mxSvgCanvas2D.prototype.createAlternateContent = function(a, b, c, d, e) {
return null != this.foAltText ? (a = this.state, b = this.createElement("text"), 
b.setAttribute("x", Math.round(d / 2)), b.setAttribute("y", Math.round((e + a.fontSize) / 2)), 
b.setAttribute("fill", a.fontColor || "black"), b.setAttribute("text-anchor", "middle"), 
b.setAttribute("font-size", Math.round(a.fontSize) + "px"), b.setAttribute("font-family", a.fontFamily), 
(a.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && b.setAttribute("font-weight", "bold"), 
(a.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && b.setAttribute("font-style", "italic"), 
(a.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && b.setAttribute("text-decoration", "underline"), 
mxUtils.write(b, this.foAltText), b) :null;
}, mxSvgCanvas2D.prototype.createGradientId = function(a, b, c, d, e) {
return "#" == a.charAt(0) && (a = a.substring(1)), "#" == b.charAt(0) && (b = b.substring(1)), 
a = a.toLowerCase() + "-" + c, b = b.toLowerCase() + "-" + d, c = null, null == e || e == mxConstants.DIRECTION_SOUTH ? c = "s" :e == mxConstants.DIRECTION_EAST ? c = "e" :(d = a, 
a = b, b = d, e == mxConstants.DIRECTION_NORTH ? c = "s" :e == mxConstants.DIRECTION_WEST && (c = "e")), 
"mx-gradient-" + a + "-" + b + "-" + c;
}, mxSvgCanvas2D.prototype.getSvgGradient = function(a, b, c, d, e) {
var f = this.createGradientId(a, b, c, d, e), g = this.gradients[f];
if (null == g) {
var h = this.root.ownerSVGElement, k = 0, l = f + "-" + k;
if (null != h) for (g = h.ownerDocument.getElementById(l); null != g && g.ownerSVGElement != h; ) l = f + "-" + k++, 
g = h.ownerDocument.getElementById(l); else l = "id" + ++this.refCount;
null == g && (g = this.createSvgGradient(a, b, c, d, e), g.setAttribute("id", l), 
null != this.defs ? this.defs.appendChild(g) :h.appendChild(g)), this.gradients[f] = g;
}
return g.getAttribute("id");
}, mxSvgCanvas2D.prototype.createSvgGradient = function(a, b, c, d, e) {
var f = this.createElement("linearGradient");
return f.setAttribute("x1", "0%"), f.setAttribute("y1", "0%"), f.setAttribute("x2", "0%"), 
f.setAttribute("y2", "0%"), null == e || e == mxConstants.DIRECTION_SOUTH ? f.setAttribute("y2", "100%") :e == mxConstants.DIRECTION_EAST ? f.setAttribute("x2", "100%") :e == mxConstants.DIRECTION_NORTH ? f.setAttribute("y1", "100%") :e == mxConstants.DIRECTION_WEST && f.setAttribute("x1", "100%"), 
c = 1 > c ? ";stop-opacity:" + c :"", e = this.createElement("stop"), e.setAttribute("offset", "0%"), 
e.setAttribute("style", "stop-color:" + a + c), f.appendChild(e), c = 1 > d ? ";stop-opacity:" + d :"", 
e = this.createElement("stop"), e.setAttribute("offset", "100%"), e.setAttribute("style", "stop-color:" + b + c), 
f.appendChild(e), f;
}, mxSvgCanvas2D.prototype.addNode = function(a, b) {
var c = this.node, d = this.state;
if (null != c) {
if ("path" == c.nodeName) {
if (!(null != this.path && 0 < this.path.length)) return;
c.setAttribute("d", this.path.join(" "));
}
a && null != d.fillColor ? this.updateFill() :this.styleEnabled || ("ellipse" != c.nodeName || !mxClient.IS_NS || mxClient.IS_GC || mxClient.IS_SF ? c.setAttribute("fill", "none") :c.setAttribute("fill", "transparent"), 
a = !1), b && null != d.strokeColor ? this.updateStroke() :this.styleEnabled || c.setAttribute("stroke", "none"), 
null != d.transform && 0 < d.transform.length && c.setAttribute("transform", d.transform), 
d.shadow && this.root.appendChild(this.createShadow(c)), 0 < this.strokeTolerance && !a && this.root.appendChild(this.createTolerance(c)), 
this.pointerEvents && ("path" != c.nodeName || this.path[this.path.length - 1] == this.closeOp) && c.setAttribute("pointer-events", "all"), 
this.root.appendChild(c);
}
}, mxSvgCanvas2D.prototype.updateFill = function() {
var a = this.state;
1 > a.alpha && this.node.setAttribute("fill-opacity", a.alpha), null != a.fillColor && (null != a.gradientColor ? (a = this.getSvgGradient(a.fillColor, a.gradientColor, a.fillAlpha, a.gradientAlpha, a.gradientDirection), 
this.node.setAttribute("fill", "url(#" + a + ")")) :this.node.setAttribute("fill", a.fillColor.toLowerCase()));
}, mxSvgCanvas2D.prototype.updateStroke = function() {
var a = this.state;
this.node.setAttribute("stroke", a.strokeColor.toLowerCase()), 1 > a.alpha && this.node.setAttribute("stroke-opacity", a.alpha);
var b = Math.max(1, this.format(a.strokeWidth * a.scale));
1 != b && this.node.setAttribute("stroke-width", b), "path" == this.node.nodeName && this.updateStrokeAttributes(), 
a.dashed && this.node.setAttribute("stroke-dasharray", this.createDashPattern(b));
}, mxSvgCanvas2D.prototype.updateStrokeAttributes = function() {
var a = this.state;
if (null != a.lineJoin && "miter" != a.lineJoin && this.node.setAttribute("stroke-linejoin", a.lineJoin), 
null != a.lineCap) {
var b = a.lineCap;
"flat" == b && (b = "butt"), "butt" != b && this.node.setAttribute("stroke-linecap", b);
}
null != a.miterLimit && (!this.styleEnabled || 10 != a.miterLimit) && this.node.setAttribute("stroke-miterlimit", a.miterLimit);
}, mxSvgCanvas2D.prototype.createDashPattern = function(a) {
var b = this.state.dashPattern.split(" "), c = [];
if (0 < b.length) for (var d = 0; d < b.length; d++) c[d] = Number(b[d]) * a;
return c.join(" ");
}, mxSvgCanvas2D.prototype.createTolerance = function(a) {
a = a.cloneNode(!0);
var b = parseFloat(a.getAttribute("stroke-width") || 1) + this.strokeTolerance;
return a.setAttribute("pointer-events", "stroke"), a.setAttribute("visibility", "hidden"), 
a.removeAttribute("stroke-dasharray"), a.setAttribute("stroke-width", b), a.setAttribute("fill", "none"), 
a.setAttribute("stroke", mxClient.IS_OP ? "none" :"white"), a;
}, mxSvgCanvas2D.prototype.createShadow = function(a) {
a = a.cloneNode(!0);
var b = this.state;
return "none" != a.getAttribute("fill") && a.setAttribute("fill", b.shadowColor), 
"none" != a.getAttribute("stroke") && a.setAttribute("stroke", b.shadowColor), a.setAttribute("transform", "translate(" + this.format(b.shadowDx * b.scale) + "," + this.format(b.shadowDy * b.scale) + ")" + (b.transform || "")), 
a.setAttribute("opacity", b.shadowAlpha), a;
}, mxSvgCanvas2D.prototype.rotate = function(a, b, c, d, e) {
if (0 != a || b || c) {
var f = this.state;
if (d += f.dx, e += f.dy, d *= f.scale, e *= f.scale, f.transform = f.transform || "", 
b && c) a += 180; else if (b ^ c) {
var g = b ? d :0, h = b ? -1 :1, k = c ? e :0, l = c ? -1 :1;
f.transform += "translate(" + this.format(g) + "," + this.format(k) + ")scale(" + this.format(h) + "," + this.format(l) + ")translate(" + this.format(-g) + "," + this.format(-k) + ")";
}
(b ? !c :c) && (a *= -1), 0 != a && (f.transform += "rotate(" + this.format(a) + "," + this.format(d) + "," + this.format(e) + ")"), 
f.rotation += a, f.rotationCx = d, f.rotationCy = e;
}
}, mxSvgCanvas2D.prototype.begin = function() {
mxAbstractCanvas2D.prototype.begin.apply(this, arguments), this.node = this.createElement("path");
}, mxSvgCanvas2D.prototype.rect = function(a, b, c, d) {
var e = this.state, f = this.createElement("rect");
f.setAttribute("x", this.format((a + e.dx) * e.scale)), f.setAttribute("y", this.format((b + e.dy) * e.scale)), 
f.setAttribute("width", this.format(c * e.scale)), f.setAttribute("height", this.format(d * e.scale)), 
this.node = f;
}, mxSvgCanvas2D.prototype.roundrect = function(a, b, c, d, e, f) {
this.rect(a, b, c, d), e > 0 && this.node.setAttribute("rx", this.format(e * this.state.scale)), 
f > 0 && this.node.setAttribute("ry", this.format(f * this.state.scale));
}, mxSvgCanvas2D.prototype.ellipse = function(a, b, c, d) {
var e = this.state, f = this.createElement("ellipse");
f.setAttribute("cx", Math.round((a + c / 2 + e.dx) * e.scale)), f.setAttribute("cy", Math.round((b + d / 2 + e.dy) * e.scale)), 
f.setAttribute("rx", c / 2 * e.scale), f.setAttribute("ry", d / 2 * e.scale), this.node = f;
}, mxSvgCanvas2D.prototype.image = function(a, b, c, d, e, f, g, h) {
e = this.converter.convert(e), f = null != f ? f :!0, g = null != g ? g :!1, h = null != h ? h :!1;
var k = this.state;
a += k.dx, b += k.dy;
var l = this.createElement("image");
if (l.setAttribute("x", this.format(a * k.scale)), l.setAttribute("y", this.format(b * k.scale)), 
l.setAttribute("width", this.format(c * k.scale)), l.setAttribute("height", this.format(d * k.scale)), 
null == l.setAttributeNS || this.root.ownerDocument != document ? l.setAttribute("xlink:href", e) :l.setAttributeNS(mxConstants.NS_XLINK, "href", e), 
f || l.setAttribute("preserveAspectRatio", "none"), 1 > k.alpha && l.setAttribute("opacity", k.alpha), 
e = this.state.transform || "", g || h) {
var m = f = 1, n = 0, p = 0;
g && (f = -1, n = -c - 2 * a), h && (m = -1, p = -d - 2 * b), e += "scale(" + f + "," + m + ")translate(" + n + "," + p + ")";
}
0 < e.length && l.setAttribute("transform", e), this.root.appendChild(l), this.blockImagePointerEvents && (l.setAttribute("style", "pointer-events:none"), 
l = this.createElement("rect"), l.setAttribute("visibility", "hidden"), l.setAttribute("pointer-events", "fill"), 
l.setAttribute("x", this.format(a * k.scale)), l.setAttribute("y", this.format(b * k.scale)), 
l.setAttribute("width", this.format(c * k.scale)), l.setAttribute("height", this.format(d * k.scale)), 
this.root.appendChild(l));
}, mxSvgCanvas2D.prototype.createDiv = function(a, b, c, d, e) {
return c = this.state, d = "display:inline-block;font-size:" + Math.round(c.fontSize) + "px;font-family:" + c.fontFamily + ";color:" + c.fontColor + ";line-height:" + Math.round(c.fontSize * mxConstants.LINE_HEIGHT) + "px;" + d, 
(c.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && (d += "font-weight:bold;"), 
(c.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && (d += "font-style:italic;"), 
(c.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && (d += "text-decoration:underline;"), 
b == mxConstants.ALIGN_CENTER ? d += "text-align:center;" :b == mxConstants.ALIGN_RIGHT && (d += "text-align:right;"), 
b = "", null != c.fontBackgroundColor && (b += "background-color:" + c.fontBackgroundColor + ";"), 
null != c.fontBorderColor && (b += "border:1px solid " + c.fontBorderColor + ";"), 
mxUtils.isNode(a) || (c = document.createElement("textarea"), c.innerHTML = a.replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), 
a = c.value, "fill" != e && "width" != e ? 0 < b.length && (a = '<div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;' + b + '">' + a + "</div>") :d += b), 
!mxClient.IS_IE && document.createElementNS ? (e = document.createElementNS("http://www.w3.org/1999/xhtml", "div"), 
e.setAttribute("style", d), mxUtils.isNode(a) ? this.root.ownerDocument != document ? e.appendChild(a.cloneNode(!0)) :e.appendChild(a) :e.innerHTML = a, 
e) :(mxUtils.isNode(a) && this.root.ownerDocument != document && (a = a.outerHTML), 
a = a.replace(/<br>/g, "<br />").replace(/<hr>/g, "<hr />"), mxUtils.parseXml('<div xmlns="http://www.w3.org/1999/xhtml" style="' + d + '">' + a + "</div>").documentElement);
}, mxSvgCanvas2D.prototype.text = function(a, b, c, d, e, f, g, h, k, l, m, n) {
if (this.textEnabled && null != e) {
n = null != n ? n :0;
var p = this.state;
if (a += p.dx, b += p.dy, this.foEnabled && "html" == k) {
var q = "vertical-align:top;";
m ? (q += "overflow:hidden;", d > 0 && (q += "max-height:" + Math.round(d) + "px;"), 
c > 0 && (q += "width:" + Math.round(c) + "px;")) :"fill" == l ? (q += "width:" + Math.round(c) + "px;", 
q += "height:" + Math.round(d) + "px;") :"width" == l && (q += "width:" + Math.round(c) + "px;", 
d > 0 && (q += "max-height:" + Math.round(d) + "px;")), h && c > 0 ? (m || (q += "width:" + Math.round(c) + "px;"), 
q += "white-space:normal;") :q += "white-space:nowrap;";
var s = this.createElement("g");
1 > p.alpha && s.setAttribute("opacity", p.alpha);
var r = this.createElement("foreignObject");
if (r.setAttribute("pointer-events", "all"), q = this.createDiv(e, f, g, q, l), 
null != q) {
s.appendChild(r), this.root.appendChild(s);
var t = 0, u = 0;
if (mxClient.IS_IE && !mxClient.IS_SVG) {
var v = document.createElement("div");
v.style.cssText = q.getAttribute("style"), v.style.display = mxClient.IS_QUIRKS ? "inline" :"inline-block", 
v.style.visibility = "hidden", v.innerHTML = mxUtils.isNode(e) ? e.outerHTML :e, 
document.body.appendChild(v), t = v.offsetWidth, u = mxClient.IS_QUIRKS && d > 0 && m ? Math.min(d, v.offsetHeight + 2) :v.offsetHeight, 
v.parentNode.removeChild(v), r.appendChild(q);
} else this.root.ownerDocument != document || 0 <= navigator.userAgent.indexOf("Firefox/3.") ? (q.style.visibility = "hidden", 
document.body.appendChild(q), t = q.offsetWidth, u = q.offsetHeight, r.appendChild(q), 
q.style.visibility = "") :(r.appendChild(q), t = q.offsetWidth, u = q.offsetHeight);
"fill" == l ? (c = Math.max(c, t), d = Math.max(d, u)) :(c = "width" == l ? Math.max(c, t) :t, 
d = u), 1 > p.alpha && s.setAttribute("opacity", p.alpha), t = q = 0, f == mxConstants.ALIGN_CENTER ? q -= c / 2 :f == mxConstants.ALIGN_RIGHT && (q -= c), 
a += q, g == mxConstants.ALIGN_MIDDLE ? t -= d / 2 :g == mxConstants.ALIGN_BOTTOM && (t -= d), 
b += t, u = 1 != p.scale ? "scale(" + p.scale + ")" :"", 0 != p.rotation && this.rotateHtml ? (u += "rotate(" + p.rotation + "," + c / 2 + "," + d / 2 + ")", 
b = this.rotatePoint((a + c / 2) * p.scale, (b + d / 2) * p.scale, p.rotation, p.rotationCx, p.rotationCy), 
a = b.x - c * p.scale / 2, b = b.y - d * p.scale / 2) :(a *= p.scale, b *= p.scale), 
0 != n && (u += "rotate(" + n + "," + -q + "," + -t + ")"), s.setAttribute("transform", "translate(" + Math.round(a) + "," + Math.round(b) + ")" + u), 
r.setAttribute("width", Math.round(Math.max(1, c))), r.setAttribute("height", Math.round(Math.max(1, d))), 
this.root.ownerDocument != document && (a = this.createAlternateContent(r, a, b, c, d, e, f, g, h, k, l, m, n), 
null != a && (r.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility"), 
c = this.createElement("switch"), c.appendChild(r), c.appendChild(a), s.appendChild(c)));
}
} else this.plainText(a, b, c, d, e, f, g, h, l, m, n);
}
}, mxSvgCanvas2D.prototype.createClip = function(a, b, c, d) {
a = Math.round(a), b = Math.round(b), c = Math.round(c), d = Math.round(d);
for (var e = "mx-clip-" + a + "-" + b + "-" + c + "-" + d, f = 0, g = e + "-" + f; null != document.getElementById(g); ) g = e + "-" + ++f;
return clip = this.createElement("clipPath"), clip.setAttribute("id", g), e = this.createElement("rect"), 
e.setAttribute("x", a), e.setAttribute("y", b), e.setAttribute("width", c), e.setAttribute("height", d), 
clip.appendChild(e), clip;
}, mxSvgCanvas2D.prototype.plainText = function(a, b, c, d, e, f, g, h, k, l, m) {
m = null != m ? m :0, h = this.state;
var n = Math.round(h.fontSize), p = this.createElement("g"), q = h.transform || "";
if (0 != m && (q += "rotate(" + m + "," + this.format(a * h.scale) + "," + this.format(b * h.scale) + ")"), 
l && c > 0 && d > 0) {
var s = a;
m = b, f == mxConstants.ALIGN_CENTER ? s -= c / 2 :f == mxConstants.ALIGN_RIGHT && (s -= c), 
"fill" != k && (g == mxConstants.ALIGN_MIDDLE ? m -= d / 2 :g == mxConstants.ALIGN_BOTTOM && (m -= d)), 
m = this.createClip(s * h.scale - 2, m * h.scale - 2, c * h.scale + 4, d * h.scale + 4), 
null != this.defs ? this.defs.appendChild(m) :this.root.appendChild(m), p.setAttribute("clip-path", "url(#" + m.getAttribute("id") + ")");
}
this.updateFont(p, f), m = f == mxConstants.ALIGN_RIGHT ? "end" :f == mxConstants.ALIGN_CENTER ? "middle" :"start", 
"start" != m && p.setAttribute("text-anchor", m), (!this.styleEnabled || n != mxConstants.DEFAULT_FONTSIZE) && p.setAttribute("font-size", Math.round(n * h.scale) + "px"), 
0 < q.length && p.setAttribute("transform", q), 1 > h.alpha && p.setAttribute("opacity", h.alpha);
var q = e.split("\n"), s = Math.round(n * mxConstants.LINE_HEIGHT), r = n + (q.length - 1) * s;
for (m = b + n - 1, g == mxConstants.ALIGN_MIDDLE ? "fill" == k ? m -= d / 2 :(l = (this.matchHtmlAlignment && l && d > 0 ? Math.min(r, d) :r) / 2, 
m -= l + 1) :g == mxConstants.ALIGN_BOTTOM && ("fill" == k ? m -= d :(l = this.matchHtmlAlignment && l && d > 0 ? Math.min(r, d) :r, 
m -= l + 2)), l = 0; l < q.length; l++) 0 < q[l].length && 0 < mxUtils.trim(q[l]).length && (n = this.createElement("text"), 
n.setAttribute("x", this.format(a * h.scale)), n.setAttribute("y", this.format(m * h.scale)), 
mxUtils.write(n, q[l]), p.appendChild(n)), m += s;
this.root.appendChild(p), this.addTextBackground(p, e, a, b, c, "fill" == k ? d :r, f, g, k);
}, mxSvgCanvas2D.prototype.updateFont = function(a) {
var b = this.state;
a.setAttribute("fill", b.fontColor), (!this.styleEnabled || b.fontFamily != mxConstants.DEFAULT_FONTFAMILY) && a.setAttribute("font-family", b.fontFamily), 
(b.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && a.setAttribute("font-weight", "bold"), 
(b.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && a.setAttribute("font-style", "italic"), 
(b.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && a.setAttribute("text-decoration", "underline");
}, mxSvgCanvas2D.prototype.addTextBackground = function(a, b, c, d, e, f, g, h, k) {
var l = this.state;
if (null != l.fontBackgroundColor || null != l.fontBorderColor) {
var m = null;
"fill" == k || "width" == k ? (g == mxConstants.ALIGN_CENTER ? c -= e / 2 :g == mxConstants.ALIGN_RIGHT && (c -= e), 
h == mxConstants.ALIGN_MIDDLE ? d -= f / 2 :h == mxConstants.ALIGN_BOTTOM && (d -= f), 
m = new mxRectangle((c + 1) * l.scale, d * l.scale, (e - 2) * l.scale, (f + 2) * l.scale)) :null != a.getBBox && this.root.ownerDocument == document ? (m = a.getBBox(), 
b = mxClient.IS_IE && mxClient.IS_SVG, m = new mxRectangle(m.x, m.y + (b ? 0 :1), m.width, m.height + (b ? 1 :0))) :(m = document.createElement("div"), 
m.style.lineHeight = Math.round(l.fontSize * mxConstants.LINE_HEIGHT) + "px", m.style.fontSize = Math.round(l.fontSize) + "px", 
m.style.fontFamily = l.fontFamily, m.style.whiteSpace = "nowrap", m.style.position = "absolute", 
m.style.visibility = "hidden", m.style.display = mxClient.IS_QUIRKS ? "inline" :"inline-block", 
m.style.zoom = "1", (l.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && (m.style.fontWeight = "bold"), 
(l.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && (m.style.fontStyle = "italic"), 
b = mxUtils.htmlEntities(b, !1), m.innerHTML = b.replace(/\n/g, "<br/>"), document.body.appendChild(m), 
e = m.offsetWidth, f = m.offsetHeight, m.parentNode.removeChild(m), g == mxConstants.ALIGN_CENTER ? c -= e / 2 :g == mxConstants.ALIGN_RIGHT && (c -= e), 
h == mxConstants.ALIGN_MIDDLE ? d -= f / 2 :h == mxConstants.ALIGN_BOTTOM && (d -= f), 
m = new mxRectangle((c + 1) * l.scale, (d + 2) * l.scale, e * l.scale, (f + 1) * l.scale)), 
null != m && (b = this.createElement("rect"), b.setAttribute("fill", l.fontBackgroundColor || "none"), 
b.setAttribute("stroke", l.fontBorderColor || "none"), b.setAttribute("x", Math.floor(m.x - 1)), 
b.setAttribute("y", Math.floor(m.y - 1)), b.setAttribute("width", Math.ceil(m.width + 2)), 
b.setAttribute("height", Math.ceil(m.height)), l = null != l.fontBorderColor ? Math.max(1, this.format(l.scale)) :0, 
b.setAttribute("stroke-width", l), this.root.ownerDocument == document && 1 == mxUtils.mod(l, 2) && b.setAttribute("transform", "translate(0.5, 0.5)"), 
a.insertBefore(b, a.firstChild));
}
}, mxSvgCanvas2D.prototype.stroke = function() {
this.addNode(!1, !0);
}, mxSvgCanvas2D.prototype.fill = function() {
this.addNode(!0, !1);
}, mxSvgCanvas2D.prototype.fillAndStroke = function() {
this.addNode(!0, !0);
};

var mxVmlCanvas2D = function(a) {
mxAbstractCanvas2D.call(this), this.root = a;
};

mxUtils.extend(mxVmlCanvas2D, mxAbstractCanvas2D), mxVmlCanvas2D.prototype.node = null, 
mxVmlCanvas2D.prototype.textEnabled = !0, mxVmlCanvas2D.prototype.moveOp = "m", 
mxVmlCanvas2D.prototype.lineOp = "l", mxVmlCanvas2D.prototype.curveOp = "c", mxVmlCanvas2D.prototype.closeOp = "x", 
mxVmlCanvas2D.prototype.rotatedHtmlBackground = "", mxVmlCanvas2D.prototype.vmlScale = 1, 
mxVmlCanvas2D.prototype.addNode = function(a, b) {
var c = this.node, d = this.state;
if (null != c) {
if ("shape" == c.nodeName) {
if (!(null != this.path && 0 < this.path.length)) return;
c.path = this.path.join(" ") + " e", c.style.width = this.root.style.width, c.style.height = this.root.style.height, 
c.coordsize = parseInt(c.style.width) + " " + parseInt(c.style.height);
}
c.strokeweight = this.format(Math.max(1, d.strokeWidth * d.scale / this.vmlScale)) + "px", 
d.shadow && this.root.appendChild(this.createShadow(c, a && null != d.fillColor, b && null != d.strokeColor)), 
b && null != d.strokeColor ? (c.stroked = "true", c.strokecolor = d.strokeColor) :c.stroked = "false", 
c.appendChild(this.createStroke()), a && null != d.fillColor ? c.appendChild(this.createFill()) :!this.pointerEvents || "shape" == c.nodeName && this.path[this.path.length - 1] != this.closeOp ? c.filled = "false" :c.appendChild(this.createTransparentFill()), 
this.root.appendChild(c);
}
}, mxVmlCanvas2D.prototype.createTransparentFill = function() {
var a = document.createElement(mxClient.VML_PREFIX + ":fill");
return a.src = mxClient.imageBasePath + "/transparent.gif", a.type = "tile", a;
}, mxVmlCanvas2D.prototype.createFill = function() {
var a = this.state, b = document.createElement(mxClient.VML_PREFIX + ":fill");
if (b.color = a.fillColor, null != a.gradientColor) {
b.type = "gradient", b.method = "none", b.color2 = a.gradientColor;
var c = 180 - a.rotation, c = a.gradientDirection == mxConstants.DIRECTION_WEST ? c - (90 + ("x" == this.root.style.flip ? 180 :0)) :a.gradientDirection == mxConstants.DIRECTION_EAST ? c + (90 + ("x" == this.root.style.flip ? 180 :0)) :a.gradientDirection == mxConstants.DIRECTION_NORTH ? c - (180 + ("y" == this.root.style.flip ? -180 :0)) :c + ("y" == this.root.style.flip ? -180 :0);
("x" == this.root.style.flip || "y" == this.root.style.flip) && (c *= -1), b.angle = mxUtils.mod(c, 360), 
b.opacity = 100 * a.alpha * a.fillAlpha + "%", b.setAttribute(mxClient.OFFICE_PREFIX + ":opacity2", 100 * a.alpha * a.gradientAlpha + "%");
} else 1 > a.alpha && (b.opacity = 100 * a.alpha + "%");
return b;
}, mxVmlCanvas2D.prototype.createStroke = function() {
var a = this.state, b = document.createElement(mxClient.VML_PREFIX + ":stroke");
return b.endcap = a.lineCap || "flat", b.joinstyle = a.lineJoin || "miter", b.miterlimit = a.miterLimit || "10", 
1 > a.alpha && (b.opacity = 100 * a.alpha + "%"), a.dashed && (b.dashstyle = this.getVmlDashStyle()), 
b;
}, mxVmlCanvas2D.prototype.getVmlDashStyle = function() {
var a = "dash";
if (null != this.state.dashPattern) {
var b = this.state.dashPattern.split(" ");
0 < b.length && 1 == b[0] && (a = "0 2");
}
return a;
}, mxVmlCanvas2D.prototype.createShadow = function(a, b, c) {
var d = this.state, e = -d.rotation * (Math.PI / 180), f = Math.cos(e), e = Math.sin(e), g = d.shadowDx * d.scale, h = d.shadowDy * d.scale;
"x" == this.root.style.flip ? g *= -1 :"y" == this.root.style.flip && (h *= -1);
var k = a.cloneNode(!0);
return k.style.marginLeft = Math.round(g * f - h * e) + "px", k.style.marginTop = Math.round(g * e + h * f) + "px", 
8 == document.documentMode && (k.strokeweight = a.strokeweight, "shape" == a.nodeName && (k.path = this.path.join(" ") + " e", 
k.style.width = this.root.style.width, k.style.height = this.root.style.height, 
k.coordsize = parseInt(a.style.width) + " " + parseInt(a.style.height))), c ? (k.strokecolor = d.shadowColor, 
k.appendChild(this.createShadowStroke())) :k.stroked = "false", b ? k.appendChild(this.createShadowFill()) :k.filled = "false", 
k;
}, mxVmlCanvas2D.prototype.createShadowFill = function() {
var a = document.createElement(mxClient.VML_PREFIX + ":fill");
return a.color = this.state.shadowColor, a.opacity = 100 * this.state.alpha * this.state.shadowAlpha + "%", 
a;
}, mxVmlCanvas2D.prototype.createShadowStroke = function() {
var a = this.createStroke();
return a.opacity = 100 * this.state.alpha * this.state.shadowAlpha + "%", a;
}, mxVmlCanvas2D.prototype.rotate = function(a, b, c, d, e) {
b && c ? a += 180 :b ? this.root.style.flip = "x" :c && (this.root.style.flip = "y"), 
(b ? !c :c) && (a *= -1), this.root.style.rotation = a, this.state.rotation += a, 
this.state.rotationCx = d, this.state.rotationCy = e;
}, mxVmlCanvas2D.prototype.begin = function() {
mxAbstractCanvas2D.prototype.begin.apply(this, arguments), this.node = document.createElement(mxClient.VML_PREFIX + ":shape"), 
this.node.style.position = "absolute";
}, mxVmlCanvas2D.prototype.quadTo = function(a, b, c, d) {
var e = this.state, f = (this.lastX + e.dx) * e.scale, g = (this.lastY + e.dy) * e.scale;
a = (a + e.dx) * e.scale, b = (b + e.dy) * e.scale, c = (c + e.dx) * e.scale, d = (d + e.dy) * e.scale;
var g = g + 2 / 3 * (b - g), h = c + 2 / 3 * (a - c);
b = d + 2 / 3 * (b - d), this.path.push("c " + this.format(f + 2 / 3 * (a - f)) + " " + this.format(g) + " " + this.format(h) + " " + this.format(b) + " " + this.format(c) + " " + this.format(d)), 
this.lastX = c / e.scale - e.dx, this.lastY = d / e.scale - e.dy;
}, mxVmlCanvas2D.prototype.createRect = function(a, b, c, d, e) {
var f = this.state;
return a = document.createElement(a), a.style.position = "absolute", a.style.left = this.format((b + f.dx) * f.scale) + "px", 
a.style.top = this.format((c + f.dy) * f.scale) + "px", a.style.width = this.format(d * f.scale) + "px", 
a.style.height = this.format(e * f.scale) + "px", a;
}, mxVmlCanvas2D.prototype.rect = function(a, b, c, d) {
this.node = this.createRect(mxClient.VML_PREFIX + ":rect", a, b, c, d);
}, mxVmlCanvas2D.prototype.roundrect = function(a, b, c, d, e, f) {
this.node = this.createRect(mxClient.VML_PREFIX + ":roundrect", a, b, c, d), this.node.setAttribute("arcsize", Math.max(100 * e / c, 100 * f / d) + "%");
}, mxVmlCanvas2D.prototype.ellipse = function(a, b, c, d) {
this.node = this.createRect(mxClient.VML_PREFIX + ":oval", a, b, c, d);
}, mxVmlCanvas2D.prototype.image = function(a, b, c, d, e, f, g, h) {
var k = null;
f ? (k = this.createRect(mxClient.VML_PREFIX + ":rect", a, b, c, d), k.stroked = "false", 
a = document.createElement(mxClient.VML_PREFIX + ":fill"), a.aspect = f ? "atmost" :"ignore", 
a.rotate = "true", a.type = "frame", a.src = e, k.appendChild(a)) :(k = this.createRect(mxClient.VML_PREFIX + ":image", a, b, c, d), 
k.src = e), g && h ? k.style.rotation = "180" :g ? k.style.flip = "x" :h && (k.style.flip = "y"), 
1 > this.state.alpha && (k.style.filter += "alpha(opacity=" + 100 * this.state.alpha + ")"), 
this.root.appendChild(k);
}, mxVmlCanvas2D.prototype.createDiv = function(a, b, c, d) {
c = document.createElement("div");
var e = this.state, f = "";
return null != e.fontBackgroundColor && (f += "background-color:" + e.fontBackgroundColor + ";"), 
null != e.fontBorderColor && (f += "border:1px solid " + e.fontBorderColor + ";"), 
mxUtils.isNode(a) ? c.appendChild(a) :0 < f.length && "fill" != d && "width" != d ? (d = document.createElement("div"), 
d.style.cssText = f, d.style.display = mxClient.IS_QUIRKS ? "inline" :"inline-block", 
d.style.zoom = "1", d.innerHTML = a, c.appendChild(d)) :(c.style.cssText = f, c.innerHTML = a), 
a = c.style, a.fontSize = Math.round(e.fontSize / this.vmlScale) + "px", a.fontFamily = e.fontFamily, 
a.color = e.fontColor, a.verticalAlign = "top", a.textAlign = b || "left", a.lineHeight = Math.round(e.fontSize * mxConstants.LINE_HEIGHT / this.vmlScale) + "px", 
(e.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && (a.fontWeight = "bold"), 
(e.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && (a.fontStyle = "italic"), 
(e.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && (a.textDecoration = "underline"), 
c;
}, mxVmlCanvas2D.prototype.text = function(a, b, c, d, e, f, g, h, k, l, m, n) {
if (this.textEnabled && null != e) {
var p = this.state;
if ("html" == k) {
null != p.rotation && (b = this.rotatePoint(a, b, p.rotation, p.rotationCx, p.rotationCy), 
a = b.x, b = b.y), 8 == document.documentMode ? (a += p.dx, b += p.dy) :(a *= p.scale, 
b *= p.scale), k = 8 == document.documentMode ? document.createElement(mxClient.VML_PREFIX + ":group") :document.createElement("div"), 
k.style.position = "absolute", k.style.display = "inline", k.style.left = this.format(a) + "px", 
k.style.top = this.format(b) + "px", k.style.zoom = p.scale;
var q = document.createElement("div");
q.style.position = "relative", q.style.display = "inline";
var s = mxUtils.getAlignmentAsPoint(f, g), r = s.x, s = s.y;
if (e = this.createDiv(e, f, g, l), f = document.createElement("div"), h && c > 0 ? (m || (e.style.width = Math.round(c) + "px"), 
e.style.whiteSpace = "normal") :e.style.whiteSpace = "nowrap", h = p.rotation + (n || 0), 
this.rotateHtml && 0 != h ? (f.style.display = "inline", f.style.zoom = "1", f.appendChild(e), 
8 == document.documentMode && "DIV" != this.root.nodeName ? (q.appendChild(f), k.appendChild(q)) :k.appendChild(f)) :8 == document.documentMode ? (q.appendChild(e), 
k.appendChild(q)) :(e.style.display = "inline", k.appendChild(e)), "DIV" != this.root.nodeName ? (n = document.createElement(mxClient.VML_PREFIX + ":rect"), 
n.stroked = "false", n.filled = "false", n.appendChild(k), this.root.appendChild(n)) :this.root.appendChild(k), 
m ? (e.style.overflow = "hidden", c > 0 && (e.style.width = Math.round(c) + "px"), 
d > 0 && 8 == document.documentMode && (e.style.maxHeight = Math.round(d) + "px")) :"fill" == l ? (e.style.width = c + "px", 
e.style.height = d + "px") :"width" == l && (e.style.width = c + "px", d > 0 && (e.style.maxHeight = Math.round(d) + "px")), 
this.rotateHtml && 0 != h) {
c = h * (Math.PI / 180), h = parseFloat(parseFloat(Math.cos(c)).toFixed(8)), n = parseFloat(parseFloat(Math.sin(-c)).toFixed(8)), 
c %= 2 * Math.PI, 0 > c && (c += 2 * Math.PI), c %= Math.PI, c > Math.PI / 2 && (c = Math.PI - c), 
g = Math.cos(c);
var t = Math.sin(c);
8 == document.documentMode && (e.style.display = "inline-block", f.style.display = "inline-block", 
q.style.display = "inline-block"), e.style.visibility = "hidden", document.body.appendChild(e), 
c = e.offsetWidth, q = e.offsetHeight, mxClient.IS_QUIRKS && (m || "width" == l) && q > d && (q = d, 
e.style.height = q + "px"), d = q, m = (d - d * g + c * -t) / 2 - n * c * (r + .5) + h * d * (s + .5), 
l = (c - c * g + d * -t) / 2 + h * c * (r + .5) + n * d * (s + .5), "group" == k.nodeName && "DIV" == this.root.nodeName ? (r = document.createElement("div"), 
r.style.display = "inline-block", r.style.position = "absolute", r.style.left = this.format(a + (l - c / 2) * p.scale) + "px", 
r.style.top = this.format(b + (m - d / 2) * p.scale) + "px", k.parentNode.appendChild(r), 
r.appendChild(k)) :(p = 8 == document.documentMode ? 1 :p.scale, k.style.left = this.format(a + (l - c / 2) * p) + "px", 
k.style.top = this.format(b + (m - d / 2) * p) + "px"), f.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11=" + h + ", M12=" + n + ", M21=" + -n + ", M22=" + h + ", sizingMethod='auto expand')", 
f.style.backgroundColor = this.rotatedHtmlBackground, 1 > this.state.alpha && (f.style.filter += "alpha(opacity=" + 100 * this.state.alpha + ")"), 
e.style.visibility = "", f.appendChild(e);
} else 8 != document.documentMode ? (e.style.verticalAlign = "top", 1 > this.state.alpha && (k.style.filter = "alpha(opacity=" + 100 * this.state.alpha + ")"), 
p = e.parentNode, e.style.visibility = "hidden", document.body.appendChild(e), c = e.offsetWidth, 
q = e.offsetHeight, mxClient.IS_QUIRKS && m && q > d && (q = d, e.style.height = q + "px"), 
d = q, e.style.visibility = "", p.appendChild(e), k.style.left = this.format(a + c * r * this.state.scale) + "px", 
k.style.top = this.format(b + d * s * this.state.scale) + "px") :(1 > this.state.alpha && (e.style.filter = "alpha(opacity=" + 100 * this.state.alpha + ")"), 
q.style.left = 100 * r + "%", q.style.top = 100 * s + "%");
} else this.plainText(a, b, c, d, mxUtils.htmlEntities(e, !1), f, g, h, k, l, m, n);
}
}, mxVmlCanvas2D.prototype.plainText = function(a, b, c, d, e, f, g, h, k, l, m, n) {
h = this.state, a = (a + h.dx) * h.scale, b = (b + h.dy) * h.scale, c = document.createElement(mxClient.VML_PREFIX + ":shape"), 
c.style.width = "1px", c.style.height = "1px", c.stroked = "false", d = document.createElement(mxClient.VML_PREFIX + ":fill"), 
d.color = h.fontColor, d.opacity = 100 * h.alpha + "%", c.appendChild(d), d = document.createElement(mxClient.VML_PREFIX + ":path"), 
d.textpathok = "true", d.v = "m " + this.format(0) + " " + this.format(0) + " l " + this.format(1) + " " + this.format(0), 
c.appendChild(d), d = document.createElement(mxClient.VML_PREFIX + ":textpath"), 
d.style.cssText = "v-text-align:" + f, d.style.align = f, d.style.fontFamily = h.fontFamily, 
d.string = e, d.on = "true", f = Math.round(h.fontSize * h.scale / this.vmlScale), 
d.style.fontSize = f + "px", (h.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD && (d.style.fontWeight = "bold"), 
(h.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC && (d.style.fontStyle = "italic"), 
(h.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE && (d.style.textDecoration = "underline"), 
e = e.split("\n"), h = f + (e.length - 1) * f * mxConstants.LINE_HEIGHT, f = e = 0, 
g == mxConstants.ALIGN_BOTTOM ? f = -h / 2 :g != mxConstants.ALIGN_MIDDLE && (f = h / 2), 
null != n && (c.style.rotation = n, g = n * (Math.PI / 180), e = Math.sin(g) * f, 
f *= Math.cos(g)), c.appendChild(d), c.style.left = this.format(a - e) + "px", c.style.top = this.format(b + f) + "px", 
this.root.appendChild(c);
}, mxVmlCanvas2D.prototype.stroke = function() {
this.addNode(!1, !0);
}, mxVmlCanvas2D.prototype.fill = function() {
this.addNode(!0, !1);
}, mxVmlCanvas2D.prototype.fillAndStroke = function() {
this.addNode(!0, !0);
}, mxGuide.prototype.graph = null, mxGuide.prototype.states = null, mxGuide.prototype.horizontal = !0, 
mxGuide.prototype.vertical = !0, mxGuide.prototype.guideX = null, mxGuide.prototype.guideY = null, 
mxGuide.prototype.setStates = function(a) {
this.states = a;
}, mxGuide.prototype.isEnabledForEvent = function() {
return !0;
}, mxGuide.prototype.getGuideTolerance = function() {
return this.graph.gridSize * this.graph.view.scale / 2;
}, mxGuide.prototype.createGuideShape = function(a) {
return a = new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH), 
a.isDashed = !0, a;
}, mxGuide.prototype.move = function(a, b, c) {
if (null != this.states && (this.horizontal || this.vertical) && null != a && null != b) {
var d = this.graph.getView().translate, e = this.graph.getView().scale, f = b.x, g = b.y, h = !1, k = !1, l = this.getGuideTolerance(), m = l, n = l, l = a.clone();
l.x += b.x, l.y += b.y;
var p = l.x, q = l.x + l.width, s = l.getCenterX(), r = l.y, t = l.y + l.height, u = l.getCenterY();
b = function(b) {
b += this.graph.panDx;
var c = !1;
if (Math.abs(b - s) < m ? (f = b - a.getCenterX(), m = Math.abs(b - s), c = !0) :Math.abs(b - p) < m ? (f = b - a.x, 
m = Math.abs(b - p), c = !0) :Math.abs(b - q) < m && (f = b - a.x - a.width, m = Math.abs(b - q), 
c = !0), c) {
null == this.guideX && (this.guideX = this.createGuideShape(!0), this.guideX.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
this.guideX.pointerEvents = !1, this.guideX.init(this.graph.getView().getOverlayPane()));
var d = this.graph.container;
b -= this.graph.panDx, this.guideX.points = [ new mxPoint(b, -this.graph.panDy), new mxPoint(b, d.scrollHeight - 3 - this.graph.panDy) ];
}
h = h || c;
};
for (var l = function(b) {
b += this.graph.panDy;
var c = !1;
if (Math.abs(b - u) < n ? (g = b - a.getCenterY(), n = Math.abs(b - u), c = !0) :Math.abs(b - r) < n ? (g = b - a.y, 
n = Math.abs(b - r), c = !0) :Math.abs(b - t) < n && (g = b - a.y - a.height, n = Math.abs(b - t), 
c = !0), c) {
null == this.guideY && (this.guideY = this.createGuideShape(!1), this.guideY.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
this.guideY.pointerEvents = !1, this.guideY.init(this.graph.getView().getOverlayPane()));
var d = this.graph.container;
b -= this.graph.panDy, this.guideY.points = [ new mxPoint(-this.graph.panDx, b), new mxPoint(d.scrollWidth - 3 - this.graph.panDx, b) ];
}
k = k || c;
}, v = 0; v < this.states.length; v++) {
var w = this.states[v];
null != w && (this.horizontal && (b.call(this, w.getCenterX()), b.call(this, w.x), 
b.call(this, w.x + w.width)), this.vertical && (l.call(this, w.getCenterY()), l.call(this, w.y), 
l.call(this, w.y + w.height)));
}
h || null == this.guideX ? null != this.guideX && (this.guideX.node.style.visibility = "visible", 
this.guideX.redraw()) :this.guideX.node.style.visibility = "hidden", k || null == this.guideY ? null != this.guideY && (this.guideY.node.style.visibility = "visible", 
this.guideY.redraw()) :this.guideY.node.style.visibility = "hidden", c && (h || (c = a.x - (this.graph.snap(a.x / e - d.x) + d.x) * e, 
f = this.graph.snap(f / e) * e - c), k || (d = a.y - (this.graph.snap(a.y / e - d.y) + d.y) * e, 
g = this.graph.snap(g / e) * e - d)), b = new mxPoint(f, g);
}
return b;
}, mxGuide.prototype.hide = function() {
null != this.guideX && (this.guideX.node.style.visibility = "hidden"), null != this.guideY && (this.guideY.node.style.visibility = "hidden");
}, mxGuide.prototype.destroy = function() {
null != this.guideX && (this.guideX.destroy(), this.guideX = null), null != this.guideY && (this.guideY.destroy(), 
this.guideY = null);
}, mxStencil.defaultLocalized = !1, mxStencil.prototype.desc = null, mxStencil.prototype.constraints = null, 
mxStencil.prototype.aspect = null, mxStencil.prototype.w0 = null, mxStencil.prototype.h0 = null, 
mxStencil.prototype.bgNode = null, mxStencil.prototype.fgNode = null, mxStencil.prototype.strokewidth = null, 
mxStencil.prototype.parseDescription = function() {
this.fgNode = this.desc.getElementsByTagName("foreground")[0], this.bgNode = this.desc.getElementsByTagName("background")[0], 
this.w0 = Number(this.desc.getAttribute("w") || 100), this.h0 = Number(this.desc.getAttribute("h") || 100);
var a = this.desc.getAttribute("aspect");
this.aspect = null != a ? a :"variable", a = this.desc.getAttribute("strokewidth"), 
this.strokewidth = null != a ? a :"1";
}, mxStencil.prototype.parseConstraints = function() {
var a = this.desc.getElementsByTagName("connections")[0];
if (null != a && (a = mxUtils.getChildNodes(a), null != a && 0 < a.length)) {
this.constraints = [];
for (var b = 0; b < a.length; b++) this.constraints.push(this.parseConstraint(a[b]));
}
}, mxStencil.prototype.parseConstraint = function(a) {
var b = Number(a.getAttribute("x")), c = Number(a.getAttribute("y"));
return a = "1" == a.getAttribute("perimeter"), new mxConnectionConstraint(new mxPoint(b, c), a);
}, mxStencil.prototype.evaluateTextAttribute = function(a, b, c) {
return b = this.evaluateAttribute(a, b, c), a = a.getAttribute("localized"), (mxStencil.defaultLocalized && null == a || "1" == a) && (b = mxResources.get(b)), 
b;
}, mxStencil.prototype.evaluateAttribute = function(a, b, c) {
return b = a.getAttribute(b), null == b && (a = mxUtils.getTextContent(a), null != a && (a = mxUtils.eval(a), 
"function" == typeof a && (b = a(c)))), b;
}, mxStencil.prototype.drawShape = function(a, b, c, d, e, f) {
this.drawChildren(a, b, c, d, e, f, this.bgNode, !1), this.drawChildren(a, b, c, d, e, f, this.fgNode, !0);
}, mxStencil.prototype.drawChildren = function(a, b, c, d, e, f, g, h) {
if (null != g) {
var k = mxUtils.getValue(b.style, mxConstants.STYLE_DIRECTION, null);
for (c = this.computeAspect(b.style, c, d, e, f, k), d = Math.min(c.width, c.height), 
d = "inherit" == this.strokewidth ? Number(mxUtils.getNumber(b.style, mxConstants.STYLE_STROKEWIDTH, 1)) :Number(this.strokewidth) * d, 
a.setStrokeWidth(d), g = g.firstChild; null != g; ) g.nodeType == mxConstants.NODETYPE_ELEMENT && this.drawNode(a, b, g, c, h), 
g = g.nextSibling;
}
}, mxStencil.prototype.computeAspect = function(a, b, c, d, e, f) {
a = b, b = d / this.w0;
var g = e / this.h0;
if (f = "north" == f || "south" == f) {
g = d / this.h0, b = e / this.w0;
var h = (d - e) / 2;
a += h, c -= h;
}
return "fixed" == this.aspect && (b = g = Math.min(b, g), f ? (a += (e - this.w0 * b) / 2, 
c += (d - this.h0 * g) / 2) :(a += (d - this.w0 * b) / 2, c += (e - this.h0 * g) / 2)), 
new mxRectangle(a, c, b, g);
}, mxStencil.prototype.drawNode = function(a, b, c, d, e) {
var f = c.nodeName, g = d.x, h = d.y, k = d.width, l = d.height, m = Math.min(k, l);
if ("save" == f) a.save(); else if ("restore" == f) a.restore(); else if ("path" == f) for (a.begin(), 
c = c.firstChild; null != c; ) c.nodeType == mxConstants.NODETYPE_ELEMENT && this.drawNode(a, b, c, d, e), 
c = c.nextSibling; else if ("close" == f) a.close(); else if ("move" == f) a.moveTo(g + Number(c.getAttribute("x")) * k, h + Number(c.getAttribute("y")) * l); else if ("line" == f) a.lineTo(g + Number(c.getAttribute("x")) * k, h + Number(c.getAttribute("y")) * l); else if ("quad" == f) a.quadTo(g + Number(c.getAttribute("x1")) * k, h + Number(c.getAttribute("y1")) * l, g + Number(c.getAttribute("x2")) * k, h + Number(c.getAttribute("y2")) * l); else if ("curve" == f) a.curveTo(g + Number(c.getAttribute("x1")) * k, h + Number(c.getAttribute("y1")) * l, g + Number(c.getAttribute("x2")) * k, h + Number(c.getAttribute("y2")) * l, g + Number(c.getAttribute("x3")) * k, h + Number(c.getAttribute("y3")) * l); else if ("arc" == f) a.arcTo(Number(c.getAttribute("rx")) * k, Number(c.getAttribute("ry")) * l, Number(c.getAttribute("x-axis-rotation")), Number(c.getAttribute("large-arc-flag")), Number(c.getAttribute("sweep-flag")), g + Number(c.getAttribute("x")) * k, h + Number(c.getAttribute("y")) * l); else if ("rect" == f) a.rect(g + Number(c.getAttribute("x")) * k, h + Number(c.getAttribute("y")) * l, Number(c.getAttribute("w")) * k, Number(c.getAttribute("h")) * l); else if ("roundrect" == f) b = c.getAttribute("arcsize"), 
0 == b && (b = 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR), m = Number(c.getAttribute("w")) * k, 
d = Number(c.getAttribute("h")) * l, b = Number(b) / 100, b = Math.min(m * b, d * b), 
a.roundrect(g + Number(c.getAttribute("x")) * k, h + Number(c.getAttribute("y")) * l, m, d, b, b); else if ("ellipse" == f) a.ellipse(g + Number(c.getAttribute("x")) * k, h + Number(c.getAttribute("y")) * l, Number(c.getAttribute("w")) * k, Number(c.getAttribute("h")) * l); else if ("image" == f) b = this.evaluateAttribute(c, "src", b), 
a.image(g + Number(c.getAttribute("x")) * k, h + Number(c.getAttribute("y")) * l, Number(c.getAttribute("w")) * k, Number(c.getAttribute("h")) * l, b, !1, "1" == c.getAttribute("flipH"), "1" == c.getAttribute("flipV")); else if ("text" == f) {
if (m = this.evaluateTextAttribute(c, "str", b), d = "1" == c.getAttribute("vertical") ? -90 :0, 
"0" == c.getAttribute("align-shape")) {
var n = b.rotation, p = 1 == mxUtils.getValue(b.style, mxConstants.STYLE_FLIPH, 0);
b = 1 == mxUtils.getValue(b.style, mxConstants.STYLE_FLIPV, 0), d = p && b ? d - n :p || b ? d + n :d - n;
}
d -= c.getAttribute("rotation"), a.text(g + Number(c.getAttribute("x")) * k, h + Number(c.getAttribute("y")) * l, 0, 0, m, c.getAttribute("align") || "left", c.getAttribute("valign") || "top", !1, "", null, !1, d);
} else if ("include-shape" == f) n = mxStencilRegistry.getStencil(c.getAttribute("name")), 
null != n && (g += Number(c.getAttribute("x")) * k, h += Number(c.getAttribute("y")) * l, 
m = Number(c.getAttribute("w")) * k, d = Number(c.getAttribute("h")) * l, n.drawShape(a, b, g, h, m, d)); else if ("fillstroke" == f) a.fillAndStroke(); else if ("fill" == f) a.fill(); else if ("stroke" == f) a.stroke(); else if ("strokewidth" == f) k = "1" == c.getAttribute("fixed") ? 1 :m, 
a.setStrokeWidth(Number(c.getAttribute("width")) * k); else if ("dashed" == f) a.setDashed("1" == c.getAttribute("dashed")); else if ("dashpattern" == f) {
if (c = c.getAttribute("pattern"), null != c) {
for (c = c.split(" "), k = [], l = 0; l < c.length; l++) 0 < c[l].length && k.push(Number(c[l]) * m);
c = k.join(" "), a.setDashPattern(c);
}
} else "strokecolor" == f ? a.setStrokeColor(c.getAttribute("color")) :"linecap" == f ? a.setLineCap(c.getAttribute("cap")) :"linejoin" == f ? a.setLineJoin(c.getAttribute("join")) :"miterlimit" == f ? a.setMiterLimit(Number(c.getAttribute("limit"))) :"fillcolor" == f ? a.setFillColor(c.getAttribute("color")) :"alpha" == f ? a.setAlpha(c.getAttribute("alpha")) :"fontcolor" == f ? a.setFontColor(c.getAttribute("color")) :"fontstyle" == f ? a.setFontStyle(c.getAttribute("style")) :"fontfamily" == f ? a.setFontFamily(c.getAttribute("family")) :"fontsize" == f && a.setFontSize(Number(c.getAttribute("size")) * m);
e && ("fillstroke" == f || "fill" == f || "stroke" == f) && a.setShadow(!1);
}, mxShape.prototype.dialect = null, mxShape.prototype.scale = 1, mxShape.prototype.bounds = null, 
mxShape.prototype.points = null, mxShape.prototype.node = null, mxShape.prototype.style = null, 
mxShape.prototype.style = null, mxShape.prototype.boundingBox = null, mxShape.prototype.stencil = null, 
mxShape.prototype.svgStrokeTolerance = 6, mxShape.prototype.pointerEvents = !0, 
mxShape.prototype.stencilPointerEvents = !1, mxShape.prototype.vmlScale = 1, mxShape.prototype.init = function(a) {
null == this.node && (this.node = this.create(a), null != a && a.appendChild(this.node));
}, mxShape.prototype.isParseVml = function() {
return !0;
}, mxShape.prototype.isHtmlAllowed = function() {
return !1;
}, mxShape.prototype.getSvgScreenOffset = function() {
return 1 == mxUtils.mod(Math.max(1, Math.round(this.strokewidth * this.scale)), 2) ? .5 :0;
}, mxShape.prototype.create = function(a) {
var b = null;
return b = null != a.ownerSVGElement ? this.createSvg(a) :8 == document.documentMode || this.dialect == mxConstants.DIALECT_SVG || this.dialect != mxConstants.DIALECT_VML && this.isHtmlAllowed() ? this.createHtml(a) :this.createVml(a);
}, mxShape.prototype.createSvg = function() {
return document.createElementNS(mxConstants.NS_SVG, "g");
}, mxShape.prototype.createVml = function() {
var a = document.createElement(mxClient.VML_PREFIX + ":group");
return a.style.position = "absolute", a;
}, mxShape.prototype.createHtml = function() {
var a = document.createElement("div");
return a.style.position = "absolute", a;
}, mxShape.prototype.reconfigure = function() {
this.redraw();
}, mxShape.prototype.redraw = function() {
this.updateBoundsFromPoints(), this.checkBounds() ? (this.node.style.visibility = "", 
"DIV" == this.node.nodeName && this.isHtmlAllowed() ? this.redrawHtmlShape() :this.redrawShape(), 
this.updateBoundingBox()) :(this.node.style.visibility = "hidden", this.boundingBox = null);
}, mxShape.prototype.updateBoundsFromPoints = function() {
var a = this.points;
if (null != a && 0 < a.length && null != a[0]) {
this.bounds = new mxRectangle(Number(a[0].x), Number(a[0].y), 1, 1);
for (var b = 1; b < this.points.length; b++) null != a[b] && this.bounds.add(new mxRectangle(Number(a[b].x), Number(a[b].y), 1, 1));
}
}, mxShape.prototype.getLabelBounds = function(a) {
return a;
}, mxShape.prototype.checkBounds = function() {
return null != this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height) && 0 < this.bounds.width && 0 < this.bounds.height;
}, mxShape.prototype.createVmlGroup = function() {
var a = document.createElement(mxClient.VML_PREFIX + ":group");
return a.style.position = "absolute", a.style.width = this.node.style.width, a.style.height = this.node.style.height, 
a;
}, mxShape.prototype.redrawShape = function() {
var a = this.createCanvas();
for (a.pointerEvents = this.pointerEvents; this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
this.paint(a), this.node != a.root && this.node.insertAdjacentHTML("beforeend", a.root.outerHTML), 
"DIV" == this.node.nodeName && 8 == document.documentMode && (this.node.style.filter = "", 
(null == this.stencil || !this.stencilPointerEvents) && mxUtils.addTransparentBackgroundFilter(this.node)), 
this.destroyCanvas(a);
}, mxShape.prototype.createCanvas = function() {
var a = null, b = null;
if (null != this.node.ownerSVGElement) a = new mxSvgCanvas2D(this.node, !1), a.strokeTolerance = this.svgStrokeTolerance, 
a.blockImagePointerEvents = mxClient.IS_NS && !mxClient.IS_SF && !mxClient.IS_GC, 
b = this.getSvgScreenOffset(), 0 != b ? this.node.setAttribute("transform", "translate(" + b + "," + b + ")") :this.node.removeAttribute("transform"); else {
this.updateVmlContainer();
var c = Math.max(1, Math.round(this.bounds.width)), d = Math.max(1, Math.round(this.bounds.height)), b = 8 == document.documentMode && this.isParseVml() ? this.createVmlGroup() :this.node, a = new mxVmlCanvas2D(b, !1);
"" != b.tagUrn && (b.coordsize = c * this.vmlScale + "," + d * this.vmlScale, a.scale(this.vmlScale), 
a.vmlScale = this.vmlScale), b = this.scale, a.translate(-Math.round(this.bounds.x / b), -Math.round(this.bounds.y / b));
}
return a;
}, mxShape.prototype.updateVmlContainer = function() {
this.node.style.left = Math.round(this.bounds.x) + "px", this.node.style.top = Math.round(this.bounds.y) + "px";
var a = Math.max(1, Math.round(this.bounds.width)), b = Math.max(1, Math.round(this.bounds.height));
this.node.style.width = a + "px", this.node.style.height = b + "px", this.node.style.overflow = "visible";
}, mxShape.prototype.destroyCanvas = function(a) {
if (a instanceof mxSvgCanvas2D) {
for (var b in a.gradients) {
var c = a.gradients[b];
c.mxRefCount = (c.mxRefCount || 0) + 1;
}
this.releaseSvgGradients(this.oldGradients), this.oldGradients = a.gradients;
}
}, mxShape.prototype.paint = function(a) {
var b = this.scale, c = this.bounds.x / b, d = this.bounds.y / b, e = this.bounds.width / b, f = this.bounds.height / b;
if (this.isPaintBoundsInverted()) var g = (e - f) / 2, c = c + g, d = d - g, g = e, e = f, f = g;
if (this.updateTransform(a, c, d, e, f), this.configureCanvas(a, c, d, e, f), null != this.stencil) this.paintStencilShape(a, c, d, e, f); else if (a.setStrokeWidth(this.strokewidth), 
null != this.points) {
for (c = [], d = 0; d < this.points.length; d++) c.push(new mxPoint(this.points[d].x / b, this.points[d].y / b));
this.paintEdgeShape(a, c);
} else this.paintVertexShape(a, c, d, e, f);
}, mxShape.prototype.configureCanvas = function(a, b, c, d, e) {
var f = null;
null != this.style && (f = this.style.dashPattern), a.setAlpha(this.opacity / 100), 
null != this.isShadow && a.setShadow(this.isShadow), null != this.isDashed && a.setDashed(this.isDashed), 
null != f && a.setDashPattern(f), null != this.gradient ? (b = this.getGradientBounds(a, b, c, d, e), 
a.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection)) :a.setFillColor(this.fill), 
a.setStrokeColor(this.stroke);
}, mxShape.prototype.getGradientBounds = function(a, b, c, d, e) {
return new mxRectangle(b, c, d, e);
}, mxShape.prototype.updateTransform = function(a, b, c, d, e) {
a.scale(this.scale), a.rotate(this.getShapeRotation(), this.flipH, this.flipV, b + d / 2, c + e / 2);
}, mxShape.prototype.paintStencilShape = function(a, b, c, d, e) {
this.stencilPointerEvents && (this.dialect == mxConstants.DIALECT_SVG ? this.addTransparentBackgroundRectangle(this.node, b, c, d, e) :8 != document.documentMode && this.setTransparentBackgroundImage(this.node)), 
this.stencil.drawShape(a, this, b, c, d, e);
}, mxShape.prototype.paintVertexShape = function(a, b, c, d, e) {
this.paintBackground(a, b, c, d, e), a.setShadow(!1), this.paintForeground(a, b, c, d, e);
}, mxShape.prototype.paintBackground = function() {}, mxShape.prototype.paintForeground = function() {}, 
mxShape.prototype.paintEdgeShape = function() {}, mxShape.prototype.getArcSize = function(a, b) {
var c = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
return Math.min(a * c, b * c);
}, mxShape.prototype.paintGlassEffect = function(a, b, c, d, e, f) {
var g = Math.ceil(this.strokewidth / 2);
a.setGradient("#ffffff", "#ffffff", b, c, d, .6 * e, "south", .9, .1), a.begin(), 
f += 2 * g, this.isRounded ? (a.moveTo(b - g + f, c - g), a.quadTo(b - g, c - g, b - g, c - g + f), 
a.lineTo(b - g, c + .4 * e), a.quadTo(b + .5 * d, c + .7 * e, b + d + g, c + .4 * e), 
a.lineTo(b + d + g, c - g + f), a.quadTo(b + d + g, c - g, b + d + g - f, c - g)) :(a.moveTo(b - g, c - g), 
a.lineTo(b - g, c + .4 * e), a.quadTo(b + .5 * d, c + .7 * e, b + d + g, c + .4 * e), 
a.lineTo(b + d + g, c - g)), a.close(), a.fill();
}, mxShape.prototype.apply = function(a) {
this.state = a, this.style = a.style, null != this.style && (this.fill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, this.fill), 
this.gradient = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENTCOLOR, this.gradient), 
this.gradientDirection = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENT_DIRECTION, this.gradientDirection), 
this.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_OPACITY, this.opacity), 
this.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, this.stroke), 
this.strokewidth = mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth), 
this.spacing = mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing), 
this.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, this.startSize), 
this.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, this.endSize), 
this.startArrow = mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, this.startArrow), 
this.endArrow = mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, this.endArrow), 
this.rotation = mxUtils.getValue(this.style, mxConstants.STYLE_ROTATION, this.rotation), 
this.direction = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, this.direction), 
this.flipH = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0), this.flipV = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0), 
null != this.stencil && (this.flipH = 1 == mxUtils.getValue(this.style, "stencilFlipH", 0) || this.flipH, 
this.flipV = 1 == mxUtils.getValue(this.style, "stencilFlipV", 0) || this.flipV), 
("north" == this.direction || "south" == this.direction) && (a = this.flipH, this.flipH = this.flipV, 
this.flipV = a), this.isShadow = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SHADOW, this.isShadow), 
this.isDashed = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, this.isDashed), 
this.isRounded = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_ROUNDED, this.isRounded), 
this.glass = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_GLASS, this.glass), 
"none" == this.fill && (this.fill = null), "none" == this.gradient && (this.gradient = null), 
"none" == this.stroke && (this.stroke = null));
}, mxShape.prototype.setCursor = function(a) {
null == a && (a = ""), this.cursor = a, null != this.node && (this.node.style.cursor = a);
}, mxShape.prototype.getCursor = function() {
return this.cursor;
}, mxShape.prototype.updateBoundingBox = function() {
if (null != this.bounds) {
var a = this.createBoundingBox();
if (null != a) {
this.augmentBoundingBox(a);
var b = this.getShapeRotation();
0 != b && (a = mxUtils.getBoundingBox(a, b)), a.x = Math.floor(a.x), a.y = Math.floor(a.y), 
a.width = Math.ceil(a.width), a.height = Math.ceil(a.height);
}
this.boundingBox = a;
}
}, mxShape.prototype.createBoundingBox = function() {
var a = this.bounds.clone();
if (this.isPaintBoundsInverted()) {
var b = (a.width - a.height) / 2;
a.x += b, a.y -= b, b = a.width, a.width = a.height, a.height = b;
}
return a;
}, mxShape.prototype.augmentBoundingBox = function(a) {
this.isShadow && (a.width += Math.ceil(mxConstants.SHADOW_OFFSET_X * this.scale), 
a.height += Math.ceil(mxConstants.SHADOW_OFFSET_Y * this.scale));
var b = Math.ceil(this.strokewidth * this.scale);
a.grow(Math.ceil(b / 2));
}, mxShape.prototype.isPaintBoundsInverted = function() {
return null == this.stencil && ("north" == this.direction || "south" == this.direction);
}, mxShape.prototype.getRotation = function() {
return null != this.rotation ? this.rotation :0;
}, mxShape.prototype.getTextRotation = function() {
var a = this.getRotation();
return 1 != mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) && (a += mxText.prototype.verticalTextRotation), 
a;
}, mxShape.prototype.getShapeRotation = function() {
var a = this.getRotation();
return null != this.direction && ("north" == this.direction ? a += 270 :"west" == this.direction ? a += 180 :"south" == this.direction && (a += 90)), 
a;
}, mxShape.prototype.addTransparentBackgroundRectangle = function(a, b, c, d, e) {
a = document.createElementNS(mxConstants.NS_SVG, "rect"), a.setAttribute("x", b), 
a.setAttribute("y", c), a.setAttribute("width", d), a.setAttribute("height", e), 
a.setAttribute("fill", "none"), a.setAttribute("stroke", "none"), a.setAttribute("pointer-events", "all"), 
this.node.appendChild(a);
}, mxShape.prototype.setTransparentBackgroundImage = function(a) {
a.style.backgroundImage = "url('" + mxClient.imageBasePath + "/transparent.gif')";
}, mxShape.prototype.releaseSvgGradients = function(a) {
if (null != a) for (var b in a) {
var c = a[b];
c.mxRefCount = (c.mxRefCount || 0) - 1, 0 == c.mxRefCount && null != c.parentNode && c.parentNode.removeChild(c);
}
}, mxShape.prototype.destroy = function() {
null != this.node && (mxEvent.release(this.node), null != this.node.parentNode && this.node.parentNode.removeChild(this.node), 
this.node = null), this.releaseSvgGradients(this.oldGradients), this.oldGradients = null;
};

var mxStencilRegistry = {
stencils:[],
addStencil:function(a, b) {
mxStencilRegistry.stencils[a] = b;
},
getStencil:function(a) {
return mxStencilRegistry.stencils[a];
}
}, mxMarker = {
markers:[],
addMarker:function(a, b) {
mxMarker.markers[a] = b;
},
createMarker:function(a, b, c, d, e, f, g, h, k, l) {
var m = mxMarker.markers[c];
return null != m ? m(a, b, c, d, e, f, g, h, k, l) :null;
}
};

!function() {
function a(a, b, e, f, g, h, k, l, m, n) {
b = 1.118 * g * m, l = 1.118 * h * m, g *= k + m, h *= k + m;
var p = f.clone();
return p.x -= b, p.y -= l, k = e != mxConstants.ARROW_CLASSIC ? 1 :.75, f.x += -g * k - b, 
f.y += -h * k - l, function() {
a.begin(), a.moveTo(p.x, p.y), a.lineTo(p.x - g - h / 2, p.y - h + g / 2), e == mxConstants.ARROW_CLASSIC && a.lineTo(p.x - 3 * g / 4, p.y - 3 * h / 4), 
a.lineTo(p.x + h / 2 - g, p.y - h - g / 2), a.close(), n ? a.fillAndStroke() :a.stroke();
};
}
function b(a, b, e, f, g, h, k, l, m, n) {
l = e == mxConstants.ARROW_DIAMOND ? .7071 :.9862, b = g * m * l, l *= h * m, g *= k + m, 
h *= k + m;
var p = f.clone();
p.x -= b, p.y -= l, f.x += -g - b, f.y += -h - l;
var q = e == mxConstants.ARROW_DIAMOND ? 2 :3.4;
return function() {
a.begin(), a.moveTo(p.x, p.y), a.lineTo(p.x - g / 2 - h / q, p.y + g / q - h / 2), 
a.lineTo(p.x - g, p.y - h), a.lineTo(p.x - g / 2 + h / q, p.y - h / 2 - g / q), 
a.close(), n ? a.fillAndStroke() :a.stroke();
};
}
mxMarker.addMarker("classic", a), mxMarker.addMarker("block", a), mxMarker.addMarker("open", function(a, b, e, f, g, h, k, l, m) {
b = 1.118 * g * m, e = 1.118 * h * m, g *= k + m, h *= k + m;
var p = f.clone();
return p.x -= b, p.y -= e, f.x += 2 * -b, f.y += 2 * -e, function() {
a.begin(), a.moveTo(p.x - g - h / 2, p.y - h + g / 2), a.lineTo(p.x, p.y), a.lineTo(p.x + h / 2 - g, p.y - h - g / 2), 
a.stroke();
};
}), mxMarker.addMarker("oval", function(a, b, e, f, g, h, k, l, m, n) {
var p = k / 2, q = f.clone();
return f.x -= g * p, f.y -= h * p, function() {
a.ellipse(q.x - p, q.y - p, k, k), n ? a.fillAndStroke() :a.stroke();
};
}), mxMarker.addMarker("diamond", b), mxMarker.addMarker("diamondThin", b);
}(), mxUtils.extend(mxActor, mxShape), mxActor.prototype.paintVertexShape = function(a, b, c, d, e) {
a.translate(b, c), a.begin(), this.redrawPath(a, b, c, d, e), a.fillAndStroke();
}, mxActor.prototype.redrawPath = function(a, b, c, d, e) {
b = d / 3, a.moveTo(0, e), a.curveTo(0, 3 * e / 5, 0, 2 * e / 5, d / 2, 2 * e / 5), 
a.curveTo(d / 2 - b, 2 * e / 5, d / 2 - b, 0, d / 2, 0), a.curveTo(d / 2 + b, 0, d / 2 + b, 2 * e / 5, d / 2, 2 * e / 5), 
a.curveTo(d, 2 * e / 5, d, 3 * e / 5, d, e), a.close();
}, mxUtils.extend(mxCloud, mxActor), mxCloud.prototype.redrawPath = function(a, b, c, d, e) {
a.moveTo(.25 * d, .25 * e), a.curveTo(.05 * d, .25 * e, 0, .5 * e, .16 * d, .55 * e), 
a.curveTo(0, .66 * e, .18 * d, .9 * e, .31 * d, .8 * e), a.curveTo(.4 * d, e, .7 * d, e, .8 * d, .8 * e), 
a.curveTo(d, .8 * e, d, .6 * e, .875 * d, .5 * e), a.curveTo(d, .3 * e, .8 * d, .1 * e, .625 * d, .2 * e), 
a.curveTo(.5 * d, .05 * e, .3 * d, .05 * e, .25 * d, .25 * e), a.close();
}, mxUtils.extend(mxRectangleShape, mxShape), mxRectangleShape.prototype.isHtmlAllowed = function() {
return !this.isRounded && !this.glass && 0 == this.rotation;
}, mxRectangleShape.prototype.paintBackground = function(a, b, c, d, e) {
if (this.isRounded) {
var f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100, f = Math.min(d * f, e * f);
a.roundrect(b, c, d, e, f, f);
} else a.rect(b, c, d, e);
a.fillAndStroke();
}, mxRectangleShape.prototype.paintForeground = function(a, b, c, d, e) {
this.glass && this.paintGlassEffect(a, b, c, d, e, this.getArcSize(d + this.strokewidth, e + this.strokewidth));
}, mxRectangleShape.prototype.redrawHtmlShape = function() {
this.updateHtmlBounds(this.node), this.updateHtmlFilters(this.node), this.updateHtmlColors(this.node);
}, mxRectangleShape.prototype.updateHtmlBounds = function(a) {
var b = 9 <= document.documentMode ? 0 :Math.ceil(this.strokewidth * this.scale);
a.style.borderWidth = Math.max(1, b) + "px", a.style.overflow = "hidden", a.style.left = Math.round(this.bounds.x - b / 2) + "px", 
a.style.top = Math.round(this.bounds.y - b / 2) + "px", "CSS1Compat" == document.compatMode && (b = -b), 
a.style.width = Math.round(Math.max(0, this.bounds.width + b)) + "px", a.style.height = Math.round(Math.max(0, this.bounds.height + b)) + "px";
}, mxRectangleShape.prototype.updateHtmlColors = function(a) {
var b = this.stroke;
null != b && b != mxConstants.NONE ? (a.style.borderColor = b, this.isDashed ? a.style.borderStyle = "dashed" :0 < this.strokewidth && (a.style.borderStyle = "solid"), 
a.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + "px") :a.style.borderWidth = "0px", 
b = this.fill, null != b && b != mxConstants.NONE ? (a.style.backgroundColor = b, 
a.style.backgroundImage = "none") :this.pointerEvents ? a.style.backgroundColor = "transparent" :8 == document.documentMode ? mxUtils.addTransparentBackgroundFilter(a) :this.setTransparentBackgroundImage(a);
}, mxRectangleShape.prototype.updateHtmlFilters = function(a) {
var b = "";
if (100 > this.opacity && (b += "alpha(opacity=" + this.opacity + ")"), this.isShadow && (b += "progid:DXImageTransform.Microsoft.dropShadow (OffX='" + Math.round(mxConstants.SHADOW_OFFSET_X * this.scale) + "', OffY='" + Math.round(mxConstants.SHADOW_OFFSET_Y * this.scale) + "', Color='" + mxConstants.SHADOWCOLOR + "')"), 
this.gradient) {
var c = this.fill, d = this.gradient, e = "0", f = {
east:0,
south:1,
west:2,
north:3
}, g = null != this.direction ? f[this.direction] :0;
null != this.gradientDirection && (g = mxUtils.mod(g + f[this.gradientDirection] - 1, 4)), 
1 == g ? (e = "1", f = c, c = d, d = f) :2 == g ? (f = c, c = d, d = f) :3 == g && (e = "1"), 
b += "progid:DXImageTransform.Microsoft.gradient(startColorStr='" + c + "', endColorStr='" + d + "', gradientType='" + e + "')";
}
a.style.filter = b;
}, mxUtils.extend(mxEllipse, mxShape), mxEllipse.prototype.paintVertexShape = function(a, b, c, d, e) {
a.ellipse(b, c, d, e), a.fillAndStroke();
}, mxUtils.extend(mxDoubleEllipse, mxShape), mxDoubleEllipse.prototype.vmlScale = 10, 
mxDoubleEllipse.prototype.paintBackground = function(a, b, c, d, e) {
a.ellipse(b, c, d, e), a.fillAndStroke();
}, mxDoubleEllipse.prototype.paintForeground = function(a, b, c, d, e) {
var f = Math.min(4, Math.min(d / 5, e / 5));
d -= 2 * f, e -= 2 * f, d > 0 && e > 0 && a.ellipse(b + f, c + f, d, e), a.stroke();
}, mxUtils.extend(mxRhombus, mxShape), mxRhombus.prototype.paintVertexShape = function(a, b, c, d, e) {
var f = d / 2, g = e / 2;
a.begin(), a.moveTo(b + f, c), a.lineTo(b + d, c + g), a.lineTo(b + f, c + e), a.lineTo(b, c + g), 
a.close(), a.fillAndStroke();
}, mxUtils.extend(mxPolyline, mxShape), mxPolyline.prototype.getRotation = function() {
return 0;
}, mxPolyline.prototype.paintEdgeShape = function(a, b) {
this.paintLine(a, b, this.isRounded);
}, mxPolyline.prototype.paintLine = function(a, b, c) {
var d = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2, e = b[0], f = b[b.length - 1];
a.begin(), a.moveTo(e.x, e.y);
for (var g = 1; g < b.length - 1; g++) {
var h = b[g], k = e.x - h.x, e = e.y - h.y;
if (c && g < b.length - 1 && (0 != k || 0 != e)) {
var l = Math.sqrt(k * k + e * e), k = k * Math.min(d, l / 2) / l, e = e * Math.min(d, l / 2) / l;
a.lineTo(h.x + k, h.y + e), e = b[g + 1], k = e.x - h.x, e = e.y - h.y, l = Math.max(1, Math.sqrt(k * k + e * e)), 
k = k * Math.min(d, l / 2) / l, e = e * Math.min(d, l / 2) / l, k = h.x + k, e = h.y + e, 
a.quadTo(h.x, h.y, k, e), h = new mxPoint(k, e);
} else a.lineTo(h.x, h.y);
e = h;
}
a.lineTo(f.x, f.y), a.stroke();
}, mxUtils.extend(mxArrow, mxShape), mxArrow.prototype.paintEdgeShape = function(a, b) {
var c = mxConstants.ARROW_SPACING, d = mxConstants.ARROW_WIDTH, e = mxConstants.ARROW_SIZE, f = b[0], g = b[b.length - 1], h = g.x - f.x, k = g.y - f.y, l = Math.sqrt(h * h + k * k), m = l - 2 * c - e, h = h / l, k = k / l, l = d * k / 3, d = -d * h / 3, e = f.x - l / 2 + c * h, f = f.y - d / 2 + c * k, n = e + l, p = f + d, q = n + m * h, m = p + m * k, s = q + l, r = m + d, t = s - 3 * l, u = r - 3 * d;
a.begin(), a.moveTo(e, f), a.lineTo(n, p), a.lineTo(q, m), a.lineTo(s, r), a.lineTo(g.x - c * h, g.y - c * k), 
a.lineTo(t, u), a.lineTo(t + l, u + d), a.close(), a.fillAndStroke();
}, mxUtils.extend(mxText, mxShape), mxText.prototype.baseSpacingTop = 0, mxText.prototype.baseSpacingBottom = 0, 
mxText.prototype.baseSpacingLeft = 0, mxText.prototype.baseSpacingRight = 0, mxText.prototype.replaceLinefeeds = !0, 
mxText.prototype.verticalTextRotation = -90, mxText.prototype.ignoreClippedStringSize = !0, 
mxText.prototype.ignoreStringSize = !1, mxText.prototype.isParseVml = function() {
return !1;
}, mxText.prototype.isHtmlAllowed = function() {
return 8 != document.documentMode;
}, mxText.prototype.getSvgScreenOffset = function() {
return 0;
}, mxText.prototype.checkBounds = function() {
return !(null == this.bounds || isNaN(this.bounds.x) || isNaN(this.bounds.y) || isNaN(this.bounds.width) || isNaN(this.bounds.height));
}, mxText.prototype.updateBoundingBox = function() {
var a = this.node;
8 == document.documentMode && null != a.firstChild && (a = a.firstChild, null != a.firstChild && (a = a.firstChild)), 
this.boundingBox = this.bounds.clone();
var b = this.getTextRotation();
if (this.ignoreStringSize || null == a || "fill" == this.overflow || this.clipped && this.ignoreClippedStringSize) this.boundingBox.x += this.margin.x * this.boundingBox.width, 
this.boundingBox.y += this.margin.y * this.boundingBox.height; else {
var c = null, d = null;
if (null != a.ownerSVGElement) if (null != a.firstChild && null != a.firstChild.firstChild && "foreignObject" == a.firstChild.firstChild.nodeName) a = a.firstChild.firstChild, 
c = this.wrap ? this.bounds.width :parseInt(a.getAttribute("width")) * this.scale, 
d = parseInt(a.getAttribute("height")) * this.scale; else {
if (b = a.getBBox(), 0 == b.width && 0 == b.height) return;
this.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height), b = 0;
} else d = this.state.view.textDiv, null != this.offsetWidth && null != this.offsetHeight ? (c = this.wrap ? this.bounds.width :this.offsetWidth * this.scale, 
d = this.offsetHeight * this.scale) :null != d ? (this.updateFont(d), this.updateSize(d), 
mxUtils.isNode(this.value) ? d.innerHTML = this.value.outerHTML :(c = this.replaceLinefeeds ? this.value.replace(/\n/g, "<br/>") :this.value, 
d.innerHTML = c), c = this.wrap ? this.bounds.width :d.offsetWidth * this.scale, 
d = d.offsetHeight * this.scale) :(c = this.wrap ? this.bounds.width :a.offsetWidth * this.scale, 
d = a.offsetHeight * this.scale);
null != c && null != d && (this.boundingBox = new mxRectangle(this.bounds.x + this.margin.x * c, this.bounds.y + this.margin.y * d, c, d));
}
null != this.boundingBox && (0 != b && (b = mxUtils.getBoundingBox(this.boundingBox, b), 
this.boundingBox.x = b.x, this.boundingBox.y = b.y, mxClient.IS_QUIRKS || (this.boundingBox.width = b.width, 
this.boundingBox.height = b.height)), this.boundingBox.x = Math.floor(this.boundingBox.x), 
this.boundingBox.y = Math.floor(this.boundingBox.y), this.boundingBox.width = Math.ceil(this.boundingBox.width), 
this.boundingBox.height = Math.ceil(this.boundingBox.height));
}, mxText.prototype.getShapeRotation = function() {
return 0;
}, mxText.prototype.getTextRotation = function() {
return null != this.state && null != this.state.shape ? this.state.shape.getTextRotation() :0;
}, mxText.prototype.isPaintBoundsInverted = function() {
return !this.horizontal && null != this.state && this.state.view.graph.model.isVertex(this.state.cell);
}, mxText.prototype.configureCanvas = function(a) {
mxShape.prototype.configureCanvas.apply(this, arguments), a.setFontColor(this.color), 
a.setFontBackgroundColor(this.background), a.setFontBorderColor(this.border), a.setFontFamily(this.family), 
a.setFontSize(this.size), a.setFontStyle(this.fontStyle);
}, mxText.prototype.updateVmlContainer = function() {
this.node.style.left = Math.round(this.bounds.x) + "px", this.node.style.top = Math.round(this.bounds.y) + "px", 
this.node.style.width = "1px", this.node.style.height = "1px", this.node.style.overflow = "visible";
}, mxText.prototype.paint = function(a) {
var b = this.scale, c = this.bounds.x / b, d = this.bounds.y / b, e = this.bounds.width / b, b = this.bounds.height / b;
this.updateTransform(a, c, d, e, b), this.configureCanvas(a, c, d, e, b);
var f = mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML, g = f || a instanceof mxVmlCanvas2D ? "html" :"", h = this.value;
!f && "html" == g && (h = mxUtils.htmlEntities(h, !1)), h = !mxUtils.isNode(this.value) && this.replaceLinefeeds && "html" == g ? h.replace(/\n/g, "<br/>") :h, 
a.text(c, d, e, b, h, this.align, this.valign, this.wrap, g, this.overflow, this.clipped, this.getTextRotation());
}, mxText.prototype.redrawHtmlShape = function() {
var a = this.node.style;
a.opacity = 1 > this.opacity ? this.opacity :"", a.overflow = "", a.width = "", 
a.height = "", this.updateFont(this.node), this.updateSize(this.node), this.updateValue(), 
this.offsetHeight = this.offsetWidth = null, null != mxClient.CSS_PREFIX ? this.updateHtmlTransform() :this.updateHtmlFilter();
}, mxText.prototype.updateHtmlTransform = function() {
var a = this.getTextRotation(), b = this.node.style, c = this.margin.x, d = this.margin.y;
0 != a ? (b[mxClient.CSS_PREFIX + "TransformOrigin"] = 100 * -c + "% " + 100 * -d + "%", 
b[mxClient.CSS_PREFIX + "Transform"] = "translate(" + 100 * c + "%," + 100 * d + "%)scale(" + this.scale + ") rotate(" + a + "deg)") :(b[mxClient.CSS_PREFIX + "TransformOrigin"] = "0% 0%", 
b[mxClient.CSS_PREFIX + "Transform"] = "scale(" + this.scale + ")translate(" + 100 * c + "%," + 100 * d + "%)"), 
b.left = Math.round(this.bounds.x) + "px", b.top = Math.round(this.bounds.y) + "px";
}, mxText.prototype.updateHtmlFilter = function() {
var a = this.node.style, b = this.margin.x, c = this.margin.y, d = this.scale;
a.filter = "";
var e = 0, f = 0, g = null != this.state ? this.state.view.textDiv :null;
if (null != g) {
if (g.style.overflow = "", g.style.height = "", g.style.width = "", this.updateFont(g), 
this.updateSize(g), mxUtils.isNode(this.value)) g.innerHTML = this.value.outerHTML; else {
var h = this.value;
this.dialect != mxConstants.DIALECT_STRICTHTML && (h = mxUtils.htmlEntities(h, !1)), 
h = this.replaceLinefeeds ? h.replace(/\n/g, "<br/>") :h, g.innerHTML = h;
}
e = g.offsetWidth + 2, f = g.offsetHeight + 2;
} else e = this.node.offsetWidth, f = this.node.offsetHeight + 1;
this.offsetWidth = e, this.offsetHeight = f, g = this.bounds.width / d, h = this.bounds.height / d, 
mxClient.IS_QUIRKS && (this.clipped || "width" == this.overflow) && h > 0 ? (h = Math.min(h, f), 
a.height = Math.round(h) + "px") :h = f, "fill" != this.overflow && "width" != this.overflow && (mxClient.IS_QUIRKS && (this.clipped || this.wrap) && g > 0 ? (g = Math.min(g, e), 
a.width = Math.round(g) + "px") :g = e);
var h = h * d, g = g * d, e = this.getTextRotation() * (Math.PI / 180), f = parseFloat(parseFloat(Math.cos(e)).toFixed(8)), k = parseFloat(parseFloat(Math.sin(-e)).toFixed(8)), e = e % (2 * Math.PI);
0 > e && (e += 2 * Math.PI), e %= Math.PI, e > Math.PI / 2 && (e = Math.PI - e);
var l = Math.cos(e), m = Math.sin(-e), b = g * -(b + .5), c = h * -(c + .5), n = (h - h * l + g * m) / 2 + k * b - f * c;
0 != e && (a.filter = "progid:DXImageTransform.Microsoft.Matrix(M11=" + f + ", M12=" + k + ", M21=" + -k + ", M22=" + f + ", sizingMethod='auto expand')"), 
a.zoom = d, a.left = Math.round(this.bounds.x + ((g - g * l + h * m) / 2 - f * b - k * c) - g / 2) + "px", 
a.top = Math.round(this.bounds.y + n - h / 2) + "px";
}, mxText.prototype.updateValue = function() {
if (mxUtils.isNode(this.value)) this.node.innerHTML = "", this.node.appendChild(this.value); else {
var a = this.value;
this.dialect != mxConstants.DIALECT_STRICTHTML && (a = mxUtils.htmlEntities(a, !1));
var a = this.replaceLinefeeds ? a.replace(/\n/g, "<br/>") :a, b = null != this.background && this.background != mxConstants.NONE ? this.background :null, c = null != this.border && this.border != mxConstants.NONE ? this.border :null;
if (null != b || null != c) if ("fill" == this.overflow || "width" == this.overflow) null != b && (this.node.style.backgroundColor = b), 
null != c && (this.node.style.border = "1px solid " + c); else {
var d = "";
null != b && (d += "background-color:" + b + ";"), null != c && (d += "border:1px solid " + c + ";"), 
a = '<div style="zoom:1;' + d + "display:inline-block;_display:inline;padding-bottom:1px;padding-right:1px;line-height:" + this.node.style.lineHeight + '">' + a + "</div>", 
this.node.style.lineHeight = "";
}
this.node.innerHTML = a;
}
}, mxText.prototype.updateFont = function(a) {
a = a.style, a.lineHeight = Math.round(this.size * mxConstants.LINE_HEIGHT) + "px", 
a.fontSize = Math.round(this.size) + "px", a.fontFamily = this.family, a.verticalAlign = "top", 
a.color = this.color, a.fontWeight = (this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD ? "bold" :"", 
a.fontStyle = (this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC ? "italic" :"", 
a.textDecoration = (this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE ? "underline" :"", 
a.textAlign = this.align == mxConstants.ALIGN_CENTER ? "center" :this.align == mxConstants.ALIGN_RIGHT ? "right" :"left";
}, mxText.prototype.updateSize = function(a) {
var b = Math.round(this.bounds.width / this.scale), c = Math.round(this.bounds.height / this.scale);
a = a.style, this.clipped ? (a.overflow = "hidden", c > 0 && (a.maxHeight = c + "px"), 
b > 0 && (a.width = b + "px")) :"fill" == this.overflow ? (a.width = b + "px", a.height = c + "px") :"width" == this.overflow && (a.width = b + "px", 
c > 0 && (a.maxHeight = c + "px")), this.wrap && b > 0 ? (this.clipped || (a.width = b + "px"), 
a.whiteSpace = "normal") :a.whiteSpace = "nowrap";
}, mxText.prototype.updateMargin = function() {
this.margin = mxUtils.getAlignmentAsPoint(this.align, this.valign);
}, mxText.prototype.getSpacing = function() {
var a = 0, b = 0, a = this.align == mxConstants.ALIGN_CENTER ? (this.spacingLeft - this.spacingRight) / 2 :this.align == mxConstants.ALIGN_RIGHT ? -this.spacingRight - this.baseSpacingRight :this.spacingLeft + this.baseSpacingLeft, b = this.valign == mxConstants.ALIGN_MIDDLE ? (this.spacingTop - this.spacingBottom) / 2 :this.valign == mxConstants.ALIGN_BOTTOM ? -this.spacingBottom - this.baseSpacingBottom :this.spacingTop + this.baseSpacingTop;
return new mxPoint(a, b);
}, mxUtils.extend(mxTriangle, mxActor), mxTriangle.prototype.redrawPath = function(a, b, c, d, e) {
a.moveTo(0, 0), a.lineTo(d, .5 * e), a.lineTo(0, e), a.close();
}, mxUtils.extend(mxHexagon, mxActor), mxHexagon.prototype.redrawPath = function(a, b, c, d, e) {
a.moveTo(.25 * d, 0), a.lineTo(.75 * d, 0), a.lineTo(d, .5 * e), a.lineTo(.75 * d, e), 
a.lineTo(.25 * d, e), a.lineTo(0, .5 * e), a.close();
}, mxUtils.extend(mxLine, mxShape), mxLine.prototype.paintVertexShape = function(a, b, c, d, e) {
c += e / 2, a.begin(), a.moveTo(b, c), a.lineTo(b + d, c), a.stroke();
}, mxUtils.extend(mxImageShape, mxRectangleShape), mxImageShape.prototype.preserveImageAspect = !0, 
mxImageShape.prototype.getSvgScreenOffset = function() {
return mxClient.IS_IE ? 0 :.5;
}, mxImageShape.prototype.apply = function() {
mxShape.prototype.apply.apply(this, arguments), this.gradient = this.stroke = this.fill = null, 
null != this.style && (this.fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND), 
this.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER), this.preserveImageAspect = 1 == mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_ASPECT, 1), 
this.flipH = this.flipH || 1 == mxUtils.getValue(this.style, "imageFlipH", 0), this.flipV = this.flipV || 1 == mxUtils.getValue(this.style, "imageFlipV", 0));
}, mxImageShape.prototype.isHtmlAllowed = function() {
return !this.preserveImageAspect;
}, mxImageShape.prototype.createHtml = function() {
var a = document.createElement("div");
return a.style.position = "absolute", a;
}, mxImageShape.prototype.paintVertexShape = function(a, b, c, d, e) {
if (null != this.image) {
var f = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null), g = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);
(null != f || null != g) && (a.setFillColor(f), a.setStrokeColor(g), a.rect(b, c, d, e), 
a.fillAndStroke()), a.image(b, c, d, e, this.image, this.preserveImageAspect, !1, !1);
} else mxRectangleShape.prototype.paintBackground.apply(this, arguments);
}, mxImageShape.prototype.redrawHtmlShape = function() {
if (this.node.style.left = Math.round(this.bounds.x) + "px", this.node.style.top = Math.round(this.bounds.y) + "px", 
this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + "px", this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + "px", 
this.node.style.backgroundColor = this.fill || "", this.node.style.borderColor = this.stroke || "", 
this.node.innerHTML = "", null != this.image) {
var a = document.createElement(mxClient.IS_IE6 || null == mxClient.CSS_PREFIX && 0 != this.rotation ? mxClient.VML_PREFIX + ":image" :"img");
a.style.position = "absolute", a.src = this.image;
var b = 100 > this.opacity ? "alpha(opacity=" + this.opacity + ")" :"";
this.node.style.filter = b, this.flipH && this.flipV ? b += "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)" :this.flipH ? b += "progid:DXImageTransform.Microsoft.BasicImage(mirror=1)" :this.flipV && (b += "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)"), 
a.style.filter != b && (a.style.filter = b), "image" == a.nodeName ? a.style.rotation = this.rotation :a.style[mxClient.CSS_PREFIX + "Transform"] = "rotate(" + this.rotation + "deg)", 
a.style.width = this.node.style.width, a.style.height = this.node.style.height, 
this.node.style.backgroundImage = "", this.node.appendChild(a);
} else this.setTransparentBackgroundImage(this.node);
}, mxUtils.extend(mxLabel, mxRectangleShape), mxLabel.prototype.imageSize = mxConstants.DEFAULT_IMAGESIZE, 
mxLabel.prototype.spacing = 2, mxLabel.prototype.indicatorSize = 10, mxLabel.prototype.indicatorSpacing = 2, 
mxLabel.prototype.init = function() {
mxShape.prototype.init.apply(this, arguments), null != this.indicatorColor && null != this.indicatorShape && (this.indicator = new this.indicatorShape(), 
this.indicator.dialect = this.dialect, this.indicator.bounds = this.bounds, this.indicator.fill = this.indicatorColor, 
this.indicator.stroke = this.indicatorColor, this.indicator.gradient = this.indicatorGradientColor, 
this.indicator.direction = this.indicatorDirection, this.indicator.init(this.node));
}, mxLabel.prototype.redraw = function() {
null != this.indicator && (this.indicator.fill = this.indicatorColor, this.indicator.stroke = this.indicatorColor, 
this.indicator.gradient = this.indicatorGradientColor, this.indicator.direction = this.indicatorDirection), 
mxShape.prototype.redraw.apply(this, arguments);
}, mxLabel.prototype.isHtmlAllowed = function() {
return mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) && null == this.indicatorColor && null == this.indicatorShape;
}, mxLabel.prototype.paintForeground = function(a, b, c, d, e) {
this.paintImage(a, b, c, d, e), this.paintIndicator(a, b, c, d, e), mxRectangleShape.prototype.paintForeground.apply(this, arguments);
}, mxLabel.prototype.paintImage = function(a, b, c, d, e) {
null != this.image && (b = this.getImageBounds(b, c, d, e), a.image(b.x, b.y, b.width, b.height, this.image, !1, !1, !1));
}, mxLabel.prototype.getImageBounds = function(a, b, c, d) {
var e = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT), f = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE), g = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_WIDTH, mxConstants.DEFAULT_IMAGESIZE), h = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_HEIGHT, mxConstants.DEFAULT_IMAGESIZE), k = mxUtils.getNumber(this.style, mxConstants.STYLE_SPACING, this.spacing) + 5;
return a = e == mxConstants.ALIGN_CENTER ? a + (c - g) / 2 :e == mxConstants.ALIGN_RIGHT ? a + (c - g - k) :a + k, 
b = f == mxConstants.ALIGN_TOP ? b + k :f == mxConstants.ALIGN_BOTTOM ? b + (d - h - k) :b + (d - h) / 2, 
new mxRectangle(a, b, g, h);
}, mxLabel.prototype.paintIndicator = function(a, b, c, d, e) {
null != this.indicator ? (this.indicator.bounds = this.getIndicatorBounds(b, c, d, e), 
this.indicator.paint(a)) :null != this.indicatorImage && (b = this.getIndicatorBounds(b, c, d, e), 
a.image(b.x, b.y, b.width, b.height, this.indicatorImage, !1, !1, !1));
}, mxLabel.prototype.getIndicatorBounds = function(a, b, c, d) {
var e = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT), f = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE), g = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_WIDTH, this.indicatorSize), h = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_HEIGHT, this.indicatorSize), k = this.spacing + 5;
return a = e == mxConstants.ALIGN_RIGHT ? a + (c - g - k) :e == mxConstants.ALIGN_CENTER ? a + (c - g) / 2 :a + k, 
b = f == mxConstants.ALIGN_BOTTOM ? b + (d - h - k) :f == mxConstants.ALIGN_TOP ? b + k :b + (d - h) / 2, 
new mxRectangle(a, b, g, h);
}, mxLabel.prototype.redrawHtmlShape = function() {
for (mxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments); this.node.hasChildNodes(); ) this.node.removeChild(this.node.lastChild);
if (null != this.image) {
var a = document.createElement("img");
a.style.position = "relative", a.setAttribute("border", "0");
var b = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
b.x -= this.bounds.x, b.y -= this.bounds.y, a.style.left = Math.round(b.x) + "px", 
a.style.top = Math.round(b.y) + "px", a.style.width = Math.round(b.width) + "px", 
a.style.height = Math.round(b.height) + "px", a.src = this.image, this.node.appendChild(a);
}
}, mxUtils.extend(mxCylinder, mxShape), mxCylinder.prototype.maxHeight = 40, mxCylinder.prototype.svgStrokeTolerance = 0, 
mxCylinder.prototype.paintVertexShape = function(a, b, c, d, e) {
a.translate(b, c), a.begin(), this.redrawPath(a, b, c, d, e, !1), a.fillAndStroke(), 
a.setShadow(!1), a.begin(), this.redrawPath(a, b, c, d, e, !0), a.stroke();
}, mxCylinder.prototype.redrawPath = function(a, b, c, d, e, f) {
b = Math.min(this.maxHeight, Math.round(e / 5)), (f && null != this.fill || !f && null == this.fill) && (a.moveTo(0, b), 
a.curveTo(0, 2 * b, d, 2 * b, d, b), f || (a.stroke(), a.begin())), f || (a.moveTo(0, b), 
a.curveTo(0, -b / 3, d, -b / 3, d, b), a.lineTo(d, e - b), a.curveTo(d, e + b / 3, 0, e + b / 3, 0, e - b), 
a.close());
}, mxUtils.extend(mxConnector, mxPolyline), mxConnector.prototype.paintEdgeShape = function(a, b) {
var c = this.createMarker(a, b, !0), d = this.createMarker(a, b, !1);
null == this.style || 1 != this.style[mxConstants.STYLE_CURVED] ? this.paintLine(a, b, this.isRounded) :this.paintCurvedLine(a, b), 
a.setFillColor(this.stroke), a.setShadow(!1), a.setDashed(!1), null != c && c(), 
null != d && d();
}, mxConnector.prototype.paintCurvedLine = function(a, b) {
a.begin();
var c = b[0], d = b.length;
for (a.moveTo(c.x, c.y), c = 1; d - 2 > c; c++) {
var e = b[c], f = b[c + 1];
a.quadTo(e.x, e.y, (e.x + f.x) / 2, (e.y + f.y) / 2);
}
e = b[d - 2], f = b[d - 1], a.quadTo(e.x, e.y, f.x, f.y), a.stroke();
}, mxConnector.prototype.createMarker = function(a, b, c) {
var d = b.length, e = c ? b[1] :b[d - 2];
b = c ? b[0] :b[d - 1];
var d = b.x - e.x, f = b.y - e.y, g = Math.max(1, Math.sqrt(d * d + f * f)), e = d / g, d = f / g, f = mxUtils.getNumber(this.style, c ? mxConstants.STYLE_STARTSIZE :mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE), g = mxUtils.getValue(this.style, c ? mxConstants.STYLE_STARTARROW :mxConstants.STYLE_ENDARROW);
return mxMarker.createMarker(a, this, g, b, e, d, f, c, this.strokewidth, 0 != this.style[c ? mxConstants.STYLE_STARTFILL :mxConstants.STYLE_ENDFILL]);
}, mxConnector.prototype.augmentBoundingBox = function(a) {
mxShape.prototype.augmentBoundingBox.apply(this, arguments);
var b = 0;
mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE && (b = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1), 
mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE && (b = Math.max(b, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1), 
a.grow(Math.ceil(b * this.scale));
}, mxUtils.extend(mxSwimlane, mxShape), mxSwimlane.prototype.imageSize = 16, mxSwimlane.prototype.getGradientBounds = function(a, b, c, d, e) {
return a = Math.min(e, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE)), 
new mxRectangle(b, c, d, a);
}, mxSwimlane.prototype.getRotation = function() {
var a = mxShape.prototype.getRotation.apply(this, arguments);
return 1 != mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) && (a += mxText.prototype.verticalTextRotation), 
a;
}, mxSwimlane.prototype.getTextRotation = function() {
return this.getRotation();
}, mxSwimlane.prototype.isPaintBoundsInverted = function() {
return mxShape.prototype.isPaintBoundsInverted.apply(this, arguments) || 1 != mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1);
}, mxSwimlane.prototype.getArcSize = function(a, b, c) {
return a = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100, 
3 * c * a;
}, mxSwimlane.prototype.paintVertexShape = function(a, b, c, d, e) {
var f = Math.min(e, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE)), g = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE), h = 1 == mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1), k = 0;
a.translate(b, c), this.isRounded ? (k = this.getArcSize(d, e, f), this.paintRoundedSwimlane(a, b, c, d, e, f, k, g, h)) :this.paintSwimlane(a, b, c, d, e, f, g, h), 
g = mxUtils.getValue(this.style, mxConstants.STYLE_SEPARATORCOLOR, mxConstants.NONE), 
this.paintSeparator(a, d, f, e, g), null != this.image && (e = this.getImageBounds(b, c, d, e), 
a.image(e.x - b, e.y - c, e.width, e.height, this.image, !1, !1, !1)), this.glass && (a.setShadow(!1), 
this.paintGlassEffect(a, 0, 0, d, f, k));
}, mxSwimlane.prototype.paintSwimlane = function(a, b, c, d, e, f, g, h) {
g != mxConstants.NONE && (a.save(), a.setFillColor(g), a.rect(0, 0, d, e), a.fillAndStroke(), 
a.restore(), a.setShadow(!1)), a.begin(), a.moveTo(0, f), a.lineTo(0, 0), a.lineTo(d, 0), 
a.lineTo(d, f), h && a.close(), a.fillAndStroke(), e > f && g == mxConstants.NONE && (a.pointerEvents = !1, 
a.begin(), a.moveTo(0, f), a.lineTo(0, e), a.lineTo(d, e), a.lineTo(d, f), a.stroke());
}, mxSwimlane.prototype.paintRoundedSwimlane = function(a, b, c, d, e, f, g, h, k) {
h != mxConstants.NONE && (a.save(), a.setFillColor(h), a.roundrect(0, 0, d, e, g, g), 
a.fillAndStroke(), a.restore(), a.setShadow(!1)), a.begin(), a.moveTo(d, f), a.lineTo(d, g), 
a.quadTo(d, 0, d - Math.min(d / 2, g), 0), a.lineTo(Math.min(d / 2, g), 0), a.quadTo(0, 0, 0, g), 
a.lineTo(0, f), k && a.close(), a.fillAndStroke(), e > f && h == mxConstants.NONE && (a.pointerEvents = !1, 
a.begin(), a.moveTo(0, f), a.lineTo(0, e - g), a.quadTo(0, e, Math.min(d / 2, g), e), 
a.lineTo(d - Math.min(d / 2, g), e), a.quadTo(d, e, d, e - g), a.lineTo(d, f), a.stroke());
}, mxSwimlane.prototype.paintSeparator = function(a, b, c, d, e) {
e != mxConstants.NONE && (a.setStrokeColor(e), a.setDashed(!0), a.begin(), a.moveTo(b, c), 
a.lineTo(b, d), a.stroke(), a.setDashed(!1));
}, mxSwimlane.prototype.getImageBounds = function(a, b, c) {
return new mxRectangle(a + c - this.imageSize, b, this.imageSize, this.imageSize);
}, mxGraphLayout.prototype.graph = null, mxGraphLayout.prototype.useBoundingBox = !0, 
mxGraphLayout.prototype.parent = null, mxGraphLayout.prototype.moveCell = function() {}, 
mxGraphLayout.prototype.execute = function() {}, mxGraphLayout.prototype.getGraph = function() {
return this.graph;
}, mxGraphLayout.prototype.getConstraint = function(a, b, c) {
return c = this.graph.view.getState(b), b = null != c ? c.style :this.graph.getCellStyle(b), 
null != b ? b[a] :null;
}, mxGraphLayout.traverse = function(a, b, c, d, e) {
if (null != c && null != a) {
b = null != b ? b :!0, e = e || [];
var f = mxCellPath.create(a);
if (null == e[f] && (e[f] = a, d = c(a, d), null == d || d) && (d = this.graph.model.getEdgeCount(a), 
d > 0)) for (f = 0; d > f; f++) {
var g = this.graph.model.getEdgeAt(a, f), h = this.graph.model.getTerminal(g, !0) == a;
(!b || h) && (h = this.graph.view.getVisibleTerminal(g, !h), this.traverse(h, b, c, g, e));
}
}
}, mxGraphLayout.prototype.isVertexMovable = function(a) {
return this.graph.isCellMovable(a);
}, mxGraphLayout.prototype.isVertexIgnored = function(a) {
return !this.graph.getModel().isVertex(a) || !this.graph.isCellVisible(a);
}, mxGraphLayout.prototype.isEdgeIgnored = function(a) {
var b = this.graph.getModel();
return !b.isEdge(a) || !this.graph.isCellVisible(a) || null == b.getTerminal(a, !0) || null == b.getTerminal(a, !1);
}, mxGraphLayout.prototype.setEdgeStyleEnabled = function(a, b) {
this.graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE, b ? "0" :"1", [ a ]);
}, mxGraphLayout.prototype.setOrthogonalEdge = function(a, b) {
this.graph.setCellStyles(mxConstants.STYLE_ORTHOGONAL, b ? "1" :"0", [ a ]);
}, mxGraphLayout.prototype.getParentOffset = function(a) {
var b = new mxPoint();
if (null != a && a != this.parent) {
var c = this.graph.getModel();
if (c.isAncestor(this.parent, a)) for (var d = c.getGeometry(a); a != this.parent; ) b.x += d.x, 
b.y += d.y, a = c.getParent(a), d = c.getGeometry(a);
}
return b;
}, mxGraphLayout.prototype.setEdgePoints = function(a, b) {
if (null != a) {
var c = this.graph.model, d = c.getGeometry(a);
if (null == d ? (d = new mxGeometry(), d.setRelative(!0)) :d = d.clone(), null != this.parent && null != b) for (var e = c.getParent(a), e = this.getParentOffset(e), f = 0; f < b.length; f++) b[f].x -= e.x, 
b[f].y -= e.y;
d.points = b, c.setGeometry(a, d);
}
}, mxGraphLayout.prototype.setVertexLocation = function(a, b, c) {
var d = this.graph.getModel(), e = d.getGeometry(a), f = null;
if (null != e) {
if (f = new mxRectangle(b, c, e.width, e.height), this.useBoundingBox) {
var g = this.graph.getView().getState(a);
if (null != g && null != g.text && null != g.text.boundingBox) {
var h = this.graph.getView().scale, k = g.text.boundingBox;
g.text.boundingBox.x < g.x && (b += (g.x - k.x) / h, f.width = k.width), g.text.boundingBox.y < g.y && (c += (g.y - k.y) / h, 
f.height = k.height);
}
}
null != this.parent && (g = d.getParent(a), null != g && g != this.parent && (g = this.getParentOffset(g), 
b -= g.x, c -= g.y)), (e.x != b || e.y != c) && (e = e.clone(), e.x = b, e.y = c, 
d.setGeometry(a, e));
}
return f;
}, mxGraphLayout.prototype.getVertexBounds = function(a) {
var b = this.graph.getModel().getGeometry(a);
if (this.useBoundingBox) {
var c = this.graph.getView().getState(a);
if (null != c && null != c.text && null != c.text.boundingBox) var d = this.graph.getView().scale, e = c.text.boundingBox, f = Math.max(c.x - e.x, 0) / d, g = Math.max(c.y - e.y, 0) / d, h = Math.max(e.x + e.width - (c.x + c.width), 0) / d, c = Math.max(e.y + e.height - (c.y + c.height), 0) / d, b = new mxRectangle(b.x - f, b.y - g, b.width + f + h, b.height + g + c);
}
return null != this.parent && (a = this.graph.getModel().getParent(a), b = b.clone(), 
null != a && a != this.parent && (a = this.getParentOffset(a), b.x += a.x, b.y += a.y)), 
new mxRectangle(b.x, b.y, b.width, b.height);
}, mxGraphLayout.prototype.arrangeGroups = function(a, b) {
this.graph.getModel().beginUpdate();
try {
for (var c = a.length - 1; c >= 0; c--) {
var d = a[c], e = this.graph.getChildVertices(d), f = this.graph.getBoundingBoxFromGeometry(e), g = this.graph.getCellGeometry(d), h = 0, k = 0;
if (this.graph.isSwimlane(d)) var l = this.graph.getStartSize(d), h = l.width, k = l.height;
null != f && null != g && (g = g.clone(), g.x = g.x + f.x - b - h, g.y = g.y + f.y - b - k, 
g.width = f.width + 2 * b + h, g.height = f.height + 2 * b + k, this.graph.getModel().setGeometry(d, g), 
this.graph.moveCells(e, b + h - f.x, b + k - f.y));
}
} finally {
this.graph.getModel().endUpdate();
}
}, mxStackLayout.prototype = new mxGraphLayout(), mxStackLayout.prototype.constructor = mxStackLayout, 
mxStackLayout.prototype.horizontal = null, mxStackLayout.prototype.spacing = null, 
mxStackLayout.prototype.x0 = null, mxStackLayout.prototype.y0 = null, mxStackLayout.prototype.border = 0, 
mxStackLayout.prototype.keepFirstLocation = !1, mxStackLayout.prototype.fill = !1, 
mxStackLayout.prototype.resizeParent = !1, mxStackLayout.prototype.resizeLast = !1, 
mxStackLayout.prototype.wrap = null, mxStackLayout.prototype.isHorizontal = function() {
return this.horizontal;
}, mxStackLayout.prototype.moveCell = function(a, b, c) {
var d = this.graph.getModel(), e = d.getParent(a), f = this.isHorizontal();
if (null != a && null != e) {
var g = 0, h = 0, k = d.getChildCount(e);
for (b = f ? b :c, g = this.graph.getView().getState(e), null != g && (b -= f ? g.x :g.y), 
g = 0; k > g; g++) if (c = d.getChildAt(e, g), c != a && (c = d.getGeometry(c), 
null != c)) {
if (c = f ? c.x + c.width / 2 :c.y + c.height / 2, b > h && c > b) break;
h = c;
}
f = e.getIndex(a), f = Math.max(0, g - (g > f ? 1 :0)), d.add(e, a, f);
}
}, mxStackLayout.prototype.getParentSize = function(a) {
var b = this.graph.getModel(), c = b.getGeometry(a);
return null != this.graph.container && (null == c && b.isLayer(a) || a == this.graph.getView().currentRoot) && (c = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1)), 
c;
}, mxStackLayout.prototype.execute = function(a) {
if (null != a) {
var b = this.isHorizontal(), c = this.graph.getModel(), d = this.getParentSize(a), e = null;
null != d && (e = b ? d.height :d.width);
var e = e - (2 * this.spacing + 2 * this.border), f = this.x0 + this.border, g = this.y0 + this.border;
if (this.graph.isSwimlane(a)) {
var h = this.graph.getCellStyle(a), k = mxUtils.getNumber(h, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE), h = 1 == mxUtils.getValue(h, mxConstants.STYLE_HORIZONTAL, !0);
null != d && (k = h ? Math.min(k, d.height) :Math.min(k, d.width)), b == h && (e -= k), 
h ? g += k :f += k;
}
c.beginUpdate();
try {
for (var k = 0, h = null, l = c.getChildCount(a), m = 0; l > m; m++) {
var n = c.getChildAt(a, m);
if (!this.isVertexIgnored(n) && this.isVertexMovable(n)) {
var p = c.getGeometry(n);
null != p && (p = p.clone(), null != this.wrap && null != h && (b && h.x + h.width + p.width + 2 * this.spacing > this.wrap || !b && h.y + h.height + p.height + 2 * this.spacing > this.wrap) && (h = null, 
b ? g += k + this.spacing :f += k + this.spacing, k = 0), k = Math.max(k, b ? p.height :p.width), 
null != h ? b ? p.x = h.x + h.width + this.spacing :p.y = h.y + h.height + this.spacing :this.keepFirstLocation || (b ? p.x = f :p.y = g), 
b ? p.y = g :p.x = f, this.fill && null != e && (b ? p.height = e :p.width = e), 
c.setGeometry(n, p), h = p);
}
}
this.resizeParent && null != d && null != h && !this.graph.isCellCollapsed(a) ? (d = d.clone(), 
b ? d.width = h.x + h.width + this.spacing :d.height = h.y + h.height + this.spacing, 
c.setGeometry(a, d)) :this.resizeLast && null != d && null != h && (b ? h.width = d.width - h.x - this.spacing :h.height = d.height - h.y - this.spacing);
} finally {
c.endUpdate();
}
}
}, mxPartitionLayout.prototype = new mxGraphLayout(), mxPartitionLayout.prototype.constructor = mxPartitionLayout, 
mxPartitionLayout.prototype.horizontal = null, mxPartitionLayout.prototype.spacing = null, 
mxPartitionLayout.prototype.border = null, mxPartitionLayout.prototype.resizeVertices = !0, 
mxPartitionLayout.prototype.isHorizontal = function() {
return this.horizontal;
}, mxPartitionLayout.prototype.moveCell = function(a, b, c) {
c = this.graph.getModel();
var d = c.getParent(a);
if (null != a && null != d) {
for (var e = 0, f = 0, g = c.getChildCount(d), e = 0; g > e; e++) {
var h = c.getChildAt(d, e), h = this.getVertexBounds(h);
if (null != h) {
if (h = h.x + h.width / 2, b > f && h > b) break;
f = h;
}
}
b = d.getIndex(a), b = Math.max(0, e - (e > b ? 1 :0)), c.add(d, a, b);
}
}, mxPartitionLayout.prototype.execute = function(a) {
var b = this.isHorizontal(), c = this.graph.getModel(), d = c.getGeometry(a);
if (null != this.graph.container && (null == d && c.isLayer(a) || a == this.graph.getView().currentRoot) && (d = new mxRectangle(0, 0, this.graph.container.offsetWidth - 1, this.graph.container.offsetHeight - 1)), 
null != d) {
for (var e = [], f = c.getChildCount(a), g = 0; f > g; g++) {
var h = c.getChildAt(a, g);
!this.isVertexIgnored(h) && this.isVertexMovable(h) && e.push(h);
}
if (f = e.length, f > 0) {
var k = this.border, l = this.border, m = b ? d.height :d.width, m = m - 2 * this.border;
if (a = this.graph.isSwimlane(a) ? this.graph.getStartSize(a) :new mxRectangle(), 
m -= b ? a.height :a.width, k += a.width, l += a.height, a = this.border + (f - 1) * this.spacing, 
d = b ? (d.width - k - a) / f :(d.height - l - a) / f, d > 0) {
c.beginUpdate();
try {
for (g = 0; f > g; g++) {
var h = e[g], n = c.getGeometry(h);
null != n && (n = n.clone(), n.x = k, n.y = l, b ? (this.resizeVertices && (n.width = d, 
n.height = m), k += d + this.spacing) :(this.resizeVertices && (n.height = d, n.width = m), 
l += d + this.spacing), c.setGeometry(h, n));
}
} finally {
c.endUpdate();
}
}
}
}
}, mxCompactTreeLayout.prototype = new mxGraphLayout(), mxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout, 
mxCompactTreeLayout.prototype.horizontal = null, mxCompactTreeLayout.prototype.invert = null, 
mxCompactTreeLayout.prototype.resizeParent = !0, mxCompactTreeLayout.prototype.groupPadding = 10, 
mxCompactTreeLayout.prototype.parentsChanged = null, mxCompactTreeLayout.prototype.moveTree = !1, 
mxCompactTreeLayout.prototype.levelDistance = 10, mxCompactTreeLayout.prototype.nodeDistance = 20, 
mxCompactTreeLayout.prototype.resetEdges = !0, mxCompactTreeLayout.prototype.prefHozEdgeSep = 5, 
mxCompactTreeLayout.prototype.prefVertEdgeOff = 4, mxCompactTreeLayout.prototype.minEdgeJetty = 8, 
mxCompactTreeLayout.prototype.channelBuffer = 4, mxCompactTreeLayout.prototype.edgeRouting = !0, 
mxCompactTreeLayout.prototype.sortEdges = !1, mxCompactTreeLayout.prototype.isVertexIgnored = function(a) {
return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(a).length;
}, mxCompactTreeLayout.prototype.isHorizontal = function() {
return this.horizontal;
}, mxCompactTreeLayout.prototype.execute = function(a, b) {
this.parent = a;
var c = this.graph.getModel();
if (null == b) if (0 < this.graph.getEdges(a, c.getParent(a), this.invert, !this.invert, !1).length) b = a; else {
var d = this.graph.findTreeRoots(a, !0, this.invert);
if (0 < d.length) for (var e = 0; e < d.length; e++) if (!this.isVertexIgnored(d[e]) && 0 < this.graph.getEdges(d[e], null, this.invert, !this.invert, !1).length) {
b = d[e];
break;
}
}
if (null != b) {
this.parentsChanged = this.resizeParent ? {} :null, c.beginUpdate();
try {
var f = this.dfs(b, a);
if (null != f) {
this.layout(f);
var g = this.graph.gridSize, d = g;
if (!this.moveTree) {
var h = this.getVertexBounds(b);
null != h && (g = h.x, d = h.y);
}
if (h = null, h = this.isHorizontal() ? this.horizontalLayout(f, g, d) :this.verticalLayout(f, null, g, d), 
null != h) {
var k = e = 0;
0 > h.x && (e = Math.abs(g - h.x)), 0 > h.y && (k = Math.abs(d - h.y)), (0 != e || 0 != k) && this.moveNode(f, e, k), 
this.resizeParent && this.adjustParents(), this.edgeRouting && this.localEdgeProcessing(f);
}
}
} finally {
c.endUpdate();
}
}
}, mxCompactTreeLayout.prototype.moveNode = function(a, b, c) {
for (a.x += b, a.y += c, this.apply(a), a = a.child; null != a; ) this.moveNode(a, b, c), 
a = a.next;
}, mxCompactTreeLayout.prototype.sortOutgoingEdges = function(a, b) {
var c = new mxDictionary();
b.sort(function(b, e) {
var f = b.getTerminal(b.getTerminal(!1) == a), g = c.get(f);
null == g && (g = mxCellPath.create(f).split(mxCellPath.PATH_SEPARATOR), c.put(f, g));
var f = e.getTerminal(e.getTerminal(!1) == a), h = c.get(f);
return null == h && (h = mxCellPath.create(f).split(mxCellPath.PATH_SEPARATOR), 
c.put(f, h)), mxCellPath.compare(g, h);
});
}, mxCompactTreeLayout.prototype.dfs = function(a, b, c) {
c = null != c ? c :[];
var d = mxCellPath.create(a), e = null;
if (null != a && null == c[d] && !this.isVertexIgnored(a)) {
c[d] = a;
var e = this.createNode(a), d = this.graph.getModel(), f = null, g = this.graph.getEdges(a, b, this.invert, !this.invert, !1, !0), h = this.graph.getView();
for (this.sortEdges && this.sortOutgoingEdges(a, g), a = 0; a < g.length; a++) {
var k = g[a];
if (!this.isEdgeIgnored(k)) {
this.resetEdges && this.setEdgePoints(k, null), this.edgeRouting && (this.setEdgeStyleEnabled(k, !1), 
this.setEdgePoints(k, null));
var l = h.getState(k), k = null != l ? l.getVisibleTerminal(this.invert) :h.getVisibleTerminal(k, this.invert), l = this.dfs(k, b, c);
null != l && null != d.getGeometry(k) && (null == f ? e.child = l :f.next = l, f = l);
}
}
}
return e;
}, mxCompactTreeLayout.prototype.layout = function(a) {
if (null != a) {
for (var b = a.child; null != b; ) this.layout(b), b = b.next;
null != a.child ? this.attachParent(a, this.join(a)) :this.layoutLeaf(a);
}
}, mxCompactTreeLayout.prototype.horizontalLayout = function(a, b, c, d) {
if (a.x += b + a.offsetX, a.y += c + a.offsetY, d = this.apply(a, d), b = a.child, 
null != b) {
d = this.horizontalLayout(b, a.x, a.y, d), c = a.y + b.offsetY;
for (var e = b.next; null != e; ) d = this.horizontalLayout(e, a.x + b.offsetX, c, d), 
c += e.offsetY, e = e.next;
}
return d;
}, mxCompactTreeLayout.prototype.verticalLayout = function(a, b, c, d, e) {
if (a.x += c + a.offsetY, a.y += d + a.offsetX, e = this.apply(a, e), b = a.child, 
null != b) for (e = this.verticalLayout(b, a, a.x, a.y, e), c = a.x + b.offsetY, 
d = b.next; null != d; ) e = this.verticalLayout(d, a, c, a.y + b.offsetX, e), c += d.offsetY, 
d = d.next;
return e;
}, mxCompactTreeLayout.prototype.attachParent = function(a, b) {
var c = this.nodeDistance + this.levelDistance, d = (b - a.width) / 2 - this.nodeDistance, e = d + a.width + 2 * this.nodeDistance - b;
a.child.offsetX = c + a.height, a.child.offsetY = e, a.contour.upperHead = this.createLine(a.height, 0, this.createLine(c, e, a.contour.upperHead)), 
a.contour.lowerHead = this.createLine(a.height, 0, this.createLine(c, d, a.contour.lowerHead));
}, mxCompactTreeLayout.prototype.layoutLeaf = function(a) {
var b = 2 * this.nodeDistance;
a.contour.upperTail = this.createLine(a.height + b, 0), a.contour.upperHead = a.contour.upperTail, 
a.contour.lowerTail = this.createLine(0, -a.width - b), a.contour.lowerHead = this.createLine(a.height + b, 0, a.contour.lowerTail);
}, mxCompactTreeLayout.prototype.join = function(a) {
var b = 2 * this.nodeDistance, c = a.child;
a.contour = c.contour;
for (var d = c.width + b, e = d, c = c.next; null != c; ) {
var f = this.merge(a.contour, c.contour);
c.offsetY = f + d, c.offsetX = 0, d = c.width + b, e += f + d, c = c.next;
}
return e;
}, mxCompactTreeLayout.prototype.merge = function(a, b) {
for (var c = 0, d = 0, e = 0, f = a.lowerHead, g = b.upperHead; null != g && null != f; ) {
var h = this.offset(c, d, g.dx, g.dy, f.dx, f.dy), d = d + h, e = e + h;
c + g.dx <= f.dx ? (c += g.dx, d += g.dy, g = g.next) :(c -= f.dx, d -= f.dy, f = f.next);
}
return null != g ? (c = this.bridge(a.upperTail, 0, 0, g, c, d), a.upperTail = null != c.next ? b.upperTail :c, 
a.lowerTail = b.lowerTail) :(c = this.bridge(b.lowerTail, c, d, f, 0, 0), null == c.next && (a.lowerTail = c)), 
a.lowerHead = b.lowerHead, e;
}, mxCompactTreeLayout.prototype.offset = function(a, b, c, d, e, f) {
var g = 0;
return a >= e || 0 >= a + c ? 0 :(g = e * d - c * f > 0 ? 0 > a ? a * d / c - b :a > 0 ? a * f / e - b :-b :a + c > e ? f - (b + (e - a) * d / c) :e > a + c ? (c + a) * f / e - (b + d) :f - (b + d), 
g > 0 ? g :0);
}, mxCompactTreeLayout.prototype.bridge = function(a, b, c, d, e, f) {
return b = e + d.dx - b, e = e = 0, 0 == d.dx ? e = d.dy :(e = b * d.dy, e /= d.dx), 
b = this.createLine(b, e, d.next), a.next = this.createLine(0, f + d.dy - e - c, b), 
b;
}, mxCompactTreeLayout.prototype.createNode = function(a) {
var b = {};
return b.cell = a, b.x = 0, b.y = 0, b.width = 0, b.height = 0, a = this.getVertexBounds(a), 
null != a && (this.isHorizontal() ? (b.width = a.height, b.height = a.width) :(b.width = a.width, 
b.height = a.height)), b.offsetX = 0, b.offsetY = 0, b.contour = {}, b;
}, mxCompactTreeLayout.prototype.apply = function(a, b) {
var c = this.graph.getModel(), d = a.cell, e = c.getGeometry(d);
return null != d && null != e && (this.isVertexMovable(d) && (e = this.setVertexLocation(d, a.x, a.y), 
this.resizeParent && (c = c.getParent(d), d = mxCellPath.create(c), null == this.parentsChanged[d] && (this.parentsChanged[d] = c))), 
b = null == b ? new mxRectangle(e.x, e.y, e.width, e.height) :new mxRectangle(Math.min(b.x, e.x), Math.min(b.y, e.y), Math.max(b.x + b.width, e.x + e.width), Math.max(b.y + b.height, e.y + e.height))), 
b;
}, mxCompactTreeLayout.prototype.createLine = function(a, b, c) {
var d = {};
return d.dx = a, d.dy = b, d.next = c, d;
}, mxCompactTreeLayout.prototype.adjustParents = function() {
var b, a = [];
for (b in this.parentsChanged) a.push(this.parentsChanged[b]);
this.arrangeGroups(mxUtils.sortCells(a, !0), this.groupPadding);
}, mxCompactTreeLayout.prototype.localEdgeProcessing = function(a) {
for (this.processNodeOutgoing(a), a = a.child; null != a; ) this.localEdgeProcessing(a), 
a = a.next;
}, mxCompactTreeLayout.prototype.processNodeOutgoing = function(a) {
for (var b = a.child, c = a.cell, d = 0, e = []; null != b; ) {
d++;
var f = b.x;
this.horizontal && (f = b.y), e.push(new WeightedCellSorter(b, f)), b = b.next;
}
e.sort(WeightedCellSorter.prototype.compare);
var f = a.width, g = (d + 1) * this.prefHozEdgeSep;
f > g + 2 * this.prefHozEdgeSep && (f -= 2 * this.prefHozEdgeSep), a = f / d, b = a / 2, 
f > g + 2 * this.prefHozEdgeSep && (b += this.prefHozEdgeSep);
for (var f = this.minEdgeJetty - this.prefVertEdgeOff, g = 0, h = this.getVertexBounds(c), k = 0; k < e.length; k++) {
for (var l = e[k].cell.cell, m = this.getVertexBounds(l), l = this.graph.getEdgesBetween(c, l, !1), n = [], p = 0, q = 0, s = 0; s < l.length; s++) this.horizontal ? (p = h.x + h.width, 
q = h.y + b, n.push(new mxPoint(p, q)), p = h.x + h.width + f, n.push(new mxPoint(p, q)), 
q = m.y + m.height / 2) :(p = h.x + b, q = h.y + h.height, n.push(new mxPoint(p, q)), 
q = h.y + h.height + f, n.push(new mxPoint(p, q)), p = m.x + m.width / 2), n.push(new mxPoint(p, q)), 
this.setEdgePoints(l[s], n);
d / 2 > k ? f += this.prefVertEdgeOff :k > d / 2 && (f -= this.prefVertEdgeOff), 
b += a, g = Math.max(g, f);
}
}, WeightedCellSorter.prototype.weightedValue = 0, WeightedCellSorter.prototype.nudge = !1, 
WeightedCellSorter.prototype.visited = !1, WeightedCellSorter.prototype.rankIndex = null, 
WeightedCellSorter.prototype.cell = null, WeightedCellSorter.prototype.compare = function(a, b) {
return null != a && null != b ? b.weightedValue > a.weightedValue ? 1 :b.weightedValue < a.weightedValue ? -1 :b.nudge ? 1 :-1 :0;
}, mxFastOrganicLayout.prototype = new mxGraphLayout(), mxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout, 
mxFastOrganicLayout.prototype.useInputOrigin = !0, mxFastOrganicLayout.prototype.resetEdges = !0, 
mxFastOrganicLayout.prototype.disableEdgeStyle = !0, mxFastOrganicLayout.prototype.forceConstant = 50, 
mxFastOrganicLayout.prototype.forceConstantSquared = 0, mxFastOrganicLayout.prototype.minDistanceLimit = 2, 
mxFastOrganicLayout.prototype.maxDistanceLimit = 500, mxFastOrganicLayout.prototype.minDistanceLimitSquared = 4, 
mxFastOrganicLayout.prototype.initialTemp = 200, mxFastOrganicLayout.prototype.temperature = 0, 
mxFastOrganicLayout.prototype.maxIterations = 0, mxFastOrganicLayout.prototype.iteration = 0, 
mxFastOrganicLayout.prototype.allowedToRun = !0, mxFastOrganicLayout.prototype.isVertexIgnored = function(a) {
return mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) || 0 == this.graph.getConnections(a).length;
}, mxFastOrganicLayout.prototype.execute = function(a) {
var b = this.graph.getModel();
this.vertexArray = [];
for (var c = this.graph.getChildVertices(a), d = 0; d < c.length; d++) this.isVertexIgnored(c[d]) || this.vertexArray.push(c[d]);
var e = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) :null, f = this.vertexArray.length;
for (this.indices = [], this.dispX = [], this.dispY = [], this.cellLocation = [], 
this.isMoveable = [], this.neighbours = [], this.radius = [], this.radiusSquared = [], 
.001 > this.forceConstant && (this.forceConstant = .001), this.forceConstantSquared = this.forceConstant * this.forceConstant, 
d = 0; d < this.vertexArray.length; d++) {
var g = this.vertexArray[d];
this.cellLocation[d] = [];
var h = mxCellPath.create(g);
this.indices[h] = d;
var k = this.getVertexBounds(g), l = k.width, m = k.height, n = k.x, p = k.y;
this.cellLocation[d][0] = n + l / 2, this.cellLocation[d][1] = p + m / 2, this.radius[d] = Math.min(l, m), 
this.radiusSquared[d] = this.radius[d] * this.radius[d];
}
b.beginUpdate();
try {
for (d = 0; f > d; d++) {
this.dispX[d] = 0, this.dispY[d] = 0, this.isMoveable[d] = this.isVertexMovable(this.vertexArray[d]);
var q = this.graph.getConnections(this.vertexArray[d], a), c = this.graph.getOpposites(q, this.vertexArray[d]);
for (this.neighbours[d] = [], l = 0; l < c.length; l++) {
this.resetEdges && this.graph.resetEdge(q[l]), this.disableEdgeStyle && this.setEdgeStyleEnabled(q[l], !1);
var h = mxCellPath.create(c[l]), s = this.indices[h];
this.neighbours[d][l] = null != s ? s :d;
}
}
for (this.temperature = this.initialTemp, 0 == this.maxIterations && (this.maxIterations = 20 * Math.sqrt(f)), 
this.iteration = 0; this.iteration < this.maxIterations; this.iteration++) {
if (!this.allowedToRun) return;
this.calcRepulsion(), this.calcAttraction(), this.calcPositions(), this.reduceTemperature();
}
for (a = c = null, d = 0; d < this.vertexArray.length; d++) g = this.vertexArray[d], 
this.isVertexMovable(g) && (k = this.getVertexBounds(g), null != k && (this.cellLocation[d][0] -= k.width / 2, 
this.cellLocation[d][1] -= k.height / 2, n = this.graph.snap(this.cellLocation[d][0]), 
p = this.graph.snap(this.cellLocation[d][1]), this.setVertexLocation(g, n, p), c = null == c ? n :Math.min(c, n), 
a = null == a ? p :Math.min(a, p)));
d = -(c || 0) + 1, g = -(a || 0) + 1, null != e && (d += e.x, g += e.y), this.graph.moveCells(this.vertexArray, d, g);
} finally {
b.endUpdate();
}
}, mxFastOrganicLayout.prototype.calcPositions = function() {
for (var a = 0; a < this.vertexArray.length; a++) if (this.isMoveable[a]) {
var b = Math.sqrt(this.dispX[a] * this.dispX[a] + this.dispY[a] * this.dispY[a]);
.001 > b && (b = .001);
var c = this.dispX[a] / b * Math.min(b, this.temperature), b = this.dispY[a] / b * Math.min(b, this.temperature);
this.dispX[a] = 0, this.dispY[a] = 0, this.cellLocation[a][0] += c, this.cellLocation[a][1] += b;
}
}, mxFastOrganicLayout.prototype.calcAttraction = function() {
for (var a = 0; a < this.vertexArray.length; a++) for (var b = 0; b < this.neighbours[a].length; b++) {
var c = this.neighbours[a][b];
if (a != c && this.isMoveable[a] && this.isMoveable[c]) {
var d = this.cellLocation[a][0] - this.cellLocation[c][0], e = this.cellLocation[a][1] - this.cellLocation[c][1], f = d * d + e * e - this.radiusSquared[a] - this.radiusSquared[c];
f < this.minDistanceLimitSquared && (f = this.minDistanceLimitSquared);
var g = Math.sqrt(f), f = f / this.forceConstant, d = d / g * f, e = e / g * f;
this.dispX[a] -= d, this.dispY[a] -= e, this.dispX[c] += d, this.dispY[c] += e;
}
}
}, mxFastOrganicLayout.prototype.calcRepulsion = function() {
for (var a = this.vertexArray.length, b = 0; a > b; b++) for (var c = b; a > c; c++) {
if (!this.allowedToRun) return;
if (c != b && this.isMoveable[b] && this.isMoveable[c]) {
var d = this.cellLocation[b][0] - this.cellLocation[c][0], e = this.cellLocation[b][1] - this.cellLocation[c][1];
0 == d && (d = .01 + Math.random()), 0 == e && (e = .01 + Math.random());
var f = Math.sqrt(d * d + e * e), g = f - this.radius[b] - this.radius[c];
g > this.maxDistanceLimit || (g < this.minDistanceLimit && (g = this.minDistanceLimit), 
g = this.forceConstantSquared / g, d = d / f * g, e = e / f * g, this.dispX[b] += d, 
this.dispY[b] += e, this.dispX[c] -= d, this.dispY[c] -= e);
}
}
}, mxFastOrganicLayout.prototype.reduceTemperature = function() {
this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
}, mxCircleLayout.prototype = new mxGraphLayout(), mxCircleLayout.prototype.constructor = mxCircleLayout, 
mxCircleLayout.prototype.radius = null, mxCircleLayout.prototype.moveCircle = !1, 
mxCircleLayout.prototype.x0 = 0, mxCircleLayout.prototype.y0 = 0, mxCircleLayout.prototype.resetEdges = !0, 
mxCircleLayout.prototype.disableEdgeStyle = !0, mxCircleLayout.prototype.execute = function(a) {
var b = this.graph.getModel();
b.beginUpdate();
try {
for (var c = 0, d = null, e = null, f = [], g = b.getChildCount(a), h = 0; g > h; h++) {
var k = b.getChildAt(a, h);
if (this.isVertexIgnored(k)) this.isEdgeIgnored(k) || (this.resetEdges && this.graph.resetEdge(k), 
this.disableEdgeStyle && this.setEdgeStyleEnabled(k, !1)); else {
f.push(k);
var l = this.getVertexBounds(k), d = null == d ? l.y :Math.min(d, l.y), e = null == e ? l.x :Math.min(e, l.x), c = Math.max(c, Math.max(l.width, l.height));
}
}
var m = this.getRadius(f.length, c);
this.moveCircle && (e = this.x0, d = this.y0), this.circle(f, m, e, d);
} finally {
b.endUpdate();
}
}, mxCircleLayout.prototype.getRadius = function(a, b) {
return Math.max(a * b / Math.PI, this.radius);
}, mxCircleLayout.prototype.circle = function(a, b, c, d) {
for (var e = a.length, f = 2 * Math.PI / e, g = 0; e > g; g++) this.isVertexMovable(a[g]) && this.setVertexLocation(a[g], c + b + b * Math.sin(g * f), d + b + b * Math.cos(g * f));
}, mxParallelEdgeLayout.prototype = new mxGraphLayout(), mxParallelEdgeLayout.prototype.constructor = mxParallelEdgeLayout, 
mxParallelEdgeLayout.prototype.spacing = 20, mxParallelEdgeLayout.prototype.execute = function(a) {
a = this.findParallels(a), this.graph.model.beginUpdate();
try {
for (var b in a) {
var c = a[b];
1 < c.length && this.layout(c);
}
} finally {
this.graph.model.endUpdate();
}
}, mxParallelEdgeLayout.prototype.findParallels = function(a) {
for (var b = this.graph.getModel(), c = [], d = b.getChildCount(a), e = 0; d > e; e++) {
var f = b.getChildAt(a, e);
if (!this.isEdgeIgnored(f)) {
var g = this.getEdgeId(f);
null != g && (null == c[g] && (c[g] = []), c[g].push(f));
}
}
return c;
}, mxParallelEdgeLayout.prototype.getEdgeId = function(a) {
var b = this.graph.getView(), c = b.getState(a), d = null != c ? c.getVisibleTerminal(!0) :b.getVisibleTerminal(a, !0);
return a = null != c ? c.getVisibleTerminal(!1) :b.getVisibleTerminal(a, !1), null != d && null != a ? (d = mxCellPath.create(d), 
a = mxCellPath.create(a), d > a ? a + "-" + d :d + "-" + a) :null;
}, mxParallelEdgeLayout.prototype.layout = function(a) {
var b = a[0], c = this.graph.getModel(), d = c.getGeometry(c.getTerminal(b, !0)), e = c.getGeometry(c.getTerminal(b, !1));
if (d == e) for (var b = d.x + d.width + this.spacing, c = d.y + d.height / 2, f = 0; f < a.length; f++) this.route(a[f], b, c), 
b += this.spacing; else if (null != d && null != e) for (var b = d.x + d.width / 2, c = d.y + d.height / 2, f = e.x + e.width / 2 - b, g = e.y + e.height / 2 - c, e = Math.sqrt(f * f + g * g), d = g * this.spacing / e, e = f * this.spacing / e, b = b + f / 2 + d * (a.length - 1) / 2, c = c + g / 2 - e * (a.length - 1) / 2, f = 0; f < a.length; f++) this.route(a[f], b, c), 
b -= d, c += e;
}, mxParallelEdgeLayout.prototype.route = function(a, b, c) {
this.graph.isCellMovable(a) && this.setEdgePoints(a, [ new mxPoint(b, c) ]);
}, mxCompositeLayout.prototype = new mxGraphLayout(), mxCompositeLayout.prototype.constructor = mxCompositeLayout, 
mxCompositeLayout.prototype.layouts = null, mxCompositeLayout.prototype.master = null, 
mxCompositeLayout.prototype.moveCell = function() {
null != this.master ? this.master.move.apply(this.master, arguments) :this.layouts[0].move.apply(this.layouts[0], arguments);
}, mxCompositeLayout.prototype.execute = function() {
var b = this.graph.getModel();
b.beginUpdate();
try {
for (var c = 0; c < this.layouts.length; c++) this.layouts[c].execute.apply(this.layouts[c], arguments);
} finally {
b.endUpdate();
}
}, mxEdgeLabelLayout.prototype = new mxGraphLayout(), mxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout, 
mxEdgeLabelLayout.prototype.execute = function(a) {
for (var b = this.graph.view, c = this.graph.getModel(), d = [], e = [], f = c.getChildCount(a), g = 0; f > g; g++) {
var h = c.getChildAt(a, g), k = b.getState(h);
null != k && (this.isVertexIgnored(h) ? this.isEdgeIgnored(h) || d.push(k) :e.push(k));
}
this.placeLabels(e, d);
}, mxEdgeLabelLayout.prototype.placeLabels = function(a, b) {
var c = this.graph.getModel();
c.beginUpdate();
try {
for (var d = 0; d < b.length; d++) {
var e = b[d];
if (null != e && null != e.text && null != e.text.boundingBox) for (var f = 0; f < a.length; f++) {
var g = a[f];
null != g && this.avoid(e, g);
}
}
} finally {
c.endUpdate();
}
}, mxEdgeLabelLayout.prototype.avoid = function(a, b) {
var c = this.graph.getModel(), d = a.text.boundingBox;
if (mxUtils.intersects(d, b)) {
var e = -d.y - d.height + b.y, f = -d.y + b.y + b.height, e = Math.abs(e) < Math.abs(f) ? e :f, f = -d.x - d.width + b.x, d = -d.x + b.x + b.width, d = Math.abs(f) < Math.abs(d) ? f :d;
Math.abs(d) < Math.abs(e) ? e = 0 :d = 0, f = c.getGeometry(a.cell), null != f && (f = f.clone(), 
null != f.offset ? (f.offset.x += d, f.offset.y += e) :f.offset = new mxPoint(d, e), 
c.setGeometry(a.cell, f));
}
}, mxGraphAbstractHierarchyCell.prototype.maxRank = -1, mxGraphAbstractHierarchyCell.prototype.minRank = -1, 
mxGraphAbstractHierarchyCell.prototype.x = null, mxGraphAbstractHierarchyCell.prototype.y = null, 
mxGraphAbstractHierarchyCell.prototype.width = 0, mxGraphAbstractHierarchyCell.prototype.height = 0, 
mxGraphAbstractHierarchyCell.prototype.nextLayerConnectedCells = null, mxGraphAbstractHierarchyCell.prototype.previousLayerConnectedCells = null, 
mxGraphAbstractHierarchyCell.prototype.temp = null, mxGraphAbstractHierarchyCell.prototype.getNextLayerConnectedCells = function() {
return null;
}, mxGraphAbstractHierarchyCell.prototype.getPreviousLayerConnectedCells = function() {
return null;
}, mxGraphAbstractHierarchyCell.prototype.isEdge = function() {
return !1;
}, mxGraphAbstractHierarchyCell.prototype.isVertex = function() {
return !1;
}, mxGraphAbstractHierarchyCell.prototype.getGeneralPurposeVariable = function() {
return null;
}, mxGraphAbstractHierarchyCell.prototype.setGeneralPurposeVariable = function() {
return null;
}, mxGraphAbstractHierarchyCell.prototype.setX = function(a, b) {
this.isVertex() ? this.x[0] = b :this.isEdge() && (this.x[a - this.minRank - 1] = b);
}, mxGraphAbstractHierarchyCell.prototype.getX = function(a) {
return this.isVertex() ? this.x[0] :this.isEdge() ? this.x[a - this.minRank - 1] :0;
}, mxGraphAbstractHierarchyCell.prototype.setY = function(a, b) {
this.isVertex() ? this.y[0] = b :this.isEdge() && (this.y[a - this.minRank - 1] = b);
}, mxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell(), mxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode, 
mxGraphHierarchyNode.prototype.cell = null, mxGraphHierarchyNode.prototype.connectsAsTarget = [], 
mxGraphHierarchyNode.prototype.connectsAsSource = [], mxGraphHierarchyNode.prototype.hashCode = !1, 
mxGraphHierarchyNode.prototype.getRankValue = function() {
return this.maxRank;
}, mxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function(a) {
if (null == this.nextLayerConnectedCells) {
this.nextLayerConnectedCells = [], this.nextLayerConnectedCells[0] = [];
for (var b = 0; b < this.connectsAsTarget.length; b++) {
var c = this.connectsAsTarget[b];
-1 == c.maxRank || c.maxRank == a + 1 ? this.nextLayerConnectedCells[0].push(c.source) :this.nextLayerConnectedCells[0].push(c);
}
}
return this.nextLayerConnectedCells[0];
}, mxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function(a) {
if (null == this.previousLayerConnectedCells) {
this.previousLayerConnectedCells = [], this.previousLayerConnectedCells[0] = [];
for (var b = 0; b < this.connectsAsSource.length; b++) {
var c = this.connectsAsSource[b];
-1 == c.minRank || c.minRank == a - 1 ? this.previousLayerConnectedCells[0].push(c.target) :this.previousLayerConnectedCells[0].push(c);
}
}
return this.previousLayerConnectedCells[0];
}, mxGraphHierarchyNode.prototype.isVertex = function() {
return !0;
}, mxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function() {
return this.temp[0];
}, mxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function(a, b) {
this.temp[0] = b;
}, mxGraphHierarchyNode.prototype.isAncestor = function(a) {
if (null != a && null != this.hashCode && null != a.hashCode && this.hashCode.length < a.hashCode.length) {
if (this.hashCode == a.hashCode) return !0;
if (null == this.hashCode || null == this.hashCode) return !1;
for (var b = 0; b < this.hashCode.length; b++) if (this.hashCode[b] != a.hashCode[b]) return !1;
return !0;
}
return !1;
}, mxGraphHierarchyNode.prototype.getCoreCell = function() {
return this.cell;
}, mxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell(), mxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge, 
mxGraphHierarchyEdge.prototype.edges = null, mxGraphHierarchyEdge.prototype.source = null, 
mxGraphHierarchyEdge.prototype.target = null, mxGraphHierarchyEdge.prototype.isReversed = !1, 
mxGraphHierarchyEdge.prototype.invert = function(a) {
a = this.source, this.source = this.target, this.target = a, this.isReversed = !this.isReversed;
}, mxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function(a) {
if (null == this.nextLayerConnectedCells) {
this.nextLayerConnectedCells = [];
for (var b = 0; b < this.temp.length; b++) this.nextLayerConnectedCells[b] = [], 
b == this.temp.length - 1 ? this.nextLayerConnectedCells[b].push(this.source) :this.nextLayerConnectedCells[b].push(this);
}
return this.nextLayerConnectedCells[a - this.minRank - 1];
}, mxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function(a) {
if (null == this.previousLayerConnectedCells) {
this.previousLayerConnectedCells = [];
for (var b = 0; b < this.temp.length; b++) this.previousLayerConnectedCells[b] = [], 
0 == b ? this.previousLayerConnectedCells[b].push(this.target) :this.previousLayerConnectedCells[b].push(this);
}
return this.previousLayerConnectedCells[a - this.minRank - 1];
}, mxGraphHierarchyEdge.prototype.isEdge = function() {
return !0;
}, mxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function(a) {
return this.temp[a - this.minRank - 1];
}, mxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function(a, b) {
this.temp[a - this.minRank - 1] = b;
}, mxGraphHierarchyEdge.prototype.getCoreCell = function() {
return null != this.edges && 0 < this.edges.length ? this.edges[0] :null;
}, mxGraphHierarchyModel.prototype.maxRank = null, mxGraphHierarchyModel.prototype.vertexMapper = null, 
mxGraphHierarchyModel.prototype.edgeMapper = null, mxGraphHierarchyModel.prototype.ranks = null, 
mxGraphHierarchyModel.prototype.roots = null, mxGraphHierarchyModel.prototype.parent = null, 
mxGraphHierarchyModel.prototype.dfsCount = 0, mxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 1e8, 
mxGraphHierarchyModel.prototype.tightenToSource = !1, mxGraphHierarchyModel.prototype.createInternalCells = function(a, b, c) {
for (var d = a.getGraph(), e = 0; e < b.length; e++) {
c[e] = new mxGraphHierarchyNode(b[e]);
var f = mxCellPath.create(b[e]);
this.vertexMapper[f] = c[e], f = a.getEdges(b[e]), c[e].connectsAsSource = [];
for (var g = 0; g < f.length; g++) {
var h = a.getVisibleTerminal(f[g], !1);
if (h != b[e] && h != b[e] && a.graph.model.isVertex(h) && !a.isVertexIgnored(h)) {
var k = a.getEdgesBetween(b[e], h, !1), l = a.getEdgesBetween(b[e], h, !0), h = mxCellPath.create(k[0]);
if (null != k && 0 < k.length && null == this.edgeMapper[h] && 2 * l.length >= k.length) {
for (var l = new mxGraphHierarchyEdge(k), m = 0; m < k.length; m++) {
var n = k[m], h = mxCellPath.create(n);
this.edgeMapper[h] = l, d.resetEdge(n), a.disableEdgeStyle && (a.setEdgeStyleEnabled(n, !1), 
a.setOrthogonalEdge(n, !0));
}
l.source = c[e], 0 > mxUtils.indexOf(c[e].connectsAsSource, l) && c[e].connectsAsSource.push(l);
}
}
}
c[e].temp[0] = 0;
}
}, mxGraphHierarchyModel.prototype.initialRank = function() {
var a = [];
if (null != this.roots) for (var b = 0; b < this.roots.length; b++) {
var c = mxCellPath.create(this.roots[b]), c = this.vertexMapper[c];
null != c && a.push(c);
}
for (var d in this.vertexMapper) c = this.vertexMapper[d], c.temp[0] = -1;
for (var e = a.slice(); 0 < a.length; ) {
var f, g, c = a[0];
f = c.connectsAsTarget, g = c.connectsAsSource;
for (var h = !0, k = this.SOURCESCANSTARTRANK, b = 0; b < f.length; b++) {
var l = f[b];
if (5270620 != l.temp[0]) {
h = !1;
break;
}
l = l.source, k = Math.min(k, l.temp[0] - 1);
}
if (h) {
if (c.temp[0] = k, this.maxRank = Math.min(this.maxRank, k), null != g) for (b = 0; b < g.length; b++) l = g[b], 
l.temp[0] = 5270620, l = l.target, -1 == l.temp[0] && (a.push(l), l.temp[0] = -2);
a.shift();
} else if (b = a.shift(), a.push(c), b == c && 1 == a.length) break;
}
for (d in this.vertexMapper) c = this.vertexMapper[d], c.temp[0] -= this.maxRank;
for (b = 0; b < e.length; b++) for (c = e[b], a = 0, f = c.connectsAsSource, d = 0; d < f.length; d++) l = f[d], 
l = l.target, c.temp[0] = Math.max(a, l.temp[0] + 1), a = c.temp[0];
this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;
}, mxGraphHierarchyModel.prototype.fixRanks = function() {
var a = [];
this.ranks = [];
for (var b = 0; b < this.maxRank + 1; b++) a[b] = [], this.ranks[b] = a[b];
var c = null;
if (null != this.roots) for (var d = this.roots, c = [], b = 0; b < d.length; b++) {
var e = mxCellPath.create(d[b]);
c[b] = this.vertexMapper[e];
}
this.visit(function(b, c, d, e, l) {
if (0 == l && 0 > c.maxRank && 0 > c.minRank && (a[c.temp[0]].push(c), c.maxRank = c.temp[0], 
c.minRank = c.temp[0], c.temp[0] = a[c.maxRank].length - 1), null != b && null != d && 1 < b.maxRank - c.maxRank) for (d.maxRank = b.maxRank, 
d.minRank = c.maxRank, d.temp = [], d.x = [], d.y = [], b = d.minRank + 1; b < d.maxRank; b++) a[b].push(d), 
d.setGeneralPurposeVariable(b, a[b].length - 1);
}, c, !1, null);
}, mxGraphHierarchyModel.prototype.visit = function(a, b, c, d) {
if (null != b) {
for (var e = 0; e < b.length; e++) {
var f = b[e];
null != f && (null == d && (d = {}), c ? (f.hashCode = [], f.hashCode[0] = this.dfsCount, 
f.hashCode[1] = e, this.extendedDfs(null, f, null, a, d, f.hashCode, e, 0)) :this.dfs(null, f, null, a, d, 0));
}
this.dfsCount++;
}
}, mxGraphHierarchyModel.prototype.dfs = function(a, b, c, d, e, f) {
if (null != b) {
var g = mxCellPath.create(b.cell);
if (null == e[g]) for (e[g] = b, d(a, b, c, f, 0), a = b.connectsAsSource.slice(), 
c = 0; c < a.length; c++) g = a[c], this.dfs(b, g.target, g, d, e, f + 1); else d(a, b, c, f, 1);
}
}, mxGraphHierarchyModel.prototype.extendedDfs = function(a, b, c, d, e, f, g, h) {
if (null != b) if (null == a || null != b.hashCode && b.hashCode[0] == a.hashCode[0] || (f = a.hashCode.length + 1, 
b.hashCode = a.hashCode.slice(), b.hashCode[f - 1] = g), g = mxCellPath.create(b.cell), 
null == e[g]) for (e[g] = b, d(a, b, c, h, 0), a = b.connectsAsSource.slice(), c = 0; c < a.length; c++) g = a[c], 
this.extendedDfs(b, g.target, g, d, e, b.hashCode, c, h + 1); else d(a, b, c, h, 1);
}, mxHierarchicalLayoutStage.prototype.execute = function() {}, mxMedianHybridCrossingReduction.prototype = new mxHierarchicalLayoutStage(), 
mxMedianHybridCrossingReduction.prototype.constructor = mxMedianHybridCrossingReduction, 
mxMedianHybridCrossingReduction.prototype.layout = null, mxMedianHybridCrossingReduction.prototype.maxIterations = 24, 
mxMedianHybridCrossingReduction.prototype.nestedBestRanks = null, mxMedianHybridCrossingReduction.prototype.currentBestCrossings = 0, 
mxMedianHybridCrossingReduction.prototype.iterationsWithoutImprovement = 0, mxMedianHybridCrossingReduction.prototype.maxNoImprovementIterations = 2, 
mxMedianHybridCrossingReduction.prototype.execute = function(a) {
a = this.layout.getModel(), this.nestedBestRanks = [];
for (var b = 0; b < a.ranks.length; b++) this.nestedBestRanks[b] = a.ranks[b].slice();
for (var c = 0, d = this.calculateCrossings(a), b = 0; b < this.maxIterations && c < this.maxNoImprovementIterations; b++) {
this.weightedMedian(b, a), this.transpose(b, a);
var e = this.calculateCrossings(a);
if (d > e) for (d = e, e = c = 0; e < this.nestedBestRanks.length; e++) for (var f = a.ranks[e], g = 0; g < f.length; g++) {
var h = f[g];
this.nestedBestRanks[e][h.getGeneralPurposeVariable(e)] = h;
} else for (c++, e = 0; e < this.nestedBestRanks.length; e++) for (f = a.ranks[e], 
g = 0; g < f.length; g++) h = f[g], h.setGeneralPurposeVariable(e, g);
if (0 == d) break;
}
for (c = [], d = [], b = 0; b < a.maxRank + 1; b++) d[b] = [], c[b] = d[b];
for (b = 0; b < this.nestedBestRanks.length; b++) for (e = 0; e < this.nestedBestRanks[b].length; e++) d[b].push(this.nestedBestRanks[b][e]);
a.ranks = c;
}, mxMedianHybridCrossingReduction.prototype.calculateCrossings = function(a) {
for (var b = a.ranks.length, c = 0, d = 1; b > d; d++) c += this.calculateRankCrossing(d, a);
return c;
}, mxMedianHybridCrossingReduction.prototype.calculateRankCrossing = function(a, b) {
for (var c = 0, d = b.ranks[a], e = d.length, f = b.ranks[a - 1].length, g = [], h = 0; e > h; h++) g[h] = [];
for (h = 0; h < d.length; h++) for (var k = d[h], l = k.getGeneralPurposeVariable(a), m = k.getPreviousLayerConnectedCells(a), k = 0; k < m.length; k++) {
var n = m[k].getGeneralPurposeVariable(a - 1);
g[l][n] = 201207;
}
for (h = 0; e > h; h++) for (k = 0; f > k; k++) if (201207 == g[h][k]) {
for (d = h + 1; e > d; d++) for (l = 0; k > l; l++) 201207 == g[d][l] && c++;
for (d = 0; h > d; d++) for (l = k + 1; f > l; l++) 201207 == g[d][l] && c++;
}
return c / 2;
}, mxMedianHybridCrossingReduction.prototype.transpose = function(a, b) {
for (var c = !0, d = 0; c && 10 > d++; ) for (var e = 1 == a % 2 && 1 == d % 2, c = !1, f = 0; f < b.ranks.length; f++) {
for (var g = b.ranks[f], h = [], k = 0; k < g.length; k++) {
var l = g[k], m = l.getGeneralPurposeVariable(f);
0 > m && (m = k), h[m] = l;
}
for (var n = m = l = null, p = null, q = null, s = null, r = null, t = null, u = null, v = null, k = 0; k < g.length - 1; k++) {
if (0 == k) {
for (var u = h[k], l = u.getNextLayerConnectedCells(f), m = u.getPreviousLayerConnectedCells(f), q = [], s = [], w = 0; w < l.length; w++) q[w] = l[w].getGeneralPurposeVariable(f + 1);
for (w = 0; w < m.length; w++) s[w] = m[w].getGeneralPurposeVariable(f - 1);
} else l = n, m = p, q = r, s = t, u = v;
for (v = h[k + 1], n = v.getNextLayerConnectedCells(f), p = v.getPreviousLayerConnectedCells(f), 
r = [], t = [], w = 0; w < n.length; w++) r[w] = n[w].getGeneralPurposeVariable(f + 1);
for (w = 0; w < p.length; w++) t[w] = p[w].getGeneralPurposeVariable(f - 1);
for (var y = 0, z = 0, w = 0; w < q.length; w++) for (var x = 0; x < r.length; x++) q[w] > r[x] && y++, 
q[w] < r[x] && z++;
for (w = 0; w < s.length; w++) for (x = 0; x < t.length; x++) s[w] > t[x] && y++, 
s[w] < t[x] && z++;
(y > z || z == y && e) && (n = u.getGeneralPurposeVariable(f), u.setGeneralPurposeVariable(f, v.getGeneralPurposeVariable(f)), 
v.setGeneralPurposeVariable(f, n), n = l, p = m, r = q, t = s, v = u, e || (c = !0));
}
}
}, mxMedianHybridCrossingReduction.prototype.weightedMedian = function(a, b) {
var c = 0 == a % 2;
if (c) for (var d = b.maxRank - 1; d >= 0; d--) this.medianRank(d, c); else for (d = 1; d < b.maxRank; d++) this.medianRank(d, c);
}, mxMedianHybridCrossingReduction.prototype.medianRank = function(a, b) {
for (var c = this.nestedBestRanks[a].length, d = [], e = [], f = 0; c > f; f++) {
var g = this.nestedBestRanks[a][f], h = new MedianCellSorter();
h.cell = g;
var k;
k = b ? g.getNextLayerConnectedCells(a) :g.getPreviousLayerConnectedCells(a);
var l;
l = b ? a + 1 :a - 1, null != k && 0 != k.length ? (h.medianValue = this.medianValue(k, l), 
d.push(h)) :e[g.getGeneralPurposeVariable(a)] = !0;
}
for (d.sort(MedianCellSorter.prototype.compare), f = 0; c > f; f++) null == e[f] && (g = d.shift().cell, 
g.setGeneralPurposeVariable(a, f));
}, mxMedianHybridCrossingReduction.prototype.medianValue = function(a, b) {
for (var c = [], d = 0, e = 0; e < a.length; e++) {
var f = a[e];
c[d++] = f.getGeneralPurposeVariable(b);
}
return c.sort(function(a, b) {
return a - b;
}), 1 == d % 2 ? c[Math.floor(d / 2)] :2 == d ? (c[0] + c[1]) / 2 :(e = d / 2, f = c[e - 1] - c[0], 
d = c[d - 1] - c[e], (c[e - 1] * d + c[e] * f) / (f + d));
}, MedianCellSorter.prototype.medianValue = 0, MedianCellSorter.prototype.cell = !1, 
MedianCellSorter.prototype.compare = function(a, b) {
return null != a && null != b ? b.medianValue > a.medianValue ? -1 :b.medianValue < a.medianValue ? 1 :0 :0;
}, mxMinimumCycleRemover.prototype = new mxHierarchicalLayoutStage(), mxMinimumCycleRemover.prototype.constructor = mxMinimumCycleRemover, 
mxMinimumCycleRemover.prototype.layout = null, mxMinimumCycleRemover.prototype.execute = function(a) {
var b = this.layout.getModel(), c = {}, d = mxUtils.clone(b.vertexMapper, null, !0), e = null;
if (null != b.roots) {
var f = b.roots, e = [];
for (a = 0; a < f.length; a++) {
var g = mxCellPath.create(f[a]);
e[a] = b.vertexMapper[g];
}
}
if (b.visit(function(a, b, e) {
b.isAncestor(a) && (e.invert(), mxUtils.remove(e, a.connectsAsSource), a.connectsAsTarget.push(e), 
mxUtils.remove(e, b.connectsAsTarget), b.connectsAsSource.push(e)), a = mxCellPath.create(b.cell), 
c[a] = b, delete d[a];
}, e, !0, null), e = null, 0 < d.lenth && (e = mxUtils.clone(d, null, !0)), a = mxUtils.clone(c, null, !0), 
b.visit(function(a, b, e) {
b.isAncestor(a) && (e.invert(), mxUtils.remove(e, a.connectsAsSource), b.connectsAsSource.push(e), 
a.connectsAsTarget.push(e), mxUtils.remove(e, b.connectsAsTarget)), a = mxCellPath.create(b.cell), 
c[a] = b, delete d[a];
}, d, !0, a), f = this.layout.getGraph(), null != e && 0 < e.length) for (b = b.roots, 
a = 0; a < e.length; a++) g = e[a].cell, 0 == f.getIncomingEdges(g).length && b.push(g);
};

var mxHierarchicalEdgeStyle = {
ORTHOGONAL:1,
POLYLINE:2,
STRAIGHT:3,
CURVE:4
};

mxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage(), mxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment, 
mxCoordinateAssignment.prototype.layout = null, mxCoordinateAssignment.prototype.intraCellSpacing = 30, 
mxCoordinateAssignment.prototype.interRankCellSpacing = 100, mxCoordinateAssignment.prototype.parallelEdgeSpacing = 10, 
mxCoordinateAssignment.prototype.maxIterations = 8, mxCoordinateAssignment.prototype.prefHozEdgeSep = 5, 
mxCoordinateAssignment.prototype.prefVertEdgeOff = 2, mxCoordinateAssignment.prototype.minEdgeJetty = 12, 
mxCoordinateAssignment.prototype.channelBuffer = 4, mxCoordinateAssignment.prototype.jettyPositions = null, 
mxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH, mxCoordinateAssignment.prototype.initialX = null, 
mxCoordinateAssignment.prototype.limitX = null, mxCoordinateAssignment.prototype.currentXDelta = null, 
mxCoordinateAssignment.prototype.widestRank = null, mxCoordinateAssignment.prototype.rankTopY = null, 
mxCoordinateAssignment.prototype.rankBottomY = null, mxCoordinateAssignment.prototype.widestRankValue = null, 
mxCoordinateAssignment.prototype.rankWidths = null, mxCoordinateAssignment.prototype.rankY = null, 
mxCoordinateAssignment.prototype.fineTuning = !0, mxCoordinateAssignment.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE, 
mxCoordinateAssignment.prototype.nextLayerConnectedCache = null, mxCoordinateAssignment.prototype.previousLayerConnectedCache = null, 
mxCoordinateAssignment.prototype.groupPadding = 10, mxCoordinateAssignment.prototype.printStatus = function() {
var a = this.layout.getModel();
mxLog.show(), mxLog.writeln("======Coord assignment debug=======");
for (var b = 0; b < a.ranks.length; b++) {
mxLog.write("Rank ", b, " : ");
for (var c = a.ranks[b], d = 0; d < c.length; d++) mxLog.write(c[d].getGeneralPurposeVariable(b), "  ");
mxLog.writeln();
}
mxLog.writeln("====================================");
}, mxCoordinateAssignment.prototype.execute = function(a) {
this.jettyPositions = [], a = this.layout.getModel(), this.currentXDelta = 0, this.initialCoords(this.layout.getGraph(), a), 
this.fineTuning && this.minNode(a);
var b = 1e8;
if (this.fineTuning) for (var c = 0; c < this.maxIterations; c++) {
if (0 != c && (this.medianPos(c, a), this.minNode(a)), this.currentXDelta < b) {
for (var d = 0; d < a.ranks.length; d++) for (var e = a.ranks[d], f = 0; f < e.length; f++) {
var g = e[f];
g.setX(d, g.getGeneralPurposeVariable(d));
}
b = this.currentXDelta;
} else for (d = 0; d < a.ranks.length; d++) for (e = a.ranks[d], f = 0; f < e.length; f++) g = e[f], 
g.setGeneralPurposeVariable(d, g.getX(d));
this.minPath(this.layout.getGraph(), a), this.currentXDelta = 0;
}
this.setCellLocations(this.layout.getGraph(), a);
}, mxCoordinateAssignment.prototype.minNode = function(a) {
for (var b = [], c = [], d = [], e = 0; e <= a.maxRank; e++) {
d[e] = a.ranks[e];
for (var f = 0; f < d[e].length; f++) {
var g = d[e][f], h = new WeightedCellSorter(g, e);
h.rankIndex = f, h.visited = !0, b.push(h), g = mxCellPath.create(g.getCoreCell()), 
c[g] = h;
}
}
for (a = 10 * b.length, f = 0; 0 < b.length && a >= f; ) {
var h = b.shift(), e = h.cell, k = h.weightedValue, l = parseInt(h.rankIndex), g = e.getNextLayerConnectedCells(k), m = e.getPreviousLayerConnectedCells(k), n = g.length, p = m.length, q = this.medianXValue(g, k + 1), s = this.medianXValue(m, k - 1), r = n + p, t = e.getGeneralPurposeVariable(k), u = t;
if (r > 0 && (u = (q * n + s * p) / r), n = !1, t - 1 > u ? 0 == l ? (e.setGeneralPurposeVariable(k, u), 
n = !0) :(l = d[k][l - 1], t = l.getGeneralPurposeVariable(k), t = t + l.width / 2 + this.intraCellSpacing + e.width / 2, 
u > t ? (e.setGeneralPurposeVariable(k, u), n = !0) :t < e.getGeneralPurposeVariable(k) - 1 && (e.setGeneralPurposeVariable(k, t), 
n = !0)) :u > t + 1 && (l == d[k].length - 1 ? (e.setGeneralPurposeVariable(k, u), 
n = !0) :(l = d[k][l + 1], t = l.getGeneralPurposeVariable(k), t = t - l.width / 2 - this.intraCellSpacing - e.width / 2, 
t > u ? (e.setGeneralPurposeVariable(k, u), n = !0) :t > e.getGeneralPurposeVariable(k) + 1 && (e.setGeneralPurposeVariable(k, t), 
n = !0))), n) {
for (e = 0; e < g.length; e++) k = g[e], k = mxCellPath.create(k.getCoreCell()), 
k = c[k], null != k && 0 == k.visited && (k.visited = !0, b.push(k));
for (e = 0; e < m.length; e++) k = m[e], k = mxCellPath.create(k.getCoreCell()), 
k = c[k], null != k && 0 == k.visited && (k.visited = !0, b.push(k));
}
h.visited = !1, f++;
}
}, mxCoordinateAssignment.prototype.medianPos = function(a, b) {
if (0 == a % 2) for (var c = b.maxRank; c > 0; c--) this.rankMedianPosition(c - 1, b, c); else for (c = 0; c < b.maxRank - 1; c++) this.rankMedianPosition(c + 1, b, c);
}, mxCoordinateAssignment.prototype.rankMedianPosition = function(a, b, c) {
b = b.ranks[a];
for (var d = [], e = [], f = 0; f < b.length; f++) {
var g = b[f];
d[f] = new WeightedCellSorter(), d[f].cell = g, d[f].rankIndex = f;
var h = mxCellPath.create(g.getCoreCell());
e[h] = d[f];
var k = null, k = a > c ? g.getPreviousLayerConnectedCells(a) :g.getNextLayerConnectedCells(a);
d[f].weightedValue = this.calculatedWeightedValue(g, k);
}
for (d.sort(WeightedCellSorter.prototype.compare), f = 0; f < d.length; f++) {
h = 0, g = d[f].cell, h = 0, k = a > c ? g.getPreviousLayerConnectedCells(a).slice() :g.getNextLayerConnectedCells(a).slice(), 
null != k && (h = k.length, h = h > 0 ? this.medianXValue(k, c) :g.getGeneralPurposeVariable(a));
for (var l = 0, k = -1e8, m = d[f].rankIndex - 1; m >= 0; ) {
var n = mxCellPath.create(b[m].getCoreCell()), n = e[n];
if (null != n) {
var p = n.cell;
n.visited ? (k = p.getGeneralPurposeVariable(a) + p.width / 2 + this.intraCellSpacing + l + g.width / 2, 
m = -1) :(l += p.width + this.intraCellSpacing, m--);
}
}
for (l = 0, p = 1e8, m = d[f].rankIndex + 1; m < d.length; ) if (n = mxCellPath.create(b[m].getCoreCell()), 
n = e[n], null != n) {
var q = n.cell;
n.visited ? (p = q.getGeneralPurposeVariable(a) - q.width / 2 - this.intraCellSpacing - l - g.width / 2, 
m = d.length) :(l += q.width + this.intraCellSpacing, m++);
}
h >= k && p >= h ? g.setGeneralPurposeVariable(a, h) :k > h ? (g.setGeneralPurposeVariable(a, k), 
this.currentXDelta += k - h) :h > p && (g.setGeneralPurposeVariable(a, p), this.currentXDelta += h - p), 
d[f].visited = !0;
}
}, mxCoordinateAssignment.prototype.calculatedWeightedValue = function(a, b) {
for (var c = 0, d = 0; d < b.length; d++) {
var e = b[d];
a.isVertex() && e.isVertex() ? c++ :c = a.isEdge() && e.isEdge() ? c + 8 :c + 2;
}
return c;
}, mxCoordinateAssignment.prototype.medianXValue = function(a, b) {
if (0 == a.length) return 0;
for (var c = [], d = 0; d < a.length; d++) c[d] = a[d].getGeneralPurposeVariable(b);
return c.sort(function(a, b) {
return a - b;
}), 1 == a.length % 2 ? c[Math.floor(a.length / 2)] :(d = a.length / 2, (c[d - 1] + c[d]) / 2);
}, mxCoordinateAssignment.prototype.initialCoords = function(a, b) {
this.calculateWidestRank(a, b);
for (var c = this.widestRank; c >= 0; c--) c < b.maxRank && this.rankCoordinates(c, a, b);
for (c = this.widestRank + 1; c <= b.maxRank; c++) c > 0 && this.rankCoordinates(c, a, b);
}, mxCoordinateAssignment.prototype.rankCoordinates = function(a, b, c) {
b = c.ranks[a], c = 0;
for (var d = this.initialX + (this.widestRankValue - this.rankWidths[a]) / 2, e = !1, f = 0; f < b.length; f++) {
var g = b[f];
if (g.isVertex()) {
var h = this.layout.getVertexBounds(g.cell);
null != h ? this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH ? (g.width = h.width, 
g.height = h.height) :(g.width = h.height, g.height = h.width) :e = !0, c = Math.max(c, g.height);
} else g.isEdge() && (h = 1, null != g.edges ? h = g.edges.length :mxLog.warn("edge.edges is null"), 
g.width = (h - 1) * this.parallelEdgeSpacing);
d += g.width / 2, g.setX(a, d), g.setGeneralPurposeVariable(a, d), d += g.width / 2, 
d += this.intraCellSpacing;
}
1 == e && mxLog.warn("At least one cell has no bounds");
}, mxCoordinateAssignment.prototype.calculateWidestRank = function(a, b) {
var c = -this.interRankCellSpacing, d = 0;
this.rankWidths = [], this.rankY = [];
for (var e = b.maxRank; e >= 0; e--) {
for (var f = 0, g = b.ranks[e], h = this.initialX, k = !1, l = 0; l < g.length; l++) {
var m = g[l];
if (m.isVertex()) {
var n = this.layout.getVertexBounds(m.cell);
null != n ? this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH ? (m.width = n.width, 
m.height = n.height) :(m.width = n.height, m.height = n.width) :k = !0, f = Math.max(f, m.height);
} else m.isEdge() && (n = 1, null != m.edges ? n = m.edges.length :mxLog.warn("edge.edges is null"), 
m.width = (n - 1) * this.parallelEdgeSpacing);
h += m.width / 2, m.setX(e, h), m.setGeneralPurposeVariable(e, h), h += m.width / 2, 
h += this.intraCellSpacing, h > this.widestRankValue && (this.widestRankValue = h, 
this.widestRank = e), this.rankWidths[e] = h;
}
for (1 == k && mxLog.warn("At least one cell has no bounds"), this.rankY[e] = c, 
h = f / 2 + d / 2 + this.interRankCellSpacing, d = f, c = this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_WEST ? c + h :c - h, 
l = 0; l < g.length; l++) g[l].setY(e, c);
}
}, mxCoordinateAssignment.prototype.minPath = function(a, b) {
var d, c = b.edgeMapper;
for (d in c) {
var e = c[d];
if (!(1 > e.maxRank - e.minRank - 1)) {
for (var f = e.getGeneralPurposeVariable(e.minRank + 1), g = !0, h = 0, k = e.minRank + 2; k < e.maxRank; k++) {
var l = e.getGeneralPurposeVariable(k);
f != l ? (g = !1, f = l) :h++;
}
if (!g) {
for (var g = f = 0, l = [], m = [], n = e.getGeneralPurposeVariable(e.minRank + 1), k = e.minRank + 1; k < e.maxRank - 1; k++) {
var p = e.getX(k + 1);
n == p ? (l[k - e.minRank - 1] = n, f++) :this.repositionValid(b, e, k + 1, n) ? (l[k - e.minRank - 1] = n, 
f++) :n = l[k - e.minRank - 1] = p;
}
for (n = e.getX(k), k = e.maxRank - 1; k > e.minRank + 1; k--) p = e.getX(k - 1), 
n == p ? (m[k - e.minRank - 2] = n, g++) :this.repositionValid(b, e, k - 1, n) ? (m[k - e.minRank - 2] = n, 
g++) :(m[k - e.minRank - 2] = e.getX(k - 1), n = p);
if (g > h || f > h) if (g >= f) for (k = e.maxRank - 2; k > e.minRank; k--) e.setX(k, m[k - e.minRank - 1]); else if (f > g) for (k = e.minRank + 2; k < e.maxRank; k++) e.setX(k, l[k - e.minRank - 2]);
}
}
}
}, mxCoordinateAssignment.prototype.repositionValid = function(a, b, c, d) {
a = a.ranks[c];
for (var e = -1, f = 0; f < a.length; f++) if (b == a[f]) {
e = f;
break;
}
if (0 > e) return !1;
if (f = b.getGeneralPurposeVariable(c), f > d) {
if (0 == e) return !0;
if (a = a[e - 1], c = a.getGeneralPurposeVariable(c), c = c + a.width / 2 + this.intraCellSpacing + b.width / 2, 
!(d >= c)) return !1;
} else if (d > f) {
if (e == a.length - 1) return !0;
if (a = a[e + 1], c = a.getGeneralPurposeVariable(c), c = c - a.width / 2 - this.intraCellSpacing - b.width / 2, 
!(c >= d)) return !1;
}
return !0;
}, mxCoordinateAssignment.prototype.setCellLocations = function(a, b) {
this.rankTopY = [], this.rankBottomY = [];
for (var c = 0; c < b.ranks.length; c++) this.rankTopY[c] = Number.MAX_VALUE, this.rankBottomY[c] = 0;
c = null, this.layout.resizeParent && (c = {});
var f, d = b.edgeMapper, e = b.vertexMapper;
for (f in e) {
var g = e[f];
if (this.setVertexLocation(g), this.layout.resizeParent) {
var g = a.model.getParent(g.cell), h = mxCellPath.create(g);
null == c[h] && (c[h] = g);
}
}
this.layout.resizeParent && null != c && this.adjustParents(c), (this.edgeStyle == mxHierarchicalEdgeStyle.ORTHOGONAL || this.edgeStyle == mxHierarchicalEdgeStyle.POLYLINE || this.edgeStyle == mxHierarchicalEdgeStyle.CURVE) && this.localEdgeProcessing(b);
for (f in d) this.setEdgePosition(d[f]);
}, mxCoordinateAssignment.prototype.adjustParents = function(a) {
var c, b = [];
for (c in a) b.push(a[c]);
this.layout.arrangeGroups(mxUtils.sortCells(b, !0), this.groupPadding);
}, mxCoordinateAssignment.prototype.localEdgeProcessing = function(a) {
for (var b = 0; b < a.ranks.length; b++) for (var c = a.ranks[b], d = 0; d < c.length; d++) {
var e = c[d];
if (e.isVertex()) for (var f = e.getPreviousLayerConnectedCells(b), g = b - 1, h = 0; 2 > h; h++) {
if (g > -1 && g < a.ranks.length && null != f && 0 < f.length) {
for (var k = [], l = 0; l < f.length; l++) {
var m = new WeightedCellSorter(f[l], f[l].getX(g));
k.push(m);
}
k.sort(WeightedCellSorter.prototype.compare);
for (var m = e.x[0] - e.width / 2, n = m + e.width, p = f = 0, g = [], l = 0; l < k.length; l++) {
var s, q = k[l].cell;
if (q.isVertex()) {
s = 0 == h ? e.connectsAsSource :e.connectsAsTarget;
for (var r = 0; r < s.length; r++) (s[r].source == q || s[r].target == q) && (f += s[r].edges.length, 
p++, g.push(s[r]));
} else f += q.edges.length, p++, g.push(q);
}
for (e.width > (f + 1) * this.prefHozEdgeSep + 2 * this.prefHozEdgeSep && (m += this.prefHozEdgeSep, 
n -= this.prefHozEdgeSep), k = (n - m) / f, m += k / 2, n = this.minEdgeJetty - this.prefVertEdgeOff, 
l = p = 0; l < g.length; l++) {
for (q = g[l].edges.length, r = mxCellPath.create(g[l].edges[0]), s = this.jettyPositions[r], 
null == s && (s = [], this.jettyPositions[r] = s), f / 2 > l ? n += this.prefVertEdgeOff :l > f / 2 && (n -= this.prefVertEdgeOff), 
r = 0; q > r; r++) s[4 * r + 2 * h] = m, m += k, s[4 * r + 2 * h + 1] = n;
p = Math.max(p, n);
}
}
f = e.getNextLayerConnectedCells(b), g = b + 1;
}
}
}, mxCoordinateAssignment.prototype.setEdgePosition = function(a) {
var b = 0;
if (101207 != a.temp[0]) {
var c = a.maxRank, d = a.minRank;
c == d && (c = a.source.maxRank, d = a.target.minRank);
for (var e = 0, f = mxCellPath.create(a.edges[0]), f = this.jettyPositions[f], g = a.isReversed ? a.target.cell :a.source.cell, h = this.layout.graph, k = 0; k < a.edges.length; k++) {
var l = a.edges[k], m = this.layout.getVisibleTerminal(l, !0), n = h.model.getTerminal(l, !0), p = [], q = a.isReversed;
if (m != g && (q = !q), null != f) {
var s = q ? 2 :0, r = q ? this.rankTopY[d] :this.rankBottomY[c], t = f[4 * e + 1 + s];
q && (t = -t), r += t, s = f[4 * e + s], n = h.model.getTerminal(l, !0), this.layout.isPort(n) && h.model.getParent(n) == m && (s = h.view.getState(n), 
s = null != s ? s.x :m.geometry.x + a.source.width * n.geometry.x), this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH ? (p.push(new mxPoint(s, r)), 
this.edgeStyle == mxHierarchicalEdgeStyle.CURVE && p.push(new mxPoint(s, r + t))) :(p.push(new mxPoint(r, s)), 
this.edgeStyle == mxHierarchicalEdgeStyle.CURVE && p.push(new mxPoint(r + t, s)));
}
for (s = a.x.length - 1, r = t = -1, m = a.maxRank - 1, q && (s = 0, t = a.x.length, 
r = 1, m = a.minRank + 1); a.maxRank != a.minRank && s != t; s += r) {
var n = a.x[s] + b, u = (this.rankTopY[m] + this.rankBottomY[m + 1]) / 2, v = (this.rankTopY[m - 1] + this.rankBottomY[m]) / 2;
if (q) var w = u, u = v, v = w;
this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH ? (p.push(new mxPoint(n, u)), 
p.push(new mxPoint(n, v))) :(p.push(new mxPoint(u, n)), p.push(new mxPoint(v, n))), 
this.limitX = Math.max(this.limitX, n), m += r;
}
null != f && (s = q ? 2 :0, r = q ? this.rankBottomY[c] :this.rankTopY[d], t = f[4 * e + 3 - s], 
q && (t = -t), r -= t, s = f[4 * e + 2 - s], q = h.model.getTerminal(l, !1), m = this.layout.getVisibleTerminal(l, !1), 
this.layout.isPort(q) && h.model.getParent(q) == m && (s = h.view.getState(q), s = null != s ? s.x :m.geometry.x + a.target.width * q.geometry.x), 
this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH ? (this.edgeStyle == mxHierarchicalEdgeStyle.CURVE && p.push(new mxPoint(s, r - t)), 
p.push(new mxPoint(s, r))) :(this.edgeStyle == mxHierarchicalEdgeStyle.CURVE && p.push(new mxPoint(r - t, s)), 
p.push(new mxPoint(r, s)))), a.isReversed && this.processReversedEdge(a, l), this.layout.setEdgePoints(l, p), 
b = 0 == b ? this.parallelEdgeSpacing :b > 0 ? -b :-b + this.parallelEdgeSpacing, 
e++;
}
a.temp[0] = 101207;
}
}, mxCoordinateAssignment.prototype.setVertexLocation = function(a) {
var b = a.cell, c = a.x[0] - a.width / 2, d = a.y[0] - a.height / 2;
this.rankTopY[a.minRank] = Math.min(this.rankTopY[a.minRank], d), this.rankBottomY[a.minRank] = Math.max(this.rankBottomY[a.minRank], d + a.height), 
this.orientation == mxConstants.DIRECTION_NORTH || this.orientation == mxConstants.DIRECTION_SOUTH ? this.layout.setVertexLocation(b, c, d) :this.layout.setVertexLocation(b, d, c), 
this.limitX = Math.max(this.limitX, c + a.width);
}, mxCoordinateAssignment.prototype.processReversedEdge = function() {}, WeightedCellSorter.prototype.weightedValue = 0, 
WeightedCellSorter.prototype.nudge = !1, WeightedCellSorter.prototype.visited = !1, 
WeightedCellSorter.prototype.rankIndex = null, WeightedCellSorter.prototype.cell = null, 
WeightedCellSorter.prototype.compare = function(a, b) {
return null != a && null != b ? b.weightedValue > a.weightedValue ? -1 :b.weightedValue < a.weightedValue ? 1 :b.nudge ? -1 :1 :0;
}, mxHierarchicalLayout.prototype = new mxGraphLayout(), mxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout, 
mxHierarchicalLayout.prototype.roots = null, mxHierarchicalLayout.prototype.resizeParent = !1, 
mxHierarchicalLayout.prototype.moveParent = !1, mxHierarchicalLayout.prototype.parentBorder = 0, 
mxHierarchicalLayout.prototype.intraCellSpacing = 30, mxHierarchicalLayout.prototype.interRankCellSpacing = 100, 
mxHierarchicalLayout.prototype.interHierarchySpacing = 60, mxHierarchicalLayout.prototype.parallelEdgeSpacing = 10, 
mxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH, mxHierarchicalLayout.prototype.fineTuning = !0, 
mxHierarchicalLayout.prototype.tightenToSource = !0, mxHierarchicalLayout.prototype.disableEdgeStyle = !0, 
mxHierarchicalLayout.prototype.traverseAncestors = !0, mxHierarchicalLayout.prototype.model = null, 
mxHierarchicalLayout.prototype.edgesCache = null, mxHierarchicalLayout.prototype.getModel = function() {
return this.model;
}, mxHierarchicalLayout.prototype.execute = function(a, b) {
this.parent = a;
var c = this.graph.model;
if (this.edgesCache = {}, null != b && "array" != typeof b && (b = [ b ]), null != b || null != a) {
if (null != b && null != a) {
for (var d = [], e = 0; e < b.length; e++) c.isAncestor(a, b[e]) && d.push(b[e]);
this.roots = d;
} else this.roots = b;
c.beginUpdate();
try {
this.run(a), this.resizeParent && !this.graph.isCellCollapsed(a) && this.graph.updateGroupBounds([ a ], this.parentBorder, this.moveParent);
} finally {
c.endUpdate();
}
}
}, mxHierarchicalLayout.prototype.findRoots = function(a, b) {
var c = [];
if (null != a && null != b) {
var g, d = this.graph.model, e = null, f = -1e5;
for (g in b) {
var h = b[g];
if (d.isVertex(h) && this.graph.isCellVisible(h)) {
for (var k = this.getEdges(h), l = 0, m = 0, n = 0; n < k.length; n++) this.getVisibleTerminal(k[n], !0) == h ? l++ :m++;
0 == m && l > 0 && c.push(h), k = l - m, k > f && (f = k, e = h);
}
}
0 == c.length && null != e && c.push(e);
}
return c;
}, mxHierarchicalLayout.prototype.getEdges = function(a) {
var b = mxCellPath.create(a);
if (null != this.edgesCache[b]) return this.edgesCache[b];
for (var c = this.graph.model, d = [], e = this.graph.isCellCollapsed(a), f = c.getChildCount(a), g = 0; f > g; g++) {
var h = c.getChildAt(a, g);
this.isPort(h) ? d = d.concat(c.getEdges(h, !0, !0)) :(e || !this.graph.isCellVisible(h)) && (d = d.concat(c.getEdges(h, !0, !0)));
}
for (d = d.concat(c.getEdges(a, !0, !0)), c = [], g = 0; g < d.length; g++) e = this.getVisibleTerminal(d[g], !0), 
f = this.getVisibleTerminal(d[g], !1), (e == f || e != f && (f == a && (null == this.parent || this.graph.isValidAncestor(e, this.parent, this.traverseAncestors)) || e == a && (null == this.parent || this.graph.isValidAncestor(f, this.parent, this.traverseAncestors)))) && c.push(d[g]);
return this.edgesCache[b] = c;
}, mxHierarchicalLayout.prototype.getVisibleTerminal = function(a, b) {
var c = this.graph.view.getState(a), c = null != c ? c.getVisibleTerminal(b) :this.graph.view.getVisibleTerminal(a, b);
return this.isPort(c) && (c = this.graph.model.getParent(c)), c;
}, mxHierarchicalLayout.prototype.run = function(a) {
var b = [], c = [];
if (null == this.roots && null != a) {
var d = {};
this.filterDescendants(a, d), this.roots = [];
var f, e = !0;
for (f in d) if (null != d[f]) {
e = !1;
break;
}
for (;!e; ) {
for (var g = this.findRoots(a, d), e = 0; e < g.length; e++) {
var h = {};
b.push(h), this.traverse(g[e], !0, null, c, h, b, d);
}
for (e = 0; e < g.length; e++) this.roots.push(g[e]);
e = !0;
for (f in d) if (null != d[f]) {
e = !1;
break;
}
}
} else for (e = 0; e < this.roots.length; e++) h = {}, b.push(h), this.traverse(this.roots[e], !0, null, c, h, b, null);
for (e = c = 0; e < b.length; e++) {
h = b[e], d = [];
for (f in h) d.push(h[f]);
this.model = new mxGraphHierarchyModel(this, d, this.roots, a, this.tightenToSource), 
this.cycleStage(a), this.layeringStage(), this.crossingStage(a), c = this.placementStage(c, a);
}
}, mxHierarchicalLayout.prototype.filterDescendants = function(a, b) {
var c = this.graph.model;
if (c.isVertex(a) && a != this.parent && this.graph.isCellVisible(a) && (b[mxCellPath.create(a)] = a), 
this.traverseAncestors || a == this.parent && this.graph.isCellVisible(a)) for (var d = c.getChildCount(a), e = 0; d > e; e++) {
var f = c.getChildAt(a, e);
this.isPort(f) || this.filterDescendants(f, b);
}
}, mxHierarchicalLayout.prototype.isPort = function(a) {
return a.geometry.relative ? !0 :!1;
}, mxHierarchicalLayout.prototype.getEdgesBetween = function(a, b, c) {
c = null != c ? c :!1;
for (var d = this.getEdges(a), e = [], f = 0; f < d.length; f++) {
var g = this.getVisibleTerminal(d[f], !0), h = this.getVisibleTerminal(d[f], !1);
(g == a && h == b || !c && g == b && h == a) && e.push(d[f]);
}
return e;
}, mxHierarchicalLayout.prototype.traverse = function(a, b, c, d, e, f, g) {
if (null != a && null != d) {
var h = mxCellPath.create(a);
if (null != d[h] || null != g && null == g[h]) {
if (null == e[h]) for (c = 0; c < f.length; c++) if (a = f[c], null != a[h]) {
for (k in e) a[k] = e[k];
return f.pop(), a;
}
} else {
null == e[h] && (e[h] = a), null == d[h] && (d[h] = a), null !== g && delete g[h];
var k = this.getEdges(a);
for (c = 0; c < k.length; c++) h = this.getVisibleTerminal(k[c], !0) == a, (!b || h) && (h = this.getVisibleTerminal(k[c], !h), 
e = this.traverse(h, b, k[c], d, e, f, g));
}
}
return e;
}, mxHierarchicalLayout.prototype.cycleStage = function(a) {
new mxMinimumCycleRemover(this).execute(a);
}, mxHierarchicalLayout.prototype.layeringStage = function() {
this.model.initialRank(), this.model.fixRanks();
}, mxHierarchicalLayout.prototype.crossingStage = function(a) {
new mxMedianHybridCrossingReduction(this).execute(a);
}, mxHierarchicalLayout.prototype.placementStage = function(a, b) {
var c = new mxCoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, a, this.parallelEdgeSpacing);
return c.fineTuning = this.fineTuning, c.execute(b), c.limitX + this.interHierarchySpacing;
}, mxGraphModel.prototype = new mxEventSource(), mxGraphModel.prototype.constructor = mxGraphModel, 
mxGraphModel.prototype.root = null, mxGraphModel.prototype.cells = null, mxGraphModel.prototype.maintainEdgeParent = !0, 
mxGraphModel.prototype.createIds = !0, mxGraphModel.prototype.prefix = "", mxGraphModel.prototype.postfix = "", 
mxGraphModel.prototype.nextId = 0, mxGraphModel.prototype.currentEdit = null, mxGraphModel.prototype.updateLevel = 0, 
mxGraphModel.prototype.endingUpdate = !1, mxGraphModel.prototype.clear = function() {
this.setRoot(this.createRoot());
}, mxGraphModel.prototype.isCreateIds = function() {
return this.createIds;
}, mxGraphModel.prototype.setCreateIds = function(a) {
this.createIds = a;
}, mxGraphModel.prototype.createRoot = function() {
var a = new mxCell();
return a.insert(new mxCell()), a;
}, mxGraphModel.prototype.getCell = function(a) {
return null != this.cells ? this.cells[a] :null;
}, mxGraphModel.prototype.filterCells = function(a, b) {
var c = null;
if (null != a) for (var c = [], d = 0; d < a.length; d++) b(a[d]) && c.push(a[d]);
return c;
}, mxGraphModel.prototype.getDescendants = function(a) {
return this.filterDescendants(null, a);
}, mxGraphModel.prototype.filterDescendants = function(a, b) {
var c = [];
b = b || this.getRoot(), (null == a || a(b)) && c.push(b);
for (var d = this.getChildCount(b), e = 0; d > e; e++) var f = this.getChildAt(b, e), c = c.concat(this.filterDescendants(a, f));
return c;
}, mxGraphModel.prototype.getRoot = function(a) {
var b = a || this.root;
if (null != a) for (;null != a; ) b = a, a = this.getParent(a);
return b;
}, mxGraphModel.prototype.setRoot = function(a) {
return this.execute(new mxRootChange(this, a)), a;
}, mxGraphModel.prototype.rootChanged = function(a) {
var b = this.root;
return this.root = a, this.nextId = 0, this.cells = null, this.cellAdded(a), b;
}, mxGraphModel.prototype.isRoot = function(a) {
return null != a && this.root == a;
}, mxGraphModel.prototype.isLayer = function(a) {
return this.isRoot(this.getParent(a));
}, mxGraphModel.prototype.isAncestor = function(a, b) {
for (;null != b && b != a; ) b = this.getParent(b);
return b == a;
}, mxGraphModel.prototype.contains = function(a) {
return this.isAncestor(this.root, a);
}, mxGraphModel.prototype.getParent = function(a) {
return null != a ? a.getParent() :null;
}, mxGraphModel.prototype.add = function(a, b, c) {
if (b != a && null != a && null != b) {
null == c && (c = this.getChildCount(a));
var d = a != this.getParent(b);
this.execute(new mxChildChange(this, a, b, c)), this.maintainEdgeParent && d && this.updateEdgeParents(b);
}
return b;
}, mxGraphModel.prototype.cellAdded = function(a) {
if (null != a) {
if (null == a.getId() && this.createIds && a.setId(this.createId(a)), null != a.getId()) {
var b = this.getCell(a.getId());
if (b != a) {
for (;null != b; ) a.setId(this.createId(a)), b = this.getCell(a.getId());
null == this.cells && (this.cells = {}), this.cells[a.getId()] = a;
}
}
mxUtils.isNumeric(a.getId()) && (this.nextId = Math.max(this.nextId, a.getId()));
for (var b = this.getChildCount(a), c = 0; b > c; c++) this.cellAdded(this.getChildAt(a, c));
}
}, mxGraphModel.prototype.createId = function(a) {
return a = this.nextId, this.nextId++, this.prefix + a + this.postfix;
}, mxGraphModel.prototype.updateEdgeParents = function(a, b) {
b = b || this.getRoot(a);
for (var c = this.getChildCount(a), d = 0; c > d; d++) {
var e = this.getChildAt(a, d);
this.updateEdgeParents(e, b);
}
for (e = this.getEdgeCount(a), c = [], d = 0; e > d; d++) c.push(this.getEdgeAt(a, d));
for (d = 0; d < c.length; d++) e = c[d], this.isAncestor(b, e) && this.updateEdgeParent(e, b);
}, mxGraphModel.prototype.updateEdgeParent = function(a, b) {
for (var c = this.getTerminal(a, !0), d = this.getTerminal(a, !1), e = null; null != c && !this.isEdge(c) && null != c.geometry && c.geometry.relative; ) c = this.getParent(c);
for (;null != d && !this.isEdge(d) && null != d.geometry && d.geometry.relative; ) d = this.getParent(d);
if (this.isAncestor(b, c) && this.isAncestor(b, d) && (e = c == d ? this.getParent(c) :this.getNearestCommonAncestor(c, d), 
null != e && (this.getParent(e) != this.root || this.isAncestor(e, a)) && this.getParent(a) != e)) {
if (c = this.getGeometry(a), null != c) {
var f = this.getOrigin(this.getParent(a)), g = this.getOrigin(e), d = g.x - f.x, f = g.y - f.y, c = c.clone();
c.translate(-d, -f), this.setGeometry(a, c);
}
this.add(e, a, this.getChildCount(e));
}
}, mxGraphModel.prototype.getOrigin = function(a) {
var b = null;
return null != a ? (b = this.getOrigin(this.getParent(a)), this.isEdge(a) || (a = this.getGeometry(a), 
null != a && (b.x += a.x, b.y += a.y))) :b = new mxPoint(), b;
}, mxGraphModel.prototype.getNearestCommonAncestor = function(a, b) {
if (null != a && null != b) {
var c = mxCellPath.create(b);
if (null != c && 0 < c.length) {
var d = a, e = mxCellPath.create(d);
if (c.length < e.length) var d = b, f = e, e = c, c = f;
for (;null != d; ) {
if (f = this.getParent(d), 0 == c.indexOf(e + mxCellPath.PATH_SEPARATOR) && null != f) return d;
e = mxCellPath.getParentPath(e), d = f;
}
}
}
return null;
}, mxGraphModel.prototype.remove = function(a) {
return a == this.root ? this.setRoot(null) :null != this.getParent(a) && this.execute(new mxChildChange(this, null, a)), 
a;
}, mxGraphModel.prototype.cellRemoved = function(a) {
if (null != a && null != this.cells) {
for (var b = this.getChildCount(a) - 1; b >= 0; b--) this.cellRemoved(this.getChildAt(a, b));
null != this.cells && null != a.getId() && delete this.cells[a.getId()];
}
}, mxGraphModel.prototype.parentForCellChanged = function(a, b, c) {
var d = this.getParent(a);
return null != b ? (b != d || d.getIndex(a) != c) && b.insert(a, c) :null != d && (c = d.getIndex(a), 
d.remove(c)), this.contains(d) || null == b ? null == b && this.cellRemoved(a) :this.cellAdded(a), 
d;
}, mxGraphModel.prototype.getChildCount = function(a) {
return null != a ? a.getChildCount() :0;
}, mxGraphModel.prototype.getChildAt = function(a, b) {
return null != a ? a.getChildAt(b) :null;
}, mxGraphModel.prototype.getChildren = function(a) {
return null != a ? a.children :null;
}, mxGraphModel.prototype.getChildVertices = function(a) {
return this.getChildCells(a, !0, !1);
}, mxGraphModel.prototype.getChildEdges = function(a) {
return this.getChildCells(a, !1, !0);
}, mxGraphModel.prototype.getChildCells = function(a, b, c) {
b = null != b ? b :!1, c = null != c ? c :!1;
for (var d = this.getChildCount(a), e = [], f = 0; d > f; f++) {
var g = this.getChildAt(a, f);
(!c && !b || c && this.isEdge(g) || b && this.isVertex(g)) && e.push(g);
}
return e;
}, mxGraphModel.prototype.getTerminal = function(a, b) {
return null != a ? a.getTerminal(b) :null;
}, mxGraphModel.prototype.setTerminal = function(a, b, c) {
var d = b != this.getTerminal(a, c);
return this.execute(new mxTerminalChange(this, a, b, c)), this.maintainEdgeParent && d && this.updateEdgeParent(a, this.getRoot()), 
b;
}, mxGraphModel.prototype.setTerminals = function(a, b, c) {
this.beginUpdate();
try {
this.setTerminal(a, b, !0), this.setTerminal(a, c, !1);
} finally {
this.endUpdate();
}
}, mxGraphModel.prototype.terminalForCellChanged = function(a, b, c) {
var d = this.getTerminal(a, c);
return null != b ? b.insertEdge(a, c) :null != d && d.removeEdge(a, c), d;
}, mxGraphModel.prototype.getEdgeCount = function(a) {
return null != a ? a.getEdgeCount() :0;
}, mxGraphModel.prototype.getEdgeAt = function(a, b) {
return null != a ? a.getEdgeAt(b) :null;
}, mxGraphModel.prototype.getDirectedEdgeCount = function(a, b, c) {
for (var d = 0, e = this.getEdgeCount(a), f = 0; e > f; f++) {
var g = this.getEdgeAt(a, f);
g != c && this.getTerminal(g, b) == a && d++;
}
return d;
}, mxGraphModel.prototype.getConnections = function(a) {
return this.getEdges(a, !0, !0, !1);
}, mxGraphModel.prototype.getIncomingEdges = function(a) {
return this.getEdges(a, !0, !1, !1);
}, mxGraphModel.prototype.getOutgoingEdges = function(a) {
return this.getEdges(a, !1, !0, !1);
}, mxGraphModel.prototype.getEdges = function(a, b, c, d) {
b = null != b ? b :!0, c = null != c ? c :!0, d = null != d ? d :!0;
for (var e = this.getEdgeCount(a), f = [], g = 0; e > g; g++) {
var h = this.getEdgeAt(a, g), k = this.getTerminal(h, !0), l = this.getTerminal(h, !1);
(d && k == l || k != l && (b && l == a || c && k == a)) && f.push(h);
}
return f;
}, mxGraphModel.prototype.getEdgesBetween = function(a, b, c) {
c = null != c ? c :!1;
var d = this.getEdgeCount(a), e = this.getEdgeCount(b), f = a, g = d;
for (d > e && (g = e, f = b), d = [], e = 0; g > e; e++) {
var h = this.getEdgeAt(f, e), k = this.getTerminal(h, !0), l = this.getTerminal(h, !1), m = l == a && k == b;
(k == a && l == b || !c && m) && d.push(h);
}
return d;
}, mxGraphModel.prototype.getOpposites = function(a, b, c, d) {
c = null != c ? c :!0, d = null != d ? d :!0;
var e = [];
if (null != a) for (var f = 0; f < a.length; f++) {
var g = this.getTerminal(a[f], !0), h = this.getTerminal(a[f], !1);
g == b && null != h && h != b && d ? e.push(h) :h == b && null != g && g != b && c && e.push(g);
}
return e;
}, mxGraphModel.prototype.getTopmostCells = function(a) {
for (var b = [], c = 0; c < a.length; c++) {
for (var d = a[c], e = !0, f = this.getParent(d); null != f; ) {
if (0 <= mxUtils.indexOf(a, f)) {
e = !1;
break;
}
f = this.getParent(f);
}
e && b.push(d);
}
return b;
}, mxGraphModel.prototype.isVertex = function(a) {
return null != a ? a.isVertex() :!1;
}, mxGraphModel.prototype.isEdge = function(a) {
return null != a ? a.isEdge() :!1;
}, mxGraphModel.prototype.isConnectable = function(a) {
return null != a ? a.isConnectable() :!1;
}, mxGraphModel.prototype.getValue = function(a) {
return null != a ? a.getValue() :null;
}, mxGraphModel.prototype.setValue = function(a, b) {
return this.execute(new mxValueChange(this, a, b)), b;
}, mxGraphModel.prototype.valueForCellChanged = function(a, b) {
return a.valueChanged(b);
}, mxGraphModel.prototype.getGeometry = function(a) {
return null != a ? a.getGeometry() :null;
}, mxGraphModel.prototype.setGeometry = function(a, b) {
return b != this.getGeometry(a) && this.execute(new mxGeometryChange(this, a, b)), 
b;
}, mxGraphModel.prototype.geometryForCellChanged = function(a, b) {
var c = this.getGeometry(a);
return a.setGeometry(b), c;
}, mxGraphModel.prototype.getStyle = function(a) {
return null != a ? a.getStyle() :null;
}, mxGraphModel.prototype.setStyle = function(a, b) {
return b != this.getStyle(a) && this.execute(new mxStyleChange(this, a, b)), b;
}, mxGraphModel.prototype.styleForCellChanged = function(a, b) {
var c = this.getStyle(a);
return a.setStyle(b), c;
}, mxGraphModel.prototype.isCollapsed = function(a) {
return null != a ? a.isCollapsed() :!1;
}, mxGraphModel.prototype.setCollapsed = function(a, b) {
return b != this.isCollapsed(a) && this.execute(new mxCollapseChange(this, a, b)), 
b;
}, mxGraphModel.prototype.collapsedStateForCellChanged = function(a, b) {
var c = this.isCollapsed(a);
return a.setCollapsed(b), c;
}, mxGraphModel.prototype.isVisible = function(a) {
return null != a ? a.isVisible() :!1;
}, mxGraphModel.prototype.setVisible = function(a, b) {
return b != this.isVisible(a) && this.execute(new mxVisibleChange(this, a, b)), 
b;
}, mxGraphModel.prototype.visibleStateForCellChanged = function(a, b) {
var c = this.isVisible(a);
return a.setVisible(b), c;
}, mxGraphModel.prototype.execute = function(a) {
a.execute(), this.beginUpdate(), this.currentEdit.add(a), this.fireEvent(new mxEventObject(mxEvent.EXECUTE, "change", a)), 
this.fireEvent(new mxEventObject(mxEvent.EXECUTED, "change", a)), this.endUpdate();
}, mxGraphModel.prototype.beginUpdate = function() {
this.updateLevel++, this.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE)), 1 == this.updateLevel && this.fireEvent(new mxEventObject(mxEvent.START_EDIT));
}, mxGraphModel.prototype.endUpdate = function() {
if (this.updateLevel--, 0 == this.updateLevel && this.fireEvent(new mxEventObject(mxEvent.END_EDIT)), 
!this.endingUpdate) {
this.endingUpdate = 0 == this.updateLevel, this.fireEvent(new mxEventObject(mxEvent.END_UPDATE, "edit", this.currentEdit));
try {
if (this.endingUpdate && !this.currentEdit.isEmpty()) {
this.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, "edit", this.currentEdit));
var a = this.currentEdit;
this.currentEdit = this.createUndoableEdit(), a.notify(), this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", a));
}
} finally {
this.endingUpdate = !1;
}
}
}, mxGraphModel.prototype.createUndoableEdit = function() {
var a = new mxUndoableEdit(this, !0);
return a.notify = function() {
a.source.fireEvent(new mxEventObject(mxEvent.CHANGE, "edit", a, "changes", a.changes)), 
a.source.fireEvent(new mxEventObject(mxEvent.NOTIFY, "edit", a, "changes", a.changes));
}, a;
}, mxGraphModel.prototype.mergeChildren = function(a, b, c) {
c = null != c ? c :!0, this.beginUpdate();
try {
var d = {};
this.mergeChildrenImpl(a, b, c, d);
for (var e in d) {
var f = d[e], g = this.getTerminal(f, !0);
null != g && (g = d[mxCellPath.create(g)], this.setTerminal(f, g, !0)), g = this.getTerminal(f, !1), 
null != g && (g = d[mxCellPath.create(g)], this.setTerminal(f, g, !1));
}
} finally {
this.endUpdate();
}
}, mxGraphModel.prototype.mergeChildrenImpl = function(a, b, c, d) {
this.beginUpdate();
try {
for (var e = a.getChildCount(), f = 0; e > f; f++) {
var g = a.getChildAt(f);
if ("function" == typeof g.getId) {
var h = g.getId(), k = null == h || this.isEdge(g) && c ? null :this.getCell(h);
if (null == k) {
var l = g.clone();
l.setId(h), l.setTerminal(g.getTerminal(!0), !0), l.setTerminal(g.getTerminal(!1), !1), 
k = b.insert(l), this.cellAdded(k);
}
d[mxCellPath.create(g)] = k, this.mergeChildrenImpl(g, k, c, d);
}
}
} finally {
this.endUpdate();
}
}, mxGraphModel.prototype.getParents = function(a) {
var b = [];
if (null != a) for (var c = {}, d = 0; d < a.length; d++) {
var e = this.getParent(a[d]);
if (null != e) {
var f = mxCellPath.create(e);
null == c[f] && (c[f] = e, b.push(e));
}
}
return b;
}, mxGraphModel.prototype.cloneCell = function(a) {
return null != a ? this.cloneCells([ a ], !0)[0] :null;
}, mxGraphModel.prototype.cloneCells = function(a, b) {
for (var c = {}, d = [], e = 0; e < a.length; e++) null != a[e] ? d.push(this.cloneCellImpl(a[e], c, b)) :d.push(null);
for (e = 0; e < d.length; e++) null != d[e] && this.restoreClone(d[e], a[e], c);
return d;
}, mxGraphModel.prototype.cloneCellImpl = function(a, b, c) {
var d = this.cellCloned(a);
if (b[mxObjectIdentity.get(a)] = d, c) {
c = this.getChildCount(a);
for (var e = 0; c > e; e++) {
var f = this.cloneCellImpl(this.getChildAt(a, e), b, !0);
d.insert(f);
}
}
return d;
}, mxGraphModel.prototype.cellCloned = function(a) {
return a.clone();
}, mxGraphModel.prototype.restoreClone = function(a, b, c) {
var d = this.getTerminal(b, !0);
null != d && (d = c[mxObjectIdentity.get(d)], null != d && d.insertEdge(a, !0)), 
d = this.getTerminal(b, !1), null != d && (d = c[mxObjectIdentity.get(d)], null != d && d.insertEdge(a, !1));
for (var d = this.getChildCount(a), e = 0; d > e; e++) this.restoreClone(this.getChildAt(a, e), this.getChildAt(b, e), c);
}, mxRootChange.prototype.execute = function() {
this.root = this.previous, this.previous = this.model.rootChanged(this.previous);
}, mxChildChange.prototype.execute = function() {
var a = this.model.getParent(this.child), b = null != a ? a.getIndex(this.child) :0;
null == this.previous && this.connect(this.child, !1), a = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex), 
null != this.previous && this.connect(this.child, !0), this.parent = this.previous, 
this.previous = a, this.index = this.previousIndex, this.previousIndex = b;
}, mxChildChange.prototype.connect = function(a, b) {
b = null != b ? b :!0;
var c = a.getTerminal(!0), d = a.getTerminal(!1);
for (null != c && (b ? this.model.terminalForCellChanged(a, c, !0) :this.model.terminalForCellChanged(a, null, !0)), 
null != d && (b ? this.model.terminalForCellChanged(a, d, !1) :this.model.terminalForCellChanged(a, null, !1)), 
a.setTerminal(c, !0), a.setTerminal(d, !1), c = this.model.getChildCount(a), d = 0; c > d; d++) this.connect(this.model.getChildAt(a, d), b);
}, mxTerminalChange.prototype.execute = function() {
this.terminal = this.previous, this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);
}, mxValueChange.prototype.execute = function() {
this.value = this.previous, this.previous = this.model.valueForCellChanged(this.cell, this.previous);
}, mxStyleChange.prototype.execute = function() {
this.style = this.previous, this.previous = this.model.styleForCellChanged(this.cell, this.previous);
}, mxGeometryChange.prototype.execute = function() {
this.geometry = this.previous, this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
}, mxCollapseChange.prototype.execute = function() {
this.collapsed = this.previous, this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);
}, mxVisibleChange.prototype.execute = function() {
this.visible = this.previous, this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);
}, mxCellAttributeChange.prototype.execute = function() {
var a = this.cell.getAttribute(this.attribute);
null == this.previous ? this.cell.value.removeAttribute(this.attribute) :this.cell.setAttribute(this.attribute, this.previous), 
this.previous = a;
}, mxCell.prototype.id = null, mxCell.prototype.value = null, mxCell.prototype.geometry = null, 
mxCell.prototype.style = null, mxCell.prototype.vertex = !1, mxCell.prototype.edge = !1, 
mxCell.prototype.connectable = !0, mxCell.prototype.visible = !0, mxCell.prototype.collapsed = !1, 
mxCell.prototype.parent = null, mxCell.prototype.source = null, mxCell.prototype.target = null, 
mxCell.prototype.children = null, mxCell.prototype.edges = null, mxCell.prototype.mxTransient = "id value parent source target children edges".split(" "), 
mxCell.prototype.getId = function() {
return this.id;
}, mxCell.prototype.setId = function(a) {
this.id = a;
}, mxCell.prototype.getValue = function() {
return this.value;
}, mxCell.prototype.setValue = function(a) {
this.value = a;
}, mxCell.prototype.valueChanged = function(a) {
var b = this.getValue();
return this.setValue(a), b;
}, mxCell.prototype.getGeometry = function() {
return this.geometry;
}, mxCell.prototype.setGeometry = function(a) {
this.geometry = a;
}, mxCell.prototype.getStyle = function() {
return this.style;
}, mxCell.prototype.setStyle = function(a) {
this.style = a;
}, mxCell.prototype.isVertex = function() {
return this.vertex;
}, mxCell.prototype.setVertex = function(a) {
this.vertex = a;
}, mxCell.prototype.isEdge = function() {
return this.edge;
}, mxCell.prototype.setEdge = function(a) {
this.edge = a;
}, mxCell.prototype.isConnectable = function() {
return this.connectable;
}, mxCell.prototype.setConnectable = function(a) {
this.connectable = a;
}, mxCell.prototype.isVisible = function() {
return this.visible;
}, mxCell.prototype.setVisible = function(a) {
this.visible = a;
}, mxCell.prototype.isCollapsed = function() {
return this.collapsed;
}, mxCell.prototype.setCollapsed = function(a) {
this.collapsed = a;
}, mxCell.prototype.getParent = function() {
return this.parent;
}, mxCell.prototype.setParent = function(a) {
this.parent = a;
}, mxCell.prototype.getTerminal = function(a) {
return a ? this.source :this.target;
}, mxCell.prototype.setTerminal = function(a, b) {
return b ? this.source = a :this.target = a, a;
}, mxCell.prototype.getChildCount = function() {
return null == this.children ? 0 :this.children.length;
}, mxCell.prototype.getIndex = function(a) {
return mxUtils.indexOf(this.children, a);
}, mxCell.prototype.getChildAt = function(a) {
return null == this.children ? null :this.children[a];
}, mxCell.prototype.insert = function(a, b) {
return null != a && (null == b && (b = this.getChildCount(), a.getParent() == this && b--), 
a.removeFromParent(), a.setParent(this), null == this.children ? (this.children = [], 
this.children.push(a)) :this.children.splice(b, 0, a)), a;
}, mxCell.prototype.remove = function(a) {
var b = null;
return null != this.children && a >= 0 && (b = this.getChildAt(a), null != b && (this.children.splice(a, 1), 
b.setParent(null))), b;
}, mxCell.prototype.removeFromParent = function() {
if (null != this.parent) {
var a = this.parent.getIndex(this);
this.parent.remove(a);
}
}, mxCell.prototype.getEdgeCount = function() {
return null == this.edges ? 0 :this.edges.length;
}, mxCell.prototype.getEdgeIndex = function(a) {
return mxUtils.indexOf(this.edges, a);
}, mxCell.prototype.getEdgeAt = function(a) {
return null == this.edges ? null :this.edges[a];
}, mxCell.prototype.insertEdge = function(a, b) {
return null != a && (a.removeFromTerminal(b), a.setTerminal(this, b), null == this.edges || a.getTerminal(!b) != this || 0 > mxUtils.indexOf(this.edges, a)) && (null == this.edges && (this.edges = []), 
this.edges.push(a)), a;
}, mxCell.prototype.removeEdge = function(a, b) {
if (null != a) {
if (a.getTerminal(!b) != this && null != this.edges) {
var c = this.getEdgeIndex(a);
c >= 0 && this.edges.splice(c, 1);
}
a.setTerminal(null, b);
}
return a;
}, mxCell.prototype.removeFromTerminal = function(a) {
var b = this.getTerminal(a);
null != b && b.removeEdge(this, a);
}, mxCell.prototype.getAttribute = function(a, b) {
var c = this.getValue();
return (null != c && c.nodeType == mxConstants.NODETYPE_ELEMENT ? c.getAttribute(a) :null) || b;
}, mxCell.prototype.setAttribute = function(a, b) {
var c = this.getValue();
null != c && c.nodeType == mxConstants.NODETYPE_ELEMENT && c.setAttribute(a, b);
}, mxCell.prototype.clone = function() {
var a = mxUtils.clone(this, this.mxTransient);
return a.setValue(this.cloneValue()), a;
}, mxCell.prototype.cloneValue = function() {
var a = this.getValue();
return null != a && ("function" == typeof a.clone ? a = a.clone() :isNaN(a.nodeType) || (a = a.cloneNode(!0))), 
a;
}, mxGeometry.prototype = new mxRectangle(), mxGeometry.prototype.constructor = mxGeometry, 
mxGeometry.prototype.TRANSLATE_CONTROL_POINTS = !0, mxGeometry.prototype.alternateBounds = null, 
mxGeometry.prototype.sourcePoint = null, mxGeometry.prototype.targetPoint = null, 
mxGeometry.prototype.points = null, mxGeometry.prototype.offset = null, mxGeometry.prototype.relative = !1, 
mxGeometry.prototype.swap = function() {
if (null != this.alternateBounds) {
var a = new mxRectangle(this.x, this.y, this.width, this.height);
this.x = this.alternateBounds.x, this.y = this.alternateBounds.y, this.width = this.alternateBounds.width, 
this.height = this.alternateBounds.height, this.alternateBounds = a;
}
}, mxGeometry.prototype.getTerminalPoint = function(a) {
return a ? this.sourcePoint :this.targetPoint;
}, mxGeometry.prototype.setTerminalPoint = function(a, b) {
return b ? this.sourcePoint = a :this.targetPoint = a, a;
}, mxGeometry.prototype.translate = function(a, b) {
if (this.clone(), this.relative || (this.x += a, this.y += b), null != this.sourcePoint && (this.sourcePoint.x += a, 
this.sourcePoint.y += b), null != this.targetPoint && (this.targetPoint.x += a, 
this.targetPoint.y += b), this.TRANSLATE_CONTROL_POINTS && null != this.points) for (var c = this.points.length, d = 0; c > d; d++) {
var e = this.points[d];
null != e && (e.x += a, e.y += b);
}
};

var mxCellPath = {
PATH_SEPARATOR:".",
create:function(a) {
var b = "";
if (null != a) for (var c = a.getParent(); null != c; ) b = c.getIndex(a) + mxCellPath.PATH_SEPARATOR + b, 
a = c, c = a.getParent();
return a = b.length, a > 1 && (b = b.substring(0, a - 1)), b;
},
getParentPath:function(a) {
if (null != a) {
var b = a.lastIndexOf(mxCellPath.PATH_SEPARATOR);
if (b >= 0) return a.substring(0, b);
if (0 < a.length) return "";
}
return null;
},
resolve:function(a, b) {
var c = a;
if (null != b) for (var d = b.split(mxCellPath.PATH_SEPARATOR), e = 0; e < d.length; e++) c = c.getChildAt(parseInt(d[e]));
return c;
},
compare:function(a, b) {
for (var c = Math.min(a.length, b.length), d = 0, e = 0; c > e; e++) if (a[e] != b[e]) {
0 == a[e].length || 0 == b[e].length ? d = a[e] == b[e] ? 0 :a[e] > b[e] ? 1 :-1 :(c = parseInt(a[e]), 
e = parseInt(b[e]), d = c == e ? 0 :c > e ? 1 :-1);
break;
}
return 0 == d && (c = a.length, e = b.length, c != e && (d = c > e ? 1 :-1)), d;
}
}, mxPerimeter = {
RectanglePerimeter:function(a, b, c, d) {
b = a.getCenterX();
var e = a.getCenterY(), f = Math.atan2(c.y - e, c.x - b), g = new mxPoint(0, 0), h = Math.PI, k = Math.PI / 2 - f, l = Math.atan2(a.height, a.width);
return -h + l > f || f > h - l ? (g.x = a.x, g.y = e - a.width * Math.tan(f) / 2) :-l > f ? (g.y = a.y, 
g.x = b - a.height * Math.tan(k) / 2) :l > f ? (g.x = a.x + a.width, g.y = e + a.width * Math.tan(f) / 2) :(g.y = a.y + a.height, 
g.x = b + a.height * Math.tan(k) / 2), d && (c.x >= a.x && c.x <= a.x + a.width ? g.x = c.x :c.y >= a.y && c.y <= a.y + a.height && (g.y = c.y), 
c.x < a.x ? g.x = a.x :c.x > a.x + a.width && (g.x = a.x + a.width), c.y < a.y ? g.y = a.y :c.y > a.y + a.height && (g.y = a.y + a.height)), 
g;
},
EllipsePerimeter:function(a, b, c, d) {
var e = a.x, f = a.y, g = a.width / 2, h = a.height / 2, k = e + g, l = f + h;
b = c.x, c = c.y;
var m = parseInt(b - k), n = parseInt(c - l);
if (0 == m && 0 != n) return new mxPoint(k, l + h * n / Math.abs(n));
if (0 == m && 0 == n) return new mxPoint(b, c);
if (d) {
if (c >= f && c <= f + a.height) return a = c - l, a = Math.sqrt(g * g * (1 - a * a / (h * h))) || 0, 
e >= b && (a = -a), new mxPoint(k + a, c);
if (b >= e && b <= e + a.width) return a = b - k, a = Math.sqrt(h * h * (1 - a * a / (g * g))) || 0, 
f >= c && (a = -a), new mxPoint(b, l + a);
}
return e = n / m, l -= e * k, f = g * g * e * e + h * h, a = -2 * k * f, h = Math.sqrt(a * a - 4 * f * (g * g * e * e * k * k + h * h * k * k - g * g * h * h)), 
g = (-a + h) / (2 * f), h = (-a - h) / (2 * f), k = e * g + l, l = e * h + l, e = Math.sqrt(Math.pow(g - b, 2) + Math.pow(k - c, 2)), 
b = Math.sqrt(Math.pow(h - b, 2) + Math.pow(l - c, 2)), f = c = 0, b > e ? (c = g, 
f = k) :(c = h, f = l), new mxPoint(c, f);
},
RhombusPerimeter:function(a, b, c, d) {
b = a.x;
var e = a.y, f = a.width;
a = a.height;
var g = b + f / 2, h = e + a / 2, k = c.x;
if (c = c.y, g == k) return h > c ? new mxPoint(g, e) :new mxPoint(g, e + a);
if (h == c) return g > k ? new mxPoint(b, h) :new mxPoint(b + f, h);
var l = g, m = h;
return d && (k >= b && b + f >= k ? l = k :c >= e && e + a >= c && (m = c)), g > k ? h > c ? mxUtils.intersection(k, c, l, m, g, e, b, h) :mxUtils.intersection(k, c, l, m, g, e + a, b, h) :h > c ? mxUtils.intersection(k, c, l, m, g, e, b + f, h) :mxUtils.intersection(k, c, l, m, g, e + a, b + f, h);
},
TrianglePerimeter:function(a, b, c, d) {
b = null != b ? b.style[mxConstants.STYLE_DIRECTION] :null;
var e = b == mxConstants.DIRECTION_NORTH || b == mxConstants.DIRECTION_SOUTH, f = a.x, g = a.y, h = a.width;
a = a.height;
var k = f + h / 2, l = g + a / 2, m = new mxPoint(f, g), n = new mxPoint(f + h, l), p = new mxPoint(f, g + a);
b == mxConstants.DIRECTION_NORTH ? (m = p, n = new mxPoint(k, g), p = new mxPoint(f + h, g + a)) :b == mxConstants.DIRECTION_SOUTH ? (n = new mxPoint(k, g + a), 
p = new mxPoint(f + h, g)) :b == mxConstants.DIRECTION_WEST && (m = new mxPoint(f + h, g), 
n = new mxPoint(f, l), p = new mxPoint(f + h, g + a));
var q = c.x - k, s = c.y - l, q = e ? Math.atan2(q, s) :Math.atan2(s, q), r = e ? Math.atan2(h, a) :Math.atan2(a, h), s = !1, s = b == mxConstants.DIRECTION_NORTH || b == mxConstants.DIRECTION_WEST ? q > -r && r > q :q < -Math.PI + r || q > Math.PI - r, r = null;
return s ? r = d && (e && c.x >= m.x && c.x <= p.x || !e && c.y >= m.y && c.y <= p.y) ? e ? new mxPoint(c.x, m.y) :new mxPoint(m.x, c.y) :b == mxConstants.DIRECTION_NORTH ? new mxPoint(f + h / 2 + a * Math.tan(q) / 2, g + a) :b == mxConstants.DIRECTION_SOUTH ? new mxPoint(f + h / 2 - a * Math.tan(q) / 2, g) :b == mxConstants.DIRECTION_WEST ? new mxPoint(f + h, g + a / 2 + h * Math.tan(q) / 2) :new mxPoint(f, g + a / 2 - h * Math.tan(q) / 2) :(d && (d = new mxPoint(k, l), 
c.y >= g && c.y <= g + a ? (d.x = e ? k :b == mxConstants.DIRECTION_WEST ? f + h :f, 
d.y = c.y) :c.x >= f && c.x <= f + h && (d.x = c.x, d.y = e ? b == mxConstants.DIRECTION_NORTH ? g + a :g :l), 
k = d.x, l = d.y), r = e && c.x <= f + h / 2 || !e && c.y <= g + a / 2 ? mxUtils.intersection(c.x, c.y, k, l, m.x, m.y, n.x, n.y) :mxUtils.intersection(c.x, c.y, k, l, n.x, n.y, p.x, p.y)), 
null == r && (r = new mxPoint(k, l)), r;
}
};

mxPrintPreview.prototype.graph = null, mxPrintPreview.prototype.pageFormat = null, 
mxPrintPreview.prototype.scale = null, mxPrintPreview.prototype.border = 0, mxPrintPreview.prototype.x0 = 0, 
mxPrintPreview.prototype.y0 = 0, mxPrintPreview.prototype.autoOrigin = !0, mxPrintPreview.prototype.printOverlays = !1, 
mxPrintPreview.prototype.borderColor = null, mxPrintPreview.prototype.title = null, 
mxPrintPreview.prototype.pageSelector = null, mxPrintPreview.prototype.wnd = null, 
mxPrintPreview.prototype.pageCount = 0, mxPrintPreview.prototype.getWindow = function() {
return this.wnd;
}, mxPrintPreview.prototype.getDoctype = function() {
var a = "";
return 8 == document.documentMode && (a = '<meta http-equiv="X-UA-Compatible" content="IE=8">'), 
a;
}, mxPrintPreview.prototype.open = function(a) {
var b = this.graph.cellRenderer.initializeOverlay, c = null;
try {
if (this.printOverlays && (this.graph.cellRenderer.initializeOverlay = function(a, b) {
b.init(a.view.getDrawPane());
}), null == this.wnd) {
this.wnd = window.open();
var d = this.wnd.document, e = this.getDoctype();
null != e && 0 < e.length && d.writeln(e), d.writeln("<html>"), d.writeln("<head>"), 
this.writeHead(d, a), d.writeln("</head>"), d.writeln('<body class="mxPage">'), 
mxClient.link("stylesheet", mxClient.basePath + "/css/common.css", d), mxClient.IS_VML && (d.namespaces.add("v", "urn:schemas-microsoft-com:vml"), 
d.namespaces.add("o", "urn:schemas-microsoft-com:office:office"), d.createStyleSheet().cssText = "v\\:*{behavior:url(#default#VML)}o\\:*{behavior:url(#default#VML)}", 
mxClient.link("stylesheet", mxClient.basePath + "/css/explorer.css", d));
var f = this.graph.getGraphBounds().clone(), g = this.graph.getView().getScale(), h = g / this.scale, k = this.graph.getView().getTranslate();
this.autoOrigin || (this.x0 = -k.x * this.scale, this.y0 = -k.y * this.scale, f.width += f.x, 
f.height += f.y, f.x = 0, this.border = f.y = 0), f.width /= h, f.height /= h;
var l = this.pageFormat.width - 2 * this.border, m = this.pageFormat.height - 2 * this.border, n = Math.max(1, Math.ceil((f.width + this.x0) / l)), p = Math.max(1, Math.ceil((f.height + this.y0) / m));
this.pageCount = n * p;
var q = mxUtils.bind(this, function() {
if (this.pageSelector && (p > 1 || n > 1)) {
var a = this.createPageSelector(p, n);
if (d.body.appendChild(a), mxClient.IS_IE) {
a.style.position = "absolute";
var b = function() {
a.style.top = d.body.scrollTop + 10 + "px";
};
mxEvent.addListener(this.wnd, "scroll", function() {
b();
}), mxEvent.addListener(this.wnd, "resize", function() {
b();
});
}
}
});
a = function(a, b) {
if (null != this.borderColor && (a.style.borderColor = this.borderColor, a.style.borderStyle = "solid", 
a.style.borderWidth = "1px"), a.style.background = "white", b && (a.style.pageBreakAfter = "always"), 
mxClient.IS_IE ? (d.writeln(a.outerHTML), a.parentNode.removeChild(a)) :(a.parentNode.removeChild(a), 
d.body.appendChild(a)), b) {
var c = d.createElement("hr");
c.className = "mxPageBreak", d.body.appendChild(c);
}
};
var s = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);
if (null != s) for (var r = 0; r < s.length; r++) a(s[r], !0);
for (var t = this.getAppendices(this.pageFormat.width, this.pageFormat.height), r = 0; p > r; r++) for (var u = r * m / this.scale - this.y0 / this.scale + (f.y - k.y * g) / g, s = 0; n > s; s++) {
if (null == this.wnd) return null;
var v = s * l / this.scale - this.x0 / this.scale + (f.x - k.x * g) / g, w = r * n + s + 1, c = this.renderPage(this.pageFormat.width, this.pageFormat.height, mxUtils.bind(this, function(a) {
this.addGraphFragment(-v, -u, this.scale, w, a);
}));
c.setAttribute("id", "mxPage-" + w), a(c, null != t || p - 1 > r || n - 1 > s);
}
if (null != t) for (r = 0; r < t.length; r++) a(t[r], r < t.length);
d.writeln("</body>"), d.writeln("</html>"), d.close(), q(), mxEvent.release(d.body);
}
this.wnd.focus();
} catch (y) {
null != c && null != c.parentNode && c.parentNode.removeChild(c);
} finally {
this.graph.cellRenderer.initializeOverlay = b;
}
return this.wnd;
}, mxPrintPreview.prototype.writeHead = function(a, b) {
null != this.title && a.writeln("<title>" + this.title + "</title>"), a.writeln('<style type="text/css">'), 
a.writeln("@media print {"), a.writeln("  table.mxPageSelector { display: none; }"), 
a.writeln("  hr.mxPageBreak { display: none; }"), a.writeln("}"), a.writeln("@media screen {"), 
a.writeln("  table.mxPageSelector { position: fixed; right: 10px; top: 10px;font-family: Arial; font-size:10pt; border: solid 1px darkgray;background: white; border-collapse:collapse; }"), 
a.writeln("  table.mxPageSelector td { border: solid 1px gray; padding:4px; }"), 
a.writeln("  body.mxPage { background: gray; }"), a.writeln("}"), null != b && a.writeln(b), 
a.writeln("</style>");
}, mxPrintPreview.prototype.createPageSelector = function(a, b) {
var c = this.wnd.document, d = c.createElement("table");
d.className = "mxPageSelector", d.setAttribute("border", "0");
for (var e = c.createElement("tbody"), f = 0; a > f; f++) {
for (var g = c.createElement("tr"), h = 0; b > h; h++) {
var k = f * b + h + 1, l = c.createElement("td");
if (!mxClient.IS_NS || mxClient.IS_SF || mxClient.IS_GC) {
var m = c.createElement("a");
m.setAttribute("href", "#mxPage-" + k), mxUtils.write(m, k, c), l.appendChild(m);
} else mxUtils.write(l, k, c);
g.appendChild(l);
}
e.appendChild(g);
}
return d.appendChild(e), d;
}, mxPrintPreview.prototype.renderPage = function(a, b, c) {
var d = document.createElement("div");
try {
d.style.width = a + "px", d.style.height = b + "px", d.style.overflow = "hidden", 
d.style.pageBreakInside = "avoid", d.style.position = "relative";
var e = document.createElement("div");
e.style.top = this.border + "px", e.style.left = this.border + "px", e.style.width = a - 2 * this.border + "px", 
e.style.height = b - 2 * this.border + "px", e.style.overflow = "hidden", this.graph.dialect == mxConstants.DIALECT_VML && (e.style.position = "absolute"), 
d.appendChild(e), document.body.appendChild(d), c(e);
} catch (f) {
throw d.parentNode.removeChild(d), f;
}
return d;
}, mxPrintPreview.prototype.getRoot = function() {
var a = this.graph.view.currentRoot;
return null == a && (a = this.graph.getModel().getRoot()), a;
}, mxPrintPreview.prototype.addGraphFragment = function(a, b, c, d, e) {
d = this.graph.getView();
var f = this.graph.container;
this.graph.container = e;
var g = d.getCanvas(), h = d.getBackgroundPane(), k = d.getDrawPane(), l = d.getOverlayPane();
this.graph.dialect == mxConstants.DIALECT_SVG ? d.createSvg() :this.graph.dialect == mxConstants.DIALECT_VML ? d.createVml() :d.createHtml();
var m = d.isEventsEnabled();
d.setEventsEnabled(!1);
var n = this.graph.isEnabled();
this.graph.setEnabled(!1);
var p = d.getTranslate();
d.translate = new mxPoint(a, b), a = null;
try {
var q = [ this.getRoot() ];
a = new mxTemporaryCellStates(d, c, q);
} finally {
if (mxClient.IS_IE) d.overlayPane.innerHTML = ""; else for (c = e.firstChild; null != c; ) q = c.nextSibling, 
b = c.nodeName.toLowerCase(), "svg" == b ? (c.setAttribute("width", parseInt(e.style.width)), 
c.setAttribute("height", parseInt(e.style.height))) :"default" != c.style.cursor && "table" != b && c.parentNode.removeChild(c), 
c = q;
d.overlayPane.parentNode.removeChild(d.overlayPane), this.graph.setEnabled(n), this.graph.container = f, 
d.canvas = g, d.backgroundPane = h, d.drawPane = k, d.overlayPane = l, d.translate = p, 
a.destroy(), d.setEventsEnabled(m);
}
}, mxPrintPreview.prototype.getCoverPages = function() {
return null;
}, mxPrintPreview.prototype.getAppendices = function() {
return null;
}, mxPrintPreview.prototype.print = function() {
var a = this.open();
null != a && a.print();
}, mxPrintPreview.prototype.close = function() {
null != this.wnd && (this.wnd.close(), this.wnd = null);
}, mxStylesheet.prototype.createDefaultVertexStyle = function() {
var a = {};
return a[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE, a[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter, 
a[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE, a[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER, 
a[mxConstants.STYLE_FILLCOLOR] = "#C3D9FF", a[mxConstants.STYLE_STROKECOLOR] = "#6482B9", 
a[mxConstants.STYLE_FONTCOLOR] = "#774400", a;
}, mxStylesheet.prototype.createDefaultEdgeStyle = function() {
var a = {};
return a[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR, a[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC, 
a[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE, a[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER, 
a[mxConstants.STYLE_STROKECOLOR] = "#6482B9", a[mxConstants.STYLE_FONTCOLOR] = "#446299", 
a;
}, mxStylesheet.prototype.putDefaultVertexStyle = function(a) {
this.putCellStyle("defaultVertex", a);
}, mxStylesheet.prototype.putDefaultEdgeStyle = function(a) {
this.putCellStyle("defaultEdge", a);
}, mxStylesheet.prototype.getDefaultVertexStyle = function() {
return this.styles.defaultVertex;
}, mxStylesheet.prototype.getDefaultEdgeStyle = function() {
return this.styles.defaultEdge;
}, mxStylesheet.prototype.putCellStyle = function(a, b) {
this.styles[a] = b;
}, mxStylesheet.prototype.getCellStyle = function(a, b) {
var c = b;
if (null != a && 0 < a.length) for (var d = a.split(";"), c = null != c && ";" != a.charAt(0) ? mxUtils.clone(c) :{}, e = 0; e < d.length; e++) {
var f = d[e], g = f.indexOf("=");
if (g >= 0) {
var h = f.substring(0, g), f = f.substring(g + 1);
f == mxConstants.NONE ? delete c[h] :c[h] = mxUtils.isNumeric(f) ? parseFloat(f) :f;
} else if (f = this.styles[f], null != f) for (h in f) c[h] = f[h];
}
return c;
}, mxCellState.prototype = new mxRectangle(), mxCellState.prototype.constructor = mxCellState, 
mxCellState.prototype.view = null, mxCellState.prototype.cell = null, mxCellState.prototype.style = null, 
mxCellState.prototype.invalid = !0, mxCellState.prototype.invalidOrder = !1, mxCellState.prototype.orderChanged = !1, 
mxCellState.prototype.origin = null, mxCellState.prototype.absolutePoints = null, 
mxCellState.prototype.absoluteOffset = null, mxCellState.prototype.visibleSourceState = null, 
mxCellState.prototype.visibleTargetState = null, mxCellState.prototype.terminalDistance = 0, 
mxCellState.prototype.length = 0, mxCellState.prototype.segments = null, mxCellState.prototype.shape = null, 
mxCellState.prototype.text = null, mxCellState.prototype.getPerimeterBounds = function(a, b) {
if (a = a || 0, b = null != b ? b :new mxRectangle(this.x, this.y, this.width, this.height), 
null != this.shape && null != this.shape.stencil) {
var c = this.shape.stencil.computeAspect(this.style, b.x, b.y, b.width, b.height);
b.x = c.x, b.y = c.y, b.width = this.shape.stencil.w0 * c.width, b.height = this.shape.stencil.h0 * c.height;
}
return 0 != a && b.grow(a), b;
}, mxCellState.prototype.setAbsoluteTerminalPoint = function(a, b) {
b ? (null == this.absolutePoints && (this.absolutePoints = []), 0 == this.absolutePoints.length ? this.absolutePoints.push(a) :this.absolutePoints[0] = a) :null == this.absolutePoints ? (this.absolutePoints = [], 
this.absolutePoints.push(null), this.absolutePoints.push(a)) :1 == this.absolutePoints.length ? this.absolutePoints.push(a) :this.absolutePoints[this.absolutePoints.length - 1] = a;
}, mxCellState.prototype.setCursor = function(a) {
null != this.shape && this.shape.setCursor(a), null != this.text && this.text.setCursor(a);
}, mxCellState.prototype.getVisibleTerminal = function(a) {
return a = this.getVisibleTerminalState(a), null != a ? a.cell :null;
}, mxCellState.prototype.getVisibleTerminalState = function(a) {
return a ? this.visibleSourceState :this.visibleTargetState;
}, mxCellState.prototype.setVisibleTerminalState = function(a, b) {
b ? this.visibleSourceState = a :this.visibleTargetState = a;
}, mxCellState.prototype.destroy = function() {
this.view.graph.cellRenderer.destroy(this);
}, mxCellState.prototype.clone = function() {
var a = new mxCellState(this.view, this.cell, this.style);
if (null != this.absolutePoints) {
a.absolutePoints = [];
for (var b = 0; b < this.absolutePoints.length; b++) a.absolutePoints[b] = this.absolutePoints[b].clone();
}
return null != this.origin && (a.origin = this.origin.clone()), null != this.absoluteOffset && (a.absoluteOffset = this.absoluteOffset.clone()), 
null != this.boundingBox && (a.boundingBox = this.boundingBox.clone()), a.terminalDistance = this.terminalDistance, 
a.segments = this.segments, a.length = this.length, a.x = this.x, a.y = this.y, 
a.width = this.width, a.height = this.height, a;
}, mxGraphSelectionModel.prototype = new mxEventSource(), mxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel, 
mxGraphSelectionModel.prototype.doneResource = "none" != mxClient.language ? "done" :"", 
mxGraphSelectionModel.prototype.updatingSelectionResource = "none" != mxClient.language ? "updatingSelection" :"", 
mxGraphSelectionModel.prototype.graph = null, mxGraphSelectionModel.prototype.singleSelection = !1, 
mxGraphSelectionModel.prototype.isSingleSelection = function() {
return this.singleSelection;
}, mxGraphSelectionModel.prototype.setSingleSelection = function(a) {
this.singleSelection = a;
}, mxGraphSelectionModel.prototype.isSelected = function(a) {
return null != a ? 0 <= mxUtils.indexOf(this.cells, a) :!1;
}, mxGraphSelectionModel.prototype.isEmpty = function() {
return 0 == this.cells.length;
}, mxGraphSelectionModel.prototype.clear = function() {
this.changeSelection(null, this.cells);
}, mxGraphSelectionModel.prototype.setCell = function(a) {
null != a && this.setCells([ a ]);
}, mxGraphSelectionModel.prototype.setCells = function(a) {
if (null != a) {
this.singleSelection && (a = [ this.getFirstSelectableCell(a) ]);
for (var b = [], c = 0; c < a.length; c++) this.graph.isCellSelectable(a[c]) && b.push(a[c]);
this.changeSelection(b, this.cells);
}
}, mxGraphSelectionModel.prototype.getFirstSelectableCell = function(a) {
if (null != a) for (var b = 0; b < a.length; b++) if (this.graph.isCellSelectable(a[b])) return a[b];
return null;
}, mxGraphSelectionModel.prototype.addCell = function(a) {
null != a && this.addCells([ a ]);
}, mxGraphSelectionModel.prototype.addCells = function(a) {
if (null != a) {
var b = null;
this.singleSelection && (b = this.cells, a = [ this.getFirstSelectableCell(a) ]);
for (var c = [], d = 0; d < a.length; d++) !this.isSelected(a[d]) && this.graph.isCellSelectable(a[d]) && c.push(a[d]);
this.changeSelection(c, b);
}
}, mxGraphSelectionModel.prototype.removeCell = function(a) {
null != a && this.removeCells([ a ]);
}, mxGraphSelectionModel.prototype.removeCells = function(a) {
if (null != a) {
for (var b = [], c = 0; c < a.length; c++) this.isSelected(a[c]) && b.push(a[c]);
this.changeSelection(null, b);
}
}, mxGraphSelectionModel.prototype.changeSelection = function(a, b) {
if (null != a && 0 < a.length && null != a[0] || null != b && 0 < b.length && null != b[0]) {
var c = new mxSelectionChange(this, a, b);
c.execute();
var d = new mxUndoableEdit(this, !1);
d.add(c), this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", d));
}
}, mxGraphSelectionModel.prototype.cellAdded = function(a) {
null != a && !this.isSelected(a) && this.cells.push(a);
}, mxGraphSelectionModel.prototype.cellRemoved = function(a) {
null != a && (a = mxUtils.indexOf(this.cells, a), a >= 0 && this.cells.splice(a, 1));
}, mxSelectionChange.prototype.execute = function() {
var a = mxLog.enter("mxSelectionChange.execute");
if (window.status = mxResources.get(this.selectionModel.updatingSelectionResource) || this.selectionModel.updatingSelectionResource, 
null != this.removed) for (var b = 0; b < this.removed.length; b++) this.selectionModel.cellRemoved(this.removed[b]);
if (null != this.added) for (b = 0; b < this.added.length; b++) this.selectionModel.cellAdded(this.added[b]);
b = this.added, this.added = this.removed, this.removed = b, window.status = mxResources.get(this.selectionModel.doneResource) || this.selectionModel.doneResource, 
mxLog.leave("mxSelectionChange.execute", a), this.selectionModel.fireEvent(new mxEventObject(mxEvent.CHANGE, "added", this.added, "removed", this.removed));
}, mxCellEditor.prototype.graph = null, mxCellEditor.prototype.textarea = null, 
mxCellEditor.prototype.editingCell = null, mxCellEditor.prototype.trigger = null, 
mxCellEditor.prototype.modified = !1, mxCellEditor.prototype.autoSize = !0, mxCellEditor.prototype.emptyLabelText = "", 
mxCellEditor.prototype.textNode = "", mxCellEditor.prototype.init = function() {
this.textarea = document.createElement("textarea"), this.textarea.className = "mxCellEditor", 
this.textarea.id = "mxCellEditor", this.textarea.style.position = "absolute", this.textarea.style.overflow = "auto", 
this.textarea.setAttribute("cols", "20"), this.textarea.setAttribute("rows", "4"), 
mxClient.IS_NS && (this.textarea.style.resize = "none"), mxEvent.addListener(this.textarea, "blur", mxUtils.bind(this, function() {
if (1 == window.remove_editor) window.remove_editor = 0, document.removeEventListener("click", editor_lost_focus, !0), 
this.focusLostTinyMce(); else {
if (-1 != window.remove_editor) return !1;
window.remove_editor = 0, this.focusLost();
}
})), mxEvent.addListener(this.textarea, "keydown", mxUtils.bind(this, function(a) {
mxEvent.isConsumed(a) || (113 == a.keyCode || this.graph.isEnterStopsCellEditing() && 13 == a.keyCode && !mxEvent.isControlDown(a) && !mxEvent.isShiftDown(a) ? (this.graph.stopEditing(!1), 
mxEvent.consume(a)) :27 == a.keyCode ? (this.graph.stopEditing(!0), mxEvent.consume(a)) :(this.clearOnChange && (this.clearOnChange = !1, 
this.textarea.value = ""), this.setModified(!0)));
})), this.changeHandler = mxUtils.bind(this, function() {
null != this.editingCell && null == this.graph.getView().getState(this.editingCell) && this.stopEditing(!0);
}), this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler), mxEvent.addListener(this.textarea, "keypress", mxUtils.bind(this, function(a) {
this.autoSize && !mxEvent.isConsumed(a) && setTimeout(mxUtils.bind(this, function() {
this.resize();
}), 0);
}));
}, mxCellEditor.prototype.resize = function() {
if (null != this.textDiv) {
var a = this.graph.getView().getState(this.editingCell);
if (null == a) this.stopEditing(!0); else {
var b = this.graph.isLabelClipped(a.cell), c = this.graph.isWrapping(a.cell);
if (this.graph.getModel().isEdge(a.cell)) this.bounds.x = a.absoluteOffset.x, this.bounds.y = a.absoluteOffset.y, 
this.bounds.width = 0, this.bounds.height = 0; else if (null != this.bounds) {
this.bounds.x = a.x, this.bounds.y = a.y, this.bounds.width = a.width, this.bounds.height = a.height;
var d = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
d == mxConstants.ALIGN_LEFT ? this.bounds.x -= a.width :d == mxConstants.ALIGN_RIGHT && (this.bounds.x += a.width), 
d = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE), 
d == mxConstants.ALIGN_TOP ? this.bounds.y -= a.height :d == mxConstants.ALIGN_BOTTOM && (this.bounds.y += a.height);
}
d = this.textarea.value, ("\n" == d.charAt(d.length - 1) || "" == d) && (d += "&nbsp;"), 
d = mxUtils.htmlEntities(d, !1), c ? (this.textDiv.style.whiteSpace = "normal", 
this.textDiv.style.width = this.bounds.width + "px") :d = d.replace(/ /g, "&nbsp;"), 
d = d.replace(/\n/g, "<br/>"), this.textDiv.innerHTML = d;
var d = this.textDiv.offsetWidth + 30, e = this.textDiv.offsetHeight + 16, d = Math.max(d, 40), e = Math.max(e, 20);
b && (d = Math.min(this.bounds.width - 4, d), e = Math.min(this.bounds.height, e));
var f = null != a.text ? a.text.margin :null;
null == f && (f = mxUtils.getValue(a.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER), 
a = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE), 
f = mxUtils.getAlignmentAsPoint(f, a)), null != f && ((b || !c) && (this.textarea.style.left = Math.max(0, Math.round(this.bounds.x - f.x * this.bounds.width + f.x * d) - 3) + "px"), 
this.textarea.style.top = Math.max(0, Math.round(this.bounds.y - f.y * this.bounds.height + f.y * e) + 4) + "px"), 
(b || !c) && (this.textarea.style.width = d + "px"), this.textarea.style.height = e + "px";
}
}
}, mxCellEditor.prototype.isModified = function() {
return this.modified;
}, mxCellEditor.prototype.setModified = function(a) {
this.modified = a;
}, mxCellEditor.prototype.focusLost = function() {
this.stopEditing(!this.graph.isInvokesStopCellEditing());
}, mxCellEditor.prototype.focusLostTinyMce = function() {
tinyMCE.triggerSave(), tinyMCE.execCommand("mceRemoveControl", !1, "mxCellEditor1"), 
this.textarea.value = this.text_tiny.value, this.modified = 1, this.div.removeChild(this.text_tiny), 
this.graph.container.removeChild(this.div), this.stopEditing(!this.graph.isInvokesStopCellEditing());
}, mxCellEditor.prototype.startEditing = function(a, b) {
null == this.textarea && this.init(), this.stopEditing(!0);
var c = this.graph.getView().getState(a);
if (null != c) {
this.editingCell = a, this.trigger = b, this.textNode = null, null != c.text && this.isHideLabel(c) && (this.textNode = c.text.node, 
this.textNode.style.visibility = "hidden");
var d = this.graph.getView().scale, d = mxUtils.getValue(c.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE) * d, e = mxUtils.getValue(c.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY), f = mxUtils.getValue(c.style, mxConstants.STYLE_FONTCOLOR, "black"), g = mxUtils.getValue(c.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT), h = (mxUtils.getValue(c.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD, k = (mxUtils.getValue(c.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC, l = (mxUtils.getValue(c.style, mxConstants.STYLE_FONTSTYLE, 0) & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE;
this.textarea.style.fontSize = Math.round(d) + "px", this.textarea.style.lineHeight = Math.round(d * mxConstants.LINE_HEIGHT) + "px", 
this.textarea.style.fontFamily = e, this.textarea.style.textAlign = g, this.textarea.style.color = f, 
this.textarea.style.fontWeight = h ? "bold" :"normal", this.textarea.style.fontStyle = k ? "italic" :"", 
this.textarea.style.textDecoration = l ? "underline" :"", this.textarea.style.overflow = "auto", 
this.textarea.style.outline = "none", this.bounds = d = this.getEditorBounds(c), 
this.textarea.style.left = d.x + "px", this.textarea.style.top = d.y + "px", this.textarea.style.width = d.width + "px", 
this.textarea.style.height = d.height + "px", this.textarea.style.zIndex = 5, c = this.getInitialValue(c, b), 
null == c || 0 == c.length ? (c = this.getEmptyLabelText(), this.clearOnChange = !0) :this.clearOnChange = !1, 
this.setModified(!1), this.textarea.value = "", this.graph.container.appendChild(this.textarea), 
null != c.match(".*\\<[^>]+>.*") ? (this.textarea.value = "", this.textarea.visibility = "hidden", 
this.div = document.createElement("div"), this.div.id = "mxCellEditor-Div", this.div.style.position = "absolute", 
this.div.style.left = d.x - 2 + "px", this.div.style.top = d.y - 32 + "px", this.div.style.zIndex = 5, 
this.text_tiny = document.createElement("textarea"), this.text_tiny.id = "mxCellEditor1", 
this.text_tiny.className = "mxCellEditor", this.text_tiny.style.position = "absolute", 
this.text_tiny.style.visibility = "hidden", this.text_tiny.style.width = d.width + "px", 
this.text_tiny.style.height = d.height + 44 + "px", this.text_tiny.value = c, this.div.appendChild(this.text_tiny), 
this.graph.container.appendChild(this.div), tinyMCE.execCommand("mceAddControl", !1, "mxCellEditor1"), 
document.addEventListener("click", editor_lost_focus, !0)) :(this.textarea.value = c, 
window.remove_editor = -1), "none" != this.textarea.style.display && (this.autoSize && (this.textDiv = this.createTextDiv(), 
document.body.appendChild(this.textDiv)), this.textarea.focus(), this.textarea.select());
}
}, mxCellEditor.prototype.createTextDiv = function() {
var a = document.createElement("div"), b = a.style;
return b.position = "absolute", b.whiteSpace = "nowrap", b.visibility = "hidden", 
b.display = mxClient.IS_QUIRKS ? "inline" :"inline-block", b.zoom = "1", b.verticalAlign = "top", 
b.lineHeight = this.textarea.style.lineHeight, b.fontSize = this.textarea.style.fontSize, 
b.fontFamily = this.textarea.style.fontFamily, b.fontWeight = this.textarea.style.fontWeight, 
b.textAlign = this.textarea.style.textAlign, b.fontStyle = this.textarea.style.fontStyle, 
b.textDecoration = this.textarea.style.textDecoration, a;
}, mxCellEditor.prototype.stopEditing = function(a) {
null != this.editingCell && (null != this.textNode && (this.textNode.style.visibility = "visible", 
this.textNode = null), !a && this.isModified() && this.graph.labelChanged(this.editingCell, this.getCurrentValue(), this.trigger), 
null != this.textDiv && (document.body.removeChild(this.textDiv), this.textDiv = null), 
this.bounds = this.trigger = this.editingCell = null, this.textarea.blur(), this.textarea.parentNode.removeChild(this.textarea));
}, mxCellEditor.prototype.getInitialValue = function(a, b) {
return this.graph.getEditingValue(a.cell, b);
}, mxCellEditor.prototype.getCurrentValue = function() {
return this.textarea.value.replace(/\r/g, "");
}, mxCellEditor.prototype.isHideLabel = function() {
return !0;
}, mxCellEditor.prototype.getMinimumSize = function(a) {
var b = this.graph.getView().scale;
return new mxRectangle(0, 0, null == a.text ? 30 :a.text.size * b + 20, "left" == this.textarea.style.textAlign ? 120 :40);
}, mxCellEditor.prototype.getEditorBounds = function(a) {
var b = this.graph.getModel().isEdge(a.cell), c = this.graph.getView().scale, d = this.getMinimumSize(a), e = d.width, d = d.height, f = parseInt(a.style[mxConstants.STYLE_SPACING] || 2) * c, g = parseInt(a.style[mxConstants.STYLE_SPACING_TOP] || 0) * c + f, h = parseInt(a.style[mxConstants.STYLE_SPACING_RIGHT] || 0) * c + f, k = parseInt(a.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) * c + f, c = parseInt(a.style[mxConstants.STYLE_SPACING_LEFT] || 0) * c + f, h = new mxRectangle(a.x, a.y, Math.max(e, a.width - c - h), Math.max(d, a.height - g - k));
return b ? (h.x = a.absoluteOffset.x, h.y = a.absoluteOffset.y, null != a.text && null != a.text.boundingBox && (0 < a.text.boundingBox.x && (h.x = a.text.boundingBox.x), 
0 < a.text.boundingBox.y && (h.y = a.text.boundingBox.y))) :null != a.text && null != a.text.boundingBox && (h.x = Math.min(h.x, a.text.boundingBox.x), 
h.y = Math.min(h.y, a.text.boundingBox.y)), h.x += c, h.y += g, null != a.text && null != a.text.boundingBox && (b ? (h.width = Math.max(e, a.text.boundingBox.width), 
h.height = Math.max(d, a.text.boundingBox.height)) :(h.width = Math.max(h.width, a.text.boundingBox.width), 
h.height = Math.max(h.height, a.text.boundingBox.height))), this.graph.getModel().isVertex(a.cell) && (b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER), 
b == mxConstants.ALIGN_LEFT ? h.x -= a.width :b == mxConstants.ALIGN_RIGHT && (h.x += a.width), 
b = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE), 
b == mxConstants.ALIGN_TOP ? h.y -= a.height :b == mxConstants.ALIGN_BOTTOM && (h.y += a.height)), 
h;
}, mxCellEditor.prototype.getEmptyLabelText = function() {
return this.emptyLabelText;
}, mxCellEditor.prototype.getEditingCell = function() {
return this.editingCell;
}, mxCellEditor.prototype.destroy = function() {
null != this.textarea && (mxEvent.release(this.textarea), null != this.textarea.parentNode && this.textarea.parentNode.removeChild(this.textarea), 
this.textarea = null, null != this.changeHandler && (this.graph.getModel().removeListener(this.changeHandler), 
this.changeHandler = null));
}, mxCellRenderer.prototype.defaultEdgeShape = mxConnector, mxCellRenderer.prototype.defaultVertexShape = mxRectangleShape, 
mxCellRenderer.prototype.defaultTextShape = mxText, mxCellRenderer.prototype.legacyControlPosition = !0, 
mxCellRenderer.prototype.defaultShapes = {}, mxCellRenderer.registerShape = function(a, b) {
mxCellRenderer.prototype.defaultShapes[a] = b;
}, mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape), 
mxCellRenderer.registerShape(mxConstants.SHAPE_ELLIPSE, mxEllipse), mxCellRenderer.registerShape(mxConstants.SHAPE_RHOMBUS, mxRhombus), 
mxCellRenderer.registerShape(mxConstants.SHAPE_CYLINDER, mxCylinder), mxCellRenderer.registerShape(mxConstants.SHAPE_CONNECTOR, mxConnector), 
mxCellRenderer.registerShape(mxConstants.SHAPE_ACTOR, mxActor), mxCellRenderer.registerShape(mxConstants.SHAPE_TRIANGLE, mxTriangle), 
mxCellRenderer.registerShape(mxConstants.SHAPE_HEXAGON, mxHexagon), mxCellRenderer.registerShape(mxConstants.SHAPE_CLOUD, mxCloud), 
mxCellRenderer.registerShape(mxConstants.SHAPE_LINE, mxLine), mxCellRenderer.registerShape(mxConstants.SHAPE_ARROW, mxArrow), 
mxCellRenderer.registerShape(mxConstants.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse), 
mxCellRenderer.registerShape(mxConstants.SHAPE_SWIMLANE, mxSwimlane), mxCellRenderer.registerShape(mxConstants.SHAPE_IMAGE, mxImageShape), 
mxCellRenderer.registerShape(mxConstants.SHAPE_LABEL, mxLabel), mxCellRenderer.prototype.initialize = function(a, b) {
var c = a.view.graph.getModel();
null != a.view.graph.container && null == a.shape && a.cell != a.view.currentRoot && (c.isVertex(a.cell) || c.isEdge(a.cell)) && (this.createShape(a), 
null == a.shape || null != b && !b || (this.initializeShape(a), a.view.graph.ordered || c.isEdge(a.cell) ? a.invalidOrder = !0 :a.view.graph.keepEdgesInForeground && null != this.firstEdge && (this.firstEdge.parentNode == a.shape.node.parentNode ? this.insertState(a, this.firstEdge) :this.firstEdge = null), 
a.shape.scale = a.view.scale, this.createCellOverlays(a), this.installListeners(a)));
}, mxCellRenderer.prototype.initializeShape = function(a) {
a.shape.init(a.view.getDrawPane());
}, mxCellRenderer.prototype.getPreviousStateInContainer = function(a, b) {
for (var c = null, d = a.view.graph, e = d.getModel(), f = a.cell, g = e.getParent(f); null != g && null == c; ) c = this.findPreviousStateInContainer(d, g, f, b), 
f = g, g = e.getParent(f);
return c;
}, mxCellRenderer.prototype.findPreviousStateInContainer = function(a, b, c, d) {
var e = null, f = a.getModel();
for (c = null != c ? b.getIndex(c) - 1 :f.getChildCount(b) - 1; c >= 0 && null == e; c--) e = this.findPreviousStateInContainer(a, f.getChildAt(b, c), null, d);
return null != e || (e = a.view.getState(b), null == e || null != e.shape && null != e.shape.node && e.shape.node.parentNode == d) || (e = null), 
e;
}, mxCellRenderer.prototype.order = function(a) {
var b = a.shape.node.parentNode, c = this.getPreviousStateInContainer(a, b), d = b.firstChild;
null != c && (d = c.shape.node, null != c.text && null != c.text.node && c.text.node.parentNode == b && (d = c.text.node), 
d = d.nextSibling), this.insertState(a, d);
}, mxCellRenderer.prototype.orderEdge = function(a) {
var b = a.view, c = b.graph.getModel();
if (b.graph.keepEdgesInForeground) (null == this.firstEdge || null == this.firstEdge.parentNode || this.firstEdge.parentNode != a.shape.node.parentNode) && (this.firstEdge = a.shape.node); else if (b.graph.keepEdgesInBackground) {
var d = a.shape.node, e = d.parentNode, c = c.getParent(a.cell), b = b.getState(c), e = null != b && null != b.shape && null != b.shape.node ? b.shape.node.nextSibling :e.firstChild;
null != e && e != d && this.insertState(a, e);
}
}, mxCellRenderer.prototype.insertState = function(a, b) {
a.shape.node.parentNode.insertBefore(a.shape.node, b), null != a.text && null != a.text.node && a.text.node.parentNode == a.shape.node.parentNode && a.shape.node.parentNode.insertBefore(a.text.node, a.shape.node.nextSibling);
}, mxCellRenderer.prototype.createShape = function(a) {
if (null != a.style) {
var b = mxStencilRegistry.getStencil(a.style[mxConstants.STYLE_SHAPE]);
null != b ? a.shape = new mxShape(b) :(b = this.getShapeConstructor(a), a.shape = new b()), 
a.shape.points = a.absolutePoints, a.shape.bounds = new mxRectangle(a.x, a.y, a.width, a.height), 
a.shape.dialect = a.view.graph.dialect, this.configureShape(a);
}
}, mxCellRenderer.prototype.getShape = function(a) {
return null != a ? mxCellRenderer.prototype.defaultShapes[a] :null;
}, mxCellRenderer.prototype.getShapeConstructor = function(a) {
var b = this.getShape(a.style[mxConstants.STYLE_SHAPE]);
return null == b && (b = a.view.graph.getModel().isEdge(a.cell) ? this.defaultEdgeShape :this.defaultVertexShape), 
b;
}, mxCellRenderer.prototype.configureShape = function(a) {
a.shape.apply(a), a.shape.image = a.view.graph.getImage(a), a.shape.indicatorShape = this.getShape(a.view.graph.getIndicatorShape(a)), 
a.shape.indicatorColor = a.view.graph.getIndicatorColor(a), a.shape.indicatorGradientColor = a.view.graph.getIndicatorGradientColor(a), 
a.shape.indicatorDirection = a.style[mxConstants.STYLE_INDICATOR_DIRECTION], a.shape.indicatorImage = a.view.graph.getIndicatorImage(a), 
this.postConfigureShape(a);
}, mxCellRenderer.prototype.postConfigureShape = function(a) {
null != a.shape && (this.resolveColor(a, "indicatorColor", mxConstants.STYLE_FILLCOLOR), 
this.resolveColor(a, "indicatorGradientColor", mxConstants.STYLE_GRADIENTCOLOR), 
this.resolveColor(a, "fill", mxConstants.STYLE_FILLCOLOR), this.resolveColor(a, "stroke", mxConstants.STYLE_STROKECOLOR), 
this.resolveColor(a, "gradient", mxConstants.STYLE_GRADIENTCOLOR));
}, mxCellRenderer.prototype.resolveColor = function(a, b, c) {
var d = a.shape[b], e = a.view.graph, f = null;
"inherit" == d ? f = e.model.getParent(a.cell) :"swimlane" == d ? (f = null != e.model.getTerminal(a.cell, !1) ? e.model.getTerminal(a.cell, !1) :a.cell, 
f = e.getSwimlane(f), c = e.swimlaneIndicatorColorAttribute) :"indicated" == d && (a.shape[b] = a.shape.indicatorColor), 
null != f && (d = e.getView().getState(f), a.shape[b] = null, null != d && (a.shape[b] = null != d.shape && "indicatorColor" != b ? d.shape[b] :d.style[c]));
}, mxCellRenderer.prototype.getLabelValue = function(a) {
return a.view.graph.getLabel(a.cell);
}, mxCellRenderer.prototype.createLabel = function(a, b) {
var c = a.view.graph;
if (c.getModel().isEdge(a.cell), 0 < a.style[mxConstants.STYLE_FONTSIZE] || null == a.style[mxConstants.STYLE_FONTSIZE]) {
var d = c.isHtmlLabel(a.cell) || null != b && mxUtils.isNode(b);
a.text = new this.defaultTextShape(b, new mxRectangle(), a.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER, c.getVerticalAlign(a), a.style[mxConstants.STYLE_FONTCOLOR], a.style[mxConstants.STYLE_FONTFAMILY], a.style[mxConstants.STYLE_FONTSIZE], a.style[mxConstants.STYLE_FONTSTYLE], a.style[mxConstants.STYLE_SPACING], a.style[mxConstants.STYLE_SPACING_TOP], a.style[mxConstants.STYLE_SPACING_RIGHT], a.style[mxConstants.STYLE_SPACING_BOTTOM], a.style[mxConstants.STYLE_SPACING_LEFT], a.style[mxConstants.STYLE_HORIZONTAL], a.style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR], a.style[mxConstants.STYLE_LABEL_BORDERCOLOR], c.isWrapping(a.cell) && c.isHtmlLabel(a.cell), c.isLabelClipped(a.cell), a.style[mxConstants.STYLE_OVERFLOW], a.style[mxConstants.STYLE_LABEL_PADDING]), 
a.text.opacity = mxUtils.getValue(a.style, mxConstants.STYLE_TEXT_OPACITY, 100), 
a.text.dialect = d ? mxConstants.DIALECT_STRICTHTML :a.view.graph.dialect, a.text.state = a, 
this.initializeLabel(a);
var e = !1, f = function(b) {
var d = a;
return (mxClient.IS_TOUCH || e) && (d = mxEvent.getClientX(b), b = mxEvent.getClientY(b), 
b = mxUtils.convertPoint(c.container, d, b), d = c.view.getState(c.getCellAt(b.x, b.y))), 
d;
};
mxEvent.addGestureListeners(a.text.node, mxUtils.bind(this, function(b) {
this.isLabelEvent(a, b) && (c.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(b, a)), 
e = c.dialect != mxConstants.DIALECT_SVG && "IMG" == mxEvent.getSource(b).nodeName);
}), mxUtils.bind(this, function(b) {
this.isLabelEvent(a, b) && c.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b, f(b)));
}), mxUtils.bind(this, function(b) {
this.isLabelEvent(a, b) && (c.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(b, f(b))), 
e = !1);
})), mxEvent.addListener(a.text.node, "dblclick", mxUtils.bind(this, function(b) {
this.isLabelEvent(a, b) && (c.dblClick(b, a.cell), mxEvent.consume(b));
}));
}
}, mxCellRenderer.prototype.initializeLabel = function(a) {
var b = a.view.graph;
a.text.dialect != mxConstants.DIALECT_SVG && (mxClient.IS_SVG && mxClient.NO_FO ? a.text.init(b.container) :mxUtils.isVml(a.view.getDrawPane()) && (null != a.shape.label ? a.text.init(a.shape.label) :a.text.init(a.shape.node))), 
null == a.text.node && (a.text.init(a.view.getDrawPane()), null != a.shape && null != a.text && a.shape.node.parentNode.insertBefore(a.text.node, a.shape.node.nextSibling));
}, mxCellRenderer.prototype.createCellOverlays = function(a) {
var b = a.view.graph.getCellOverlays(a.cell), c = null;
if (null != b) for (var c = new mxDictionary(), d = 0; d < b.length; d++) {
var e = null != a.overlays ? a.overlays.remove(b[d]) :null;
null == e && (e = new mxImageShape(new mxRectangle(), b[d].image.src), e.dialect = a.view.graph.dialect, 
e.preserveImageAspect = !1, e.overlay = b[d], this.initializeOverlay(a, e), this.installCellOverlayListeners(a, b[d], e), 
null != b[d].cursor && (e.node.style.cursor = b[d].cursor)), c.put(b[d], e);
}
null != a.overlays && a.overlays.visit(function(a, b) {
b.destroy();
}), a.overlays = c;
}, mxCellRenderer.prototype.initializeOverlay = function(a, b) {
b.init(a.view.getOverlayPane());
}, mxCellRenderer.prototype.installCellOverlayListeners = function(a, b, c) {
var d = a.view.graph;
mxEvent.addListener(c.node, "click", function(c) {
d.isEditing() && d.stopEditing(!d.isInvokesStopCellEditing()), b.fireEvent(new mxEventObject(mxEvent.CLICK, "event", c, "cell", a.cell));
}), mxEvent.addGestureListeners(c.node, function(a) {
mxEvent.consume(a);
}, function(b) {
d.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b, a));
}), mxClient.IS_TOUCH && mxEvent.addListener(c.node, "touchend", function(c) {
b.fireEvent(new mxEventObject(mxEvent.CLICK, "event", c, "cell", a.cell));
});
}, mxCellRenderer.prototype.createControl = function(a) {
var b = a.view.graph, c = b.getFoldingImage(a);
if (b.foldingEnabled && null != c) {
if (null == a.control) {
var d = new mxRectangle(0, 0, c.width, c.height);
a.control = new mxImageShape(d, c.src), a.control.preserveImageAspect = !1, a.control.dialect = b.dialect, 
this.initControl(a, a.control, !0, function(c) {
if (b.isEnabled()) {
var d = !b.isCellCollapsed(a.cell);
b.foldCells(d, !1, [ a.cell ]), mxEvent.consume(c);
}
});
}
} else null != a.control && (a.control.destroy(), a.control = null);
}, mxCellRenderer.prototype.initControl = function(a, b, c, d) {
var e = a.view.graph;
return e.isHtmlLabel(a.cell) && mxClient.NO_FO && e.dialect == mxConstants.DIALECT_SVG ? (b.dialect = mxConstants.DIALECT_PREFERHTML, 
b.init(e.container), b.node.style.zIndex = 1) :b.init(a.view.getOverlayPane()), 
b = b.innerNode || b.node, d && (e.isEnabled() && (b.style.cursor = "pointer"), 
mxEvent.addListener(b, "click", d)), c && mxEvent.addGestureListeners(b, function(b) {
e.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(b, a)), mxEvent.consume(b);
}, function(b) {
e.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b, a));
}), b;
}, mxCellRenderer.prototype.isShapeEvent = function() {
return !0;
}, mxCellRenderer.prototype.isLabelEvent = function() {
return !0;
}, mxCellRenderer.prototype.installListeners = function(a) {
var b = a.view.graph, c = function(c) {
var d = a;
return (b.dialect != mxConstants.DIALECT_SVG && "IMG" == mxEvent.getSource(c).nodeName || mxClient.IS_TOUCH) && (d = mxEvent.getClientX(c), 
c = mxEvent.getClientY(c), c = mxUtils.convertPoint(b.container, d, c), d = b.view.getState(b.getCellAt(c.x, c.y))), 
d;
}, d = !1;
mxEvent.addListener(a.shape.node, "gesturestart", mxUtils.bind(this, function(a) {
b.lastTouchTime = 0, d = !0, mxEvent.consume(a);
})), mxEvent.addGestureListeners(a.shape.node, mxUtils.bind(this, function(c) {
this.isShapeEvent(a, c) && !d ? b.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(c, null != a.shape && mxEvent.getSource(c) == a.shape.content ? null :a)) :d && mxEvent.consume(c);
}), mxUtils.bind(this, function(e) {
this.isShapeEvent(a, e) && !d ? b.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(e, null != a.shape && mxEvent.getSource(e) == a.shape.content ? null :c(e))) :d && mxEvent.consume(e);
}), mxUtils.bind(this, function(e) {
this.isShapeEvent(a, e) && !d ? b.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(e, null != a.shape && mxEvent.getSource(e) == a.shape.content ? null :c(e))) :d && mxEvent.consume(e);
}));
var e = mxClient.IS_TOUCH ? "gestureend" :"dblclick";
mxEvent.addListener(a.shape.node, e, mxUtils.bind(this, function(c) {
d = !1, "gestureend" == e ? (b.lastTouchTime = 0, b.gestureEnabled && (b.handleGesture(a, c), 
mxEvent.consume(c))) :this.isShapeEvent(a, c) && (b.dblClick(c, null != a.shape && mxEvent.getSource(c) == a.shape.content ? null :a.cell), 
mxEvent.consume(c));
}));
}, mxCellRenderer.prototype.redrawLabel = function(a, b) {
var c = this.getLabelValue(a);
if (null == a.text && null != c && (mxUtils.isNode(c) || 0 < c.length) ? this.createLabel(a, c) :null == a.text || null != c && 0 != c.length || (a.text.destroy(), 
a.text = null), null != a.text) {
var d = a.view.graph, e = d.isWrapping(a.cell), d = d.isLabelClipped(a.cell), f = this.getLabelBounds(a);
(b || a.text.value != c || a.text.isWrapping != e || a.text.isClipping != d || a.text.scale != a.view.scale || !a.text.bounds.equals(f)) && (a.text.value = c, 
a.text.bounds = f, a.text.scale = this.getTextScale(a), a.text.isWrapping = e, a.text.isClipping = d, 
a.text.redraw());
}
}, mxCellRenderer.prototype.getTextScale = function(a) {
return a.view.scale;
}, mxCellRenderer.prototype.getLabelBounds = function(a) {
var b = a.view.graph, c = a.view.scale, d = b.getModel().isEdge(a.cell), e = new mxRectangle(a.absoluteOffset.x, a.absoluteOffset.y);
if (a.text.updateMargin(), d) {
var f = a.text.getSpacing();
e.x += f.x * c, e.y += f.y * c, b = b.getCellGeometry(a.cell), null != b && (e.width = Math.max(0, b.width * c), 
e.height = Math.max(0, b.height * c));
} else a.text.isPaintBoundsInverted() && (f = e.x, e.x = e.y, e.y = f), e.x += a.x, 
e.y += a.y, e.width = Math.max(1, a.width), e.height = Math.max(1, a.height), b.isSwimlane(a.cell) && (b = b.getStartSize(a.cell), 
0 < b.width ? (f = Math.min(e.width, b.width * c), a.shape.flipH && (e.x += e.width - f), 
e.width = f) :0 < b.height && (f = Math.min(e.height, b.height * c), a.shape.flipV && (e.y += e.height - f), 
e.height = f));
return null != a.shape && (e = a.shape.getLabelBounds(e)), d || this.rotateLabelBounds(a, e), 
e;
}, mxCellRenderer.prototype.rotateLabelBounds = function(a, b) {
if (a.text.isPaintBoundsInverted()) {
var c = (a.width - a.height) / 2;
b.x += c, b.y -= c, c = b.width, b.width = b.height, b.height = c;
}
if (b.x -= a.text.margin.x * b.width, b.y -= a.text.margin.y * b.height, "fill" != a.style[mxConstants.STYLE_OVERFLOW] && "width" != a.style[mxConstants.STYLE_OVERFLOW]) {
var c = a.view.scale, d = a.text.getSpacing();
b.x += d.x * c, b.y += d.y * c, b.width = Math.max(0, b.width - a.text.spacingLeft * c - a.text.spacingRight * c), 
b.height = Math.max(0, b.height - a.text.spacingTop * c - a.text.spacingBottom * c);
}
var e = a.text.getTextRotation();
0 != e && null != a && a.view.graph.model.isVertex(a.cell) && (c = a.getCenterX(), 
d = a.getCenterY(), b.x != c || b.y != d) && (e *= Math.PI / 180, pt = mxUtils.getRotatedPoint(new mxPoint(b.x, b.y), Math.cos(e), Math.sin(e), new mxPoint(c, d)), 
b.x = pt.x, b.y = pt.y);
}, mxCellRenderer.prototype.redrawCellOverlays = function(a, b) {
if (this.createCellOverlays(a), null != a.overlays) {
var c = mxUtils.mod(mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0), 90), d = mxUtils.toRadians(c), e = Math.cos(d), f = Math.sin(d);
a.overlays.visit(function(d, h) {
var k = h.overlay.getBounds(a);
if (!a.view.graph.getModel().isEdge(a.cell) && null != a.shape && 0 != c) {
var l = k.getCenterX(), m = k.getCenterY(), m = mxUtils.getRotatedPoint(new mxPoint(l, m), e, f, new mxPoint(a.getCenterX(), a.getCenterY())), l = m.x, m = m.y;
k.x = Math.round(l - k.width / 2), k.y = Math.round(m - k.height / 2);
}
(b || null == h.bounds || h.scale != a.view.scale || !h.bounds.equals(k)) && (h.bounds = k, 
h.scale = a.view.scale, h.redraw());
});
}
}, mxCellRenderer.prototype.redrawControl = function(a, b) {
if (null != a.control) {
var c = this.getControlBounds(a), d = this.legacyControlPosition ? mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0) :a.shape.getTextRotation(), e = a.view.scale;
(b || a.control.scale != e || !a.control.bounds.equals(c) || a.control.rotation != d) && (a.control.rotation = d, 
a.control.bounds = c, a.control.scale = e, a.control.redraw());
}
}, mxCellRenderer.prototype.getControlBounds = function(a) {
if (null != a.control) {
var b = a.control.scale, c = a.control.bounds.width / b, b = a.control.bounds.height / b, d = a.view.scale, e = a.getCenterX(), f = a.getCenterY();
if (!a.view.graph.getModel().isEdge(a.cell) && (e = a.x + c * d, f = a.y + b * d, 
null != a.shape)) {
var g = a.shape.getShapeRotation();
if (this.legacyControlPosition) g = mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0); else if (a.shape.isPaintBoundsInverted()) var h = (a.width - a.height) / 2, e = e + h, f = f - h;
0 != g && (h = mxUtils.toRadians(g), g = Math.cos(h), h = Math.sin(h), f = mxUtils.getRotatedPoint(new mxPoint(e, f), g, h, new mxPoint(a.getCenterX(), a.getCenterY())), 
e = f.x, f = f.y);
}
return a.view.graph.getModel().isEdge(a.cell), new mxRectangle(Math.round(e - c / 2 * d), Math.round(f - b / 2 * d), Math.round(c * d), Math.round(b * d));
}
return null;
}, mxCellRenderer.prototype.redraw = function(a, b, c) {
if (null != a.shape) {
var d = !1;
a.view.graph.getModel().isEdge(a.cell), reconfigure = null != b ? b :!1, this.createControl(a), 
(a.orderChanged || a.invalidOrder) && (a.view.graph.ordered ? this.order(a) :this.orderEdge(a)), 
(a.orderChanged || !mxUtils.equalEntries(a.shape.style, a.style)) && (this.configureShape(a), 
b = !0), delete a.invalidOrder, delete a.orderChanged, !b && null != a.shape.bounds && a.shape.scale == a.view.scale && a.shape.bounds.equals(a) && mxUtils.equalPoints(a.shape.points, a.absolutePoints) || (d = !0, 
a.shape.points = null != a.absolutePoints ? a.absolutePoints.slice() :null, a.shape.bounds = new mxRectangle(a.x, a.y, a.width, a.height), 
a.shape.scale = a.view.scale, null == c || c ? a.shape.redraw() :a.shape.updateBoundingBox()), 
(null == c || c) && (this.redrawLabel(a, d), this.redrawCellOverlays(a, d), this.redrawControl(a, d));
}
}, mxCellRenderer.prototype.destroy = function(a) {
null != a.shape && (null != a.text && (a.text.destroy(), a.text = null), null != a.overlays && (a.overlays.visit(function(a, c) {
c.destroy();
}), a.overlays = null), null != a.control && (a.control.destroy(), a.control = null), 
a.shape.destroy(), a.shape = null);
};

var mxEdgeStyle = {
EntityRelation:function(a, b, c, d, e) {
var f = a.view, g = f.graph;
d = mxUtils.getValue(a.style, mxConstants.STYLE_SEGMENT, mxConstants.ENTITY_SEGMENT) * f.scale;
var h = a.absolutePoints, k = h[0], l = h[h.length - 1], h = !1;
if (null != k) b = new mxCellState(), b.x = k.x, b.y = k.y; else {
if (null == b) return;
var m = mxUtils.getPortConstraints(b, a, !0, mxConstants.DIRECTION_MASK_NONE);
m != mxConstants.DIRECTION_MASK_NONE ? h = m == mxConstants.DIRECTION_MASK_WEST :(k = g.getCellGeometry(b.cell), 
k.relative ? h = .5 >= k.x :null != c && (h = c.x + c.width < b.x));
}
k = !0, null != l ? (c = new mxCellState(), c.x = l.x, c.y = l.y) :null != c && (m = mxUtils.getPortConstraints(c, a, !1, mxConstants.DIRECTION_MASK_NONE), 
m != mxConstants.DIRECTION_MASK_NONE ? k = m == mxConstants.DIRECTION_MASK_WEST :(a = g.getCellGeometry(c.cell), 
a.relative ? k = .5 >= a.x :null != b && (k = b.x + b.width < c.x))), null != b && null != c && (a = h ? b.x :b.x + b.width, 
b = f.getRoutingCenterY(b), g = k ? c.x :c.x + c.width, c = f.getRoutingCenterY(c), 
f = new mxPoint(a + (h ? -d :d), b), l = new mxPoint(g + (k ? -d :d), c), h == k ? (d = h ? Math.min(a, g) - d :Math.max(a, g) + d, 
e.push(new mxPoint(d, b)), e.push(new mxPoint(d, c))) :(f.x < l.x == h ? (d = b + (c - b) / 2, 
e.push(f), e.push(new mxPoint(f.x, d)), e.push(new mxPoint(l.x, d))) :e.push(f), 
e.push(l)));
},
Loop:function(a, b, c, d, e) {
if (null != b) {
c = a.view;
var f = c.graph;
d = null != d && 0 < d.length ? d[0] :null, null != d && (d = c.transformControlPoint(a, d), 
mxUtils.contains(b, d.x, d.y) && (d = null));
var g = 0, h = 0, k = 0, l = 0, f = mxUtils.getValue(a.style, mxConstants.STYLE_SEGMENT, f.gridSize) * c.scale;
a = mxUtils.getValue(a.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_WEST), 
a == mxConstants.DIRECTION_NORTH || a == mxConstants.DIRECTION_SOUTH ? (g = c.getRoutingCenterX(b), 
h = f) :(k = c.getRoutingCenterY(b), l = f), null == d || d.x < b.x || d.x > b.x + b.width ? null != d ? (g = d.x, 
l = Math.max(Math.abs(k - d.y), l)) :a == mxConstants.DIRECTION_NORTH ? k = b.y - 2 * h :a == mxConstants.DIRECTION_SOUTH ? k = b.y + b.height + 2 * h :g = a == mxConstants.DIRECTION_EAST ? b.x - 2 * l :b.x + b.width + 2 * l :null != d && (g = c.getRoutingCenterX(b), 
h = Math.max(Math.abs(g - d.x), l), k = d.y, l = 0), e.push(new mxPoint(g - h, k - l)), 
e.push(new mxPoint(g + h, k + l));
}
},
ElbowConnector:function(a, b, c, d, e) {
var f = null != d && 0 < d.length ? d[0] :null, g = !1, h = !1;
if (null != b && null != c) if (null != f) var k = Math.min(b.x, c.x), l = Math.max(b.x + b.width, c.x + c.width), h = Math.min(b.y, c.y), m = Math.max(b.y + b.height, c.y + c.height), f = a.view.transformControlPoint(a, f), g = f.y < h || f.y > m, h = f.x < k || f.x > l; else k = Math.max(b.x, c.x), 
l = Math.min(b.x + b.width, c.x + c.width), g = k == l, g || (h = Math.max(b.y, c.y), 
m = Math.min(b.y + b.height, c.y + c.height), h = h == m);
h || !g && a.style[mxConstants.STYLE_ELBOW] != mxConstants.ELBOW_VERTICAL ? mxEdgeStyle.SideToSide(a, b, c, d, e) :mxEdgeStyle.TopToBottom(a, b, c, d, e);
},
SideToSide:function(a, b, c, d, e) {
var f = a.view;
d = null != d && 0 < d.length ? d[0] :null;
var g = a.absolutePoints, h = g[0], g = g[g.length - 1];
null != d && (d = f.transformControlPoint(a, d)), null != h && (b = new mxCellState(), 
b.x = h.x, b.y = h.y), null != g && (c = new mxCellState(), c.x = g.x, c.y = g.y), 
null != b && null != c && (a = Math.max(b.x, c.x), h = Math.min(b.x + b.width, c.x + c.width), 
a = null != d ? d.x :h + (a - h) / 2, h = f.getRoutingCenterY(b), f = f.getRoutingCenterY(c), 
null != d && (d.y >= b.y && d.y <= b.y + b.height && (h = d.y), d.y >= c.y && d.y <= c.y + c.height && (f = d.y)), 
!mxUtils.contains(c, a, h) && !mxUtils.contains(b, a, h) && e.push(new mxPoint(a, h)), 
!mxUtils.contains(c, a, f) && !mxUtils.contains(b, a, f) && e.push(new mxPoint(a, f)), 
1 == e.length && (null != d ? !mxUtils.contains(c, a, d.y) && !mxUtils.contains(b, a, d.y) && e.push(new mxPoint(a, d.y)) :(f = Math.max(b.y, c.y), 
b = Math.min(b.y + b.height, c.y + c.height), e.push(new mxPoint(a, f + (b - f) / 2)))));
},
TopToBottom:function(a, b, c, d, e) {
var f = a.view;
d = null != d && 0 < d.length ? d[0] :null;
var g = a.absolutePoints, h = g[0], g = g[g.length - 1];
null != d && (d = f.transformControlPoint(a, d)), null != h && (b = new mxCellState(), 
b.x = h.x, b.y = h.y), null != g && (c = new mxCellState(), c.x = g.x, c.y = g.y), 
null != b && null != c && (h = Math.max(b.y, c.y), g = Math.min(b.y + b.height, c.y + c.height), 
a = f.getRoutingCenterX(b), null != d && d.x >= b.x && d.x <= b.x + b.width && (a = d.x), 
h = null != d ? d.y :g + (h - g) / 2, !mxUtils.contains(c, a, h) && !mxUtils.contains(b, a, h) && e.push(new mxPoint(a, h)), 
a = null != d && d.x >= c.x && d.x <= c.x + c.width ? d.x :f.getRoutingCenterX(c), 
!mxUtils.contains(c, a, h) && !mxUtils.contains(b, a, h) && e.push(new mxPoint(a, h)), 
1 == e.length && (null != d && 1 == e.length ? !mxUtils.contains(c, d.x, h) && !mxUtils.contains(b, d.x, h) && e.push(new mxPoint(d.x, h)) :(f = Math.max(b.x, c.x), 
b = Math.min(b.x + b.width, c.x + c.width), e.push(new mxPoint(f + (b - f) / 2, h)))));
},
SegmentConnector:function(a, b, c, d, e) {
var f = a.absolutePoints, g = !0, h = null, k = f[0];
null == k && null != b ? k = new mxPoint(a.view.getRoutingCenterX(b), a.view.getRoutingCenterY(b)) :null != k && (k = k.clone());
var l = f.length - 1;
if (null != d && 0 < d.length) {
for (var h = a.view.transformControlPoint(a, d[0]), m = b, n = f[0], p = !1, q = !1, p = h, s = d.length, r = 0; 2 > r; r++) {
var t = null != n && n.x == p.x, u = null != n && n.y == p.y, v = null != m && p.y >= m.y && p.y <= m.y + m.height, m = null != m && p.x >= m.x && p.x <= m.x + m.width, p = u || null == n && v, q = t || null == n && m;
if (null != n && !u && !t && (v || m)) {
g = v ? !1 :!0;
break;
}
if (q || p) {
g = p, 1 == r && (g = 0 == d.length % 2 ? p :q);
break;
}
m = c, n = f[l], p = a.view.transformControlPoint(a, d[s - 1]);
}
for (g && (null != f[0] && f[0].y != h.y || null == f[0] && null != b && (h.y < b.y || h.y > b.y + b.height)) ? e.push(new mxPoint(k.x, h.y)) :!g && (null != f[0] && f[0].x != h.x || null == f[0] && null != b && (h.x < b.x || h.x > b.x + b.width)) && e.push(new mxPoint(h.x, k.y)), 
g ? k.y = h.y :k.x = h.x, r = 0; r < d.length; r++) g = !g, h = a.view.transformControlPoint(a, d[r]), 
g ? k.y = h.y :k.x = h.x, e.push(k.clone());
} else h = k, g = !0;
if (k = f[l], null == k && null != c && (k = new mxPoint(a.view.getRoutingCenterX(c), a.view.getRoutingCenterY(c))), 
g && (null != f[l] && f[l].y != h.y || null == f[l] && null != c && (h.y < c.y || h.y > c.y + c.height)) ? e.push(new mxPoint(k.x, h.y)) :!g && (null != f[l] && f[l].x != h.x || null == f[l] && null != c && (h.x < c.x || h.x > c.x + c.width)) && e.push(new mxPoint(h.x, k.y)), 
null == f[0] && null != b) for (;1 < e.length && mxUtils.contains(b, e[1].x, e[1].y); ) e = e.splice(1, 1);
if (null == f[l] && null != c) for (;1 < e.length && mxUtils.contains(c, e[e.length - 1].x, e[e.length - 1].y); ) e = e.splice(e.length - 1, 1);
},
orthBuffer:10,
dirVectors:[ [ -1, 0 ], [ 0, -1 ], [ 1, 0 ], [ 0, 1 ], [ -1, 0 ], [ 0, -1 ], [ 1, 0 ] ],
wayPoints1:[ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
routePatterns:[ [ [ 513, 2308, 2081, 2562 ], [ 513, 1090, 514, 2184, 2114, 2561 ], [ 513, 1090, 514, 2564, 2184, 2562 ], [ 513, 2308, 2561, 1090, 514, 2568, 2308 ] ], [ [ 514, 1057, 513, 2308, 2081, 2562 ], [ 514, 2184, 2114, 2561 ], [ 514, 2184, 2562, 1057, 513, 2564, 2184 ], [ 514, 1057, 513, 2568, 2308, 2561 ] ], [ [ 1090, 514, 1057, 513, 2308, 2081, 2562 ], [ 2114, 2561 ], [ 1090, 2562, 1057, 513, 2564, 2184 ], [ 1090, 514, 1057, 513, 2308, 2561, 2568 ] ], [ [ 2081, 2562 ], [ 1057, 513, 1090, 514, 2184, 2114, 2561 ], [ 1057, 513, 1090, 514, 2184, 2562, 2564 ], [ 1057, 2561, 1090, 514, 2568, 2308 ] ] ],
inlineRoutePatterns:[ [ null, [ 2114, 2568 ], null, null ], [ null, [ 514, 2081, 2114, 2568 ], null, null ], [ null, [ 2114, 2561 ], null, null ], [ [ 2081, 2562 ], [ 1057, 2114, 2568 ], [ 2184, 2562 ], null ] ],
vertexSeperations:[],
limits:[ [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ],
LEFT_MASK:32,
TOP_MASK:64,
RIGHT_MASK:128,
BOTTOM_MASK:256,
LEFT:1,
TOP:2,
RIGHT:4,
BOTTOM:8,
SIDE_MASK:480,
CENTER_MASK:512,
SOURCE_MASK:1024,
TARGET_MASK:2048,
VERTEX_MASK:3072,
OrthConnector:function(a, b, c, d, e) {
var f = a.view.graph, g = null == b ? !1 :f.getModel().isEdge(b.cell), f = null == c ? !1 :f.getModel().isEdge(c.cell);
if (null != d && 0 < d.length || g || f) mxEdgeStyle.SegmentConnector(a, b, c, d, e); else {
d = a.absolutePoints;
var h = d[0], k = d[d.length - 1];
d = null != b ? b.x :h.x;
var g = null != b ? b.y :h.y, l = null != b ? b.width :1, m = null != b ? b.height :1, n = null != c ? c.x :k.x, p = null != c ? c.y :k.y, q = null != c ? c.width :1, s = null != c ? c.height :1, f = a.view.scale * mxEdgeStyle.orthBuffer, r = [ mxConstants.DIRECTION_MASK_ALL, mxConstants.DIRECTION_MASK_ALL ];
for (null != b && (r[0] = mxUtils.getPortConstraints(b, a, !0, mxConstants.DIRECTION_MASK_ALL)), 
null != c && (r[1] = mxUtils.getPortConstraints(c, a, !1, mxConstants.DIRECTION_MASK_ALL)), 
a = [ 0, 0 ], d = [ [ d, g, l, m ], [ n, p, q, s ] ], l = 0; 2 > l; l++) mxEdgeStyle.limits[l][1] = d[l][0] - f, 
mxEdgeStyle.limits[l][2] = d[l][1] - f, mxEdgeStyle.limits[l][4] = d[l][0] + d[l][2] + f, 
mxEdgeStyle.limits[l][8] = d[l][1] + d[l][3] + f;
for (l = d[0][0] + d[0][2] / 2 - (d[1][0] + d[1][2] / 2), m = d[0][1] + d[0][3] / 2 - (d[1][1] + d[1][3] / 2), 
g = 0, 0 > l ? g = 0 > m ? 2 :1 :0 >= m && (g = 3, 0 == l && (g = 2)), m = null, 
null != b && (m = h), b = [ [ .5, .5 ], [ .5, .5 ] ], l = 0; 2 > l; l++) null != m && (b[l][0] = (m.x - d[l][0]) / d[l][2], 
.01 > b[l][0] ? a[l] = mxConstants.DIRECTION_MASK_WEST :.99 < b[l][0] && (a[l] = mxConstants.DIRECTION_MASK_EAST), 
b[l][1] = (m.y - d[l][1]) / d[l][3], .01 > b[l][1] ? a[l] = mxConstants.DIRECTION_MASK_NORTH :.99 < b[l][1] && (a[l] = mxConstants.DIRECTION_MASK_SOUTH)), 
m = null, null != c && (m = k);
for (l = d[0][1] - (d[1][1] + d[1][3]), m = d[0][0] - (d[1][0] + d[1][2]), n = d[1][1] - (d[0][1] + d[0][3]), 
p = d[1][0] - (d[0][0] + d[0][2]), mxEdgeStyle.vertexSeperations[1] = Math.max(m - 2 * f, 0), 
mxEdgeStyle.vertexSeperations[2] = Math.max(l - 2 * f, 0), mxEdgeStyle.vertexSeperations[4] = Math.max(n - 2 * f, 0), 
mxEdgeStyle.vertexSeperations[3] = Math.max(p - 2 * f, 0), c = [], h = [], k = [], 
h[0] = m >= p ? mxConstants.DIRECTION_MASK_WEST :mxConstants.DIRECTION_MASK_EAST, 
k[0] = l >= n ? mxConstants.DIRECTION_MASK_NORTH :mxConstants.DIRECTION_MASK_SOUTH, 
h[1] = mxUtils.reversePortConstraints(h[0]), k[1] = mxUtils.reversePortConstraints(k[0]), 
m = m >= p ? m :p, n = l >= n ? l :n, p = [ [ 0, 0 ], [ 0, 0 ] ], q = !1, l = 0; 2 > l; l++) 0 == a[l] && (0 == (h[l] & r[l]) && (h[l] = mxUtils.reversePortConstraints(h[l])), 
0 == (k[l] & r[l]) && (k[l] = mxUtils.reversePortConstraints(k[l])), p[l][0] = k[l], 
p[l][1] = h[l]);
for (n > 2 * f && m > 2 * f && (0 < (h[0] & r[0]) && 0 < (k[1] & r[1]) ? (p[0][0] = h[0], 
p[0][1] = k[0], p[1][0] = k[1], p[1][1] = h[1], q = !0) :0 < (k[0] & r[0]) && 0 < (h[1] & r[1]) && (p[0][0] = k[0], 
p[0][1] = h[0], p[1][0] = h[1], p[1][1] = k[1], q = !0)), n > 2 * f && !q && (p[0][0] = k[0], 
p[0][1] = h[0], p[1][0] = k[1], p[1][1] = h[1], q = !0), m > 2 * f && !q && (p[0][0] = h[0], 
p[0][1] = k[0], p[1][0] = h[1], p[1][1] = k[1]), l = 0; 2 > l; l++) 0 == a[l] && (0 == (p[l][0] & r[l]) && (p[l][0] = p[l][1]), 
c[l] = p[l][0] & r[l], c[l] |= (p[l][1] & r[l]) << 8, c[l] |= (p[1 - l][l] & r[l]) << 16, 
c[l] |= (p[1 - l][1 - l] & r[l]) << 24, 0 == (15 & c[l]) && (c[l] <<= 8), 0 == (3840 & c[l]) && (c[l] = 15 & c[l] | c[l] >> 8), 
0 == (983040 & c[l]) && (c[l] = 65535 & c[l] | (251658240 & c[l]) >> 8), a[l] = 15 & c[l], 
r[l] == mxConstants.DIRECTION_MASK_WEST || r[l] == mxConstants.DIRECTION_MASK_NORTH || r[l] == mxConstants.DIRECTION_MASK_EAST || r[l] == mxConstants.DIRECTION_MASK_SOUTH) && (a[l] = r[l]);
switch (l = a[0] == mxConstants.DIRECTION_MASK_EAST ? 3 :a[0], r = a[1] == mxConstants.DIRECTION_MASK_EAST ? 3 :a[1], 
l -= g, r -= g, 1 > l && (l += 4), 1 > r && (r += 4), r = mxEdgeStyle.routePatterns[l - 1][r - 1], 
mxEdgeStyle.wayPoints1[0][0] = d[0][0], mxEdgeStyle.wayPoints1[0][1] = d[0][1], 
a[0]) {
case mxConstants.DIRECTION_MASK_WEST:
mxEdgeStyle.wayPoints1[0][0] -= f, mxEdgeStyle.wayPoints1[0][1] += b[0][1] * d[0][3];
break;

case mxConstants.DIRECTION_MASK_SOUTH:
mxEdgeStyle.wayPoints1[0][0] += b[0][0] * d[0][2], mxEdgeStyle.wayPoints1[0][1] += d[0][3] + f;
break;

case mxConstants.DIRECTION_MASK_EAST:
mxEdgeStyle.wayPoints1[0][0] += d[0][2] + f, mxEdgeStyle.wayPoints1[0][1] += b[0][1] * d[0][3];
break;

case mxConstants.DIRECTION_MASK_NORTH:
mxEdgeStyle.wayPoints1[0][0] += b[0][0] * d[0][2], mxEdgeStyle.wayPoints1[0][1] -= f;
}
for (f = 0, h = c = 0 < (a[0] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 :1, 
l = k = 0; l < r.length; l++) {
k = 15 & r[l], s = k == mxConstants.DIRECTION_MASK_EAST ? 3 :k, s += g, s > 4 && (s -= 4), 
m = mxEdgeStyle.dirVectors[s - 1], k = s % 2 > 0 ? 0 :1, k != c && (f++, mxEdgeStyle.wayPoints1[f][0] = mxEdgeStyle.wayPoints1[f - 1][0], 
mxEdgeStyle.wayPoints1[f][1] = mxEdgeStyle.wayPoints1[f - 1][1]);
var t = 0 < (r[l] & mxEdgeStyle.TARGET_MASK), q = 0 < (r[l] & mxEdgeStyle.SOURCE_MASK), n = (r[l] & mxEdgeStyle.SIDE_MASK) >> 5, n = n << g;
n > 15 && (n >>= 4), p = 0 < (r[l] & mxEdgeStyle.CENTER_MASK), (q || t) && 9 > n ? (s = 0, 
q = q ? 0 :1, s = p && 0 == k ? d[q][0] + b[q][0] * d[q][2] :p ? d[q][1] + b[q][1] * d[q][3] :mxEdgeStyle.limits[q][n], 
0 == k ? (n = (s - mxEdgeStyle.wayPoints1[f][0]) * m[0], n > 0 && (mxEdgeStyle.wayPoints1[f][0] += m[0] * n)) :(n = (s - mxEdgeStyle.wayPoints1[f][1]) * m[1], 
n > 0 && (mxEdgeStyle.wayPoints1[f][1] += m[1] * n))) :p && (mxEdgeStyle.wayPoints1[f][0] += m[0] * Math.abs(mxEdgeStyle.vertexSeperations[s] / 2), 
mxEdgeStyle.wayPoints1[f][1] += m[1] * Math.abs(mxEdgeStyle.vertexSeperations[s] / 2)), 
f > 0 && mxEdgeStyle.wayPoints1[f][k] == mxEdgeStyle.wayPoints1[f - 1][k] ? f-- :c = k;
}
for (l = 0; f >= l && (l != f || ((0 < (a[1] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) ? 0 :1) == h ? 0 :1) == (f + 1) % 2); l++) e.push(new mxPoint(mxEdgeStyle.wayPoints1[l][0], mxEdgeStyle.wayPoints1[l][1]));
}
},
getRoutePattern:function(a, b, c, d) {
var e = a[0] == mxConstants.DIRECTION_MASK_EAST ? 3 :a[0];
return a = a[1] == mxConstants.DIRECTION_MASK_EAST ? 3 :a[1], e -= b, a -= b, 1 > e && (e += 4), 
1 > a && (a += 4), b = routePatterns[e - 1][a - 1], (0 == c || 0 == d) && null != inlineRoutePatterns[e - 1][a - 1] && (b = inlineRoutePatterns[e - 1][a - 1]), 
b;
}
}, mxStyleRegistry = {
values:[],
putValue:function(a, b) {
mxStyleRegistry.values[a] = b;
},
getValue:function(a) {
return mxStyleRegistry.values[a];
},
getName:function(a) {
for (var b in mxStyleRegistry.values) if (mxStyleRegistry.values[b] == a) return b;
return null;
}
};

mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector), 
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation), 
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_LOOP, mxEdgeStyle.Loop), mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide), 
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom), 
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector), 
mxStyleRegistry.putValue(mxConstants.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector), 
mxStyleRegistry.putValue(mxConstants.PERIMETER_ELLIPSE, mxPerimeter.EllipsePerimeter), 
mxStyleRegistry.putValue(mxConstants.PERIMETER_RECTANGLE, mxPerimeter.RectanglePerimeter), 
mxStyleRegistry.putValue(mxConstants.PERIMETER_RHOMBUS, mxPerimeter.RhombusPerimeter), 
mxStyleRegistry.putValue(mxConstants.PERIMETER_TRIANGLE, mxPerimeter.TrianglePerimeter), 
mxGraphView.prototype = new mxEventSource(), mxGraphView.prototype.constructor = mxGraphView, 
mxGraphView.prototype.EMPTY_POINT = new mxPoint(), mxGraphView.prototype.doneResource = "none" != mxClient.language ? "done" :"", 
mxGraphView.prototype.updatingDocumentResource = "none" != mxClient.language ? "updatingDocument" :"", 
mxGraphView.prototype.allowEval = !1, mxGraphView.prototype.captureDocumentGesture = !0, 
mxGraphView.prototype.optimizeVmlReflows = !0, mxGraphView.prototype.rendering = !0, 
mxGraphView.prototype.graph = null, mxGraphView.prototype.currentRoot = null, mxGraphView.prototype.graphBounds = null, 
mxGraphView.prototype.scale = 1, mxGraphView.prototype.translate = null, mxGraphView.prototype.updateStyle = !1, 
mxGraphView.prototype.getGraphBounds = function() {
return this.graphBounds;
}, mxGraphView.prototype.setGraphBounds = function(a) {
this.graphBounds = a;
}, mxGraphView.prototype.getBounds = function(a) {
var b = null;
if (null != a && 0 < a.length) for (var c = this.graph.getModel(), d = 0; d < a.length; d++) if (c.isVertex(a[d]) || c.isEdge(a[d])) {
var e = this.getState(a[d]);
null != e && (null == b ? b = new mxRectangle(e.x, e.y, e.width, e.height) :b.add(e));
}
return b;
}, mxGraphView.prototype.setCurrentRoot = function(a) {
if (this.currentRoot != a) {
var b = new mxCurrentRootChange(this, a);
b.execute();
var c = new mxUndoableEdit(this, !1);
c.add(b), this.fireEvent(new mxEventObject(mxEvent.UNDO, "edit", c)), this.graph.sizeDidChange();
}
return a;
}, mxGraphView.prototype.scaleAndTranslate = function(a, b, c) {
var d = this.scale, e = new mxPoint(this.translate.x, this.translate.y);
(this.scale != a || this.translate.x != b || this.translate.y != c) && (this.scale = a, 
this.translate.x = b, this.translate.y = c, this.isEventsEnabled() && (this.revalidate(), 
this.graph.sizeDidChange())), this.fireEvent(new mxEventObject(mxEvent.SCALE_AND_TRANSLATE, "scale", a, "previousScale", d, "translate", this.translate, "previousTranslate", e));
}, mxGraphView.prototype.getScale = function() {
return this.scale;
}, mxGraphView.prototype.setScale = function(a) {
var b = this.scale;
this.scale != a && (this.scale = a, this.isEventsEnabled() && (this.revalidate(), 
this.graph.sizeDidChange())), this.fireEvent(new mxEventObject(mxEvent.SCALE, "scale", a, "previousScale", b));
}, mxGraphView.prototype.getTranslate = function() {
return this.translate;
}, mxGraphView.prototype.setTranslate = function(a, b) {
var c = new mxPoint(this.translate.x, this.translate.y);
(this.translate.x != a || this.translate.y != b) && (this.translate.x = a, this.translate.y = b, 
this.isEventsEnabled() && (this.revalidate(), this.graph.sizeDidChange())), this.fireEvent(new mxEventObject(mxEvent.TRANSLATE, "translate", this.translate, "previousTranslate", c));
}, mxGraphView.prototype.refresh = function() {
null != this.currentRoot && this.clear(), this.revalidate();
}, mxGraphView.prototype.revalidate = function() {
this.invalidate(), this.validate();
}, mxGraphView.prototype.clear = function(a, b, c) {
var d = this.graph.getModel();
if (a = a || d.getRoot(), b = null != b ? b :!1, c = null != c ? c :!0, this.removeState(a), 
c && (b || a != this.currentRoot)) {
c = d.getChildCount(a);
for (var e = 0; c > e; e++) this.clear(d.getChildAt(a, e), b);
} else this.invalidate(a);
}, mxGraphView.prototype.invalidate = function(a, b, c, d) {
var e = this.graph.getModel();
a = a || e.getRoot(), b = null != b ? b :!0, c = null != c ? c :!0, d = null != d ? d :!1;
var f = this.getState(a);
if (null != f && (f.invalid = !0, d && (f.orderChanged = !0)), b) for (var g = e.getChildCount(a), f = 0; g > f; f++) {
var h = e.getChildAt(a, f);
this.invalidate(h, b, c, d);
}
if (c) for (d = e.getEdgeCount(a), f = 0; d > f; f++) this.invalidate(e.getEdgeAt(a, f), b, c);
}, mxGraphView.prototype.validate = function(a) {
var b = mxLog.enter("mxGraphView.validate");
window.status = mxResources.get(this.updatingDocumentResource) || this.updatingDocumentResource;
var c = null;
if (this.optimizeVmlReflows && null != this.canvas && null == this.textDiv && (8 == document.documentMode || mxClient.IS_QUIRKS)) {
c = this.canvas.style.display, this.canvas.style.display = "none";
var d = document.createElement("div");
d.style.position = "absolute", d.style.whiteSpace = "nowrap", d.style.visibility = "hidden", 
d.style.display = mxClient.IS_QUIRKS ? "inline" :"inline-block", d.style.zoom = "1", 
document.body.appendChild(d), this.textDiv = d;
}
a = a || (null != this.currentRoot ? this.currentRoot :this.graph.getModel().getRoot()), 
this.validateBounds(null, a), a = this.validatePoints(null, a), null == a && (a = new mxRectangle()), 
this.setGraphBounds(a), this.validateBackground(), null != c && (this.canvas.style.display = c, 
document.body.removeChild(this.textDiv), this.textDiv = null), window.status = mxResources.get(this.doneResource) || this.doneResource, 
mxLog.leave("mxGraphView.validate", b);
}, mxGraphView.prototype.createBackgroundPageShape = function(a) {
return new mxRectangleShape(a, "white", "black");
}, mxGraphView.prototype.validateBackground = function() {
var a = this.graph.getBackgroundImage();
if (null != a) {
if (null == this.backgroundImage || this.backgroundImage.image != a.src) {
null != this.backgroundImage && this.backgroundImage.destroy();
var b = new mxRectangle(0, 0, 1, 1);
this.backgroundImage = new mxImageShape(b, a.src), this.backgroundImage.dialect = this.graph.dialect, 
this.backgroundImage.init(this.backgroundPane), this.backgroundImage.redraw();
}
this.redrawBackgroundImage(this.backgroundImage, a);
} else null != this.backgroundImage && (this.backgroundImage.destroy(), this.backgroundImage = null);
this.graph.pageVisible ? (b = this.getBackgroundPageBounds(), null == this.backgroundPageShape ? (this.backgroundPageShape = this.createBackgroundPageShape(b), 
this.backgroundPageShape.scale = this.scale, this.backgroundPageShape.isShadow = !0, 
this.backgroundPageShape.dialect = this.graph.dialect, this.backgroundPageShape.init(this.backgroundPane), 
this.backgroundPageShape.redraw(), mxEvent.addListener(this.backgroundPageShape.node, "dblclick", mxUtils.bind(this, function(a) {
this.graph.dblClick(a);
})), mxEvent.addGestureListeners(this.backgroundPageShape.node, mxUtils.bind(this, function(a) {
this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a));
}), mxUtils.bind(this, function(a) {
null != this.graph.tooltipHandler && this.graph.tooltipHandler.isHideOnHover() && this.graph.tooltipHandler.hide(), 
this.graph.isMouseDown && !mxEvent.isConsumed(a) && this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(a));
}), mxUtils.bind(this, function(a) {
this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(a));
}))) :(this.backgroundPageShape.scale = this.scale, this.backgroundPageShape.bounds = b, 
this.backgroundPageShape.redraw())) :null != this.backgroundPageShape && (this.backgroundPageShape.destroy(), 
this.backgroundPageShape = null);
}, mxGraphView.prototype.getBackgroundPageBounds = function() {
var a = this.graph.pageFormat, b = this.scale * this.graph.pageScale;
return new mxRectangle(this.scale * this.translate.x, this.scale * this.translate.y, a.width * b, a.height * b);
}, mxGraphView.prototype.redrawBackgroundImage = function(a, b) {
a.scale = this.scale, a.bounds.x = this.scale * this.translate.x, a.bounds.y = this.scale * this.translate.y, 
a.bounds.width = this.scale * b.width, a.bounds.height = this.scale * b.height, 
a.redraw();
}, mxGraphView.prototype.validateBounds = function(a, b) {
var c = this.graph.getModel(), d = this.getState(b, !0);
if (null != d && d.invalid) {
if (this.graph.isCellVisible(b)) {
if (b != this.currentRoot && null != a) {
d.absoluteOffset.x = 0, d.absoluteOffset.y = 0, d.origin.x = a.origin.x, d.origin.y = a.origin.y;
var e = this.graph.getCellGeometry(b);
if (null != e) {
if (!c.isEdge(b)) {
var f = e.offset || this.EMPTY_POINT;
e.relative ? (d.origin.x += e.x * a.width / this.scale + f.x, d.origin.y += e.y * a.height / this.scale + f.y) :(d.absoluteOffset.x = this.scale * f.x, 
d.absoluteOffset.y = this.scale * f.y, d.origin.x += e.x, d.origin.y += e.y);
}
if (d.x = this.scale * (this.translate.x + d.origin.x), d.y = this.scale * (this.translate.y + d.origin.y), 
d.width = this.scale * e.width, d.height = this.scale * e.height, c.isVertex(b)) {
if (e.relative && (f = mxUtils.toRadians(a.style[mxConstants.STYLE_ROTATION] || "0"), 
0 != f)) {
var e = Math.cos(f), f = Math.sin(f), g = new mxPoint(d.getCenterX(), d.getCenterY()), h = new mxPoint(a.getCenterX(), a.getCenterY()), e = mxUtils.getRotatedPoint(g, e, f, h);
d.x = e.x - d.width / 2, d.y = e.y - d.height / 2;
}
this.updateVertexLabelOffset(d);
}
}
}
} else this.removeState(b);
f = this.graph.getChildOffsetForCell(b), null != f && (d.origin.x += f.x, d.origin.y += f.y);
}
if (null != d && (!this.graph.isCellCollapsed(b) || b == this.currentRoot)) for (e = c.getChildCount(b), 
f = 0; e > f; f++) g = c.getChildAt(b, f), this.validateBounds(d, g);
}, mxGraphView.prototype.updateVertexLabelOffset = function(a) {
var b = mxUtils.getValue(a.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);
b == mxConstants.ALIGN_LEFT ? a.absoluteOffset.x -= a.width :b == mxConstants.ALIGN_RIGHT && (a.absoluteOffset.x += a.width), 
b = mxUtils.getValue(a.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE), 
b == mxConstants.ALIGN_TOP ? a.absoluteOffset.y -= a.height :b == mxConstants.ALIGN_BOTTOM && (a.absoluteOffset.y += a.height);
}, mxGraphView.prototype.validatePoints = function(a, b) {
var c = this.graph.getModel(), d = this.getState(b), e = null;
if (null != d) {
if (d.invalid) {
var f = this.graph.getCellGeometry(b);
if (null != f && c.isEdge(b)) {
var g = this.getState(this.getVisibleTerminal(b, !0));
if (d.setVisibleTerminalState(g, !0), null != g && c.isEdge(g.cell) && !c.isAncestor(g.cell, b)) {
var h = this.getState(c.getParent(g.cell));
this.validatePoints(h, g.cell);
}
var k = this.getState(this.getVisibleTerminal(b, !1));
d.setVisibleTerminalState(k, !1), null != k && c.isEdge(k.cell) && !c.isAncestor(k.cell, b) && (h = this.getState(c.getParent(k.cell)), 
this.validatePoints(h, k.cell)), this.updateFixedTerminalPoints(d, g, k), this.updatePoints(d, f.points, g, k), 
this.updateFloatingTerminalPoints(d, g, k), this.updateEdgeBounds(d), this.updateEdgeLabelOffset(d);
} else null != f && f.relative && null != a && c.isEdge(a.cell) && (f = this.getPoint(a, f), 
null != f && (d.x = f.x, d.y = f.y, f.x = f.x / this.scale - this.translate.x, f.y = f.y / this.scale - this.translate.y, 
d.origin = f, this.childMoved(a, d)));
d.invalid = !1, b != this.currentRoot && this.graph.cellRenderer.redraw(d, !1, this.isRendering());
}
(c.isEdge(b) || c.isVertex(b)) && (null != d.shape && null != d.shape.boundingBox && (e = d.shape.boundingBox.clone()), 
null != d.text && !this.graph.isLabelClipped(d.cell) && null != d.text.boundingBox && (null != e ? e.add(d.text.boundingBox) :e = d.text.boundingBox.clone()));
}
if (null != d && (!this.graph.isCellCollapsed(b) || b == this.currentRoot)) for (f = c.getChildCount(b), 
g = 0; f > g; g++) h = c.getChildAt(b, g), h = this.validatePoints(d, h), null != h && (null == e ? e = h :e.add(h));
return e;
}, mxGraphView.prototype.childMoved = function(a, b) {
var c = b.cell;
if (!this.graph.isCellCollapsed(c) || c == this.currentRoot) for (var d = this.graph.getModel(), e = d.getChildCount(c), f = 0; e > f; f++) this.validateBounds(b, d.getChildAt(c, f));
}, mxGraphView.prototype.updateFixedTerminalPoints = function(a, b, c) {
this.updateFixedTerminalPoint(a, b, !0, this.graph.getConnectionConstraint(a, b, !0)), 
this.updateFixedTerminalPoint(a, c, !1, this.graph.getConnectionConstraint(a, c, !1));
}, mxGraphView.prototype.updateFixedTerminalPoint = function(a, b, c, d) {
var e = null;
if (null != d && (e = this.graph.getConnectionPoint(b, d)), null == e && null == b) {
b = this.scale, d = this.translate;
var f = a.origin, e = this.graph.getCellGeometry(a.cell).getTerminalPoint(c);
null != e && (e = new mxPoint(b * (d.x + e.x + f.x), b * (d.y + e.y + f.y)));
}
a.setAbsoluteTerminalPoint(e, c);
}, mxGraphView.prototype.updatePoints = function(a, b, c, d) {
if (null != a) {
var e = [];
e.push(a.absolutePoints[0]);
var f = this.getEdgeStyle(a, b, c, d);
if (null != f) c = this.getTerminalPort(a, c, !0), d = this.getTerminalPort(a, d, !1), 
f(a, c, d, b, e); else if (null != b) for (f = 0; f < b.length; f++) null != b[f] && (d = mxUtils.clone(b[f]), 
e.push(this.transformControlPoint(a, d)));
b = a.absolutePoints, e.push(b[b.length - 1]), a.absolutePoints = e;
}
}, mxGraphView.prototype.transformControlPoint = function(a, b) {
var c = a.origin;
return new mxPoint(this.scale * (b.x + this.translate.x + c.x), this.scale * (b.y + this.translate.y + c.y));
}, mxGraphView.prototype.getEdgeStyle = function(a, b, c, d) {
return a = null != c && c == d ? mxUtils.getValue(a.style, mxConstants.STYLE_LOOP, this.graph.defaultLoopStyle) :mxUtils.getValue(a.style, mxConstants.STYLE_NOEDGESTYLE, !1) ? null :a.style[mxConstants.STYLE_EDGE], 
"string" == typeof a && (b = mxStyleRegistry.getValue(a), null == b && this.isAllowEval() && (b = mxUtils.eval(a)), 
a = b), "function" == typeof a ? a :null;
}, mxGraphView.prototype.updateFloatingTerminalPoints = function(a, b, c) {
var d = a.absolutePoints, e = d[0];
null == d[d.length - 1] && null != c && this.updateFloatingTerminalPoint(a, c, b, !1), 
null == e && null != b && this.updateFloatingTerminalPoint(a, b, c, !0);
}, mxGraphView.prototype.updateFloatingTerminalPoint = function(a, b, c, d) {
b = this.getTerminalPort(a, b, d);
var e = this.getNextPoint(a, c, d), f = this.graph.isOrthogonal(a);
c = mxUtils.toRadians(Number(b.style[mxConstants.STYLE_ROTATION] || "0"));
var g = new mxPoint(b.getCenterX(), b.getCenterY());
if (0 != c) var h = Math.cos(-c), k = Math.sin(-c), e = mxUtils.getRotatedPoint(e, h, k, g);
h = parseFloat(a.style[mxConstants.STYLE_PERIMETER_SPACING] || 0), h += parseFloat(a.style[d ? mxConstants.STYLE_SOURCE_PERIMETER_SPACING :mxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0), 
b = this.getPerimeterPoint(b, e, 0 == c && f, h), 0 != c && (h = Math.cos(c), k = Math.sin(c), 
b = mxUtils.getRotatedPoint(b, h, k, g)), a.setAbsoluteTerminalPoint(b, d);
}, mxGraphView.prototype.getTerminalPort = function(a, b, c) {
return a = mxUtils.getValue(a.style, c ? mxConstants.STYLE_SOURCE_PORT :mxConstants.STYLE_TARGET_PORT), 
null != a && (a = this.getState(this.graph.getModel().getCell(a)), null != a && (b = a)), 
b;
}, mxGraphView.prototype.getPerimeterPoint = function(a, b, c, d) {
var e = null;
if (null != a) {
var f = this.getPerimeterFunction(a);
null != f && null != b && (d = this.getPerimeterBounds(a, d), 0 < d.width || 0 < d.height) && (e = f(d, a, b, c)), 
null == e && (e = this.getPoint(a));
}
return e;
}, mxGraphView.prototype.getRoutingCenterX = function(a) {
var b = null != a.style ? parseFloat(a.style[mxConstants.STYLE_ROUTING_CENTER_X]) || 0 :0;
return a.getCenterX() + b * a.width;
}, mxGraphView.prototype.getRoutingCenterY = function(a) {
var b = null != a.style ? parseFloat(a.style[mxConstants.STYLE_ROUTING_CENTER_Y]) || 0 :0;
return a.getCenterY() + b * a.height;
}, mxGraphView.prototype.getPerimeterBounds = function(a, b) {
return b = null != b ? b :0, null != a && (b += parseFloat(a.style[mxConstants.STYLE_PERIMETER_SPACING] || 0)), 
a.getPerimeterBounds(b * this.scale);
}, mxGraphView.prototype.getPerimeterFunction = function(a) {
if (a = a.style[mxConstants.STYLE_PERIMETER], "string" == typeof a) {
var b = mxStyleRegistry.getValue(a);
null == b && this.isAllowEval() && (b = mxUtils.eval(a)), a = b;
}
return "function" == typeof a ? a :null;
}, mxGraphView.prototype.getNextPoint = function(a, b, c) {
a = a.absolutePoints;
var d = null;
return null != a && (c || 2 < a.length || null == b) && (d = a.length, d = a[c ? Math.min(1, d - 1) :Math.max(0, d - 2)]), 
null == d && null != b && (d = new mxPoint(b.getCenterX(), b.getCenterY())), d;
}, mxGraphView.prototype.getVisibleTerminal = function(a, b) {
for (var c = this.graph.getModel(), d = c.getTerminal(a, b), e = d; null != d && d != this.currentRoot; ) (!this.graph.isCellVisible(e) || this.graph.isCellCollapsed(d)) && (e = d), 
d = c.getParent(d);
return c.getParent(e) == c.getRoot() && (e = null), e;
}, mxGraphView.prototype.updateEdgeBounds = function(a) {
var b = a.absolutePoints;
if (a.length = 0, null != b && 0 < b.length) {
var c = b[0], d = b[b.length - 1];
if (null == c || null == d) a.cell != this.currentRoot && this.clear(a.cell, !0); else {
if (c.x != d.x || c.y != d.y) {
var e = d.x - c.x, f = d.y - c.y;
a.terminalDistance = Math.sqrt(e * e + f * f);
} else a.terminalDistance = 0;
var d = 0, g = [], f = c;
if (null != f) {
for (var c = f.x, h = f.y, k = c, l = h, m = 1; m < b.length; m++) {
var n = b[m];
null != n && (e = f.x - n.x, f = f.y - n.y, e = Math.sqrt(e * e + f * f), g.push(e), 
d += e, f = n, c = Math.min(f.x, c), h = Math.min(f.y, h), k = Math.max(f.x, k), 
l = Math.max(f.y, l));
}
a.length = d, a.segments = g, a.x = c, a.y = h, a.width = Math.max(1, k - c), a.height = Math.max(1, l - h);
}
}
}
}, mxGraphView.prototype.getPoint = function(a, b) {
var c = a.getCenterX(), d = a.getCenterY();
if (null == a.segments || null != b && !b.relative) null != b && (l = b.offset, 
null != l && (c += l.x, d += l.y)); else {
for (var e = a.absolutePoints.length, f = ((null != b ? b.x / 2 :0) + .5) * a.length, g = a.segments[0], h = 0, k = 1; f > h + g && e - 1 > k; ) h += g, 
g = a.segments[k++];
if (e = 0 == g ? 0 :(f - h) / g, f = a.absolutePoints[k - 1], k = a.absolutePoints[k], 
null != f && null != k) {
if (h = c = d = 0, null != b) {
var d = b.y, l = b.offset;
null != l && (c = l.x, h = l.y);
}
l = k.x - f.x, k = k.y - f.y, c = f.x + l * e + ((0 == g ? 0 :k / g) * d + c) * this.scale, 
d = f.y + k * e - ((0 == g ? 0 :l / g) * d - h) * this.scale;
}
}
return new mxPoint(c, d);
}, mxGraphView.prototype.getRelativePoint = function(a, b, c) {
var d = this.graph.getModel().getGeometry(a.cell);
if (null != d) {
var e = a.absolutePoints.length;
if (d.relative && e > 1) {
for (var d = a.length, f = a.segments, g = a.absolutePoints[0], h = a.absolutePoints[1], k = mxUtils.ptSegDistSq(g.x, g.y, h.x, h.y, b, c), l = 0, m = 0, n = 0, p = 2; e > p; p++) m += f[p - 2], 
h = a.absolutePoints[p], g = mxUtils.ptSegDistSq(g.x, g.y, h.x, h.y, b, c), k >= g && (k = g, 
l = p - 1, n = m), g = h;
return e = f[l], g = a.absolutePoints[l], h = a.absolutePoints[l + 1], k = h.x, 
f = h.y, a = g.x - k, l = g.y - f, k = b - k, f = c - f, k = a - k, f = l - f, f = k * a + f * l, 
a = Math.sqrt(0 >= f ? 0 :f * f / (a * a + l * l)), a > e && (a = e), e = Math.sqrt(mxUtils.ptSegDistSq(g.x, g.y, h.x, h.y, b, c)), 
-1 == mxUtils.relativeCcw(g.x, g.y, h.x, h.y, b, c) && (e = -e), new mxPoint(-2 * ((d / 2 - n - a) / d), e / this.scale);
}
}
return new mxPoint();
}, mxGraphView.prototype.updateEdgeLabelOffset = function(a) {
var b = a.absolutePoints;
if (a.absoluteOffset.x = a.getCenterX(), a.absoluteOffset.y = a.getCenterY(), null != b && 0 < b.length && null != a.segments) {
var c = this.graph.getCellGeometry(a.cell);
if (c.relative) {
var d = this.getPoint(a, c);
null != d && (a.absoluteOffset = d);
} else {
var d = b[0], e = b[b.length - 1];
if (null != d && null != e) {
var b = e.x - d.x, f = e.y - d.y, g = e = 0, c = c.offset;
null != c && (e = c.x, g = c.y), c = d.y + f / 2 + g * this.scale, a.absoluteOffset.x = d.x + b / 2 + e * this.scale, 
a.absoluteOffset.y = c;
}
}
}
}, mxGraphView.prototype.getState = function(a, b) {
b = b || !1;
var c = null;
return null != a && (c = this.states.get(a), this.graph.isCellVisible(a) && (null == c && b && this.graph.isCellVisible(a) ? (c = this.createState(a), 
this.states.put(a, c)) :b && null != c && this.updateStyle && (c.style = this.graph.getCellStyle(a)))), 
c;
}, mxGraphView.prototype.isRendering = function() {
return this.rendering;
}, mxGraphView.prototype.setRendering = function(a) {
this.rendering = a;
}, mxGraphView.prototype.isAllowEval = function() {
return this.allowEval;
}, mxGraphView.prototype.setAllowEval = function(a) {
this.allowEval = a;
}, mxGraphView.prototype.getStates = function() {
return this.states;
}, mxGraphView.prototype.setStates = function(a) {
this.states = a;
}, mxGraphView.prototype.getCellStates = function(a) {
if (null == a) return this.states;
for (var b = [], c = 0; c < a.length; c++) {
var d = this.getState(a[c]);
null != d && b.push(d);
}
return b;
}, mxGraphView.prototype.removeState = function(a) {
var b = null;
return null != a && (b = this.states.remove(a), null != b && (this.graph.cellRenderer.destroy(b), 
b.destroy())), b;
}, mxGraphView.prototype.createState = function(a) {
var b = this.graph.getCellStyle(a);
return a = new mxCellState(this, a, b), this.graph.cellRenderer.initialize(a, this.isRendering()), 
a;
}, mxGraphView.prototype.getCanvas = function() {
return this.canvas;
}, mxGraphView.prototype.getBackgroundPane = function() {
return this.backgroundPane;
}, mxGraphView.prototype.getDrawPane = function() {
return this.drawPane;
}, mxGraphView.prototype.getOverlayPane = function() {
return this.overlayPane;
}, mxGraphView.prototype.isContainerEvent = function(a) {
return a = mxEvent.getSource(a), a == this.graph.container || a.parentNode == this.backgroundPane || null != a.parentNode && a.parentNode.parentNode == this.backgroundPane || a == this.canvas.parentNode || a == this.canvas || a == this.backgroundPane || a == this.drawPane || a == this.overlayPane;
}, mxGraphView.prototype.isScrollEvent = function(a) {
var b = mxUtils.getOffset(this.graph.container);
a = new mxPoint(a.clientX - b.x, a.clientY - b.y);
var b = this.graph.container.offsetWidth, c = this.graph.container.clientWidth;
return b > c && a.x > c + 2 && a.x <= b ? !0 :(b = this.graph.container.offsetHeight, 
c = this.graph.container.clientHeight, b > c && a.y > c + 2 && a.y <= b ? !0 :!1);
}, mxGraphView.prototype.init = function() {
this.installListeners();
var a = this.graph;
a.dialect == mxConstants.DIALECT_SVG ? this.createSvg() :a.dialect == mxConstants.DIALECT_VML ? this.createVml() :this.createHtml();
}, mxGraphView.prototype.installListeners = function() {
var a = this.graph, b = a.container;
if (null != b) {
mxEvent.addGestureListeners(b, mxUtils.bind(this, function(b) {
mxClient.IS_TOUCH && a.isEditing() && a.stopEditing(!a.isInvokesStopCellEditing()), 
this.isContainerEvent(b) && (!mxClient.IS_IE && !mxClient.IS_GC && !mxClient.IS_OP && !mxClient.IS_SF || !this.isScrollEvent(b)) && a.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(b));
}), mxUtils.bind(this, function(b) {
this.isContainerEvent(b) && a.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b));
}), mxUtils.bind(this, function(b) {
this.isContainerEvent(b) && a.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(b));
})), mxEvent.addListener(b, "dblclick", mxUtils.bind(this, function(b) {
a.dblClick(b);
}));
var c = function(c) {
var e = null;
return mxClient.IS_TOUCH && (e = mxEvent.getClientX(c), c = mxEvent.getClientY(c), 
c = mxUtils.convertPoint(b, e, c), e = a.view.getState(a.getCellAt(c.x, c.y))), 
e;
};
a.addMouseListener({
mouseDown:function() {
a.panningHandler.hideMenu();
},
mouseMove:function() {},
mouseUp:function() {}
}), this.moveHandler = mxUtils.bind(this, function(b) {
null != a.tooltipHandler && a.tooltipHandler.isHideOnHover() && a.tooltipHandler.hide(), 
this.captureDocumentGesture && a.isMouseDown && !mxEvent.isConsumed(b) && a.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(b, c(b)));
}), this.endHandler = mxUtils.bind(this, function(b) {
this.captureDocumentGesture && a.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(b));
}), mxEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);
}
}, mxGraphView.prototype.createHtml = function() {
var a = this.graph.container;
null != a && (this.canvas = this.createHtmlPane("100%", "100%"), this.backgroundPane = this.createHtmlPane("1px", "1px"), 
this.drawPane = this.createHtmlPane("1px", "1px"), this.overlayPane = this.createHtmlPane("1px", "1px"), 
this.canvas.appendChild(this.backgroundPane), this.canvas.appendChild(this.drawPane), 
this.canvas.appendChild(this.overlayPane), a.appendChild(this.canvas), mxClient.IS_QUIRKS && (a = mxUtils.bind(this, function(a) {
a = this.getGraphBounds(), this.updateHtmlCanvasSize(a.x + a.width + this.graph.border, a.y + a.height + this.graph.border);
}), mxEvent.addListener(window, "resize", a)));
}, mxGraphView.prototype.updateHtmlCanvasSize = function(a, b) {
if (null != this.graph.container) {
var c = this.graph.container.offsetHeight;
this.canvas.style.width = this.graph.container.offsetWidth < a ? a + "px" :"100%", 
this.canvas.style.height = b > c ? b + "px" :"100%";
}
}, mxGraphView.prototype.createHtmlPane = function(a, b) {
var c = document.createElement("DIV");
return null != a && null != b ? (c.style.position = "absolute", c.style.left = "0px", 
c.style.top = "0px", c.style.width = a, c.style.height = b) :c.style.position = "relative", 
c;
}, mxGraphView.prototype.createVml = function() {
var a = this.graph.container;
if (null != a) {
var b = a.offsetWidth, c = a.offsetHeight;
this.canvas = this.createVmlPane(b, c), this.backgroundPane = this.createVmlPane(b, c), 
this.drawPane = this.createVmlPane(b, c), this.overlayPane = this.createVmlPane(b, c), 
this.canvas.appendChild(this.backgroundPane), this.canvas.appendChild(this.drawPane), 
this.canvas.appendChild(this.overlayPane), a.appendChild(this.canvas);
}
}, mxGraphView.prototype.createVmlPane = function(a, b) {
var c = document.createElement(mxClient.VML_PREFIX + ":group");
return c.style.position = "absolute", c.style.left = "0px", c.style.top = "0px", 
c.style.width = a + "px", c.style.height = b + "px", c.setAttribute("coordsize", a + "," + b), 
c.setAttribute("coordorigin", "0,0"), c;
}, mxGraphView.prototype.createSvg = function() {
var a = this.graph.container;
this.canvas = document.createElementNS(mxConstants.NS_SVG, "g"), this.backgroundPane = document.createElementNS(mxConstants.NS_SVG, "g"), 
this.canvas.appendChild(this.backgroundPane), this.drawPane = document.createElementNS(mxConstants.NS_SVG, "g"), 
this.canvas.appendChild(this.drawPane), this.overlayPane = document.createElementNS(mxConstants.NS_SVG, "g"), 
this.canvas.appendChild(this.overlayPane);
var b = document.createElementNS(mxConstants.NS_SVG, "svg");
b.style.width = "100%", b.style.height = "100%", b.style.display = "block", b.appendChild(this.canvas), 
null != a && (a.appendChild(b), this.updateContainerStyle(a));
}, mxGraphView.prototype.updateContainerStyle = function(a) {
"static" == mxUtils.getCurrentStyle(a).position && (a.style.position = "relative"), 
mxClient.IS_POINTER && (a.style.msTouchAction = "none");
}, mxGraphView.prototype.destroy = function() {
var a = null != this.canvas ? this.canvas.ownerSVGElement :null;
null == a && (a = this.canvas), null != a && null != a.parentNode && (this.clear(this.currentRoot, !0), 
mxEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler), 
mxEvent.release(this.graph.container), a.parentNode.removeChild(a), this.overlayPane = this.drawPane = this.backgroundPane = this.canvas = this.endHandler = this.moveHandler = null);
}, mxCurrentRootChange.prototype.execute = function() {
var a = this.view.currentRoot;
this.view.currentRoot = this.previous, this.previous = a, a = this.view.graph.getTranslateForRoot(this.view.currentRoot), 
null != a && (this.view.translate = new mxPoint(-a.x, -a.y)), this.view.fireEvent(new mxEventObject(this.isUp ? mxEvent.UP :mxEvent.DOWN, "root", this.view.currentRoot, "previous", this.previous)), 
this.isUp ? (this.view.clear(this.view.currentRoot, !0), this.view.validate()) :this.view.refresh(), 
this.isUp = !this.isUp;
}, mxLoadResources && mxResources.add(mxClient.basePath + "/resources/graph"), mxGraph.prototype = new mxEventSource(), 
mxGraph.prototype.constructor = mxGraph, mxGraph.prototype.EMPTY_ARRAY = [], mxGraph.prototype.mouseListeners = null, 
mxGraph.prototype.isMouseDown = !1, mxGraph.prototype.model = null, mxGraph.prototype.view = null, 
mxGraph.prototype.stylesheet = null, mxGraph.prototype.selectionModel = null, mxGraph.prototype.cellEditor = null, 
mxGraph.prototype.cellRenderer = null, mxGraph.prototype.multiplicities = null, 
mxGraph.prototype.renderHint = null, mxGraph.prototype.dialect = null, mxGraph.prototype.gridSize = 10, 
mxGraph.prototype.gridEnabled = !0, mxGraph.prototype.portsEnabled = !0, mxGraph.prototype.doubleTapEnabled = !0, 
mxGraph.prototype.doubleTapTimeout = 700, mxGraph.prototype.doubleTapTolerance = 25, 
mxGraph.prototype.lastTouchY = 0, mxGraph.prototype.lastTouchY = 0, mxGraph.prototype.lastTouchTime = 0, 
mxGraph.prototype.gestureEnabled = !0, mxGraph.prototype.tolerance = 4, mxGraph.prototype.defaultOverlap = .5, 
mxGraph.prototype.defaultParent = null, mxGraph.prototype.alternateEdgeStyle = null, 
mxGraph.prototype.backgroundImage = null, mxGraph.prototype.pageVisible = !1, mxGraph.prototype.pageBreaksVisible = !1, 
mxGraph.prototype.pageBreakColor = "gray", mxGraph.prototype.pageBreakDashed = !0, 
mxGraph.prototype.minPageBreakDist = 20, mxGraph.prototype.preferPageSize = !1, 
mxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT, mxGraph.prototype.pageScale = 1.5, 
mxGraph.prototype.enabled = !0, mxGraph.prototype.escapeEnabled = !0, mxGraph.prototype.invokesStopCellEditing = !0, 
mxGraph.prototype.enterStopsCellEditing = !1, mxGraph.prototype.useScrollbarsForPanning = !0, 
mxGraph.prototype.exportEnabled = !0, mxGraph.prototype.importEnabled = !0, mxGraph.prototype.cellsLocked = !1, 
mxGraph.prototype.cellsCloneable = !0, mxGraph.prototype.foldingEnabled = !0, mxGraph.prototype.cellsEditable = !0, 
mxGraph.prototype.cellsDeletable = !0, mxGraph.prototype.cellsMovable = !0, mxGraph.prototype.edgeLabelsMovable = !0, 
mxGraph.prototype.vertexLabelsMovable = !1, mxGraph.prototype.dropEnabled = !1, 
mxGraph.prototype.splitEnabled = !0, mxGraph.prototype.cellsResizable = !0, mxGraph.prototype.cellsBendable = !0, 
mxGraph.prototype.cellsSelectable = !0, mxGraph.prototype.cellsDisconnectable = !0, 
mxGraph.prototype.autoSizeCells = !1, mxGraph.prototype.autoScroll = !0, mxGraph.prototype.timerAutoScroll = !1, 
mxGraph.prototype.allowAutoPanning = !1, mxGraph.prototype.ignoreScrollbars = !1, 
mxGraph.prototype.autoExtend = !0, mxGraph.prototype.maximumGraphBounds = null, 
mxGraph.prototype.minimumGraphSize = null, mxGraph.prototype.minimumContainerSize = null, 
mxGraph.prototype.maximumContainerSize = null, mxGraph.prototype.resizeContainer = !1, 
mxGraph.prototype.border = 0, mxGraph.prototype.ordered = !0, mxGraph.prototype.keepEdgesInForeground = !1, 
mxGraph.prototype.keepEdgesInBackground = !0, mxGraph.prototype.allowNegativeCoordinates = !0, 
mxGraph.prototype.constrainChildren = !0, mxGraph.prototype.extendParents = !0, 
mxGraph.prototype.extendParentsOnAdd = !0, mxGraph.prototype.collapseToPreferredSize = !0, 
mxGraph.prototype.zoomFactor = 1.2, mxGraph.prototype.keepSelectionVisibleOnZoom = !1, 
mxGraph.prototype.centerZoom = !0, mxGraph.prototype.resetViewOnRootChange = !0, 
mxGraph.prototype.resetEdgesOnResize = !1, mxGraph.prototype.resetEdgesOnMove = !1, 
mxGraph.prototype.resetEdgesOnConnect = !0, mxGraph.prototype.allowLoops = !1, mxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop, 
mxGraph.prototype.multigraph = !0, mxGraph.prototype.connectableEdges = !1, mxGraph.prototype.allowDanglingEdges = !0, 
mxGraph.prototype.cloneInvalidEdges = !1, mxGraph.prototype.disconnectOnMove = !0, 
mxGraph.prototype.labelsVisible = !0, mxGraph.prototype.htmlLabels = !1, mxGraph.prototype.swimlaneSelectionEnabled = !0, 
mxGraph.prototype.swimlaneNesting = !0, mxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR, 
mxGraph.prototype.imageBundles = null, mxGraph.prototype.minFitScale = .1, mxGraph.prototype.maxFitScale = 8, 
mxGraph.prototype.panDx = 0, mxGraph.prototype.panDy = 0, mxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + "/collapsed.gif", 9, 9), 
mxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + "/expanded.gif", 9, 9), 
mxGraph.prototype.warningImage = new mxImage(mxClient.imageBasePath + "/warning" + (mxClient.IS_MAC ? ".png" :".gif"), 16, 16), 
mxGraph.prototype.alreadyConnectedResource = "none" != mxClient.language ? "alreadyConnected" :"", 
mxGraph.prototype.containsValidationErrorsResource = "none" != mxClient.language ? "containsValidationErrors" :"", 
mxGraph.prototype.collapseExpandResource = "none" != mxClient.language ? "collapse-expand" :"", 
mxGraph.prototype.init = function(a) {
this.container = a, this.cellEditor = this.createCellEditor(), this.view.init(), 
this.sizeDidChange(), mxClient.IS_IE && (mxEvent.addListener(window, "unload", mxUtils.bind(this, function() {
this.destroy();
})), mxEvent.addListener(a, "selectstart", mxUtils.bind(this, function() {
return this.isEditing();
}))), 8 == document.documentMode && a.insertAdjacentHTML("beforeend", '<v:group style="DISPLAY: none;"></v:group>');
}, mxGraph.prototype.createHandlers = function() {
this.tooltipHandler = new mxTooltipHandler(this), this.tooltipHandler.setEnabled(!1), 
this.panningHandler = new mxPanningHandler(this), this.panningHandler.panningEnabled = !1, 
this.selectionCellsHandler = new mxSelectionCellsHandler(this), this.connectionHandler = new mxConnectionHandler(this), 
this.connectionHandler.setEnabled(!1), this.graphHandler = new mxGraphHandler(this);
}, mxGraph.prototype.createSelectionModel = function() {
return new mxGraphSelectionModel(this);
}, mxGraph.prototype.createStylesheet = function() {
return new mxStylesheet();
}, mxGraph.prototype.createGraphView = function() {
return new mxGraphView(this);
}, mxGraph.prototype.createCellRenderer = function() {
return new mxCellRenderer();
}, mxGraph.prototype.createCellEditor = function() {
return new mxCellEditor(this);
}, mxGraph.prototype.getModel = function() {
return this.model;
}, mxGraph.prototype.getView = function() {
return this.view;
}, mxGraph.prototype.getStylesheet = function() {
return this.stylesheet;
}, mxGraph.prototype.setStylesheet = function(a) {
this.stylesheet = a;
}, mxGraph.prototype.getSelectionModel = function() {
return this.selectionModel;
}, mxGraph.prototype.setSelectionModel = function(a) {
this.selectionModel = a;
}, mxGraph.prototype.getSelectionCellsForChanges = function(a) {
for (var b = [], c = 0; c < a.length; c++) {
var d = a[c];
if (d.constructor != mxRootChange) {
var e = null;
d instanceof mxChildChange && null == d.previous ? e = d.child :null != d.cell && d.cell instanceof mxCell && (e = d.cell), 
null != e && 0 > mxUtils.indexOf(b, e) && b.push(e);
}
}
return this.getModel().getTopmostCells(b);
}, mxGraph.prototype.graphModelChanged = function(a) {
for (var b = 0; b < a.length; b++) this.processChange(a[b]);
this.removeSelectionCells(this.getRemovedCellsForChanges(a)), this.view.validate(), 
this.sizeDidChange();
}, mxGraph.prototype.getRemovedCellsForChanges = function(a) {
for (var b = [], c = 0; c < a.length; c++) {
var d = a[c];
if (d instanceof mxRootChange) break;
d instanceof mxChildChange ? null != d.previous && null == d.parent && (b = b.concat(this.model.getDescendants(d.child))) :d instanceof mxVisibleChange && (b = b.concat(this.model.getDescendants(d.cell)));
}
return b;
}, mxGraph.prototype.processChange = function(a) {
if (a instanceof mxRootChange) this.clearSelection(), this.removeStateForCell(a.previous), 
this.resetViewOnRootChange && (this.view.scale = 1, this.view.translate.x = 0, this.view.translate.y = 0), 
this.fireEvent(new mxEventObject(mxEvent.ROOT)); else if (a instanceof mxChildChange) {
var b = this.model.getParent(a.child);
null != b ? this.view.invalidate(a.child, !0, !1, null != a.previous) :(this.removeStateForCell(a.child), 
this.view.currentRoot == a.child && this.home()), b != a.previous && (null != b && this.view.invalidate(b, !1, !1), 
null != a.previous && this.view.invalidate(a.previous, !1, !1));
} else a instanceof mxTerminalChange || a instanceof mxGeometryChange ? this.view.invalidate(a.cell) :a instanceof mxValueChange ? this.view.invalidate(a.cell, !1, !1) :a instanceof mxStyleChange ? (this.view.invalidate(a.cell, !0, !0, !1), 
this.view.removeState(a.cell)) :null != a.cell && a.cell instanceof mxCell && this.removeStateForCell(a.cell);
}, mxGraph.prototype.removeStateForCell = function(a) {
for (var b = this.model.getChildCount(a), c = 0; b > c; c++) this.removeStateForCell(this.model.getChildAt(a, c));
this.view.removeState(a);
}, mxGraph.prototype.addCellOverlay = function(a, b) {
null == a.overlays && (a.overlays = []), a.overlays.push(b);
var c = this.view.getState(a);
return null != c && this.cellRenderer.redraw(c), this.fireEvent(new mxEventObject(mxEvent.ADD_OVERLAY, "cell", a, "overlay", b)), 
b;
}, mxGraph.prototype.getCellOverlays = function(a) {
return a.overlays;
}, mxGraph.prototype.removeCellOverlay = function(a, b) {
if (null == b) this.removeCellOverlays(a); else {
var c = mxUtils.indexOf(a.overlays, b);
c >= 0 ? (a.overlays.splice(c, 1), 0 == a.overlays.length && (a.overlays = null), 
c = this.view.getState(a), null != c && this.cellRenderer.redraw(c), this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, "cell", a, "overlay", b))) :b = null;
}
return b;
}, mxGraph.prototype.removeCellOverlays = function(a) {
var b = a.overlays;
if (null != b) {
a.overlays = null;
var c = this.view.getState(a);
for (null != c && this.cellRenderer.redraw(c), c = 0; c < b.length; c++) this.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY, "cell", a, "overlay", b[c]));
}
return b;
}, mxGraph.prototype.clearCellOverlays = function(a) {
a = null != a ? a :this.model.getRoot(), this.removeCellOverlays(a);
for (var b = this.model.getChildCount(a), c = 0; b > c; c++) {
var d = this.model.getChildAt(a, c);
this.clearCellOverlays(d);
}
}, mxGraph.prototype.setCellWarning = function(a, b, c, d) {
return null != b && 0 < b.length ? (c = null != c ? c :this.warningImage, b = new mxCellOverlay(c, "<font color=red>" + b + "</font>"), 
d && b.addListener(mxEvent.CLICK, mxUtils.bind(this, function() {
this.isEnabled() && this.setSelectionCell(a);
})), this.addCellOverlay(a, b)) :(this.removeCellOverlays(a), null);
}, mxGraph.prototype.startEditing = function(a) {
this.startEditingAtCell(null, a);
}, mxGraph.prototype.startEditingAtCell = function(a, b) {
null == a && (a = this.getSelectionCell(), null != a && !this.isCellEditable(a) && (a = null)), 
null != a && (this.fireEvent(new mxEventObject(mxEvent.START_EDITING, "cell", a, "event", b)), 
this.cellEditor.startEditing(a, b));
}, mxGraph.prototype.getEditingValue = function(a) {
return this.convertValueToString(a);
}, mxGraph.prototype.stopEditing = function(a) {
this.cellEditor.stopEditing(a);
}, mxGraph.prototype.labelChanged = function(a, b, c) {
this.model.beginUpdate();
try {
this.cellLabelChanged(a, b, this.isAutoSizeCell(a)), this.fireEvent(new mxEventObject(mxEvent.LABEL_CHANGED, "cell", a, "value", b, "event", c));
} finally {
this.model.endUpdate();
}
return a;
}, mxGraph.prototype.cellLabelChanged = function(a, b, c) {
this.model.beginUpdate();
try {
this.model.setValue(a, b), c && this.cellSizeUpdated(a, !1);
} finally {
this.model.endUpdate();
}
}, mxGraph.prototype.escape = function(a) {
this.stopEditing(!0), this.connectionHandler.reset(), this.graphHandler.reset(), 
a = this.getSelectionCells();
for (var b = 0; b < a.length; b++) {
var c = this.view.getState(a[b]);
null != c && null != c.handler && c.handler.reset();
}
}, mxGraph.prototype.click = function(a) {
var b = a.getEvent(), c = a.getCell(), d = new mxEventObject(mxEvent.CLICK, "event", b, "cell", c);
a.isConsumed() && d.consume(), this.fireEvent(d), this.isEnabled() && !mxEvent.isConsumed(b) && !d.isConsumed() && (null != c ? this.selectCellForEvent(c, b) :(c = null, 
this.isSwimlaneSelectionEnabled() && (c = this.getSwimlaneAt(a.getGraphX(), a.getGraphY())), 
null != c ? this.selectCellForEvent(c, b) :this.isToggleEvent(b) || this.clearSelection()));
}, mxGraph.prototype.dblClick = function(a, b) {
var c = new mxEventObject(mxEvent.DOUBLE_CLICK, "event", a, "cell", b);
this.fireEvent(c), this.isEnabled() && !mxEvent.isConsumed(a) && !c.isConsumed() && null != b && this.isCellEditable(b) && this.startEditingAtCell(b, a);
}, mxGraph.prototype.scrollPointToVisible = function(a, b, c, d) {
if (this.timerAutoScroll || !this.ignoreScrollbars && !mxUtils.hasScrollbars(this.container)) this.allowAutoPanning && !this.panningHandler.active && (null == this.panningManager && (this.panningManager = this.createPanningManager()), 
this.panningManager.panTo(a + this.panDx, b + this.panDy)); else {
var e = this.container;
if (d = null != d ? d :20, a >= e.scrollLeft && b >= e.scrollTop && a <= e.scrollLeft + e.clientWidth && b <= e.scrollTop + e.clientHeight) {
var f = e.scrollLeft + e.clientWidth - a;
if (d > f) {
if (a = e.scrollLeft, e.scrollLeft += d - f, c && a == e.scrollLeft) {
if (this.dialect == mxConstants.DIALECT_SVG) {
a = this.view.getDrawPane().ownerSVGElement;
var g = this.container.scrollWidth + d - f;
} else g = Math.max(e.clientWidth, e.scrollWidth) + d - f, a = this.view.getCanvas();
a.style.width = g + "px", e.scrollLeft += d - f;
}
} else f = a - e.scrollLeft, d > f && (e.scrollLeft -= d - f);
f = e.scrollTop + e.clientHeight - b, d > f ? (a = e.scrollTop, e.scrollTop += d - f, 
a == e.scrollTop && c && (this.dialect == mxConstants.DIALECT_SVG ? (a = this.view.getDrawPane().ownerSVGElement, 
b = this.container.scrollHeight + d - f) :(b = Math.max(e.clientHeight, e.scrollHeight) + d - f, 
a = this.view.getCanvas()), a.style.height = b + "px", e.scrollTop += d - f)) :(f = b - e.scrollTop, 
d > f && (e.scrollTop -= d - f));
}
}
}, mxGraph.prototype.createPanningManager = function() {
return new mxPanningManager(this);
}, mxGraph.prototype.getBorderSizes = function() {
function a(a) {
var b = 0, b = "thin" == a ? 2 :"medium" == a ? 4 :"thick" == a ? 6 :parseInt(a);
return isNaN(b) && (b = 0), b;
}
var b = mxUtils.getCurrentStyle(this.container), c = new mxRectangle();
return c.x = a(b.borderLeftWidth) + parseInt(b.paddingLeft || 0), c.y = a(b.borderTopWidth) + parseInt(b.paddingTop || 0), 
c.width = a(b.borderRightWidth) + parseInt(b.paddingRight || 0), c.height = a(b.borderBottomWidth) + parseInt(b.paddingBottom || 0), 
c;
}, mxGraph.prototype.getPreferredPageSize = function(a, b, c) {
a = this.view.scale;
var d = this.view.translate, e = this.pageFormat, f = a * this.pageScale, e = new mxRectangle(0, 0, e.width * f, e.height * f);
return b = this.pageBreaksVisible ? Math.ceil(b / e.width) :1, c = this.pageBreaksVisible ? Math.ceil(c / e.height) :1, 
new mxRectangle(0, 0, b * e.width + 2 + d.x / a, c * e.height + 2 + d.y / a);
}, mxGraph.prototype.sizeDidChange = function() {
var a = this.getGraphBounds();
if (null != this.container) {
var b = this.getBorder(), c = Math.max(0, a.x + a.width + 1 + b), b = Math.max(0, a.y + a.height + 1 + b);
if (null != this.minimumContainerSize && (c = Math.max(c, this.minimumContainerSize.width), 
b = Math.max(b, this.minimumContainerSize.height)), this.resizeContainer && this.doResizeContainer(c, b), 
this.preferPageSize || !mxClient.IS_IE && this.pageVisible) {
var d = this.getPreferredPageSize(a, c, b);
null != d && (c = d.width, b = d.height);
}
null != this.minimumGraphSize && (c = Math.max(c, this.minimumGraphSize.width * this.view.scale), 
b = Math.max(b, this.minimumGraphSize.height * this.view.scale)), c = Math.ceil(c - 1), 
b = Math.ceil(b - 1), this.dialect == mxConstants.DIALECT_SVG ? (d = this.view.getDrawPane().ownerSVGElement, 
d.style.minWidth = Math.max(1, c) + "px", d.style.minHeight = Math.max(1, b) + "px", 
d.style.width = "100%", d.style.height = "100%") :mxClient.IS_QUIRKS ? this.view.updateHtmlCanvasSize(Math.max(1, c), Math.max(1, b)) :(this.view.canvas.style.minWidth = Math.max(1, c) + "px", 
this.view.canvas.style.minHeight = Math.max(1, b) + "px"), this.updatePageBreaks(this.pageBreaksVisible, c - 1, b - 1);
}
this.fireEvent(new mxEventObject(mxEvent.SIZE, "bounds", a));
}, mxGraph.prototype.doResizeContainer = function(a, b) {
if (mxClient.IS_IE) if (mxClient.IS_QUIRKS) {
var c = this.getBorderSizes();
a += Math.max(2, c.x + c.width + 1), b += Math.max(2, c.y + c.height + 1);
} else 9 <= document.documentMode ? (a += 3, b += 5) :(a += 1, b += 1); else b += 1;
null != this.maximumContainerSize && (a = Math.min(this.maximumContainerSize.width, a), 
b = Math.min(this.maximumContainerSize.height, b)), this.container.style.width = Math.ceil(a) + "px", 
this.container.style.height = Math.ceil(b) + "px";
}, mxGraph.prototype.updatePageBreaks = function(a, b, c) {
var d = this.view.scale, e = this.view.translate, f = this.pageFormat, g = d * this.pageScale, e = new mxRectangle(d * e.x, d * e.y, f.width * g, f.height * g);
if (a = a && Math.min(e.width, e.height) > this.minPageBreakDist, e.x = mxUtils.mod(e.x, e.width), 
e.y = mxUtils.mod(e.y, e.height), f = a ? Math.ceil((b - e.x) / e.width) :0, a = a ? Math.ceil((c - e.y) / e.height) :0, 
null == this.horizontalPageBreaks && f > 0 && (this.horizontalPageBreaks = []), 
null != this.horizontalPageBreaks) {
for (g = 0; f >= g; g++) {
var h = [ new mxPoint(e.x + g * e.width, 1), new mxPoint(e.x + g * e.width, c) ];
null != this.horizontalPageBreaks[g] ? (this.horizontalPageBreaks[g].scale = 1, 
this.horizontalPageBreaks[g].points = h, this.horizontalPageBreaks[g].redraw()) :(h = new mxPolyline(h, this.pageBreakColor, this.scale), 
h.dialect = this.dialect, h.isDashed = this.pageBreakDashed, h.scale = d, h.init(this.view.backgroundPane), 
h.redraw(), this.horizontalPageBreaks[g] = h);
}
for (g = f; g < this.horizontalPageBreaks.length; g++) this.horizontalPageBreaks[g].destroy();
this.horizontalPageBreaks.splice(f, this.horizontalPageBreaks.length - f);
}
if (null == this.verticalPageBreaks && a > 0 && (this.verticalPageBreaks = []), 
null != this.verticalPageBreaks) {
for (g = 0; a >= g; g++) h = [ new mxPoint(1, e.y + g * e.height), new mxPoint(b, e.y + g * e.height) ], 
null != this.verticalPageBreaks[g] ? (this.verticalPageBreaks[g].scale = 1, this.verticalPageBreaks[g].points = h, 
this.verticalPageBreaks[g].redraw()) :(h = new mxPolyline(h, this.pageBreakColor, d), 
h.dialect = this.dialect, h.isDashed = this.pageBreakDashed, h.scale = d, h.init(this.view.backgroundPane), 
h.redraw(), this.verticalPageBreaks[g] = h);
for (g = a; g < this.verticalPageBreaks.length; g++) this.verticalPageBreaks[g].destroy();
this.verticalPageBreaks.splice(a, this.verticalPageBreaks.length - a);
}
}, mxGraph.prototype.getCellStyle = function(a) {
var b = this.model.getStyle(a), c = null, c = this.model.isEdge(a) ? this.stylesheet.getDefaultEdgeStyle() :this.stylesheet.getDefaultVertexStyle();
return null != b && (c = this.postProcessCellStyle(this.stylesheet.getCellStyle(b, c))), 
null == c && (c = mxGraph.prototype.EMPTY_ARRAY), c;
}, mxGraph.prototype.postProcessCellStyle = function(a) {
if (null != a) {
var b = a[mxConstants.STYLE_IMAGE], c = this.getImageFromBundles(b);
null != c ? a[mxConstants.STYLE_IMAGE] = c :c = b, null != c && "data:image/" == c.substring(0, 11) && ("data:image/svg+xml," != c.substring(0, 19) && (b = c.indexOf(","), 
b > 0 && (c = c.substring(0, b) + ";base64," + c.substring(b + 1))), a[mxConstants.STYLE_IMAGE] = c);
}
return a;
}, mxGraph.prototype.setCellStyle = function(a, b) {
if (b = b || this.getSelectionCells(), null != b) {
this.model.beginUpdate();
try {
for (var c = 0; c < b.length; c++) this.model.setStyle(b[c], a);
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.toggleCellStyle = function(a, b, c) {
c = c || this.getSelectionCell(), this.toggleCellStyles(a, b, [ c ]);
}, mxGraph.prototype.toggleCellStyles = function(a, b, c) {
if (b = null != b ? b :!1, c = c || this.getSelectionCells(), null != c && 0 < c.length) {
var d = this.view.getState(c[0]), d = null != d ? d.style :this.getCellStyle(c[0]);
null != d && (b = mxUtils.getValue(d, a, b) ? 0 :1, this.setCellStyles(a, b, c));
}
}, mxGraph.prototype.setCellStyles = function(a, b, c) {
c = c || this.getSelectionCells(), mxUtils.setCellStyles(this.model, c, a, b);
}, mxGraph.prototype.toggleCellStyleFlags = function(a, b, c) {
this.setCellStyleFlags(a, b, null, c);
}, mxGraph.prototype.setCellStyleFlags = function(a, b, c, d) {
if (d = d || this.getSelectionCells(), null != d && 0 < d.length) {
if (null == c) {
var e = this.view.getState(d[0]), e = null != e ? e.style :this.getCellStyle(d[0]);
null != e && (c = (parseInt(e[a] || 0) & b) != b);
}
mxUtils.setCellStyleFlags(this.model, d, a, b, c);
}
}, mxGraph.prototype.alignCells = function(a, b, c) {
if (null == b && (b = this.getSelectionCells()), null != b && 1 < b.length) {
if (null == c) for (var d = 0; d < b.length; d++) {
var e = this.getCellGeometry(b[d]);
if (null != e && !this.model.isEdge(b[d])) if (null == c) {
if (a == mxConstants.ALIGN_CENTER) {
c = e.x + e.width / 2;
break;
}
if (a == mxConstants.ALIGN_RIGHT) c = e.x + e.width; else if (a == mxConstants.ALIGN_TOP) c = e.y; else {
if (a == mxConstants.ALIGN_MIDDLE) {
c = e.y + e.height / 2;
break;
}
c = a == mxConstants.ALIGN_BOTTOM ? e.y + e.height :e.x;
}
} else c = a == mxConstants.ALIGN_RIGHT ? Math.max(c, e.x + e.width) :a == mxConstants.ALIGN_TOP ? Math.min(c, e.y) :a == mxConstants.ALIGN_BOTTOM ? Math.max(c, e.y + e.height) :Math.min(c, e.x);
}
if (null != c) {
this.model.beginUpdate();
try {
for (d = 0; d < b.length; d++) e = this.getCellGeometry(b[d]), null != e && !this.model.isEdge(b[d]) && (e = e.clone(), 
a == mxConstants.ALIGN_CENTER ? e.x = c - e.width / 2 :a == mxConstants.ALIGN_RIGHT ? e.x = c - e.width :a == mxConstants.ALIGN_TOP ? e.y = c :a == mxConstants.ALIGN_MIDDLE ? e.y = c - e.height / 2 :a == mxConstants.ALIGN_BOTTOM ? e.y = c - e.height :e.x = c, 
this.model.setGeometry(b[d], e));
this.fireEvent(new mxEventObject(mxEvent.ALIGN_CELLS, "align", a, "cells", b));
} finally {
this.model.endUpdate();
}
}
}
return b;
}, mxGraph.prototype.flipEdge = function(a) {
if (null != a && null != this.alternateEdgeStyle) {
this.model.beginUpdate();
try {
var b = this.model.getStyle(a);
null == b || 0 == b.length ? this.model.setStyle(a, this.alternateEdgeStyle) :this.model.setStyle(a, null), 
this.resetEdge(a), this.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, "edge", a));
} finally {
this.model.endUpdate();
}
}
return a;
}, mxGraph.prototype.addImageBundle = function(a) {
this.imageBundles.push(a);
}, mxGraph.prototype.removeImageBundle = function(a) {
for (var b = [], c = 0; c < this.imageBundles.length; c++) this.imageBundles[c] != a && b.push(this.imageBundles[c]);
this.imageBundles = b;
}, mxGraph.prototype.getImageFromBundles = function(a) {
if (null != a) for (var b = 0; b < this.imageBundles.length; b++) {
var c = this.imageBundles[b].getImage(a);
if (null != c) return c;
}
return null;
}, mxGraph.prototype.orderCells = function(a, b) {
null == b && (b = mxUtils.sortCells(this.getSelectionCells(), !0)), this.model.beginUpdate();
try {
this.cellsOrdered(b, a), this.fireEvent(new mxEventObject(mxEvent.ORDER_CELLS, "back", a, "cells", b));
} finally {
this.model.endUpdate();
}
return b;
}, mxGraph.prototype.cellsOrdered = function(a, b) {
if (null != a) {
this.model.beginUpdate();
try {
for (var c = 0; c < a.length; c++) {
var d = this.model.getParent(a[c]);
b ? this.model.add(d, a[c], c) :this.model.add(d, a[c], this.model.getChildCount(d) - 1);
}
this.fireEvent(new mxEventObject(mxEvent.CELLS_ORDERED, "back", b, "cells", a));
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.groupCells = function(a, b, c) {
null == c && (c = mxUtils.sortCells(this.getSelectionCells(), !0)), c = this.getCellsForGroup(c), 
null == a && (a = this.createGroupCell(c));
var d = this.getBoundsForGroup(a, c, b);
if (0 < c.length && null != d) {
var e = this.model.getParent(a);
null == e && (e = this.model.getParent(c[0])), this.model.beginUpdate();
try {
null == this.getCellGeometry(a) && this.model.setGeometry(a, new mxGeometry());
var f = this.model.getChildCount(e);
this.cellsAdded([ a ], e, f, null, null, !1), f = this.model.getChildCount(a), this.cellsAdded(c, a, f, null, null, !1, !1), 
this.cellsMoved(c, -d.x, -d.y, !1, !0), this.cellsResized([ a ], [ d ]), this.fireEvent(new mxEventObject(mxEvent.GROUP_CELLS, "group", a, "border", b, "cells", c));
} finally {
this.model.endUpdate();
}
}
return a;
}, mxGraph.prototype.getCellsForGroup = function(a) {
var b = [];
if (null != a && 0 < a.length) {
var c = this.model.getParent(a[0]);
b.push(a[0]);
for (var d = 1; d < a.length; d++) this.model.getParent(a[d]) == c && b.push(a[d]);
}
return b;
}, mxGraph.prototype.getBoundsForGroup = function(a, b, c) {
return b = this.getBoundingBoxFromGeometry(b), null != b && (this.isSwimlane(a) && (a = this.getStartSize(a), 
b.x -= a.width, b.y -= a.height, b.width += a.width, b.height += a.height), b.x -= c, 
b.y -= c, b.width += 2 * c, b.height += 2 * c), b;
}, mxGraph.prototype.createGroupCell = function(a) {
return a = new mxCell(""), a.setVertex(!0), a.setConnectable(!1), a;
}, mxGraph.prototype.ungroupCells = function(a) {
var b = [];
if (null == a) {
a = this.getSelectionCells();
for (var c = [], d = 0; d < a.length; d++) 0 < this.model.getChildCount(a[d]) && c.push(a[d]);
a = c;
}
if (null != a && 0 < a.length) {
this.model.beginUpdate();
try {
for (d = 0; d < a.length; d++) {
var e = this.model.getChildren(a[d]);
if (null != e && 0 < e.length) {
var e = e.slice(), f = this.model.getParent(a[d]), g = this.model.getChildCount(f);
this.cellsAdded(e, f, g, null, null, !0), b = b.concat(e);
}
}
this.cellsRemoved(this.addAllEdges(a)), this.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, "cells", a));
} finally {
this.model.endUpdate();
}
}
return b;
}, mxGraph.prototype.removeCellsFromParent = function(a) {
null == a && (a = this.getSelectionCells()), this.model.beginUpdate();
try {
var b = this.getDefaultParent(), c = this.model.getChildCount(b);
this.cellsAdded(a, b, c, null, null, !0), this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, "cells", a));
} finally {
this.model.endUpdate();
}
return a;
}, mxGraph.prototype.updateGroupBounds = function(a, b, c) {
null == a && (a = this.getSelectionCells()), b = null != b ? b :0, c = null != c ? c :!1, 
this.model.beginUpdate();
try {
for (var d = 0; d < a.length; d++) {
var e = this.getCellGeometry(a[d]);
if (null != e) {
var f = this.getChildCells(a[d]);
if (null != f && 0 < f.length) {
var g = this.getBoundingBoxFromGeometry(f);
if (0 < g.width && 0 < g.height) {
var h = this.isSwimlane(a[d]) ? this.getStartSize(a[d]) :new mxRectangle(), e = e.clone();
c && (e.x += g.x - h.width - b, e.y += g.y - h.height - b), e.width = g.width + h.width + 2 * b, 
e.height = g.height + h.height + 2 * b, this.model.setGeometry(a[d], e), this.moveCells(f, -g.x + h.width + b, -g.y + h.height + b);
}
}
}
}
} finally {
this.model.endUpdate();
}
return a;
}, mxGraph.prototype.cloneCells = function(a, b) {
b = null != b ? b :!0;
var c = null;
if (null != a) {
for (var d = {}, c = [], e = 0; e < a.length; e++) {
var f = mxCellPath.create(a[e]);
d[f] = a[e], c.push(a[e]);
}
if (0 < c.length) for (var f = this.view.scale, g = this.view.translate, c = this.model.cloneCells(a, !0), e = 0; e < a.length; e++) if (!b && this.model.isEdge(c[e]) && null != this.getEdgeValidationError(c[e], this.model.getTerminal(c[e], !0), this.model.getTerminal(c[e], !1))) c[e] = null; else {
var h = this.model.getGeometry(c[e]);
if (null != h) {
var k = this.view.getState(a[e]), l = this.view.getState(this.model.getParent(a[e]));
if (null != k && null != l) {
var m = l.origin.x, l = l.origin.y;
if (this.model.isEdge(c[e])) {
for (var k = k.absolutePoints, n = this.model.getTerminal(a[e], !0), p = mxCellPath.create(n); null != n && null == d[p]; ) n = this.model.getParent(n), 
p = mxCellPath.create(n);
for (null == n && h.setTerminalPoint(new mxPoint(k[0].x / f - g.x, k[0].y / f - g.y), !0), 
n = this.model.getTerminal(a[e], !1), p = mxCellPath.create(n); null != n && null == d[p]; ) n = this.model.getParent(n), 
p = mxCellPath.create(n);
if (null == n && (n = k.length - 1, h.setTerminalPoint(new mxPoint(k[n].x / f - g.x, k[n].y / f - g.y), !1)), 
h = h.points, null != h) for (k = 0; k < h.length; k++) h[k].x += m, h[k].y += l;
} else h.x += m, h.y += l;
}
}
} else c = [];
}
return c;
}, mxGraph.prototype.insertVertex = function(a, b, c, d, e, f, g, h, k) {
return b = this.createVertex(a, b, c, d, e, f, g, h, k), this.addCell(b, a);
}, mxGraph.prototype.createVertex = function(a, b, c, d, e, f, g, h, k) {
return a = new mxGeometry(d, e, f, g), a.relative = null != k ? k :!1, c = new mxCell(c, a, h), 
c.setId(b), c.setVertex(!0), c.setConnectable(!0), c;
}, mxGraph.prototype.insertEdge = function(a, b, c, d, e, f) {
return b = this.createEdge(a, b, c, d, e, f), this.addEdge(b, a, d, e);
}, mxGraph.prototype.createEdge = function(a, b, c, d, e, f) {
return a = new mxCell(c, new mxGeometry(), f), a.setId(b), a.setEdge(!0), a.geometry.relative = !0, 
a;
}, mxGraph.prototype.addEdge = function(a, b, c, d, e) {
return this.addCell(a, b, e, c, d);
}, mxGraph.prototype.addCell = function(a, b, c, d, e) {
return this.addCells([ a ], b, c, d, e)[0];
}, mxGraph.prototype.addCells = function(a, b, c, d, e) {
null == b && (b = this.getDefaultParent()), null == c && (c = this.model.getChildCount(b)), 
this.model.beginUpdate();
try {
this.cellsAdded(a, b, c, d, e, !1, !0), this.fireEvent(new mxEventObject(mxEvent.ADD_CELLS, "cells", a, "parent", b, "index", c, "source", d, "target", e));
} finally {
this.model.endUpdate();
}
return a;
}, mxGraph.prototype.cellsAdded = function(a, b, c, d, e, f, g) {
if (null != a && null != b && null != c) {
this.model.beginUpdate();
try {
for (var h = f ? this.view.getState(b) :null, k = null != h ? h.origin :null, l = new mxPoint(0, 0), h = 0; h < a.length; h++) if (null == a[h]) c--; else {
var m = this.model.getParent(a[h]);
if (null != k && a[h] != b && b != m) {
var n = this.view.getState(m), p = null != n ? n.origin :l, q = this.model.getGeometry(a[h]);
if (null != q) {
var s = p.x - k.x, r = p.y - k.y, q = q.clone();
q.translate(s, r), !q.relative && this.model.isVertex(a[h]) && !this.isAllowNegativeCoordinates() && (q.x = Math.max(0, q.x), 
q.y = Math.max(0, q.y)), this.model.setGeometry(a[h], q);
}
}
b == m && c + h > this.model.getChildCount(b) && c--, this.model.add(b, a[h], c + h), 
this.isExtendParentsOnAdd() && this.isExtendParent(a[h]) && this.extendParent(a[h]), 
(null == g || g) && this.constrainChild(a[h]), null != d && this.cellConnected(a[h], d, !0), 
null != e && this.cellConnected(a[h], e, !1);
}
this.fireEvent(new mxEventObject(mxEvent.CELLS_ADDED, "cells", a, "parent", b, "index", c, "source", d, "target", e, "absolute", f));
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.removeCells = function(a, b) {
b = null != b ? b :!0, null == a && (a = this.getDeletableCells(this.getSelectionCells())), 
b && (a = this.getDeletableCells(this.addAllEdges(a))), this.model.beginUpdate();
try {
this.cellsRemoved(a), this.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS, "cells", a, "includeEdges", b));
} finally {
this.model.endUpdate();
}
return a;
}, mxGraph.prototype.cellsRemoved = function(a) {
if (null != a && 0 < a.length) {
var b = this.view.scale, c = this.view.translate;
this.model.beginUpdate();
try {
for (var d = {}, e = 0; e < a.length; e++) {
var f = mxCellPath.create(a[e]);
d[f] = a[e];
}
for (e = 0; e < a.length; e++) {
for (var g = this.getConnections(a[e]), h = 0; h < g.length; h++) if (f = mxCellPath.create(g[h]), 
null == d[f]) {
var k = this.model.getGeometry(g[h]);
if (null != k) {
var l = this.view.getState(g[h]);
if (null != l) {
var k = k.clone(), m = l.getVisibleTerminal(!0) == a[e], n = l.absolutePoints, p = m ? 0 :n.length - 1;
k.setTerminalPoint(new mxPoint(n[p].x / b - c.x, n[p].y / b - c.y), m), this.model.setTerminal(g[h], null, m), 
this.model.setGeometry(g[h], k);
}
}
}
this.model.remove(a[e]);
}
this.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, "cells", a));
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.splitEdge = function(a, b, c, d, e) {
d = d || 0, e = e || 0, null == c && (c = this.cloneCells([ a ])[0]);
var f = this.model.getParent(a), g = this.model.getTerminal(a, !0);
this.model.beginUpdate();
try {
this.cellsMoved(b, d, e, !1, !1), this.cellsAdded(b, f, this.model.getChildCount(f), null, null, !0), 
this.cellsAdded([ c ], f, this.model.getChildCount(f), g, b[0], !1), this.cellConnected(a, b[0], !0), 
this.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, "edge", a, "cells", b, "newEdge", c, "dx", d, "dy", e));
} finally {
this.model.endUpdate();
}
return c;
}, mxGraph.prototype.toggleCells = function(a, b, c) {
null == b && (b = this.getSelectionCells()), c && (b = this.addAllEdges(b)), this.model.beginUpdate();
try {
this.cellsToggled(b, a), this.fireEvent(new mxEventObject(mxEvent.TOGGLE_CELLS, "show", a, "cells", b, "includeEdges", c));
} finally {
this.model.endUpdate();
}
return b;
}, mxGraph.prototype.cellsToggled = function(a, b) {
if (null != a && 0 < a.length) {
this.model.beginUpdate();
try {
for (var c = 0; c < a.length; c++) this.model.setVisible(a[c], b);
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.foldCells = function(a, b, c, d) {
b = null != b ? b :!1, null == c && (c = this.getFoldableCells(this.getSelectionCells(), a)), 
this.stopEditing(!1), this.model.beginUpdate();
try {
this.cellsFolded(c, a, b, d), this.fireEvent(new mxEventObject(mxEvent.FOLD_CELLS, "collapse", a, "recurse", b, "cells", c));
} finally {
this.model.endUpdate();
}
return c;
}, mxGraph.prototype.cellsFolded = function(a, b, c, d) {
if (null != a && 0 < a.length) {
this.model.beginUpdate();
try {
for (var e = 0; e < a.length; e++) if ((!d || this.isCellFoldable(a[e], b)) && b != this.isCellCollapsed(a[e]) && (this.model.setCollapsed(a[e], b), 
this.swapBounds(a[e], b), this.isExtendParent(a[e]) && this.extendParent(a[e]), 
c)) {
var f = this.model.getChildren(a[e]);
this.foldCells(f, b, c);
}
this.fireEvent(new mxEventObject(mxEvent.CELLS_FOLDED, "cells", a, "collapse", b, "recurse", c));
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.swapBounds = function(a, b) {
if (null != a) {
var c = this.model.getGeometry(a);
null != c && (c = c.clone(), this.updateAlternateBounds(a, c, b), c.swap(), this.model.setGeometry(a, c));
}
}, mxGraph.prototype.updateAlternateBounds = function(a, b, c) {
if (null != a && null != b) {
if (c = this.view.getState(a), c = null != c ? c.style :this.getCellStyle(a), null == b.alternateBounds) {
var d = b;
this.collapseToPreferredSize && (a = this.getPreferredSizeForCell(a), null != a && (d = a, 
a = mxUtils.getValue(c, mxConstants.STYLE_STARTSIZE), a > 0 && (d.height = Math.max(d.height, a)))), 
b.alternateBounds = new mxRectangle(0, 0, d.width, d.height);
}
if (null != b.alternateBounds) {
b.alternateBounds.x = b.x, b.alternateBounds.y = b.y;
var e = mxUtils.toRadians(c[mxConstants.STYLE_ROTATION] || "0");
0 != e && (a = b.alternateBounds.getCenterX() - b.getCenterX(), c = b.alternateBounds.getCenterY() - b.getCenterY(), 
d = Math.cos(e), e = Math.sin(e), b.alternateBounds.x += d * a - e * c - a, b.alternateBounds.y += e * a + d * c - c);
}
}
}, mxGraph.prototype.addAllEdges = function(a) {
var b = a.slice();
return b = b.concat(this.getAllEdges(a));
}, mxGraph.prototype.getAllEdges = function(a) {
var b = [];
if (null != a) for (var c = 0; c < a.length; c++) {
for (var d = this.model.getEdgeCount(a[c]), e = 0; d > e; e++) b.push(this.model.getEdgeAt(a[c], e));
d = this.model.getChildren(a[c]), b = b.concat(this.getAllEdges(d));
}
return b;
}, mxGraph.prototype.updateCellSize = function(a, b) {
b = null != b ? b :!1, this.model.beginUpdate();
try {
this.cellSizeUpdated(a, b), this.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE, "cell", a, "ignoreChildren", b));
} finally {
this.model.endUpdate();
}
return a;
}, mxGraph.prototype.cellSizeUpdated = function(a, b) {
if (null != a) {
this.model.beginUpdate();
try {
var c = this.getPreferredSizeForCell(a), d = this.model.getGeometry(a);
if (null != c && null != d) {
var e = this.isCellCollapsed(a), d = d.clone();
if (this.isSwimlane(a)) {
var f = this.view.getState(a), g = null != f ? f.style :this.getCellStyle(a), h = this.model.getStyle(a);
null == h && (h = ""), mxUtils.getValue(g, mxConstants.STYLE_HORIZONTAL, !0) ? (h = mxUtils.setStyle(h, mxConstants.STYLE_STARTSIZE, c.height + 8), 
e && (d.height = c.height + 8), d.width = c.width) :(h = mxUtils.setStyle(h, mxConstants.STYLE_STARTSIZE, c.width + 8), 
e && (d.width = c.width + 8), d.height = c.height), this.model.setStyle(a, h);
} else d.width = c.width, d.height = c.height;
if (!b && !e) {
var k = this.view.getBounds(this.model.getChildren(a));
if (null != k) {
var l = this.view.translate, m = this.view.scale, n = (k.y + k.height) / m - d.y - l.y;
d.width = Math.max(d.width, (k.x + k.width) / m - d.x - l.x), d.height = Math.max(d.height, n);
}
}
this.cellsResized([ a ], [ d ]);
}
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.getPreferredSizeForCell = function(a) {
var b = null;
if (null != a) {
var c = this.view.getState(a), d = null != c ? c.style :this.getCellStyle(a);
if (null != d && !this.model.isEdge(a)) {
var e = d[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE, f = 0, b = 0;
null == this.getImage(c) && null == d[mxConstants.STYLE_IMAGE] || d[mxConstants.STYLE_SHAPE] != mxConstants.SHAPE_LABEL || (d[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE && (f += parseFloat(d[mxConstants.STYLE_IMAGE_WIDTH]) || mxLabel.prototype.imageSize), 
d[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER && (b += parseFloat(d[mxConstants.STYLE_IMAGE_HEIGHT]) || mxLabel.prototype.imageSize)), 
f += 2 * (d[mxConstants.STYLE_SPACING] || 0), f += d[mxConstants.STYLE_SPACING_LEFT] || 0, 
f += d[mxConstants.STYLE_SPACING_RIGHT] || 0, b += 2 * (d[mxConstants.STYLE_SPACING] || 0), 
b += d[mxConstants.STYLE_SPACING_TOP] || 0, b += d[mxConstants.STYLE_SPACING_BOTTOM] || 0, 
c = this.getFoldingImage(c), null != c && (f += c.width + 8), c = this.getLabel(a), 
null != c && 0 < c.length ? (this.isHtmlLabel(a) || (c = c.replace(/\n/g, "<br>")), 
e = mxUtils.getSizeForString(c, e, d[mxConstants.STYLE_FONTFAMILY]), a = e.width + f, 
b = e.height + b, mxUtils.getValue(d, mxConstants.STYLE_HORIZONTAL, !0) || (d = b, 
b = a, a = d), this.gridEnabled && (a = this.snap(a + this.gridSize / 2), b = this.snap(b + this.gridSize / 2)), 
b = new mxRectangle(0, 0, a, b)) :(d = 4 * this.gridSize, b = new mxRectangle(0, 0, d, d));
}
}
return b;
}, mxGraph.prototype.handleGesture = function(a, b) {
if (this.isEnabled() && this.isCellResizable(a.cell) && .2 < Math.abs(1 - b.scale)) {
var c = this.view.scale, d = this.view.translate, e = a.width * b.scale, f = a.height * b.scale, g = a.y - (f - a.height) / 2, c = new mxRectangle(this.snap((a.x - (e - a.width) / 2) / c) - d.x, this.snap(g / c) - d.y, this.snap(e / c), this.snap(f / c));
this.resizeCell(a.cell, c);
}
}, mxGraph.prototype.resizeCell = function(a, b) {
return this.resizeCells([ a ], [ b ])[0];
}, mxGraph.prototype.resizeCells = function(a, b) {
this.model.beginUpdate();
try {
this.cellsResized(a, b), this.fireEvent(new mxEventObject(mxEvent.RESIZE_CELLS, "cells", a, "bounds", b));
} finally {
this.model.endUpdate();
}
return a;
}, mxGraph.prototype.cellsResized = function(a, b) {
if (null != a && null != b && a.length == b.length) {
this.model.beginUpdate();
try {
for (var c = 0; c < a.length; c++) {
var d = b[c], e = this.model.getGeometry(a[c]);
if (null != e && (e.x != d.x || e.y != d.y || e.width != d.width || e.height != d.height)) {
if (e = e.clone(), e.relative) {
var f = e.offset;
null != f && (f.x += d.x - e.x, f.y += d.y - e.y);
} else e.x = d.x, e.y = d.y;
e.width = d.width, e.height = d.height, !e.relative && this.model.isVertex(a[c]) && !this.isAllowNegativeCoordinates() && (e.x = Math.max(0, e.x), 
e.y = Math.max(0, e.y)), this.model.setGeometry(a[c], e), this.isExtendParent(a[c]) && this.extendParent(a[c]);
}
}
this.resetEdgesOnResize && this.resetEdges(a), this.fireEvent(new mxEventObject(mxEvent.CELLS_RESIZED, "cells", a, "bounds", b));
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.extendParent = function(a) {
if (null != a) {
var b = this.model.getParent(a), c = this.model.getGeometry(b);
null != b && null != c && !this.isCellCollapsed(b) && (a = this.model.getGeometry(a), 
null != a && (c.width < a.x + a.width || c.height < a.y + a.height)) && (c = c.clone(), 
c.width = Math.max(c.width, a.x + a.width), c.height = Math.max(c.height, a.y + a.height), 
this.cellsResized([ b ], [ c ]));
}
}, mxGraph.prototype.importCells = function(a, b, c, d, e) {
return this.moveCells(a, b, c, !0, d, e);
}, mxGraph.prototype.moveCells = function(a, b, c, d, e, f) {
if (b = null != b ? b :0, c = null != c ? c :0, d = null != d ? d :!1, null != a && (0 != b || 0 != c || d || null != e)) {
this.model.beginUpdate();
try {
d && (a = this.cloneCells(a, this.isCloneInvalidEdges()), null == e && (e = this.getDefaultParent()));
var g = this.isAllowNegativeCoordinates();
if (null != e && this.setAllowNegativeCoordinates(!0), this.cellsMoved(a, b, c, !d && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), null == e), 
this.setAllowNegativeCoordinates(g), null != e) {
var h = this.model.getChildCount(e);
this.cellsAdded(a, e, h, null, null, !0);
}
this.fireEvent(new mxEventObject(mxEvent.MOVE_CELLS, "cells", a, "dx", b, "dy", c, "clone", d, "target", e, "event", f));
} finally {
this.model.endUpdate();
}
}
return a;
}, mxGraph.prototype.cellsMoved = function(a, b, c, d, e) {
if (null != a && (0 != b || 0 != c)) {
this.model.beginUpdate();
try {
d && this.disconnectGraph(a);
for (var f = 0; f < a.length; f++) this.translateCell(a[f], b, c), e && this.constrainChild(a[f]);
this.resetEdgesOnMove && this.resetEdges(a), this.fireEvent(new mxEventObject(mxEvent.CELLS_MOVED, "cells", a, "dx", c, "dy", c, "disconnect", d));
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.translateCell = function(a, b, c) {
var d = this.model.getGeometry(a);
null != d && (d = d.clone(), d.translate(b, c), !d.relative && this.model.isVertex(a) && !this.isAllowNegativeCoordinates() && (d.x = Math.max(0, d.x), 
d.y = Math.max(0, d.y)), d.relative && !this.model.isEdge(a) && (null == d.offset ? d.offset = new mxPoint(b, c) :(d.offset.x += b, 
d.offset.y += c)), this.model.setGeometry(a, d));
}, mxGraph.prototype.getCellContainmentArea = function(a) {
if (null != a && !this.model.isEdge(a)) {
var b = this.model.getParent(a);
if (b == this.getDefaultParent() || b == this.getCurrentRoot()) return this.getMaximumGraphBounds();
if (null != b && b != this.getDefaultParent()) {
var c = this.model.getGeometry(b);
if (null != c) {
var d = a = 0, e = c.width, c = c.height;
return this.isSwimlane(b) && (b = this.getStartSize(b), a = b.width, e -= b.width, 
d = b.height, c -= b.height), new mxRectangle(a, d, e, c);
}
}
}
return null;
}, mxGraph.prototype.getMaximumGraphBounds = function() {
return this.maximumGraphBounds;
}, mxGraph.prototype.constrainChild = function(a) {
if (null != a) {
var b = this.model.getGeometry(a), c = this.isConstrainChild(a) ? this.getCellContainmentArea(a) :this.getMaximumGraphBounds();
null != b && null != c && !b.relative && (b.x < c.x || b.y < c.y || c.width < b.x + b.width || c.height < b.y + b.height) && (a = this.getOverlap(a), 
0 < c.width && (b.x = Math.min(b.x, c.x + c.width - (1 - a) * b.width)), 0 < c.height && (b.y = Math.min(b.y, c.y + c.height - (1 - a) * b.height)), 
b.x = Math.max(b.x, c.x - b.width * a), b.y = Math.max(b.y, c.y - b.height * a));
}
}, mxGraph.prototype.resetEdges = function(a) {
if (null != a) {
for (var b = {}, c = 0; c < a.length; c++) {
var d = mxCellPath.create(a[c]);
b[d] = a[c];
}
this.model.beginUpdate();
try {
for (c = 0; c < a.length; c++) {
var e = this.model.getEdges(a[c]);
if (null != e) for (d = 0; d < e.length; d++) {
var f = this.view.getState(e[d]), g = null != f ? f.getVisibleTerminal(!0) :this.view.getVisibleTerminal(e[d], !0), h = null != f ? f.getVisibleTerminal(!1) :this.view.getVisibleTerminal(e[d], !1), k = mxCellPath.create(g), l = mxCellPath.create(h);
(null == b[k] || null == b[l]) && this.resetEdge(e[d]);
}
this.resetEdges(this.model.getChildren(a[c]));
}
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.resetEdge = function(a) {
var b = this.model.getGeometry(a);
return null != b && null != b.points && 0 < b.points.length && (b = b.clone(), b.points = [], 
this.model.setGeometry(a, b)), a;
}, mxGraph.prototype.getAllConnectionConstraints = function(a) {
return null != a && null != a.shape && null != a.shape.stencil ? a.shape.stencil.constraints :null;
}, mxGraph.prototype.getConnectionConstraint = function(a, b, c) {
b = null;
var d = a.style[c ? mxConstants.STYLE_EXIT_X :mxConstants.STYLE_ENTRY_X];
if (null != d) {
var e = a.style[c ? mxConstants.STYLE_EXIT_Y :mxConstants.STYLE_ENTRY_Y];
null != e && (b = new mxPoint(parseFloat(d), parseFloat(e)));
}
return d = !1, null != b && (d = mxUtils.getValue(a.style, c ? mxConstants.STYLE_EXIT_PERIMETER :mxConstants.STYLE_ENTRY_PERIMETER, !0)), 
new mxConnectionConstraint(b, d);
}, mxGraph.prototype.setConnectionConstraint = function(a, b, c, d) {
if (null != d) {
this.model.beginUpdate();
try {
null == d || null == d.point ? (this.setCellStyles(c ? mxConstants.STYLE_EXIT_X :mxConstants.STYLE_ENTRY_X, null, [ a ]), 
this.setCellStyles(c ? mxConstants.STYLE_EXIT_Y :mxConstants.STYLE_ENTRY_Y, null, [ a ]), 
this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER :mxConstants.STYLE_ENTRY_PERIMETER, null, [ a ])) :null != d.point && (this.setCellStyles(c ? mxConstants.STYLE_EXIT_X :mxConstants.STYLE_ENTRY_X, d.point.x, [ a ]), 
this.setCellStyles(c ? mxConstants.STYLE_EXIT_Y :mxConstants.STYLE_ENTRY_Y, d.point.y, [ a ]), 
d.perimeter ? this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER :mxConstants.STYLE_ENTRY_PERIMETER, null, [ a ]) :this.setCellStyles(c ? mxConstants.STYLE_EXIT_PERIMETER :mxConstants.STYLE_ENTRY_PERIMETER, "0", [ a ]));
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.getConnectionPoint = function(a, b) {
var c = null;
if (null != a) {
var d = this.view.getPerimeterBounds(a), e = new mxPoint(d.getCenterX(), d.getCenterY()), f = a.style[mxConstants.STYLE_DIRECTION], g = 0;
if (null != f && ("north" == f ? g += 270 :"west" == f ? g += 180 :"south" == f && (g += 90), 
"north" == f || "south" == f)) {
d.x += d.width / 2 - d.height / 2, d.y += d.height / 2 - d.width / 2;
var h = d.width;
d.width = d.height, d.height = h;
}
if (null != b.point) {
var k = c = 1, l = 0, m = 0;
if (this.getModel().isVertex(a.cell)) {
var n = a.style[mxConstants.STYLE_FLIPH], p = a.style[mxConstants.STYLE_FLIPV];
null != a.shape.stencil && (n = 1 == mxUtils.getValue(a.style, "stencilFlipH", 0) || n, 
p = 1 == mxUtils.getValue(a.style, "stencilFlipV", 0) || p), ("north" == f || "south" == f) && (h = n, 
n = p, p = h), n && (c = -1, l = -d.width), p && (k = -1, m = -d.height);
}
c = new mxPoint(d.x + b.point.x * d.width * c - l, d.y + b.point.y * d.height * k - m);
}
f = a.style[mxConstants.STYLE_ROTATION] || 0, b.perimeter ? (0 != g && null != c && (h = d = 0, 
90 == g ? h = 1 :180 == g ? d = -1 :270 == f && (h = -1), c = mxUtils.getRotatedPoint(c, d, h, e)), 
null != c && b.perimeter && (c = this.view.getPerimeterPoint(a, c, !1))) :f += g, 
0 != f && null != c && (g = mxUtils.toRadians(f), d = Math.cos(g), h = Math.sin(g), 
c = mxUtils.getRotatedPoint(c, d, h, e));
}
return c;
}, mxGraph.prototype.connectCell = function(a, b, c, d) {
this.model.beginUpdate();
try {
var e = this.model.getTerminal(a, c);
this.cellConnected(a, b, c, d), this.fireEvent(new mxEventObject(mxEvent.CONNECT_CELL, "edge", a, "terminal", b, "source", c, "previous", e));
} finally {
this.model.endUpdate();
}
return a;
}, mxGraph.prototype.cellConnected = function(a, b, c, d) {
if (null != a) {
this.model.beginUpdate();
try {
var e = this.model.getTerminal(a, c);
this.setConnectionConstraint(a, b, c, d), this.isPortsEnabled() && (d = null, this.isPort(b) && (d = b.getId(), 
b = this.getTerminalForPort(b, c)), this.setCellStyles(c ? mxConstants.STYLE_SOURCE_PORT :mxConstants.STYLE_TARGET_PORT, d, [ a ])), 
this.model.setTerminal(a, b, c), this.resetEdgesOnConnect && this.resetEdge(a), 
this.fireEvent(new mxEventObject(mxEvent.CELL_CONNECTED, "edge", a, "terminal", b, "source", c, "previous", e));
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.disconnectGraph = function(a) {
if (null != a) {
this.model.beginUpdate();
try {
for (var b = this.view.scale, c = this.view.translate, d = {}, e = 0; e < a.length; e++) {
var f = mxCellPath.create(a[e]);
d[f] = a[e];
}
for (e = 0; e < a.length; e++) if (this.model.isEdge(a[e])) {
var g = this.model.getGeometry(a[e]);
if (null != g) {
var h = this.view.getState(a[e]), k = this.view.getState(this.model.getParent(a[e]));
if (null != h && null != k) {
var g = g.clone(), l = -k.origin.x, m = -k.origin.y, n = h.absolutePoints, p = this.model.getTerminal(a[e], !0);
if (null != p && this.isCellDisconnectable(a[e], p, !0)) {
for (var q = mxCellPath.create(p); null != p && null == d[q]; ) p = this.model.getParent(p), 
q = mxCellPath.create(p);
null == p && (g.setTerminalPoint(new mxPoint(n[0].x / b - c.x + l, n[0].y / b - c.y + m), !0), 
this.model.setTerminal(a[e], null, !0));
}
var s = this.model.getTerminal(a[e], !1);
if (null != s && this.isCellDisconnectable(a[e], s, !1)) {
for (var r = mxCellPath.create(s); null != s && null == d[r]; ) s = this.model.getParent(s), 
r = mxCellPath.create(s);
if (null == s) {
var t = n.length - 1;
g.setTerminalPoint(new mxPoint(n[t].x / b - c.x + l, n[t].y / b - c.y + m), !1), 
this.model.setTerminal(a[e], null, !1);
}
}
this.model.setGeometry(a[e], g);
}
}
}
} finally {
this.model.endUpdate();
}
}
}, mxGraph.prototype.getCurrentRoot = function() {
return this.view.currentRoot;
}, mxGraph.prototype.getTranslateForRoot = function() {
return null;
}, mxGraph.prototype.isPort = function() {
return !1;
}, mxGraph.prototype.getTerminalForPort = function(a) {
return this.model.getParent(a);
}, mxGraph.prototype.getChildOffsetForCell = function() {
return null;
}, mxGraph.prototype.enterGroup = function(a) {
a = a || this.getSelectionCell(), null != a && this.isValidRoot(a) && (this.view.setCurrentRoot(a), 
this.clearSelection());
}, mxGraph.prototype.exitGroup = function() {
var a = this.model.getRoot(), b = this.getCurrentRoot();
if (null != b) {
for (var c = this.model.getParent(b); c != a && !this.isValidRoot(c) && this.model.getParent(c) != a; ) c = this.model.getParent(c);
c == a || this.model.getParent(c) == a ? this.view.setCurrentRoot(null) :this.view.setCurrentRoot(c), 
null != this.view.getState(b) && this.setSelectionCell(b);
}
}, mxGraph.prototype.home = function() {
var a = this.getCurrentRoot();
null != a && (this.view.setCurrentRoot(null), null != this.view.getState(a) && this.setSelectionCell(a));
}, mxGraph.prototype.isValidRoot = function(a) {
return null != a;
}, mxGraph.prototype.getGraphBounds = function() {
return this.view.getGraphBounds();
}, mxGraph.prototype.getCellBounds = function(a, b, c) {
var d = [ a ];
if (b && (d = d.concat(this.model.getEdges(a))), d = this.view.getBounds(d), c) {
c = this.model.getChildCount(a);
for (var e = 0; c > e; e++) {
var f = this.getCellBounds(this.model.getChildAt(a, e), b, !0);
null != d ? d.add(f) :d = f;
}
}
return d;
}, mxGraph.prototype.getBoundingBoxFromGeometry = function(a, b) {
b = null != b ? b :!1;
var c = null;
if (null != a) for (var d = 0; d < a.length; d++) if (b || this.model.isVertex(a[d])) {
var e = this.getCellGeometry(a[d]);
if (null != e) {
var f = e.points;
if (null != f && 0 < f.length) {
for (var g = new mxRectangle(f[0].x, f[0].y, 0, 0), h = function(a) {
null != a && g.add(new mxRectangle(a.x, a.y, 0, 0));
}, k = 1; k < f.length; k++) h(f[k]);
h(e.getTerminalPoint(!0)), h(e.getTerminalPoint(!1));
}
null == c ? c = new mxRectangle(e.x, e.y, e.width, e.height) :c.add(e);
}
}
return c;
}, mxGraph.prototype.refresh = function(a) {
this.view.clear(a, null == a), this.view.validate(), this.sizeDidChange(), this.fireEvent(new mxEventObject(mxEvent.REFRESH));
}, mxGraph.prototype.snap = function(a) {
return this.gridEnabled && (a = Math.round(a / this.gridSize) * this.gridSize), 
a;
}, mxGraph.prototype.panGraph = function(a, b) {
if (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container)) this.container.scrollLeft = -a, 
this.container.scrollTop = -b; else {
var c = this.view.getCanvas();
if (this.dialect == mxConstants.DIALECT_SVG) if (0 == a && 0 == b) {
if (mxClient.IS_IE ? c.setAttribute("transform", "translate(" + a + "," + b + ")") :c.removeAttribute("transform"), 
null != this.shiftPreview1) {
for (var d = this.shiftPreview1.firstChild; null != d; ) {
var e = d.nextSibling;
this.container.appendChild(d), d = e;
}
for (this.shiftPreview1.parentNode.removeChild(this.shiftPreview1), this.shiftPreview1 = null, 
this.container.appendChild(c.parentNode), d = this.shiftPreview2.firstChild; null != d; ) e = d.nextSibling, 
this.container.appendChild(d), d = e;
this.shiftPreview2.parentNode.removeChild(this.shiftPreview2), this.shiftPreview2 = null;
}
} else {
if (c.setAttribute("transform", "translate(" + a + "," + b + ")"), null == this.shiftPreview1) {
this.shiftPreview1 = document.createElement("div"), this.shiftPreview1.style.position = "absolute", 
this.shiftPreview1.style.overflow = "visible", this.shiftPreview2 = document.createElement("div"), 
this.shiftPreview2.style.position = "absolute", this.shiftPreview2.style.overflow = "visible";
for (var f = this.shiftPreview1, d = this.container.firstChild; null != d; ) e = d.nextSibling, 
d != c.parentNode ? f.appendChild(d) :f = this.shiftPreview2, d = e;
this.container.insertBefore(this.shiftPreview1, c.parentNode), this.container.appendChild(this.shiftPreview2);
}
this.shiftPreview1.style.left = a + "px", this.shiftPreview1.style.top = b + "px", 
this.shiftPreview2.style.left = a + "px", this.shiftPreview2.style.top = b + "px";
} else c.style.left = a + "px", c.style.top = b + "px";
this.panDx = a, this.panDy = b, this.fireEvent(new mxEventObject(mxEvent.PAN));
}
}, mxGraph.prototype.zoomIn = function() {
this.zoom(this.zoomFactor);
}, mxGraph.prototype.zoomOut = function() {
this.zoom(1 / this.zoomFactor);
}, mxGraph.prototype.zoomActual = function() {
1 == this.view.scale ? this.view.setTranslate(0, 0) :(this.view.translate.x = 0, 
this.view.translate.y = 0, this.view.setScale(1));
}, mxGraph.prototype.zoomTo = function(a, b) {
this.zoom(a / this.view.scale, b);
}, mxGraph.prototype.zoom = function(a, b) {
b = null != b ? b :this.centerZoom;
var c = this.view.scale * a, d = this.view.getState(this.getSelectionCell());
if (this.keepSelectionVisibleOnZoom && null != d) d = new mxRectangle(d.x * a, d.y * a, d.width * a, d.height * a), 
this.view.scale = c, this.scrollRectToVisible(d) || (this.view.revalidate(), this.view.setScale(c)); else if (b && !mxUtils.hasScrollbars(this.container)) {
var d = this.container.offsetWidth, e = this.container.offsetHeight;
if (a > 1) var f = (a - 1) / (2 * c), d = d * -f, e = e * -f; else f = (1 / a - 1) / (2 * this.view.scale), 
d *= f, e *= f;
this.view.scaleAndTranslate(c, this.view.translate.x + d, this.view.translate.y + e);
} else this.view.setScale(c), mxUtils.hasScrollbars(this.container) && (e = d = 0, 
b && (d = this.container.offsetWidth * (a - 1) / 2, e = this.container.offsetHeight * (a - 1) / 2), 
this.container.scrollLeft = Math.round(this.container.scrollLeft * a + d), this.container.scrollTop = Math.round(this.container.scrollTop * a + e));
}, mxGraph.prototype.zoomToRect = function(a) {
var b = this.container.clientWidth / a.width / (this.container.clientHeight / a.height);
a.x = Math.max(0, a.x), a.y = Math.max(0, a.y);
var c = Math.min(this.container.scrollWidth, a.x + a.width), d = Math.min(this.container.scrollHeight, a.y + a.height);
a.width = c - a.x, a.height = d - a.y, 1 > b ? (b = a.height / b, c = (b - a.height) / 2, 
a.height = b, b = Math.min(a.y, c), a.y -= b, d = Math.min(this.container.scrollHeight, a.y + a.height), 
a.height = d - a.y) :(b *= a.width, c = (b - a.width) / 2, a.width = b, b = Math.min(a.x, c), 
a.x -= b, c = Math.min(this.container.scrollWidth, a.x + a.width), a.width = c - a.x), 
b = this.container.clientWidth / a.width, c = this.view.scale * b, mxUtils.hasScrollbars(this.container) ? (this.view.setScale(c), 
this.container.scrollLeft = Math.round(a.x * b), this.container.scrollTop = Math.round(a.y * b)) :this.view.scaleAndTranslate(c, this.view.translate.x - a.x / this.view.scale, this.view.translate.y - a.y / this.view.scale);
}, mxGraph.prototype.fit = function(a, b) {
if (null != this.container) {
a = null != a ? a :0, b = null != b ? b :!1;
var c = this.container.clientWidth, d = this.container.clientHeight, e = this.view.getGraphBounds();
b && null != e.x && null != e.y && (e.width += e.x, e.height += e.y, e.x = 0, e.y = 0);
var f = this.view.scale, g = e.width / f, h = e.height / f;
null != this.backgroundImage && (g = Math.max(g, this.backgroundImage.width - e.x / f), 
h = Math.max(h, this.backgroundImage.height - e.y / f));
var k = b ? a :2 * a, c = Math.floor(100 * Math.min(c / (g + k), d / (h + k))) / 100;
null != this.minFitScale && (c = Math.max(c, this.minFitScale)), null != this.maxFitScale && (c = Math.min(c, this.maxFitScale)), 
b ? this.view.scale != c && this.view.setScale(c) :mxUtils.hasScrollbars(this.container) ? (this.view.setScale(c), 
null != e.x && (this.container.scrollLeft = Math.round(e.x / f) * c - a - Math.max(0, (this.container.clientWidth - g * c) / 2)), 
null != e.y && (this.container.scrollTop = Math.round(e.y / f) * c - a - Math.max(0, (this.container.clientHeight - h * c) / 2))) :this.view.scaleAndTranslate(c, null != e.x ? Math.floor(this.view.translate.x - e.x / f + a + 1) :a, null != e.y ? Math.floor(this.view.translate.y - e.y / f + a + 1) :a);
}
return this.view.scale;
}, mxGraph.prototype.scrollCellToVisible = function(a, b) {
var c = -this.view.translate.x, d = -this.view.translate.y, e = this.view.getState(a);
null != e && (c = new mxRectangle(c + e.x, d + e.y, e.width, e.height), b && null != this.container && (d = this.container.clientWidth, 
e = this.container.clientHeight, c.x = c.getCenterX() - d / 2, c.width = d, c.y = c.getCenterY() - e / 2, 
c.height = e), this.scrollRectToVisible(c) && this.view.setTranslate(this.view.translate.x, this.view.translate.y));
}, mxGraph.prototype.scrollRectToVisible = function(a) {
var b = !1;
if (null != a) {
var c = this.container.offsetWidth, d = this.container.offsetHeight, e = Math.min(c, a.width), f = Math.min(d, a.height);
if (mxUtils.hasScrollbars(this.container)) {
c = this.container, a.x += this.view.translate.x, a.y += this.view.translate.y;
var g = c.scrollLeft - a.x, d = Math.max(g - c.scrollLeft, 0);
g > 0 ? c.scrollLeft -= g + 2 :(g = a.x + e - c.scrollLeft - c.clientWidth, g > 0 && (c.scrollLeft += g + 2)), 
e = c.scrollTop - a.y, g = Math.max(0, e - c.scrollTop), e > 0 ? c.scrollTop -= e + 2 :(e = a.y + f - c.scrollTop - c.clientHeight, 
e > 0 && (c.scrollTop += e + 2)), !this.useScrollbarsForPanning && (0 != d || 0 != g) && this.view.setTranslate(d, g);
} else {
var g = -this.view.translate.x, h = -this.view.translate.y, k = this.view.scale;
a.x + e > g + c && (this.view.translate.x -= (a.x + e - c - g) / k, b = !0), a.y + f > h + d && (this.view.translate.y -= (a.y + f - d - h) / k, 
b = !0), a.x < g && (this.view.translate.x += (g - a.x) / k, b = !0), a.y < h && (this.view.translate.y += (h - a.y) / k, 
b = !0), b && (this.view.refresh(), null != this.selectionCellsHandler && this.selectionCellsHandler.refresh());
}
}
return b;
}, mxGraph.prototype.getCellGeometry = function(a) {
return this.model.getGeometry(a);
}, mxGraph.prototype.isCellVisible = function(a) {
return this.model.isVisible(a);
}, mxGraph.prototype.isCellCollapsed = function(a) {
return this.model.isCollapsed(a);
}, mxGraph.prototype.isCellConnectable = function(a) {
return this.model.isConnectable(a);
}, mxGraph.prototype.isOrthogonal = function(a) {
var b = a.style[mxConstants.STYLE_ORTHOGONAL];
return null != b ? b :(a = this.view.getEdgeStyle(a), a == mxEdgeStyle.SegmentConnector || a == mxEdgeStyle.ElbowConnector || a == mxEdgeStyle.SideToSide || a == mxEdgeStyle.TopToBottom || a == mxEdgeStyle.EntityRelation || a == mxEdgeStyle.OrthConnector);
}, mxGraph.prototype.isLoop = function(a) {
var b = a.getVisibleTerminalState(!0);
return a = a.getVisibleTerminalState(!1), null != b && b == a;
}, mxGraph.prototype.isCloneEvent = function(a) {
return mxEvent.isControlDown(a);
}, mxGraph.prototype.isToggleEvent = function(a) {
return mxClient.IS_MAC ? mxEvent.isMetaDown(a) :mxEvent.isControlDown(a);
}, mxGraph.prototype.isGridEnabledEvent = function(a) {
return null != a && !mxEvent.isAltDown(a);
}, mxGraph.prototype.isConstrainedEvent = function(a) {
return mxEvent.isShiftDown(a);
}, mxGraph.prototype.isForceMarqueeEvent = function(a) {
return mxEvent.isAltDown(a);
}, mxGraph.prototype.validationAlert = function(a) {
mxUtils.alert(a);
}, mxGraph.prototype.isEdgeValid = function(a, b, c) {
return null == this.getEdgeValidationError(a, b, c);
}, mxGraph.prototype.getEdgeValidationError = function(a, b, c) {
if (null != a && !this.isAllowDanglingEdges() && (null == b || null == c)) return "";
if (null != a && null == this.model.getTerminal(a, !0) && null == this.model.getTerminal(a, !1)) return null;
if (!this.allowLoops && b == c && null != b || !this.isValidConnection(b, c)) return "";
if (null != b && null != c) {
var d = "";
if (!this.multigraph) {
var e = this.model.getEdgesBetween(b, c, !0);
(1 < e.length || 1 == e.length && e[0] != a) && (d += (mxResources.get(this.alreadyConnectedResource) || this.alreadyConnectedResource) + "\n");
}
var e = this.model.getDirectedEdgeCount(b, !0, a), f = this.model.getDirectedEdgeCount(c, !1, a);
if (null != this.multiplicities) for (var g = 0; g < this.multiplicities.length; g++) {
var h = this.multiplicities[g].check(this, a, b, c, e, f);
null != h && (d += h);
}
return h = this.validateEdge(a, b, c), null != h && (d += h), 0 < d.length ? d :null;
}
return this.allowDanglingEdges ? null :"";
}, mxGraph.prototype.validateEdge = function() {
return null;
}, mxGraph.prototype.validateGraph = function(a, b) {
a = null != a ? a :this.model.getRoot(), b = null != b ? b :{};
for (var c = !0, d = this.model.getChildCount(a), e = 0; d > e; e++) {
var f = this.model.getChildAt(a, e), g = b;
this.isValidRoot(f) && (g = {}), g = this.validateGraph(f, g), null != g ? this.setCellWarning(f, g.replace(/\n/g, "<br>")) :this.setCellWarning(f, null), 
c = c && null == g;
}
return d = "", this.isCellCollapsed(a) && !c && (d += (mxResources.get(this.containsValidationErrorsResource) || this.containsValidationErrorsResource) + "\n"), 
d = this.model.isEdge(a) ? d + (this.getEdgeValidationError(a, this.model.getTerminal(a, !0), this.model.getTerminal(a, !1)) || "") :d + (this.getCellValidationError(a) || ""), 
e = this.validateCell(a, b), null != e && (d += e), null == this.model.getParent(a) && this.view.validate(), 
0 < d.length || !c ? d :null;
}, mxGraph.prototype.getCellValidationError = function(a) {
var b = this.model.getDirectedEdgeCount(a, !0), c = this.model.getDirectedEdgeCount(a, !1);
a = this.model.getValue(a);
var d = "";
if (null != this.multiplicities) for (var e = 0; e < this.multiplicities.length; e++) {
var f = this.multiplicities[e];
f.source && mxUtils.isNode(a, f.type, f.attr, f.value) && (0 == f.max && b > 0 || 1 == f.min && 0 == b || 1 == f.max && b > 1) ? d += f.countError + "\n" :!f.source && mxUtils.isNode(a, f.type, f.attr, f.value) && (0 == f.max && c > 0 || 1 == f.min && 0 == c || 1 == f.max && c > 1) && (d += f.countError + "\n");
}
return 0 < d.length ? d :null;
}, mxGraph.prototype.validateCell = function() {
return null;
}, mxGraph.prototype.getBackgroundImage = function() {
return this.backgroundImage;
}, mxGraph.prototype.setBackgroundImage = function(a) {
this.backgroundImage = a;
}, mxGraph.prototype.getFoldingImage = function(a) {
if (null != a && this.foldingEnabled && !this.getModel().isEdge(a.cell)) {
var b = this.isCellCollapsed(a.cell);
if (this.isCellFoldable(a.cell, !b)) return b ? this.collapsedImage :this.expandedImage;
}
return null;
}, mxGraph.prototype.convertValueToString = function(a) {
if (a = this.model.getValue(a), null != a) {
if (mxUtils.isNode(a)) return a.nodeName;
if ("function" == typeof a.toString) return a.toString();
}
return "";
}, mxGraph.prototype.getLabel = function(a) {
var b = "";
if (this.labelsVisible && null != a) {
var c = this.view.getState(a), c = null != c ? c.style :this.getCellStyle(a);
mxUtils.getValue(c, mxConstants.STYLE_NOLABEL, !1) || (b = this.convertValueToString(a));
}
return b;
}, mxGraph.prototype.isHtmlLabel = function() {
return this.isHtmlLabels();
}, mxGraph.prototype.isHtmlLabels = function() {
return this.htmlLabels;
}, mxGraph.prototype.setHtmlLabels = function(a) {
this.htmlLabels = a;
}, mxGraph.prototype.isWrapping = function(a) {
var b = this.view.getState(a);
return a = null != b ? b.style :this.getCellStyle(a), null != a ? "wrap" == a[mxConstants.STYLE_WHITE_SPACE] :!1;
}, mxGraph.prototype.isLabelClipped = function(a) {
var b = this.view.getState(a);
return a = null != b ? b.style :this.getCellStyle(a), null != a ? "hidden" == a[mxConstants.STYLE_OVERFLOW] :!1;
}, mxGraph.prototype.getTooltip = function(a, b, c) {
var e = null;
return null != a && (null == a.control || b != a.control.node && b.parentNode != a.control.node || (e = this.collapseExpandResource, 
e = mxResources.get(e) || e), null == e && null != a.overlays && a.overlays.visit(function(a, c) {
null != e || b != c.node && b.parentNode != c.node || (e = c.overlay.toString());
}), null == e && (c = this.selectionCellsHandler.getHandler(a.cell), null != c && "function" == typeof c.getTooltipForNode && (e = c.getTooltipForNode(b))), 
null == e && (e = this.getTooltipForCell(a.cell))), e;
}, mxGraph.prototype.getTooltipForCell = function(a) {
var b = null;
return b = null != a && null != a.getTooltip ? a.getTooltip() :this.convertValueToString(a);
}, mxGraph.prototype.getCursorForCell = function() {
return null;
}, mxGraph.prototype.getStartSize = function(a) {
var b = new mxRectangle(), c = this.view.getState(a);
return a = null != c ? c.style :this.getCellStyle(a), null != a && (c = parseInt(mxUtils.getValue(a, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE)), 
mxUtils.getValue(a, mxConstants.STYLE_HORIZONTAL, !0) ? b.height = c :b.width = c), 
b;
}, mxGraph.prototype.getImage = function(a) {
return null != a && null != a.style ? a.style[mxConstants.STYLE_IMAGE] :null;
}, mxGraph.prototype.getVerticalAlign = function(a) {
return null != a && null != a.style ? a.style[mxConstants.STYLE_VERTICAL_ALIGN] || mxConstants.ALIGN_MIDDLE :null;
}, mxGraph.prototype.getIndicatorColor = function(a) {
return null != a && null != a.style ? a.style[mxConstants.STYLE_INDICATOR_COLOR] :null;
}, mxGraph.prototype.getIndicatorGradientColor = function(a) {
return null != a && null != a.style ? a.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] :null;
}, mxGraph.prototype.getIndicatorShape = function(a) {
return null != a && null != a.style ? a.style[mxConstants.STYLE_INDICATOR_SHAPE] :null;
}, mxGraph.prototype.getIndicatorImage = function(a) {
return null != a && null != a.style ? a.style[mxConstants.STYLE_INDICATOR_IMAGE] :null;
}, mxGraph.prototype.getBorder = function() {
return this.border;
}, mxGraph.prototype.setBorder = function(a) {
this.border = a;
}, mxGraph.prototype.isSwimlane = function(a) {
if (null != a && this.model.getParent(a) != this.model.getRoot()) {
var b = this.view.getState(a), b = null != b ? b.style :this.getCellStyle(a);
if (null != b && !this.model.isEdge(a)) return b[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;
}
return !1;
}, mxGraph.prototype.isResizeContainer = function() {
return this.resizeContainer;
}, mxGraph.prototype.setResizeContainer = function(a) {
this.resizeContainer = a;
}, mxGraph.prototype.isEnabled = function() {
return this.enabled;
}, mxGraph.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxGraph.prototype.isEscapeEnabled = function() {
return this.escapeEnabled;
}, mxGraph.prototype.setEscapeEnabled = function(a) {
this.escapeEnabled = a;
}, mxGraph.prototype.isInvokesStopCellEditing = function() {
return this.invokesStopCellEditing;
}, mxGraph.prototype.setInvokesStopCellEditing = function(a) {
this.invokesStopCellEditing = a;
}, mxGraph.prototype.isEnterStopsCellEditing = function() {
return this.enterStopsCellEditing;
}, mxGraph.prototype.setEnterStopsCellEditing = function(a) {
this.enterStopsCellEditing = a;
}, mxGraph.prototype.isCellLocked = function(a) {
var b = this.model.getGeometry(a);
return this.isCellsLocked() || null != b && this.model.isVertex(a) && b.relative;
}, mxGraph.prototype.isCellsLocked = function() {
return this.cellsLocked;
}, mxGraph.prototype.setCellsLocked = function(a) {
this.cellsLocked = a;
}, mxGraph.prototype.getCloneableCells = function(a) {
return this.model.filterCells(a, mxUtils.bind(this, function(a) {
return this.isCellCloneable(a);
}));
}, mxGraph.prototype.isCellCloneable = function(a) {
var b = this.view.getState(a);
return a = null != b ? b.style :this.getCellStyle(a), this.isCellsCloneable() && 0 != a[mxConstants.STYLE_CLONEABLE];
}, mxGraph.prototype.isCellsCloneable = function() {
return this.cellsCloneable;
}, mxGraph.prototype.setCellsCloneable = function(a) {
this.cellsCloneable = a;
}, mxGraph.prototype.getExportableCells = function(a) {
return this.model.filterCells(a, mxUtils.bind(this, function(a) {
return this.canExportCell(a);
}));
}, mxGraph.prototype.canExportCell = function() {
return this.exportEnabled;
}, mxGraph.prototype.getImportableCells = function(a) {
return this.model.filterCells(a, mxUtils.bind(this, function(a) {
return this.canImportCell(a);
}));
}, mxGraph.prototype.canImportCell = function() {
return this.importEnabled;
}, mxGraph.prototype.isCellSelectable = function() {
return this.isCellsSelectable();
}, mxGraph.prototype.isCellsSelectable = function() {
return this.cellsSelectable;
}, mxGraph.prototype.setCellsSelectable = function(a) {
this.cellsSelectable = a;
}, mxGraph.prototype.getDeletableCells = function(a) {
return this.model.filterCells(a, mxUtils.bind(this, function(a) {
return this.isCellDeletable(a);
}));
}, mxGraph.prototype.isCellDeletable = function(a) {
var b = this.view.getState(a);
return a = null != b ? b.style :this.getCellStyle(a), this.isCellsDeletable() && 0 != a[mxConstants.STYLE_DELETABLE];
}, mxGraph.prototype.isCellsDeletable = function() {
return this.cellsDeletable;
}, mxGraph.prototype.setCellsDeletable = function(a) {
this.cellsDeletable = a;
}, mxGraph.prototype.isLabelMovable = function(a) {
return !this.isCellLocked(a) && (this.model.isEdge(a) && this.edgeLabelsMovable || this.model.isVertex(a) && this.vertexLabelsMovable);
}, mxGraph.prototype.isCellRotatable = function(a) {
var b = this.view.getState(a);
return 0 != (null != b ? b.style :this.getCellStyle(a))[mxConstants.STYLE_ROTATABLE];
}, mxGraph.prototype.getMovableCells = function(a) {
return this.model.filterCells(a, mxUtils.bind(this, function(a) {
return this.isCellMovable(a);
}));
}, mxGraph.prototype.isCellMovable = function(a) {
var b = this.view.getState(a), b = null != b ? b.style :this.getCellStyle(a);
return this.isCellsMovable() && !this.isCellLocked(a) && 0 != b[mxConstants.STYLE_MOVABLE];
}, mxGraph.prototype.isCellsMovable = function() {
return this.cellsMovable;
}, mxGraph.prototype.setCellsMovable = function(a) {
this.cellsMovable = a;
}, mxGraph.prototype.isGridEnabled = function() {
return this.gridEnabled;
}, mxGraph.prototype.setGridEnabled = function(a) {
this.gridEnabled = a;
}, mxGraph.prototype.isPortsEnabled = function() {
return this.portsEnabled;
}, mxGraph.prototype.setPortsEnabled = function(a) {
this.portsEnabled = a;
}, mxGraph.prototype.getGridSize = function() {
return this.gridSize;
}, mxGraph.prototype.setGridSize = function(a) {
this.gridSize = a;
}, mxGraph.prototype.getTolerance = function() {
return this.tolerance;
}, mxGraph.prototype.setTolerance = function(a) {
this.tolerance = a;
}, mxGraph.prototype.isVertexLabelsMovable = function() {
return this.vertexLabelsMovable;
}, mxGraph.prototype.setVertexLabelsMovable = function(a) {
this.vertexLabelsMovable = a;
}, mxGraph.prototype.isEdgeLabelsMovable = function() {
return this.edgeLabelsMovable;
}, mxGraph.prototype.setEdgeLabelsMovable = function(a) {
this.edgeLabelsMovable = a;
}, mxGraph.prototype.isSwimlaneNesting = function() {
return this.swimlaneNesting;
}, mxGraph.prototype.setSwimlaneNesting = function(a) {
this.swimlaneNesting = a;
}, mxGraph.prototype.isSwimlaneSelectionEnabled = function() {
return this.swimlaneSelectionEnabled;
}, mxGraph.prototype.setSwimlaneSelectionEnabled = function(a) {
this.swimlaneSelectionEnabled = a;
}, mxGraph.prototype.isMultigraph = function() {
return this.multigraph;
}, mxGraph.prototype.setMultigraph = function(a) {
this.multigraph = a;
}, mxGraph.prototype.isAllowLoops = function() {
return this.allowLoops;
}, mxGraph.prototype.setAllowDanglingEdges = function(a) {
this.allowDanglingEdges = a;
}, mxGraph.prototype.isAllowDanglingEdges = function() {
return this.allowDanglingEdges;
}, mxGraph.prototype.setConnectableEdges = function(a) {
this.connectableEdges = a;
}, mxGraph.prototype.isConnectableEdges = function() {
return this.connectableEdges;
}, mxGraph.prototype.setCloneInvalidEdges = function(a) {
this.cloneInvalidEdges = a;
}, mxGraph.prototype.isCloneInvalidEdges = function() {
return this.cloneInvalidEdges;
}, mxGraph.prototype.setAllowLoops = function(a) {
this.allowLoops = a;
}, mxGraph.prototype.isDisconnectOnMove = function() {
return this.disconnectOnMove;
}, mxGraph.prototype.setDisconnectOnMove = function(a) {
this.disconnectOnMove = a;
}, mxGraph.prototype.isDropEnabled = function() {
return this.dropEnabled;
}, mxGraph.prototype.setDropEnabled = function(a) {
this.dropEnabled = a;
}, mxGraph.prototype.isSplitEnabled = function() {
return this.splitEnabled;
}, mxGraph.prototype.setSplitEnabled = function(a) {
this.splitEnabled = a;
}, mxGraph.prototype.isCellResizable = function(a) {
var b = this.view.getState(a), b = null != b ? b.style :this.getCellStyle(a);
return this.isCellsResizable() && !this.isCellLocked(a) && 0 != b[mxConstants.STYLE_RESIZABLE];
}, mxGraph.prototype.isCellsResizable = function() {
return this.cellsResizable;
}, mxGraph.prototype.setCellsResizable = function(a) {
this.cellsResizable = a;
}, mxGraph.prototype.isTerminalPointMovable = function() {
return !0;
}, mxGraph.prototype.isCellBendable = function(a) {
var b = this.view.getState(a), b = null != b ? b.style :this.getCellStyle(a);
return this.isCellsBendable() && !this.isCellLocked(a) && 0 != b[mxConstants.STYLE_BENDABLE];
}, mxGraph.prototype.isCellsBendable = function() {
return this.cellsBendable;
}, mxGraph.prototype.setCellsBendable = function(a) {
this.cellsBendable = a;
}, mxGraph.prototype.isCellEditable = function(a) {
var b = this.view.getState(a), b = null != b ? b.style :this.getCellStyle(a);
return this.isCellsEditable() && !this.isCellLocked(a) && 0 != b[mxConstants.STYLE_EDITABLE];
}, mxGraph.prototype.isCellsEditable = function() {
return this.cellsEditable;
}, mxGraph.prototype.setCellsEditable = function(a) {
this.cellsEditable = a;
}, mxGraph.prototype.isCellDisconnectable = function(a) {
return this.isCellsDisconnectable() && !this.isCellLocked(a);
}, mxGraph.prototype.isCellsDisconnectable = function() {
return this.cellsDisconnectable;
}, mxGraph.prototype.setCellsDisconnectable = function(a) {
this.cellsDisconnectable = a;
}, mxGraph.prototype.isValidSource = function(a) {
return null == a && this.allowDanglingEdges || null != a && (!this.model.isEdge(a) || this.connectableEdges) && this.isCellConnectable(a);
}, mxGraph.prototype.isValidTarget = function(a) {
return this.isValidSource(a);
}, mxGraph.prototype.isValidConnection = function(a, b) {
return this.isValidSource(a) && this.isValidTarget(b);
}, mxGraph.prototype.setConnectable = function(a) {
this.connectionHandler.setEnabled(a);
}, mxGraph.prototype.isConnectable = function() {
return this.connectionHandler.isEnabled();
}, mxGraph.prototype.setTooltips = function(a) {
this.tooltipHandler.setEnabled(a);
}, mxGraph.prototype.setPanning = function(a) {
this.panningHandler.panningEnabled = a;
}, mxGraph.prototype.isEditing = function(a) {
if (null != this.cellEditor) {
var b = this.cellEditor.getEditingCell();
return null == a ? null != b :a == b;
}
return !1;
}, mxGraph.prototype.isAutoSizeCell = function(a) {
var b = this.view.getState(a);
return a = null != b ? b.style :this.getCellStyle(a), this.isAutoSizeCells() || 1 == a[mxConstants.STYLE_AUTOSIZE];
}, mxGraph.prototype.isAutoSizeCells = function() {
return this.autoSizeCells;
}, mxGraph.prototype.setAutoSizeCells = function(a) {
this.autoSizeCells = a;
}, mxGraph.prototype.isExtendParent = function(a) {
return !this.getModel().isEdge(a) && this.isExtendParents();
}, mxGraph.prototype.isExtendParents = function() {
return this.extendParents;
}, mxGraph.prototype.setExtendParents = function(a) {
this.extendParents = a;
}, mxGraph.prototype.isExtendParentsOnAdd = function() {
return this.extendParentsOnAdd;
}, mxGraph.prototype.setExtendParentsOnAdd = function(a) {
this.extendParentsOnAdd = a;
}, mxGraph.prototype.isConstrainChild = function(a) {
return this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(a));
}, mxGraph.prototype.isConstrainChildren = function() {
return this.constrainChildren;
}, mxGraph.prototype.setConstrainChildren = function(a) {
this.constrainChildren = a;
}, mxGraph.prototype.isAllowNegativeCoordinates = function() {
return this.allowNegativeCoordinates;
}, mxGraph.prototype.setAllowNegativeCoordinates = function(a) {
this.allowNegativeCoordinates = a;
}, mxGraph.prototype.getOverlap = function(a) {
return this.isAllowOverlapParent(a) ? this.defaultOverlap :0;
}, mxGraph.prototype.isAllowOverlapParent = function() {
return !1;
}, mxGraph.prototype.getFoldableCells = function(a, b) {
return this.model.filterCells(a, mxUtils.bind(this, function(a) {
return this.isCellFoldable(a, b);
}));
}, mxGraph.prototype.isCellFoldable = function(a) {
var c = this.view.getState(a), c = null != c ? c.style :this.getCellStyle(a);
return 0 < this.model.getChildCount(a) && 0 != c[mxConstants.STYLE_FOLDABLE];
}, mxGraph.prototype.isValidDropTarget = function(a, b, c) {
return null != a && (this.isSplitEnabled() && this.isSplitTarget(a, b, c) || !this.model.isEdge(a) && (this.isSwimlane(a) || 0 < this.model.getChildCount(a) && !this.isCellCollapsed(a)));
}, mxGraph.prototype.isSplitTarget = function(a, b, c) {
return this.model.isEdge(a) && null != b && 1 == b.length && this.isCellConnectable(b[0]) && null == this.getEdgeValidationError(a, this.model.getTerminal(a, !0), b[0]) ? (c = this.model.getTerminal(a, !0), 
a = this.model.getTerminal(a, !1), !this.model.isAncestor(b[0], c) && !this.model.isAncestor(b[0], a)) :!1;
}, mxGraph.prototype.getDropTarget = function(a, b, c) {
if (!this.isSwimlaneNesting()) for (var d = 0; d < a.length; d++) if (this.isSwimlane(a[d])) return null;
if (d = mxUtils.convertPoint(this.container, mxEvent.getClientX(b), mxEvent.getClientY(b)), 
d.x -= this.panDx, d.y -= this.panDy, d = this.getSwimlaneAt(d.x, d.y), null == c) c = d; else if (null != d) {
for (var e = this.model.getParent(d); null != e && this.isSwimlane(e) && e != c; ) e = this.model.getParent(e);
e == c && (c = d);
}
for (;null != c && !this.isValidDropTarget(c, a, b) && !this.model.isLayer(c); ) c = this.model.getParent(c);
return !this.model.isLayer(c) && 0 > mxUtils.indexOf(a, c) ? c :null;
}, mxGraph.prototype.getDefaultParent = function() {
var a = this.getCurrentRoot();
return null == a && (a = this.defaultParent, null == a && (a = this.model.getRoot(), 
a = this.model.getChildAt(a, 0))), a;
}, mxGraph.prototype.setDefaultParent = function(a) {
this.defaultParent = a;
}, mxGraph.prototype.getSwimlane = function(a) {
for (;null != a && !this.isSwimlane(a); ) a = this.model.getParent(a);
return a;
}, mxGraph.prototype.getSwimlaneAt = function(a, b, c) {
if (c = c || this.getDefaultParent(), null != c) for (var d = this.model.getChildCount(c), e = 0; d > e; e++) {
var f = this.model.getChildAt(c, e), g = this.getSwimlaneAt(a, b, f);
if (null != g) return g;
if (this.isSwimlane(f) && (g = this.view.getState(f), this.intersects(g, a, b))) return f;
}
return null;
}, mxGraph.prototype.getCellAt = function(a, b, c, d, e) {
if (d = null != d ? d :!0, e = null != e ? e :!0, c = null != c ? c :this.getDefaultParent(), 
null != c) for (var f = this.model.getChildCount(c) - 1; f >= 0; f--) {
var g = this.model.getChildAt(c, f), h = this.getCellAt(a, b, g, d, e);
if (null != h) return h;
if (this.isCellVisible(g) && (e && this.model.isEdge(g) || d && this.model.isVertex(g)) && (h = this.view.getState(g), 
this.intersects(h, a, b))) return g;
}
return null;
}, mxGraph.prototype.intersects = function(a, b, c) {
if (null != a) {
var d = a.absolutePoints;
if (null != d) {
a = this.tolerance * this.tolerance;
for (var e = d[0], f = 1; f < d.length; f++) {
var g = d[f];
if (mxUtils.ptSegDistSq(e.x, e.y, g.x, g.y, b, c) <= a) return !0;
e = g;
}
} else if (e = mxUtils.toRadians(mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION) || 0), 
0 != e && (d = Math.cos(-e), e = Math.sin(-e), f = new mxPoint(a.getCenterX(), a.getCenterY()), 
e = mxUtils.getRotatedPoint(new mxPoint(b, c), d, e, f), b = e.x, c = e.y), mxUtils.contains(a, b, c)) return !0;
}
return !1;
}, mxGraph.prototype.hitsSwimlaneContent = function(a, b, c) {
var d = this.getView().getState(a);
if (a = this.getStartSize(a), null != d) {
var e = this.getView().getScale();
if (b -= d.x, c -= d.y, 0 < a.width && b > 0 && b > a.width * e || 0 < a.height && c > 0 && c > a.height * e) return !0;
}
return !1;
}, mxGraph.prototype.getChildVertices = function(a) {
return this.getChildCells(a, !0, !1);
}, mxGraph.prototype.getChildEdges = function(a) {
return this.getChildCells(a, !1, !0);
}, mxGraph.prototype.getChildCells = function(a, b, c) {
for (a = null != a ? a :this.getDefaultParent(), a = this.model.getChildCells(a, null != b ? b :!1, null != c ? c :!1), 
b = [], c = 0; c < a.length; c++) this.isCellVisible(a[c]) && b.push(a[c]);
return b;
}, mxGraph.prototype.getConnections = function(a, b) {
return this.getEdges(a, b, !0, !0, !1);
}, mxGraph.prototype.getIncomingEdges = function(a, b) {
return this.getEdges(a, b, !0, !1, !1);
}, mxGraph.prototype.getOutgoingEdges = function(a, b) {
return this.getEdges(a, b, !1, !0, !1);
}, mxGraph.prototype.getEdges = function(a, b, c, d, e, f) {
c = null != c ? c :!0, d = null != d ? d :!0, e = null != e ? e :!0, f = null != f ? f :!1;
for (var g = [], h = this.isCellCollapsed(a), k = this.model.getChildCount(a), l = 0; k > l; l++) {
var m = this.model.getChildAt(a, l);
(h || !this.isCellVisible(m)) && (g = g.concat(this.model.getEdges(m, c, d)));
}
for (g = g.concat(this.model.getEdges(a, c, d)), h = [], l = 0; l < g.length; l++) m = this.view.getState(g[l]), 
k = null != m ? m.getVisibleTerminal(!0) :this.view.getVisibleTerminal(g[l], !0), 
m = null != m ? m.getVisibleTerminal(!1) :this.view.getVisibleTerminal(g[l], !1), 
(e && k == m || k != m && (c && m == a && (null == b || this.isValidAncestor(k, b, f)) || d && k == a && (null == b || this.isValidAncestor(m, b, f)))) && h.push(g[l]);
return h;
}, mxGraph.prototype.isValidAncestor = function(a, b, c) {
return c ? this.model.isAncestor(b, a) :this.model.getParent(a) == b;
}, mxGraph.prototype.getOpposites = function(a, b, c, d) {
c = null != c ? c :!0, d = null != d ? d :!0;
var e = [], f = {};
if (null != a) for (var g = 0; g < a.length; g++) {
var h = this.view.getState(a[g]), k = null != h ? h.getVisibleTerminal(!0) :this.view.getVisibleTerminal(a[g], !0), h = null != h ? h.getVisibleTerminal(!1) :this.view.getVisibleTerminal(a[g], !1);
if (k == b && null != h && h != b && d) {
var l = mxCellPath.create(h);
null == f[l] && (f[l] = h, e.push(h));
} else h == b && null != k && k != b && c && (l = mxCellPath.create(k), null == f[l] && (f[l] = k, 
e.push(k)));
}
return e;
}, mxGraph.prototype.getEdgesBetween = function(a, b, c) {
c = null != c ? c :!1;
for (var d = this.getEdges(a), e = [], f = 0; f < d.length; f++) {
var g = this.view.getState(d[f]), h = null != g ? g.getVisibleTerminal(!0) :this.view.getVisibleTerminal(d[f], !0), g = null != g ? g.getVisibleTerminal(!1) :this.view.getVisibleTerminal(d[f], !1);
(h == a && g == b || !c && h == b && g == a) && e.push(d[f]);
}
return e;
}, mxGraph.prototype.getPointForEvent = function(a, b) {
var c = mxUtils.convertPoint(this.container, mxEvent.getClientX(a), mxEvent.getClientY(a)), d = this.view.scale, e = this.view.translate, f = 0 != b ? this.gridSize / 2 :0;
return c.x = this.snap(c.x / d - e.x - f), c.y = this.snap(c.y / d - e.y - f), c;
}, mxGraph.prototype.getCells = function(a, b, c, d, e, f) {
if (f = null != f ? f :[], c > 0 || d > 0) {
var g = a + c, h = b + d;
if (e = e || this.getDefaultParent(), null != e) for (var k = this.model.getChildCount(e), l = 0; k > l; l++) {
var m = this.model.getChildAt(e, l), n = this.view.getState(m);
if (this.isCellVisible(m) && null != n) {
var p = n, n = mxUtils.getValue(n.style, mxConstants.STYLE_ROTATION) || 0;
0 != n && (p = mxUtils.getBoundingBox(p, n)), p.x >= a && p.y + p.height <= h && p.y >= b && p.x + p.width <= g ? f.push(m) :this.getCells(a, b, c, d, m, f);
}
}
}
return f;
}, mxGraph.prototype.getCellsBeyond = function(a, b, c, d, e) {
var f = [];
if ((d || e) && (null == c && (c = this.getDefaultParent()), null != c)) for (var g = this.model.getChildCount(c), h = 0; g > h; h++) {
var k = this.model.getChildAt(c, h), l = this.view.getState(k);
this.isCellVisible(k) && null != l && (!d || l.x >= a) && (!e || l.y >= b) && f.push(k);
}
return f;
}, mxGraph.prototype.findTreeRoots = function(a, b, c) {
b = null != b ? b :!1, c = null != c ? c :!1;
var d = [];
if (null != a) {
for (var e = this.getModel(), f = e.getChildCount(a), g = null, h = 0, k = 0; f > k; k++) {
var l = e.getChildAt(a, k);
if (this.model.isVertex(l) && this.isCellVisible(l)) {
for (var m = this.getConnections(l, b ? a :null), n = 0, p = 0, q = 0; q < m.length; q++) this.view.getVisibleTerminal(m[q], !0) == l ? n++ :p++;
(c && 0 == n && p > 0 || !c && 0 == p && n > 0) && d.push(l), m = c ? p - n :n - p, 
m > h && (h = m, g = l);
}
}
0 == d.length && null != g && d.push(g);
}
return d;
}, mxGraph.prototype.traverse = function(a, b, c, d, e) {
if (null != c && null != a) {
b = null != b ? b :!0, e = e || [];
var f = mxCellPath.create(a);
if (null == e[f] && (e[f] = a, d = c(a, d), null == d || d) && (d = this.model.getEdgeCount(a), 
d > 0)) for (f = 0; d > f; f++) {
var g = this.model.getEdgeAt(a, f), h = this.model.getTerminal(g, !0) == a;
(!b || h) && (h = this.model.getTerminal(g, !h), this.traverse(h, b, c, g, e));
}
}
}, mxGraph.prototype.isCellSelected = function(a) {
return this.getSelectionModel().isSelected(a);
}, mxGraph.prototype.isSelectionEmpty = function() {
return this.getSelectionModel().isEmpty();
}, mxGraph.prototype.clearSelection = function() {
return this.getSelectionModel().clear();
}, mxGraph.prototype.getSelectionCount = function() {
return this.getSelectionModel().cells.length;
}, mxGraph.prototype.getSelectionCell = function() {
return this.getSelectionModel().cells[0];
}, mxGraph.prototype.getSelectionCells = function() {
return this.getSelectionModel().cells.slice();
}, mxGraph.prototype.setSelectionCell = function(a) {
this.getSelectionModel().setCell(a);
}, mxGraph.prototype.setSelectionCells = function(a) {
this.getSelectionModel().setCells(a);
}, mxGraph.prototype.addSelectionCell = function(a) {
this.getSelectionModel().addCell(a);
}, mxGraph.prototype.addSelectionCells = function(a) {
this.getSelectionModel().addCells(a);
}, mxGraph.prototype.removeSelectionCell = function(a) {
this.getSelectionModel().removeCell(a);
}, mxGraph.prototype.removeSelectionCells = function(a) {
this.getSelectionModel().removeCells(a);
}, mxGraph.prototype.selectRegion = function(a, b) {
var c = this.getCells(a.x, a.y, a.width, a.height);
return this.selectCellsForEvent(c, b), c;
}, mxGraph.prototype.selectNextCell = function() {
this.selectCell(!0);
}, mxGraph.prototype.selectPreviousCell = function() {
this.selectCell();
}, mxGraph.prototype.selectParentCell = function() {
this.selectCell(!1, !0);
}, mxGraph.prototype.selectChildCell = function() {
this.selectCell(!1, !1, !0);
}, mxGraph.prototype.selectCell = function(a, b, c) {
var d = this.selectionModel, e = 0 < d.cells.length ? d.cells[0] :null;
1 < d.cells.length && d.clear();
var d = null != e ? this.model.getParent(e) :this.getDefaultParent(), f = this.model.getChildCount(d);
null == e && f > 0 ? (a = this.model.getChildAt(d, 0), this.setSelectionCell(a)) :null != e && !b || null == this.view.getState(d) || null == this.model.getGeometry(d) ? null != e && c ? 0 < this.model.getChildCount(e) && (a = this.model.getChildAt(e, 0), 
this.setSelectionCell(a)) :f > 0 && (b = d.getIndex(e), a ? (b++, a = this.model.getChildAt(d, b % f)) :(b--, 
a = this.model.getChildAt(d, 0 > b ? f - 1 :b)), this.setSelectionCell(a)) :this.getCurrentRoot() != d && this.setSelectionCell(d);
}, mxGraph.prototype.selectAll = function(a) {
a = a || this.getDefaultParent(), a = this.model.getChildren(a), null != a && this.setSelectionCells(a);
}, mxGraph.prototype.selectVertices = function(a) {
this.selectCells(!0, !1, a);
}, mxGraph.prototype.selectEdges = function(a) {
this.selectCells(!1, !0, a);
}, mxGraph.prototype.selectCells = function(a, b, c) {
c = c || this.getDefaultParent();
var d = mxUtils.bind(this, function(c) {
return null != this.view.getState(c) && 0 == this.model.getChildCount(c) && (this.model.isVertex(c) && a || this.model.isEdge(c) && b);
});
c = this.model.filterDescendants(d, c), this.setSelectionCells(c);
}, mxGraph.prototype.selectCellForEvent = function(a, b) {
var c = this.isCellSelected(a);
this.isToggleEvent(b) ? c ? this.removeSelectionCell(a) :this.addSelectionCell(a) :(!c || 1 != this.getSelectionCount()) && this.setSelectionCell(a);
}, mxGraph.prototype.selectCellsForEvent = function(a, b) {
this.isToggleEvent(b) ? this.addSelectionCells(a) :this.setSelectionCells(a);
}, mxGraph.prototype.createHandler = function(a) {
var b = null;
return null != a && (this.model.isEdge(a.cell) ? (b = this.view.getEdgeStyle(a), 
b = this.isLoop(a) || b == mxEdgeStyle.ElbowConnector || b == mxEdgeStyle.SideToSide || b == mxEdgeStyle.TopToBottom ? new mxElbowEdgeHandler(a) :b == mxEdgeStyle.SegmentConnector || b == mxEdgeStyle.OrthConnector ? new mxEdgeSegmentHandler(a) :new mxEdgeHandler(a)) :b = new mxVertexHandler(a)), 
b;
}, mxGraph.prototype.addMouseListener = function(a) {
null == this.mouseListeners && (this.mouseListeners = []), this.mouseListeners.push(a);
}, mxGraph.prototype.removeMouseListener = function(a) {
if (null != this.mouseListeners) for (var b = 0; b < this.mouseListeners.length; b++) if (this.mouseListeners[b] == a) {
this.mouseListeners.splice(b, 1);
break;
}
}, mxGraph.prototype.updateMouseEvent = function(a) {
if (null == a.graphX || null == a.graphY) {
var b = mxUtils.convertPoint(this.container, a.getX(), a.getY());
a.graphX = b.x - this.panDx, a.graphY = b.y - this.panDy;
}
}, mxGraph.prototype.fireMouseEvent = function(a, b, c) {
if (null == c && (c = this), this.updateMouseEvent(b), a == mxEvent.MOUSE_DOWN && (this.isMouseDown = !0), 
mxClient.IS_TOUCH && this.doubleTapEnabled && a == mxEvent.MOUSE_DOWN) {
var d = new Date().getTime();
d - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - b.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - b.getY()) < this.doubleTapTolerance ? (this.lastTouchTime = 0, 
this.dblClick(b.getEvent(), b.getCell()), b.getEvent().cancelBubble = !0) :(this.lastTouchX = b.getX(), 
this.lastTouchY = b.getY(), this.lastTouchTime = d);
}
if (d = 2 != b.getEvent().detail, mxClient.IS_IE && "CSS1Compat" == document.compatMode && ((null != this.lastMouseX && Math.abs(this.lastMouseX - b.getX()) > this.doubleTapTolerance || null != this.lastMouseY && Math.abs(this.lastMouseY - b.getY()) > this.doubleTapTolerance) && (d = !0), 
a == mxEvent.MOUSE_UP && (this.lastMouseX = b.getX(), this.lastMouseY = b.getY())), 
(a != mxEvent.MOUSE_UP || this.isMouseDown) && d) {
if (a == mxEvent.MOUSE_UP && (this.isMouseDown = !1), !this.isEditing() && (mxClient.IS_OP || mxClient.IS_SF || mxClient.IS_GC || mxClient.IS_IE && mxClient.IS_SVG || b.getEvent().target != this.container)) {
if (a == mxEvent.MOUSE_MOVE && this.isMouseDown && this.autoScroll && this.scrollPointToVisible(b.getGraphX(), b.getGraphY(), this.autoExtend), 
null != this.mouseListeners) for (c = [ c, b ], b.getEvent().returnValue = !0, d = 0; d < this.mouseListeners.length; d++) {
var e = this.mouseListeners[d];
a == mxEvent.MOUSE_DOWN ? e.mouseDown.apply(e, c) :a == mxEvent.MOUSE_MOVE ? e.mouseMove.apply(e, c) :a == mxEvent.MOUSE_UP && e.mouseUp.apply(e, c);
}
a == mxEvent.MOUSE_UP && this.click(b);
}
} else a == mxEvent.MOUSE_UP && (this.isMouseDown = !1);
}, mxGraph.prototype.destroy = function() {
this.destroyed || (this.destroyed = !0, null != this.tooltipHandler && this.tooltipHandler.destroy(), 
null != this.selectionCellsHandler && this.selectionCellsHandler.destroy(), null != this.panningHandler && this.panningHandler.destroy(), 
null != this.connectionHandler && this.connectionHandler.destroy(), null != this.graphHandler && this.graphHandler.destroy(), 
null != this.cellEditor && this.cellEditor.destroy(), null != this.view && this.view.destroy(), 
null != this.model && null != this.graphModelChangeListener && (this.model.removeListener(this.graphModelChangeListener), 
this.graphModelChangeListener = null), this.container = null);
}, mxCellOverlay.prototype = new mxEventSource(), mxCellOverlay.prototype.constructor = mxCellOverlay, 
mxCellOverlay.prototype.image = null, mxCellOverlay.prototype.tooltip = null, mxCellOverlay.prototype.align = mxConstants.ALIGN_RIGHT, 
mxCellOverlay.prototype.verticalAlign = mxConstants.ALIGN_BOTTOM, mxCellOverlay.prototype.offset = null, 
mxCellOverlay.prototype.cursor = null, mxCellOverlay.prototype.defaultOverlap = .5, 
mxCellOverlay.prototype.getBounds = function(a) {
var b = a.view.graph.getModel().isEdge(a.cell), c = a.view.scale, d = null, e = this.image.width, f = this.image.height;
return b ? (b = a.absolutePoints, 1 == b.length % 2 ? d = b[Math.floor(b.length / 2)] :(d = b.length / 2, 
a = b[d - 1], b = b[d], d = new mxPoint(a.x + (b.x - a.x) / 2, a.y + (b.y - a.y) / 2))) :(d = new mxPoint(), 
d.x = this.align == mxConstants.ALIGN_LEFT ? a.x :this.align == mxConstants.ALIGN_CENTER ? a.x + a.width / 2 :a.x + a.width, 
d.y = this.verticalAlign == mxConstants.ALIGN_TOP ? a.y :this.verticalAlign == mxConstants.ALIGN_MIDDLE ? a.y + a.height / 2 :a.y + a.height), 
new mxRectangle(Math.round(d.x - (e * this.defaultOverlap - this.offset.x) * c), Math.round(d.y - (f * this.defaultOverlap - this.offset.y) * c), e * c, f * c);
}, mxCellOverlay.prototype.toString = function() {
return this.tooltip;
}, mxOutline.prototype.source = null, mxOutline.prototype.outline = null, mxOutline.prototype.graphRenderHint = mxConstants.RENDERING_HINT_FASTER, 
mxOutline.prototype.enabled = !0, mxOutline.prototype.showViewport = !0, mxOutline.prototype.border = 10, 
mxOutline.prototype.sizerSize = 8, mxOutline.prototype.updateOnPan = !1, mxOutline.prototype.sizerImage = null, 
mxOutline.prototype.suspended = !1, mxOutline.prototype.init = function(a) {
this.outline = new mxGraph(a, this.source.getModel(), this.graphRenderHint, this.source.getStylesheet()), 
this.outline.foldingEnabled = !1, this.outline.autoScroll = !1;
var b = this.outline.graphModelChanged;
this.outline.graphModelChanged = mxUtils.bind(this, function() {
!this.suspended && null != this.outline && b.apply(this.outline, arguments);
}), mxClient.IS_SVG && (a = this.outline.getView().getCanvas().parentNode, a.setAttribute("shape-rendering", "optimizeSpeed"), 
a.setAttribute("image-rendering", "optimizeSpeed")), this.outline.labelsVisible = !1, 
this.outline.setEnabled(!1), this.updateHandler = mxUtils.bind(this, function() {
!this.suspended && !this.active && this.update();
}), this.source.getModel().addListener(mxEvent.CHANGE, this.updateHandler), this.outline.addMouseListener(this), 
a = this.source.getView(), a.addListener(mxEvent.SCALE, this.updateHandler), a.addListener(mxEvent.TRANSLATE, this.updateHandler), 
a.addListener(mxEvent.SCALE_AND_TRANSLATE, this.updateHandler), a.addListener(mxEvent.DOWN, this.updateHandler), 
a.addListener(mxEvent.UP, this.updateHandler), mxEvent.addListener(this.source.container, "scroll", this.updateHandler), 
this.panHandler = mxUtils.bind(this, function() {
this.updateOnPan && this.updateHandler.apply(this, arguments);
}), this.source.addListener(mxEvent.PAN, this.panHandler), this.refreshHandler = mxUtils.bind(this, function() {
this.outline.setStylesheet(this.source.getStylesheet()), this.outline.refresh();
}), this.source.addListener(mxEvent.REFRESH, this.refreshHandler), this.bounds = new mxRectangle(0, 0, 0, 0), 
this.selectionBorder = new mxRectangleShape(this.bounds, null, mxConstants.OUTLINE_COLOR, mxConstants.OUTLINE_STROKEWIDTH), 
this.selectionBorder.dialect = this.outline.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
this.selectionBorder.init(this.outline.getView().getOverlayPane()), a = mxUtils.bind(this, function(a) {
var b = mxEvent.getSource(a), e = mxUtils.bind(this, function(a) {
this.outline.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(a));
}), f = mxUtils.bind(this, function(a) {
mxEvent.removeGestureListeners(b, null, e, f), this.outline.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(a));
});
mxEvent.addGestureListeners(b, null, e, f), this.outline.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a));
}), mxEvent.addGestureListeners(this.selectionBorder.node, a), this.sizer = this.createSizer(), 
this.sizer.init(this.outline.getView().getOverlayPane()), this.enabled && (this.sizer.node.style.cursor = "pointer"), 
mxEvent.addGestureListeners(this.sizer.node, a), this.selectionBorder.node.style.display = this.showViewport ? "" :"none", 
this.sizer.node.style.display = this.selectionBorder.node.style.display, this.selectionBorder.node.style.cursor = "move", 
this.update(!1);
}, mxOutline.prototype.isEnabled = function() {
return this.enabled;
}, mxOutline.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxOutline.prototype.setZoomEnabled = function(a) {
this.sizer.node.style.visibility = a ? "visible" :"hidden";
}, mxOutline.prototype.refresh = function() {
this.update(!0);
}, mxOutline.prototype.createSizer = function() {
var a = null != this.sizerImage ? new mxImageShape(new mxRectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src) :new mxRectangleShape(new mxRectangle(0, 0, this.sizerSize, this.sizerSize), mxConstants.OUTLINE_HANDLE_FILLCOLOR, mxConstants.OUTLINE_HANDLE_STROKECOLOR);
return a.dialect = this.outline.dialect, a;
}, mxOutline.prototype.getSourceContainerSize = function() {
return new mxRectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);
}, mxOutline.prototype.getOutlineOffset = function() {
return null;
}, mxOutline.prototype.update = function(a) {
if (null != this.source) {
var b = this.source.view.scale, c = this.source.getGraphBounds(), c = new mxRectangle(c.x / b + this.source.panDx, c.y / b + this.source.panDy, c.width / b, c.height / b), d = new mxRectangle(0, 0, this.source.container.clientWidth / b, this.source.container.clientHeight / b), e = c.clone();
e.add(d);
var f = this.getSourceContainerSize(), d = Math.max(f.width / b, e.width), b = Math.max(f.height / b, e.height), e = Math.max(0, this.outline.container.clientWidth - this.border), f = Math.max(0, this.outline.container.clientHeight - this.border), e = Math.min(e / d, f / b);
if (e > 0) {
this.outline.getView().scale != e && (this.outline.getView().scale = e, a = !0), 
d = this.outline.getView(), d.currentRoot != this.source.getView().currentRoot && d.setCurrentRoot(this.source.getView().currentRoot);
var b = this.source.view.translate, f = b.x + this.source.panDx, g = b.y + this.source.panDy, e = this.getOutlineOffset(e);
null != e && (f += e.x, g += e.y), 0 > c.x && (f -= c.x), 0 > c.y && (g -= c.y), 
(d.translate.x != f || d.translate.y != g) && (d.translate.x = f, d.translate.y = g, 
a = !0);
var c = d.translate, e = this.source.getView().scale, f = e / d.scale, g = 1 / d.scale, h = this.source.container;
this.bounds = new mxRectangle((c.x - b.x - this.source.panDx) / g, (c.y - b.y - this.source.panDy) / g, h.clientWidth / f, h.clientHeight / f), 
this.bounds.x += this.source.container.scrollLeft * d.scale / e, this.bounds.y += this.source.container.scrollTop * d.scale / e, 
c = this.selectionBorder.bounds, (c.x != this.bounds.x || c.y != this.bounds.y || c.width != this.bounds.width || c.height != this.bounds.height) && (this.selectionBorder.bounds = this.bounds, 
this.selectionBorder.redraw()), c = this.sizer.bounds, d = new mxRectangle(this.bounds.x + this.bounds.width - c.width / 2, this.bounds.y + this.bounds.height - c.height / 2, c.width, c.height), 
(c.x != d.x || c.y != d.y || c.width != d.width || c.height != d.height) && (this.sizer.bounds = d, 
"hidden" != this.sizer.node.style.visibility && this.sizer.redraw()), a && this.outline.view.revalidate();
}
}
}, mxOutline.prototype.mouseDown = function(a, b) {
this.enabled && this.showViewport && (this.zoom = b.isSource(this.sizer), this.startX = b.getX(), 
this.startY = b.getY(), this.active = !0, this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container) ? (this.dx0 = this.source.container.scrollLeft, 
this.dy0 = this.source.container.scrollTop) :this.dy0 = this.dx0 = 0), b.consume();
}, mxOutline.prototype.mouseMove = function(a, b) {
if (this.active) {
this.selectionBorder.node.style.display = this.showViewport ? "" :"none", this.sizer.node.style.display = this.selectionBorder.node.style.display;
var c = this.getTranslateForEvent(b), d = c.x, e = c.y, c = null;
if (this.zoom) c = this.source.container, e = d / (c.clientWidth / c.clientHeight), 
c = new mxRectangle(this.bounds.x, this.bounds.y, Math.max(1, this.bounds.width + d), Math.max(1, this.bounds.height + e)), 
this.selectionBorder.bounds = c, this.selectionBorder.redraw(); else {
var f = this.outline.getView().scale, c = new mxRectangle(this.bounds.x + d, this.bounds.y + e, this.bounds.width, this.bounds.height);
this.selectionBorder.bounds = c, this.selectionBorder.redraw(), d = d / f * this.source.getView().scale, 
e = e / f * this.source.getView().scale, this.source.panGraph(-d - this.dx0, -e - this.dy0);
}
d = this.sizer.bounds, this.sizer.bounds = new mxRectangle(c.x + c.width - d.width / 2, c.y + c.height - d.height / 2, d.width, d.height), 
"hidden" != this.sizer.node.style.visibility && this.sizer.redraw(), b.consume();
}
}, mxOutline.prototype.getTranslateForEvent = function(a) {
return new mxPoint(a.getX() - this.startX, a.getY() - this.startY);
}, mxOutline.prototype.mouseUp = function(a, b) {
if (this.active) {
var c = this.getTranslateForEvent(b), d = c.x, c = c.y;
if (0 < Math.abs(d) || 0 < Math.abs(c)) {
if (this.zoom) {
var c = this.selectionBorder.bounds.width, e = this.source.getView().scale;
this.source.zoomTo(e - d * e / c, !1);
} else this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container) || (this.source.panGraph(0, 0), 
d /= this.outline.getView().scale, c /= this.outline.getView().scale, e = this.source.getView().translate, 
this.source.getView().setTranslate(e.x - d, e.y - c));
this.update(), b.consume();
}
this.index = null, this.active = !1;
}
}, mxOutline.prototype.destroy = function() {
null != this.source && (this.source.removeListener(this.panHandler), this.source.removeListener(this.refreshHandler), 
this.source.getModel().removeListener(this.updateHandler), this.source.getView().removeListener(this.updateHandler), 
mxEvent.addListener(this.source.container, "scroll", this.updateHandler), this.source = null), 
null != this.outline && (this.outline.removeMouseListener(this), this.outline.destroy(), 
this.outline = null), null != this.selectionBorder && (this.selectionBorder.destroy(), 
this.selectionBorder = null), null != this.sizer && (this.sizer.destroy(), this.sizer = null);
}, mxMultiplicity.prototype.type = null, mxMultiplicity.prototype.attr = null, mxMultiplicity.prototype.value = null, 
mxMultiplicity.prototype.source = null, mxMultiplicity.prototype.min = null, mxMultiplicity.prototype.max = null, 
mxMultiplicity.prototype.validNeighbors = null, mxMultiplicity.prototype.validNeighborsAllowed = !0, 
mxMultiplicity.prototype.countError = null, mxMultiplicity.prototype.typeError = null, 
mxMultiplicity.prototype.check = function(a, b, c, d, e, f) {
var g = "";
return (this.source && this.checkTerminal(a, c, b) || !this.source && this.checkTerminal(a, d, b)) && (null != this.countError && (this.source && (0 == this.max || e >= this.max) || !this.source && (0 == this.max || f >= this.max)) && (g += this.countError + "\n"), 
null != this.validNeighbors && null != this.typeError && 0 < this.validNeighbors.length && (this.checkNeighbors(a, b, c, d) || (g += this.typeError + "\n"))), 
0 < g.length ? g :null;
}, mxMultiplicity.prototype.checkNeighbors = function(a, b, c, d) {
b = a.model.getValue(c), d = a.model.getValue(d), c = !this.validNeighborsAllowed;
for (var e = this.validNeighbors, f = 0; f < e.length; f++) {
if (this.source && this.checkType(a, d, e[f])) {
c = this.validNeighborsAllowed;
break;
}
if (!this.source && this.checkType(a, b, e[f])) {
c = this.validNeighborsAllowed;
break;
}
}
return c;
}, mxMultiplicity.prototype.checkTerminal = function(a, b) {
return b = a.model.getValue(b), this.checkType(a, b, this.type, this.attr, this.value);
}, mxMultiplicity.prototype.checkType = function(a, b, c, d, e) {
return null != b ? isNaN(b.nodeType) ? b == c :mxUtils.isNode(b, c, d, e) :!1;
}, mxLayoutManager.prototype = new mxEventSource(), mxLayoutManager.prototype.constructor = mxLayoutManager, 
mxLayoutManager.prototype.graph = null, mxLayoutManager.prototype.bubbling = !0, 
mxLayoutManager.prototype.enabled = !0, mxLayoutManager.prototype.updateHandler = null, 
mxLayoutManager.prototype.moveHandler = null, mxLayoutManager.prototype.isEnabled = function() {
return this.enabled;
}, mxLayoutManager.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxLayoutManager.prototype.isBubbling = function() {
return this.bubbling;
}, mxLayoutManager.prototype.setBubbling = function(a) {
this.bubbling = a;
}, mxLayoutManager.prototype.getGraph = function() {
return this.graph;
}, mxLayoutManager.prototype.setGraph = function(a) {
if (null != this.graph) {
var b = this.graph.getModel();
b.removeListener(this.undoHandler), this.graph.removeListener(this.moveHandler);
}
this.graph = a, null != this.graph && (b = this.graph.getModel(), b.addListener(mxEvent.BEFORE_UNDO, this.undoHandler), 
this.graph.addListener(mxEvent.MOVE_CELLS, this.moveHandler));
}, mxLayoutManager.prototype.getLayout = function() {
return null;
}, mxLayoutManager.prototype.beforeUndo = function(a) {
a = this.getCellsForChanges(a.changes);
var b = this.getGraph().getModel();
if (this.isBubbling()) for (var c = b.getParents(a); 0 < c.length; ) a = a.concat(c), 
c = b.getParents(c);
this.layoutCells(mxUtils.sortCells(a, !1));
}, mxLayoutManager.prototype.cellsMoved = function(a, b) {
if (null != a && null != b) for (var c = mxUtils.convertPoint(this.getGraph().container, mxEvent.getClientX(b), mxEvent.getClientY(b)), d = this.getGraph().getModel(), e = 0; e < a.length; e++) {
var f = this.getLayout(d.getParent(a[e]));
null != f && f.moveCell(a[e], c.x, c.y);
}
}, mxLayoutManager.prototype.getCellsForChanges = function(a) {
for (var b = [], c = {}, d = 0; d < a.length; d++) {
var e = a[d];
if (e instanceof mxRootChange) return [];
for (var e = this.getCellsForChange(e), f = 0; f < e.length; f++) if (null != e[f]) {
var g = mxCellPath.create(e[f]);
null == c[g] && (c[g] = e[f], b.push(e[f]));
}
}
return b;
}, mxLayoutManager.prototype.getCellsForChange = function(a) {
var b = this.getGraph().getModel();
return a instanceof mxChildChange ? [ a.child, a.previous, b.getParent(a.child) ] :a instanceof mxTerminalChange || a instanceof mxGeometryChange ? [ a.cell, b.getParent(a.cell) ] :[];
}, mxLayoutManager.prototype.layoutCells = function(a) {
if (0 < a.length) {
var b = this.getGraph().getModel();
b.beginUpdate();
try {
for (var c = null, d = 0; d < a.length; d++) a[d] != b.getRoot() && a[d] != c && (c = a[d], 
this.executeLayout(this.getLayout(c), c));
this.fireEvent(new mxEventObject(mxEvent.LAYOUT_CELLS, "cells", a));
} finally {
b.endUpdate();
}
}
}, mxLayoutManager.prototype.executeLayout = function(a, b) {
null != a && null != b && a.execute(b);
}, mxLayoutManager.prototype.destroy = function() {
this.setGraph(null);
}, mxSpaceManager.prototype = new mxEventSource(), mxSpaceManager.prototype.constructor = mxSpaceManager, 
mxSpaceManager.prototype.graph = null, mxSpaceManager.prototype.enabled = !0, mxSpaceManager.prototype.shiftRightwards = !0, 
mxSpaceManager.prototype.shiftDownwards = !0, mxSpaceManager.prototype.extendParents = !0, 
mxSpaceManager.prototype.resizeHandler = null, mxSpaceManager.prototype.foldHandler = null, 
mxSpaceManager.prototype.isCellIgnored = function(a) {
return !this.getGraph().getModel().isVertex(a);
}, mxSpaceManager.prototype.isCellShiftable = function(a) {
return this.getGraph().getModel().isVertex(a) && this.getGraph().isCellMovable(a);
}, mxSpaceManager.prototype.isEnabled = function() {
return this.enabled;
}, mxSpaceManager.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxSpaceManager.prototype.isShiftRightwards = function() {
return this.shiftRightwards;
}, mxSpaceManager.prototype.setShiftRightwards = function(a) {
this.shiftRightwards = a;
}, mxSpaceManager.prototype.isShiftDownwards = function() {
return this.shiftDownwards;
}, mxSpaceManager.prototype.setShiftDownwards = function(a) {
this.shiftDownwards = a;
}, mxSpaceManager.prototype.isExtendParents = function() {
return this.extendParents;
}, mxSpaceManager.prototype.setExtendParents = function(a) {
this.extendParents = a;
}, mxSpaceManager.prototype.getGraph = function() {
return this.graph;
}, mxSpaceManager.prototype.setGraph = function(a) {
null != this.graph && (this.graph.removeListener(this.resizeHandler), this.graph.removeListener(this.foldHandler)), 
this.graph = a, null != this.graph && (this.graph.addListener(mxEvent.RESIZE_CELLS, this.resizeHandler), 
this.graph.addListener(mxEvent.FOLD_CELLS, this.foldHandler));
}, mxSpaceManager.prototype.cellsResized = function(a) {
if (null != a) {
var b = this.graph.getModel();
b.beginUpdate();
try {
for (var c = 0; c < a.length; c++) if (!this.isCellIgnored(a[c])) {
this.cellResized(a[c]);
break;
}
} finally {
b.endUpdate();
}
}
}, mxSpaceManager.prototype.cellResized = function(a) {
var b = this.getGraph(), c = b.getView(), d = b.getModel(), e = c.getState(a), f = c.getState(d.getParent(a));
if (null != e && null != f) {
var g = this.getCellsToShift(e), h = d.getGeometry(a);
if (null != g && null != h) {
var k = c.translate, l = c.scale, c = e.x - f.origin.x - k.x * l, f = e.y - f.origin.y - k.y * l, k = e.x + e.width, m = e.y + e.height, n = e.width - h.width * l + c - h.x * l, p = e.height - h.height * l + f - h.y * l, q = 1 - h.width * l / e.width, e = 1 - h.height * l / e.height;
d.beginUpdate();
try {
for (h = 0; h < g.length; h++) g[h] != a && this.isCellShiftable(g[h]) && this.shiftCell(g[h], n, p, c, f, k, m, q, e, this.isExtendParents() && b.isExtendParent(g[h]));
} finally {
d.endUpdate();
}
}
}
}, mxSpaceManager.prototype.shiftCell = function(a, b, c, d, e, f, g, h, k, l) {
d = this.getGraph();
var m = d.getView().getState(a);
if (null != m) {
var n = d.getModel(), p = n.getGeometry(a);
if (null != p) {
n.beginUpdate();
try {
if (this.isShiftRightwards()) if (m.x >= f) p = p.clone(), p.translate(-b, 0); else {
var q = Math.max(0, m.x - x0), p = p.clone();
p.translate(-h * q, 0);
}
if (this.isShiftDownwards()) if (m.y >= g) p = p.clone(), p.translate(0, -c); else {
var s = Math.max(0, m.y - e), p = p.clone();
p.translate(0, -k * s);
}
p != n.getGeometry(a) && (n.setGeometry(a, p), l && d.extendParent(a));
} finally {
n.endUpdate();
}
}
}
}, mxSpaceManager.prototype.getCellsToShift = function(a) {
var b = this.getGraph(), c = b.getModel().getParent(a.cell), d = this.isShiftDownwards(), e = this.isShiftRightwards();
return b.getCellsBeyond(a.x + (d ? 0 :a.width), a.y + (d && e ? 0 :a.height), c, e, d);
}, mxSpaceManager.prototype.destroy = function() {
this.setGraph(null);
}, mxSwimlaneManager.prototype = new mxEventSource(), mxSwimlaneManager.prototype.constructor = mxSwimlaneManager, 
mxSwimlaneManager.prototype.graph = null, mxSwimlaneManager.prototype.enabled = !0, 
mxSwimlaneManager.prototype.horizontal = !0, mxSwimlaneManager.prototype.addEnabled = !0, 
mxSwimlaneManager.prototype.resizeEnabled = !0, mxSwimlaneManager.prototype.addHandler = null, 
mxSwimlaneManager.prototype.resizeHandler = null, mxSwimlaneManager.prototype.isEnabled = function() {
return this.enabled;
}, mxSwimlaneManager.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxSwimlaneManager.prototype.isHorizontal = function() {
return this.horizontal;
}, mxSwimlaneManager.prototype.setHorizontal = function(a) {
this.horizontal = a;
}, mxSwimlaneManager.prototype.isAddEnabled = function() {
return this.addEnabled;
}, mxSwimlaneManager.prototype.setAddEnabled = function(a) {
this.addEnabled = a;
}, mxSwimlaneManager.prototype.isResizeEnabled = function() {
return this.resizeEnabled;
}, mxSwimlaneManager.prototype.setResizeEnabled = function(a) {
this.resizeEnabled = a;
}, mxSwimlaneManager.prototype.getGraph = function() {
return this.graph;
}, mxSwimlaneManager.prototype.setGraph = function(a) {
null != this.graph && (this.graph.removeListener(this.addHandler), this.graph.removeListener(this.resizeHandler)), 
this.graph = a, null != this.graph && (this.graph.addListener(mxEvent.ADD_CELLS, this.addHandler), 
this.graph.addListener(mxEvent.CELLS_RESIZED, this.resizeHandler));
}, mxSwimlaneManager.prototype.isSwimlaneIgnored = function(a) {
return !this.getGraph().isSwimlane(a);
}, mxSwimlaneManager.prototype.isCellHorizontal = function(a) {
if (this.graph.isSwimlane(a)) {
var b = this.graph.view.getState(a);
return a = null != b ? b.style :this.graph.getCellStyle(a), 1 == mxUtils.getValue(a, mxConstants.STYLE_HORIZONTAL, 1);
}
return !this.isHorizontal();
}, mxSwimlaneManager.prototype.cellsAdded = function(a) {
if (null != a) {
var b = this.getGraph().getModel();
b.beginUpdate();
try {
for (var c = 0; c < a.length; c++) this.isSwimlaneIgnored(a[c]) || this.swimlaneAdded(a[c]);
} finally {
b.endUpdate();
}
}
}, mxSwimlaneManager.prototype.swimlaneAdded = function(a) {
for (var b = this.getGraph().getModel(), c = b.getParent(a), d = b.getChildCount(c), e = null, f = 0; d > f; f++) {
var g = b.getChildAt(c, f);
if (g != a && !this.isSwimlaneIgnored(g) && (e = b.getGeometry(g), null != e)) break;
}
null != e && this.resizeSwimlane(a, e.width, e.height);
}, mxSwimlaneManager.prototype.cellsResized = function(a) {
if (null != a) {
var b = this.getGraph().getModel();
b.beginUpdate();
try {
for (var c = 0; c < a.length; c++) if (!this.isSwimlaneIgnored(a[c])) {
var d = b.getGeometry(a[c]);
if (null != d) {
for (var e = new mxRectangle(0, 0, d.width, d.height), f = a[c], g = f; null != g; ) {
var f = g, g = b.getParent(g), h = this.graph.isSwimlane(g) ? this.graph.getStartSize(g) :new mxRectangle();
e.width += h.width, e.height += h.height;
}
this.resizeSwimlane(f, e.width, e.height);
}
}
} finally {
b.endUpdate();
}
}
}, mxSwimlaneManager.prototype.resizeSwimlane = function(a, b, c) {
var d = this.getGraph().getModel();
d.beginUpdate();
try {
if (!this.isSwimlaneIgnored(a)) {
var e = d.getGeometry(a);
if (null != e) {
var f = this.isCellHorizontal(a);
(f && e.height != c || !f && e.width != b) && (e = e.clone(), f ? e.height = c :e.width = b, 
d.setGeometry(a, e));
}
}
var g = this.graph.isSwimlane(a) ? this.graph.getStartSize(a) :new mxRectangle();
b -= g.width, c -= g.height;
for (var h = d.getChildCount(a), e = 0; h > e; e++) {
var k = d.getChildAt(a, e);
this.resizeSwimlane(k, b, c);
}
} finally {
d.endUpdate();
}
}, mxSwimlaneManager.prototype.destroy = function() {
this.setGraph(null);
}, mxTemporaryCellStates.prototype.view = null, mxTemporaryCellStates.prototype.oldStates = null, 
mxTemporaryCellStates.prototype.oldBounds = null, mxTemporaryCellStates.prototype.oldScale = null, 
mxTemporaryCellStates.prototype.destroy = function() {
this.view.setScale(this.oldScale), this.view.setStates(this.oldStates), this.view.setGraphBounds(this.oldBounds);
}, mxCellStatePreview.prototype.graph = null, mxCellStatePreview.prototype.deltas = null, 
mxCellStatePreview.prototype.count = 0, mxCellStatePreview.prototype.isEmpty = function() {
return 0 == this.count;
}, mxCellStatePreview.prototype.moveState = function(a, b, c, d, e) {
d = null != d ? d :!0, e = null != e ? e :!0;
var f = mxCellPath.create(a.cell), g = this.deltas[f];
return null == g ? (g = new mxPoint(b, c), this.deltas[f] = g, this.count++) :d ? (g.X += b, 
g.Y += c) :(g.X = b, g.Y = c), e && this.addEdges(a), g;
}, mxCellStatePreview.prototype.show = function(a) {
var d, b = this.graph.getModel(), c = b.getRoot();
for (d in this.deltas) {
var e = mxCellPath.resolve(c, d), f = this.graph.view.getState(e), g = this.deltas[d], e = this.graph.view.getState(b.getParent(e));
this.translateState(e, f, g.x, g.y);
}
for (d in this.deltas) e = mxCellPath.resolve(c, d), f = this.graph.view.getState(e), 
g = this.deltas[d], e = this.graph.view.getState(b.getParent(e)), this.revalidateState(e, f, g.x, g.y, a);
}, mxCellStatePreview.prototype.translateState = function(a, b, c, d) {
if (null != b) {
var e = this.graph.getModel();
if (e.isVertex(b.cell)) {
b.invalid = !0, this.graph.view.validateBounds(a, b.cell), a = e.getGeometry(b.cell);
var f = mxCellPath.create(b.cell);
0 == c && 0 == d || null == a || a.relative && null == this.deltas[f] || (b.x += c, 
b.y += d);
}
for (a = e.getChildCount(b.cell), f = 0; a > f; f++) this.translateState(b, this.graph.view.getState(e.getChildAt(b.cell, f)), c, d);
}
}, mxCellStatePreview.prototype.revalidateState = function(a, b, c, d, e) {
if (null != b) {
b.invalid = !0, this.graph.view.validatePoints(a, b.cell);
var f = mxCellPath.create(b.cell), g = this.graph.getModel(), h = this.graph.getCellGeometry(b.cell);
for (0 == c && 0 == d || null == h || !h.relative || !g.isVertex(b.cell) || null != a && !g.isVertex(a.cell) && null == this.deltas[f] || (b.x += c, 
b.y += d, this.graph.cellRenderer.redraw(b)), null != e && e(b), a = g.getChildCount(b.cell), 
f = 0; a > f; f++) this.revalidateState(b, this.graph.view.getState(g.getChildAt(b.cell, f)), c, d, e);
}
}, mxCellStatePreview.prototype.addEdges = function(a) {
for (var b = this.graph.getModel(), c = b.getEdgeCount(a.cell), d = 0; c > d; d++) {
var e = this.graph.view.getState(b.getEdgeAt(a.cell, d));
null != e && this.moveState(e, 0, 0);
}
}, mxConnectionConstraint.prototype.point = null, mxConnectionConstraint.prototype.perimeter = null, 
mxGraphHandler.prototype.graph = null, mxGraphHandler.prototype.maxCells = mxClient.IS_IE ? 20 :50, 
mxGraphHandler.prototype.enabled = !0, mxGraphHandler.prototype.highlightEnabled = !0, 
mxGraphHandler.prototype.cloneEnabled = !0, mxGraphHandler.prototype.moveEnabled = !0, 
mxGraphHandler.prototype.guidesEnabled = !1, mxGraphHandler.prototype.guide = null, 
mxGraphHandler.prototype.currentDx = null, mxGraphHandler.prototype.currentDy = null, 
mxGraphHandler.prototype.updateCursor = !0, mxGraphHandler.prototype.selectEnabled = !0, 
mxGraphHandler.prototype.removeCellsFromParent = !0, mxGraphHandler.prototype.connectOnDrop = !1, 
mxGraphHandler.prototype.scrollOnMove = !0, mxGraphHandler.prototype.minimumSize = 6, 
mxGraphHandler.prototype.previewColor = "black", mxGraphHandler.prototype.htmlPreview = !1, 
mxGraphHandler.prototype.shape = null, mxGraphHandler.prototype.scaleGrid = !1, 
mxGraphHandler.prototype.rotationEnabled = !0, mxGraphHandler.prototype.isEnabled = function() {
return this.enabled;
}, mxGraphHandler.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxGraphHandler.prototype.isCloneEnabled = function() {
return this.cloneEnabled;
}, mxGraphHandler.prototype.setCloneEnabled = function(a) {
this.cloneEnabled = a;
}, mxGraphHandler.prototype.isMoveEnabled = function() {
return this.moveEnabled;
}, mxGraphHandler.prototype.setMoveEnabled = function(a) {
this.moveEnabled = a;
}, mxGraphHandler.prototype.isSelectEnabled = function() {
return this.selectEnabled;
}, mxGraphHandler.prototype.setSelectEnabled = function(a) {
this.selectEnabled = a;
}, mxGraphHandler.prototype.isRemoveCellsFromParent = function() {
return this.removeCellsFromParent;
}, mxGraphHandler.prototype.setRemoveCellsFromParent = function(a) {
this.removeCellsFromParent = a;
}, mxGraphHandler.prototype.getInitialCellForEvent = function(a) {
return a.getCell();
}, mxGraphHandler.prototype.isDelayedSelection = function(a) {
return this.graph.isCellSelected(a);
}, mxGraphHandler.prototype.mouseDown = function(a, b) {
if (!b.isConsumed() && this.isEnabled() && this.graph.isEnabled() && !this.graph.isForceMarqueeEvent(b.getEvent()) && null != b.getState()) {
var c = this.getInitialCellForEvent(b);
if (this.cell = null, this.delayedSelection = this.isDelayedSelection(c), this.isSelectEnabled() && !this.delayedSelection && this.graph.selectCellForEvent(c, b.getEvent()), 
this.isMoveEnabled()) {
var d = this.graph.model, e = d.getGeometry(c);
this.graph.isCellMovable(c) && (!d.isEdge(c) || 1 < this.graph.getSelectionCount() || null != e.points && 0 < e.points.length || null == d.getTerminal(c, !0) || null == d.getTerminal(c, !1) || this.graph.allowDanglingEdges || this.graph.isCloneEvent(b.getEvent()) && this.graph.isCellsCloneable()) && this.start(c, b.getX(), b.getY()), 
this.cellWasClicked = !0, !mxClient.IS_SF && !mxClient.IS_GC || "SELECT" != b.getSource().nodeName ? b.consume() :mxClient.IS_SF && "SELECT" == b.getSource().nodeName && (this.cellWasClicked = !1, 
this.first = null);
}
}
}, mxGraphHandler.prototype.getGuideStates = function() {
var a = this.graph.getDefaultParent(), b = this.graph.getModel(), c = mxUtils.bind(this, function(a) {
return null != this.graph.view.getState(a) && b.isVertex(a) && null != b.getGeometry(a) && !b.getGeometry(a).relative;
});
return this.graph.view.getCellStates(b.filterDescendants(c, a));
}, mxGraphHandler.prototype.getCells = function(a) {
return !this.delayedSelection && this.graph.isCellMovable(a) ? [ a ] :this.graph.getMovableCells(this.graph.getSelectionCells());
}, mxGraphHandler.prototype.getPreviewBounds = function(a) {
return a = this.getBoundingBox(a), null != a && (a.grow(-1, -1), a.width < this.minimumSize && (a.x -= (this.minimumSize - a.width) / 2, 
a.width = this.minimumSize), a.height < this.minimumSize && (a.y -= (this.minimumSize - a.height) / 2, 
a.height = this.minimumSize)), a;
}, mxGraphHandler.prototype.getBoundingBox = function(a) {
var b = null;
if (null != a && 0 < a.length) for (var c = this.graph.getModel(), d = 0; d < a.length; d++) if (c.isVertex(a[d]) || c.isEdge(a[d])) {
var e = this.graph.view.getState(a[d]);
if (null != e) {
var f = e;
c.isVertex(a[d]) && null != e.shape && null != e.shape.boundingBox && (f = e.shape.boundingBox), 
null == b ? b = new mxRectangle(f.x, f.y, f.width, f.height) :b.add(f);
}
}
return b;
}, mxGraphHandler.prototype.createPreviewShape = function(a) {
return a = new mxRectangleShape(a, null, this.previewColor), a.isDashed = !0, this.htmlPreview ? (a.dialect = mxConstants.DIALECT_STRICTHTML, 
a.init(this.graph.container)) :(a.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
a.init(this.graph.getView().getOverlayPane()), a.pointerEvents = !1), a;
}, mxGraphHandler.prototype.start = function(a, b, c) {
this.cell = a, this.first = mxUtils.convertPoint(this.graph.container, b, c), this.cells = this.getCells(this.cell), 
this.bounds = this.graph.getView().getBounds(this.cells), this.pBounds = this.getPreviewBounds(this.cells), 
this.guidesEnabled && (this.guide = new mxGuide(this.graph, this.getGuideStates()));
}, mxGraphHandler.prototype.useGuidesForEvent = function(a) {
return null != this.guide ? this.guide.isEnabledForEvent(a.getEvent()) :!0;
}, mxGraphHandler.prototype.snap = function(a) {
var b = this.scaleGrid ? this.graph.view.scale :1;
return a.x = this.graph.snap(a.x / b) * b, a.y = this.graph.snap(a.y / b) * b, a;
}, mxGraphHandler.prototype.mouseMove = function(a, b) {
var c = this.graph;
if (!b.isConsumed() && c.isMouseDown && null != this.cell && null != this.first && null != this.bounds) {
var d = mxUtils.convertPoint(c.container, b.getX(), b.getY()), e = d.x - this.first.x, f = d.y - this.first.y, d = c.tolerance;
if (null != this.shape || Math.abs(e) > d || Math.abs(f) > d) {
null == this.highlight && (this.highlight = new mxCellHighlight(this.graph, mxConstants.DROP_TARGET_COLOR, 3)), 
null == this.shape && (this.shape = this.createPreviewShape(this.bounds));
var g = c.isGridEnabledEvent(b.getEvent()), d = !0;
if (null != this.guide && this.useGuidesForEvent(b)) f = this.guide.move(this.bounds, new mxPoint(e, f), g), 
d = !1, e = f.x, f = f.y; else if (g) var h = c.getView().translate, k = c.getView().scale, g = this.bounds.x - (c.snap(this.bounds.x / k - h.x) + h.x) * k, h = this.bounds.y - (c.snap(this.bounds.y / k - h.y) + h.y) * k, f = this.snap(new mxPoint(e, f)), e = f.x - g, f = f.y - h;
for (null != this.guide && d && this.guide.hide(), c.isConstrainedEvent(b.getEvent()) && (Math.abs(e) > Math.abs(f) ? f = 0 :e = 0), 
this.currentDx = e, this.currentDy = f, this.updatePreviewShape(), d = null, f = b.getCell(), 
c.isDropEnabled() && this.highlightEnabled && (d = c.getDropTarget(this.cells, b.getEvent(), f)), 
g = d, h = c.getModel(); null != g && g != this.cells[0]; ) g = h.getParent(g);
var k = c.isCloneEvent(b.getEvent()) && c.isCellsCloneable() && this.isCloneEnabled(), e = c.getView().getState(d), l = !1;
null == e || null != g || h.getParent(this.cell) == d && !k ? (this.target = null, 
this.connectOnDrop && null != f && 1 == this.cells.length && c.getModel().isVertex(f) && c.isCellConnectable(f) && (e = c.getView().getState(f), 
null != e && (c = null == c.getEdgeValidationError(null, this.cell, f) ? mxConstants.VALID_COLOR :mxConstants.INVALID_CONNECT_TARGET_COLOR, 
this.setHighlightColor(c), l = !0))) :(this.target != d && (this.target = d, this.setHighlightColor(mxConstants.DROP_TARGET_COLOR)), 
l = !0), null != e && l ? this.highlight.highlight(e) :this.highlight.hide();
}
b.consume(), mxEvent.consume(b.getEvent());
} else !this.isMoveEnabled() && !this.isCloneEnabled() || !this.updateCursor || b.isConsumed() || null == b.getState() || c.isMouseDown || (e = c.getCursorForCell(b.getCell()), 
null == e && c.isEnabled() && c.isCellMovable(b.getCell()) && (e = c.getModel().isEdge(b.getCell()) ? mxConstants.CURSOR_MOVABLE_EDGE :mxConstants.CURSOR_MOVABLE_VERTEX), 
b.getState().setCursor(e), b.consume());
}, mxGraphHandler.prototype.updatePreviewShape = function() {
null != this.shape && (this.shape.bounds = new mxRectangle(Math.round(this.pBounds.x + this.currentDx - this.graph.panDx), Math.round(this.pBounds.y + this.currentDy - this.graph.panDy), this.pBounds.width, this.pBounds.height), 
this.shape.redraw());
}, mxGraphHandler.prototype.setHighlightColor = function(a) {
null != this.highlight && this.highlight.setHighlightColor(a);
}, mxGraphHandler.prototype.mouseUp = function(a, b) {
if (!b.isConsumed()) {
var c = this.graph;
if (null != this.cell && null != this.first && null != this.shape && null != this.currentDx && null != this.currentDy) {
var d = c.getView().scale, e = c.isCloneEvent(b.getEvent()) && c.isCellsCloneable() && this.isCloneEnabled(), f = this.currentDx / d, d = this.currentDy / d, g = b.getCell();
this.connectOnDrop && null == this.target && null != g && c.getModel().isVertex(g) && c.isCellConnectable(g) && c.isEdgeValid(null, this.cell, g) ? c.connectionHandler.connect(this.cell, g, b.getEvent()) :(g = this.target, 
c.isSplitEnabled() && c.isSplitTarget(g, this.cells, b.getEvent()) ? c.splitEdge(g, this.cells, null, f, d) :this.moveCells(this.cells, f, d, e, this.target, b.getEvent()));
} else this.isSelectEnabled() && this.delayedSelection && null != this.cell && this.selectDelayed(b);
}
this.cellWasClicked && b.consume(), this.reset();
}, mxGraphHandler.prototype.selectDelayed = function(a) {
this.graph.selectCellForEvent(this.cell, a.getEvent());
}, mxGraphHandler.prototype.reset = function() {
this.destroyShapes(), this.delayedSelection = this.cellWasClicked = !1, this.target = this.cell = this.first = this.guides = this.currentDy = this.currentDx = null;
}, mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(a, b, c) {
if (this.graph.getModel().isVertex(a)) {
a = this.graph.getView().getState(a), c = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(c), mxEvent.getClientY(c));
var d = mxUtils.toRadians(mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION) || 0);
if (0 != d) {
b = Math.cos(-d);
var d = Math.sin(-d), e = new mxPoint(a.getCenterX(), a.getCenterY());
c = mxUtils.getRotatedPoint(c, b, d, e);
}
return null != a && !mxUtils.contains(a, c.x, c.y);
}
return !1;
}, mxGraphHandler.prototype.moveCells = function(a, b, c, d, e, f) {
d && (a = this.graph.getCloneableCells(a)), null == e && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(this.graph.getModel().getParent(this.cell), a, f) && (e = this.graph.getDefaultParent()), 
a = this.graph.moveCells(a, b - this.graph.panDx / this.graph.view.scale, c - this.graph.panDy / this.graph.view.scale, d, e, f), 
this.isSelectEnabled() && this.scrollOnMove && this.graph.scrollCellToVisible(a[0]), 
d && this.graph.setSelectionCells(a);
}, mxGraphHandler.prototype.destroyShapes = function() {
null != this.shape && (this.shape.destroy(), this.shape = null), null != this.guide && (this.guide.destroy(), 
this.guide = null), null != this.highlight && (this.highlight.destroy(), this.highlight = null);
}, mxGraphHandler.prototype.destroy = function() {
this.graph.removeMouseListener(this), this.graph.removeListener(this.panHandler), 
this.destroyShapes();
}, mxPanningHandler.prototype = new mxPopupMenu(), mxPanningHandler.prototype.constructor = mxPanningHandler, 
mxPanningHandler.prototype.graph = null, mxPanningHandler.prototype.triggerX = null, 
mxPanningHandler.prototype.triggerY = null, mxPanningHandler.prototype.usePopupTrigger = !0, 
mxPanningHandler.prototype.useLeftButtonForPanning = !1, mxPanningHandler.prototype.selectOnPopup = !0, 
mxPanningHandler.prototype.clearSelectionOnBackground = !0, mxPanningHandler.prototype.ignoreCell = !1, 
mxPanningHandler.prototype.previewEnabled = !0, mxPanningHandler.prototype.useGrid = !1, 
mxPanningHandler.prototype.panningEnabled = !0, mxPanningHandler.prototype.isPanningEnabled = function() {
return this.panningEnabled;
}, mxPanningHandler.prototype.setPanningEnabled = function(a) {
this.panningEnabled = a;
}, mxPanningHandler.prototype.init = function() {
mxPopupMenu.prototype.init.apply(this), mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function() {
this.graph.tooltipHandler.hide();
}));
}, mxPanningHandler.prototype.isPanningTrigger = function(a) {
var b = a.getEvent();
return this.useLeftButtonForPanning && (this.ignoreCell || null == a.getState()) && mxEvent.isLeftMouseButton(b) || mxEvent.isControlDown(b) && mxEvent.isShiftDown(b) || this.usePopupTrigger && mxEvent.isPopupTrigger(b);
}, mxPanningHandler.prototype.mouseDown = function(a, b) {
if (!b.isConsumed() && this.isEnabled() && !this.active) {
this.hideMenu(), this.dx0 = -this.graph.container.scrollLeft, this.dy0 = -this.graph.container.scrollTop;
var c = mxUtils.convertPoint(this.graph.container, b.getX(), b.getY());
this.triggerX = c.x, this.triggerY = c.y, this.popupTrigger = this.isPopupTrigger(b), 
this.panningTrigger = this.isPanningEnabled() && this.isPanningTrigger(b), this.startX = b.getX(), 
this.startY = b.getY(), this.panningTrigger && this.consumePanningTrigger(b);
}
}, mxPanningHandler.prototype.consumePanningTrigger = function(a) {
a.consume();
}, mxPanningHandler.prototype.mouseMove = function(a, b) {
var c = b.getX() - this.startX, d = b.getY() - this.startY;
if (this.active) {
var e = b.getEvent().scale;
null != e && 1 != e ? this.scaleGraph(e, !0) :this.previewEnabled && (this.useGrid && (c = this.graph.snap(c), 
d = this.graph.snap(d)), this.graph.panGraph(c + this.dx0, d + this.dy0)), this.fireEvent(new mxEventObject(mxEvent.PAN, "event", b)), 
b.consume();
} else this.panningTrigger && (e = this.active, this.active = Math.abs(c) > this.graph.tolerance || Math.abs(d) > this.graph.tolerance, 
!e && this.active && this.fireEvent(new mxEventObject(mxEvent.PAN_START, "event", b)));
}, mxPanningHandler.prototype.mouseUp = function(a, b) {
var c = Math.abs(b.getX() - this.startX), d = Math.abs(b.getY() - this.startY);
if (this.active) {
if (!this.graph.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.graph.container)) {
c = b.getX() - this.startX, d = b.getY() - this.startY, this.useGrid && (c = this.graph.snap(c), 
d = this.graph.snap(d));
var e = this.graph.getView().scale, f = this.graph.getView().translate;
this.graph.panGraph(0, 0);
var g = b.getEvent().scale;
null != g && 1 != g ? this.scaleGraph(g, !1) :this.panGraph(f.x + c / e, f.y + d / e);
}
this.active = !1, this.fireEvent(new mxEventObject(mxEvent.PAN_END, "event", b)), 
b.consume();
} else this.popupTrigger && c < this.graph.tolerance && d < this.graph.tolerance && (c = this.getCellForPopupEvent(b), 
this.graph.isEnabled() && this.selectOnPopup && null != c && !this.graph.isCellSelected(c) ? this.graph.setSelectionCell(c) :this.clearSelectionOnBackground && null == c && this.graph.clearSelection(), 
this.graph.tooltipHandler.hide(), d = mxUtils.getScrollOrigin(), d = new mxPoint(b.getX() + d.x, b.getY() + d.y), 
this.popup(d.x + 1, d.y + 1, c, b.getEvent()), b.consume());
this.popupTrigger = this.panningTrigger = !1;
}, mxPanningHandler.prototype.scaleGraph = function(a, b) {
b ? this.graph.view.getCanvas().setAttribute("transform", "scale(" + a + ")") :(this.graph.view.getCanvas().removeAttribute("transform"), 
this.graph.view.setScale(this.graph.view.scale * a));
}, mxPanningHandler.prototype.getCellForPopupEvent = function(a) {
return a.getCell();
}, mxPanningHandler.prototype.panGraph = function(a, b) {
this.graph.getView().setTranslate(a, b);
}, mxPanningHandler.prototype.destroy = function() {
this.graph.removeMouseListener(this), mxPopupMenu.prototype.destroy.apply(this);
}, mxUtils.extend(mxCellMarker, mxEventSource), mxCellMarker.prototype.graph = null, 
mxCellMarker.prototype.enabled = !0, mxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT, 
mxCellMarker.prototype.hotspotEnabled = !1, mxCellMarker.prototype.validColor = null, 
mxCellMarker.prototype.invalidColor = null, mxCellMarker.prototype.currentColor = null, 
mxCellMarker.prototype.validState = null, mxCellMarker.prototype.markedState = null, 
mxCellMarker.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxCellMarker.prototype.isEnabled = function() {
return this.enabled;
}, mxCellMarker.prototype.setHotspot = function(a) {
this.hotspot = a;
}, mxCellMarker.prototype.getHotspot = function() {
return this.hotspot;
}, mxCellMarker.prototype.setHotspotEnabled = function(a) {
this.hotspotEnabled = a;
}, mxCellMarker.prototype.isHotspotEnabled = function() {
return this.hotspotEnabled;
}, mxCellMarker.prototype.hasValidState = function() {
return null != this.validState;
}, mxCellMarker.prototype.getValidState = function() {
return this.validState;
}, mxCellMarker.prototype.getMarkedState = function() {
return this.markedState;
}, mxCellMarker.prototype.reset = function() {
this.validState = null, null != this.markedState && (this.markedState = null, this.unmark());
}, mxCellMarker.prototype.process = function(a) {
var b = null;
if (this.isEnabled()) {
var b = this.getState(a), c = null != b ? this.isValidState(b) :!1;
a = this.getMarkerColor(a.getEvent(), b, c), this.validState = c ? b :null, (b != this.markedState || a != this.currentColor) && (this.currentColor = a, 
null != b && null != this.currentColor ? (this.markedState = b, this.mark()) :null != this.markedState && (this.markedState = null, 
this.unmark()));
}
return b;
}, mxCellMarker.prototype.markCell = function(a, b) {
var c = this.graph.getView().getState(a);
null != c && (this.currentColor = null != b ? b :this.validColor, this.markedState = c, 
this.mark());
}, mxCellMarker.prototype.mark = function() {
this.highlight.setHighlightColor(this.currentColor), this.highlight.highlight(this.markedState), 
this.fireEvent(new mxEventObject(mxEvent.MARK, "state", this.markedState));
}, mxCellMarker.prototype.unmark = function() {
this.mark();
}, mxCellMarker.prototype.isValidState = function() {
return !0;
}, mxCellMarker.prototype.getMarkerColor = function(a, b, c) {
return c ? this.validColor :this.invalidColor;
}, mxCellMarker.prototype.getState = function(a) {
var b = this.graph.getView();
return cell = this.getCell(a), b = this.getStateToMark(b.getState(cell)), null != b && this.intersects(b, a) ? b :null;
}, mxCellMarker.prototype.getCell = function(a) {
return a.getCell();
}, mxCellMarker.prototype.getStateToMark = function(a) {
return a;
}, mxCellMarker.prototype.intersects = function(a, b) {
return this.hotspotEnabled ? mxUtils.intersectsHotspot(a, b.getGraphX(), b.getGraphY(), this.hotspot, mxConstants.MIN_HOTSPOT_SIZE, mxConstants.MAX_HOTSPOT_SIZE) :!0;
}, mxCellMarker.prototype.destroy = function() {
this.graph.getView().removeListener(this.resetHandler), this.graph.getModel().removeListener(this.resetHandler), 
this.highlight.destroy();
}, mxUtils.extend(mxSelectionCellsHandler, mxEventSource), mxSelectionCellsHandler.prototype.graph = null, 
mxSelectionCellsHandler.prototype.enabled = !0, mxSelectionCellsHandler.prototype.refreshHandler = null, 
mxSelectionCellsHandler.prototype.maxHandlers = 100, mxSelectionCellsHandler.prototype.handlers = null, 
mxSelectionCellsHandler.prototype.isEnabled = function() {
return this.enabled;
}, mxSelectionCellsHandler.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxSelectionCellsHandler.prototype.getHandler = function(a) {
return this.handlers.get(a);
}, mxSelectionCellsHandler.prototype.reset = function() {
this.handlers.visit(function(a, b) {
b.reset.apply(b);
});
}, mxSelectionCellsHandler.prototype.refresh = function() {
var a = this.handlers;
this.handlers = new mxDictionary();
for (var b = this.graph.getSelectionCells(), c = 0; c < b.length; c++) {
var d = this.graph.view.getState(b[c]);
if (null != d) {
var e = a.remove(b[c]);
null != e && (e.state != d ? (e.destroy(), e = null) :e.redraw()), null == e && (e = this.graph.createHandler(d), 
this.fireEvent(new mxEventObject(mxEvent.ADD, "state", d))), null != e && this.handlers.put(b[c], e);
}
}
a.visit(mxUtils.bind(this, function(a, b) {
this.fireEvent(new mxEventObject(mxEvent.REMOVE, "state", b.state)), b.destroy();
}));
}, mxSelectionCellsHandler.prototype.mouseDown = function(a, b) {
if (this.graph.isEnabled() && this.isEnabled()) {
var c = [ a, b ];
this.handlers.visit(function(a, b) {
b.mouseDown.apply(b, c);
});
}
}, mxSelectionCellsHandler.prototype.mouseMove = function(a, b) {
if (this.graph.isEnabled() && this.isEnabled()) {
var c = [ a, b ];
this.handlers.visit(function(a, b) {
b.mouseMove.apply(b, c);
});
}
}, mxSelectionCellsHandler.prototype.mouseUp = function(a, b) {
if (this.graph.isEnabled() && this.isEnabled()) {
var c = [ a, b ];
this.handlers.visit(function(a, b) {
b.mouseUp.apply(b, c);
});
}
}, mxSelectionCellsHandler.prototype.destroy = function() {
this.graph.removeMouseListener(this), null != this.refreshHandler && (this.graph.getSelectionModel().removeListener(this.refreshHandler), 
this.graph.getModel().removeListener(this.refreshHandler), this.graph.getView().removeListener(this.refreshHandler), 
this.refreshHandler = null);
}, mxUtils.extend(mxConnectionHandler, mxEventSource), mxConnectionHandler.prototype.graph = null, 
mxConnectionHandler.prototype.factoryMethod = !0, mxConnectionHandler.prototype.moveIconFront = !1, 
mxConnectionHandler.prototype.moveIconBack = !1, mxConnectionHandler.prototype.connectImage = null, 
mxConnectionHandler.prototype.targetConnectImage = !1, mxConnectionHandler.prototype.enabled = !0, 
mxConnectionHandler.prototype.select = !0, mxConnectionHandler.prototype.createTarget = !1, 
mxConnectionHandler.prototype.marker = null, mxConnectionHandler.prototype.constraintHandler = null, 
mxConnectionHandler.prototype.error = null, mxConnectionHandler.prototype.waypointsEnabled = !1, 
mxConnectionHandler.prototype.tapAndHoldEnabled = !0, mxConnectionHandler.prototype.tapAndHoldDelay = 500, 
mxConnectionHandler.prototype.tapAndHoldInProgress = !1, mxConnectionHandler.prototype.tapAndHoldValid = !1, 
mxConnectionHandler.prototype.tapAndHoldTolerance = 4, mxConnectionHandler.prototype.initialTouchX = 0, 
mxConnectionHandler.prototype.initialTouchY = 0, mxConnectionHandler.prototype.ignoreMouseDown = !1, 
mxConnectionHandler.prototype.first = null, mxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET), 
mxConnectionHandler.prototype.edgeState = null, mxConnectionHandler.prototype.changeHandler = null, 
mxConnectionHandler.prototype.drillHandler = null, mxConnectionHandler.prototype.mouseDownCounter = 0, 
mxConnectionHandler.prototype.movePreviewAway = mxClient.IS_VML, mxConnectionHandler.prototype.isEnabled = function() {
return this.enabled;
}, mxConnectionHandler.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxConnectionHandler.prototype.isCreateTarget = function() {
return this.createTarget;
}, mxConnectionHandler.prototype.setCreateTarget = function(a) {
this.createTarget = a;
}, mxConnectionHandler.prototype.createShape = function() {
var a = new mxPolyline([], mxConstants.INVALID_COLOR);
if (a.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
a.init(this.graph.getView().getOverlayPane()), a.svgStrokeTolerance = 0, a.pointerEvents = !1, 
a.isDashed = !0, this.graph.dialect == mxConstants.DIALECT_SVG) a.node.setAttribute("pointer-events", "none"); else {
var b = mxUtils.bind(this, function(a) {
return a = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(a), mxEvent.getClientY(a)), 
this.graph.view.getState(this.graph.getCellAt(a.x, a.y));
});
mxEvent.redirectMouseEvents(a.node, this.graph, b);
}
return a;
}, mxConnectionHandler.prototype.init = function() {
this.graph.addMouseListener(this), this.marker = this.createMarker(), this.constraintHandler = new mxConstraintHandler(this.graph), 
this.changeHandler = mxUtils.bind(this, function() {
null != this.iconState && (this.iconState = this.graph.getView().getState(this.iconState.cell)), 
null != this.iconState ? (this.redrawIcons(this.icons, this.iconState), this.constraintHandler.reset()) :this.reset();
}), this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler), this.graph.getView().addListener(mxEvent.SCALE, this.changeHandler), 
this.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler), this.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler), 
this.drillHandler = mxUtils.bind(this, function() {
this.reset();
}), this.graph.addListener(mxEvent.START_EDITING, this.drillHandler), this.graph.getView().addListener(mxEvent.DOWN, this.drillHandler), 
this.graph.getView().addListener(mxEvent.UP, this.drillHandler);
}, mxConnectionHandler.prototype.isConnectableCell = function() {
return !0;
}, mxConnectionHandler.prototype.createMarker = function() {
var a = new mxCellMarker(this.graph);
return a.hotspotEnabled = !0, a.getCell = mxUtils.bind(this, function(b, c) {
return c = mxCellMarker.prototype.getCell.apply(a, arguments), this.error = null, 
this.isConnectableCell(c) ? (null != c ? this.isConnecting() ? null != this.previous && (this.error = this.validateConnection(this.previous.cell, c), 
null != this.error && 0 == this.error.length && (c = null, this.isCreateTarget() && (this.error = null))) :this.isValidSource(c) || (c = null) :this.isConnecting() && !this.isCreateTarget() && !this.graph.allowDanglingEdges && (this.error = ""), 
c) :null;
}), a.isValidState = mxUtils.bind(this, function() {
return this.isConnecting() ? null == this.error :mxCellMarker.prototype.isValidState.apply(a, arguments);
}), a.getMarkerColor = mxUtils.bind(this, function() {
return null == this.connectImage || this.isConnecting() ? mxCellMarker.prototype.getMarkerColor.apply(a, arguments) :null;
}), a.intersects = mxUtils.bind(this, function() {
return null != this.connectImage || this.isConnecting() ? !0 :mxCellMarker.prototype.intersects.apply(a, arguments);
}), a;
}, mxConnectionHandler.prototype.start = function(a, b, c, d) {
this.previous = a, this.first = new mxPoint(b, c), this.edgeState = null != d ? d :this.createEdgeState(null), 
this.marker.currentColor = this.marker.validColor, this.marker.markedState = a, 
this.marker.mark(), this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous));
}, mxConnectionHandler.prototype.isConnecting = function() {
return null != this.first && null != this.shape;
}, mxConnectionHandler.prototype.isValidSource = function(a) {
return this.graph.isValidSource(a);
}, mxConnectionHandler.prototype.isValidTarget = function() {
return !0;
}, mxConnectionHandler.prototype.validateConnection = function(a, b) {
return this.isValidTarget(b) ? this.graph.getEdgeValidationError(null, a, b) :"";
}, mxConnectionHandler.prototype.getConnectImage = function() {
return this.connectImage;
}, mxConnectionHandler.prototype.isMoveIconToFrontForState = function(a) {
return null != a.text && a.text.node.parentNode == this.graph.container ? !0 :this.moveIconFront;
}, mxConnectionHandler.prototype.createIcons = function(a) {
var b = this.getConnectImage(a);
if (null != b && null != a) {
this.iconState = a;
var c = [], d = new mxRectangle(0, 0, b.width, b.height), e = new mxImageShape(d, b.src, null, null, 0);
e.preserveImageAspect = !1, this.isMoveIconToFrontForState(a) ? (e.dialect = mxConstants.DIALECT_STRICTHTML, 
e.init(this.graph.container)) :(e.dialect = this.graph.dialect == mxConstants.DIALECT_SVG ? mxConstants.DIALECT_SVG :mxConstants.DIALECT_VML, 
e.init(this.graph.getView().getOverlayPane()), this.moveIconBack && null != e.node.previousSibling && e.node.parentNode.insertBefore(e.node, e.node.parentNode.firstChild)), 
e.node.style.cursor = mxConstants.CURSOR_CONNECT;
var f = mxUtils.bind(this, function() {
return null != this.currentState ? this.currentState :a;
}), b = mxUtils.bind(this, function(a) {
mxEvent.isConsumed(a) || (this.icon = e, this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a, f())));
});
return mxEvent.redirectMouseEvents(e.node, this.graph, f, b), c.push(e), this.redrawIcons(c, this.iconState), 
c;
}
return null;
}, mxConnectionHandler.prototype.redrawIcons = function(a, b) {
if (null != a && null != a[0] && null != b) {
var c = this.getIconPosition(a[0], b);
a[0].bounds.x = c.x, a[0].bounds.y = c.y, a[0].redraw();
}
}, mxConnectionHandler.prototype.getIconPosition = function(a, b) {
var c = this.graph.getView().scale, d = b.getCenterX(), e = b.getCenterY();
if (this.graph.isSwimlane(b.cell)) {
var f = this.graph.getStartSize(b.cell), d = 0 != f.width ? b.x + f.width * c / 2 :d, e = 0 != f.height ? b.y + f.height * c / 2 :e, f = mxUtils.toRadians(mxUtils.getValue(b.style, mxConstants.STYLE_ROTATION) || 0);
if (0 != f) var c = Math.cos(f), f = Math.sin(f), g = new mxPoint(b.getCenterX(), b.getCenterY()), e = mxUtils.getRotatedPoint(new mxPoint(d, e), c, f, g), d = e.x, e = e.y;
}
return new mxPoint(d - a.bounds.width / 2, e - a.bounds.height / 2);
}, mxConnectionHandler.prototype.destroyIcons = function() {
if (null != this.icons) {
for (var a = 0; a < this.icons.length; a++) this.icons[a].destroy();
this.iconState = this.selectedIcon = this.icon = this.icons = null;
}
}, mxConnectionHandler.prototype.isStartEvent = function(a) {
return !this.graph.isForceMarqueeEvent(a.getEvent()) && (null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint || null != this.previous && null == this.error && (null == this.icons || null != this.icons && null != this.icon));
}, mxConnectionHandler.prototype.mouseDown = function(a, b) {
if (this.mouseDownCounter++, this.isEnabled() && this.graph.isEnabled() && !b.isConsumed() && !this.isConnecting() && this.isStartEvent(b)) {
if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint ? (this.sourceConstraint = this.constraintHandler.currentConstraint, 
this.previous = this.constraintHandler.currentFocus, this.first = this.constraintHandler.currentPoint.clone()) :this.first = new mxPoint(b.getGraphX(), b.getGraphY()), 
this.edgeState = this.createEdgeState(b), this.mouseDownCounter = 1, this.waypointsEnabled && null == this.shape && (this.waypoints = null, 
this.shape = this.createShape()), null == this.previous && null != this.edgeState) {
var c = this.graph.getPointForEvent(b.getEvent());
this.edgeState.cell.geometry.setTerminalPoint(c, !0);
}
this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous)), b.consume();
} else if (mxClient.IS_TOUCH && this.tapAndHoldEnabled && !this.tapAndHoldInProgress && this.isEnabled() && this.graph.isEnabled() && !this.isConnecting()) {
this.tapAndHoldInProgress = !0, this.initialTouchX = b.getX(), this.initialTouchY = b.getY();
var d = this.graph.view.getState(this.marker.getCell(b));
this.tapAndHoldThread && window.clearTimeout(this.tapAndHoldThread), this.tapAndHoldThread = window.setTimeout(mxUtils.bind(this, function() {
this.tapAndHoldValid && this.tapAndHold(b, d), this.tapAndHoldValid = this.tapAndHoldInProgress = !1;
}), this.tapAndHoldDelay), this.tapAndHoldValid = !0;
}
this.selectedIcon = this.icon, this.icon = null;
}, mxConnectionHandler.prototype.tapAndHold = function(a, b) {
null != b && (this.marker.currentColor = this.marker.validColor, this.marker.markedState = b, 
this.marker.mark(), this.first = new mxPoint(a.getGraphX(), a.getGraphY()), this.edgeState = this.createEdgeState(a), 
this.previous = b, this.fireEvent(new mxEventObject(mxEvent.START, "state", this.previous)));
}, mxConnectionHandler.prototype.isImmediateConnectSource = function(a) {
return !this.graph.isCellMovable(a.cell);
}, mxConnectionHandler.prototype.createEdgeState = function() {
return null;
}, mxConnectionHandler.prototype.updateCurrentState = function(a) {
var b = this.marker.process(a);
this.constraintHandler.update(a, null == this.first), this.currentState = b;
}, mxConnectionHandler.prototype.convertWaypoint = function(a) {
var b = this.graph.getView().getScale(), c = this.graph.getView().getTranslate();
a.x = a.x / b - c.x, a.y = a.y / b - c.y;
}, mxConnectionHandler.prototype.mouseMove = function(a, b) {
if (this.tapAndHoldValid && (this.tapAndHoldValid = Math.abs(this.initialTouchX - b.getX()) < this.tapAndHoldTolerance && Math.abs(this.initialTouchY - b.getY()) < this.tapAndHoldTolerance), 
b.isConsumed() || !this.ignoreMouseDown && null == this.first && this.graph.isMouseDown) this.constraintHandler.reset(); else {
if (!this.isEnabled() && null != this.currentState && (this.destroyIcons(), this.currentState = null), 
(null != this.first || this.isEnabled() && this.graph.isEnabled()) && this.updateCurrentState(b), 
null != this.first) {
var c = this.graph.getView().scale, c = new mxPoint(this.graph.snap(b.getGraphX() / c) * c, this.graph.snap(b.getGraphY() / c) * c), d = null, e = c;
null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentPoint && (d = this.constraintHandler.currentConstraint, 
e = this.constraintHandler.currentPoint.clone());
var f = this.first;
if (null != this.selectedIcon) {
var g = this.selectedIcon.bounds.width, h = this.selectedIcon.bounds.height;
null != this.currentState && this.targetConnectImage ? (g = this.getIconPosition(this.selectedIcon, this.currentState), 
this.selectedIcon.bounds.x = g.x, this.selectedIcon.bounds.y = g.y) :(g = new mxRectangle(b.getGraphX() + this.connectIconOffset.x, b.getGraphY() + this.connectIconOffset.y, g, h), 
this.selectedIcon.bounds = g), this.selectedIcon.redraw();
}
if (null != this.edgeState) {
if (this.edgeState.absolutePoints = [ null, null != this.currentState ? null :e ], 
this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, !0, this.sourceConstraint), 
null != this.currentState && (null == d && (d = this.graph.getConnectionConstraint(this.edgeState, this.previous, !1)), 
this.edgeState.setAbsoluteTerminalPoint(null, !1), this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, !1, d)), 
f = null, null != this.waypoints) for (f = [], e = 0; e < this.waypoints.length; e++) d = this.waypoints[e].clone(), 
this.convertWaypoint(d), f[e] = d;
this.graph.view.updatePoints(this.edgeState, f, this.previous, this.currentState), 
this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState), 
e = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1], f = this.edgeState.absolutePoints[0];
} else null != this.currentState && null == this.constraintHandler.currentConstraint && (g = this.getTargetPerimeterPoint(this.currentState, b), 
null != g && (e = g)), null == this.sourceConstraint && null != this.previous && (g = this.getSourcePerimeterPoint(this.previous, null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[0] :e, b), 
null != g && (f = g));
if (null == this.currentState && this.movePreviewAway) {
if (g = f, null != this.edgeState && 2 < this.edgeState.absolutePoints.length && (d = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2], 
null != d && (g = d)), d = e.x - g.x, g = e.y - g.y, h = Math.sqrt(d * d + g * g), 
0 == h) return;
e.x -= 4 * d / h, e.y -= 4 * g / h;
}
null == this.shape && (d = Math.abs(c.x - this.first.x), g = Math.abs(c.y - this.first.y), 
d > this.graph.tolerance || g > this.graph.tolerance) && (this.shape = this.createShape(), 
this.updateCurrentState(b)), null != this.shape && (null != this.edgeState ? this.shape.points = this.edgeState.absolutePoints :(c = [ f ], 
null != this.waypoints && (c = c.concat(this.waypoints)), c.push(e), this.shape.points = c), 
this.drawPreview()), mxEvent.consume(b.getEvent()), b.consume();
} else this.isEnabled() && this.graph.isEnabled() ? this.previous != this.currentState && null == this.edgeState ? (this.destroyIcons(), 
null != this.currentState && null == this.error && (this.icons = this.createIcons(this.currentState), 
null == this.icons && (this.currentState.setCursor(mxConstants.CURSOR_CONNECT), 
b.consume())), this.previous = this.currentState) :this.previous == this.currentState && null != this.currentState && null == this.icons && !this.graph.isMouseDown && b.consume() :this.constraintHandler.reset();
if (null != this.constraintHandler.currentConstraint && this.marker.reset(), !this.graph.isMouseDown && null != this.currentState && null != this.icons) {
for (c = !1, f = b.getSource(), e = 0; e < this.icons.length && !c; e++) c = f == this.icons[e].node || f.parentNode == this.icons[e].node;
c || this.updateIcons(this.currentState, this.icons, b);
}
}
}, mxConnectionHandler.prototype.getTargetPerimeterPoint = function(a) {
var c = null, d = a.view, e = d.getPerimeterFunction(a);
if (null != e) {
var f = null != this.waypoints && 0 < this.waypoints.length ? this.waypoints[this.waypoints.length - 1] :new mxPoint(this.previous.getCenterX(), this.previous.getCenterY()), d = e(d.getPerimeterBounds(a), this.edgeState, f, !1);
null != d && (c = d);
} else c = new mxPoint(a.getCenterX(), a.getCenterY());
return c;
}, mxConnectionHandler.prototype.getSourcePerimeterPoint = function(a, b, c) {
c = null;
var d = a.view, e = d.getPerimeterFunction(a), f = new mxPoint(a.getCenterX(), a.getCenterY());
if (null != e) {
var g = mxUtils.getValue(a.style, mxConstants.STYLE_ROTATION, 0), h = -g * (Math.PI / 180);
0 != g && (b = mxUtils.getRotatedPoint(new mxPoint(b.x, b.y), Math.cos(h), Math.sin(h), f)), 
a = e(d.getPerimeterBounds(a), a, b, !1), null != a && (0 != g && (a = mxUtils.getRotatedPoint(new mxPoint(a.x, a.y), Math.cos(-h), Math.sin(-h), f)), 
c = a);
} else c = f;
return c;
}, mxConnectionHandler.prototype.updateIcons = function() {}, mxConnectionHandler.prototype.isStopEvent = function(a) {
return null != a.getState();
}, mxConnectionHandler.prototype.addWaypointForEvent = function(a) {
var b = mxUtils.convertPoint(this.graph.container, a.getX(), a.getY()), c = Math.abs(b.x - this.first.x), b = Math.abs(b.y - this.first.y);
(null != this.waypoints || 1 < this.mouseDownCounter && (c > this.graph.tolerance || b > this.graph.tolerance)) && (null == this.waypoints && (this.waypoints = []), 
c = this.graph.view.scale, b = new mxPoint(this.graph.snap(a.getGraphX() / c) * c, this.graph.snap(a.getGraphY() / c) * c), 
this.waypoints.push(b));
}, mxConnectionHandler.prototype.mouseUp = function(a, b) {
if (!b.isConsumed() && this.isConnecting()) {
if (this.waypointsEnabled && !this.isStopEvent(b)) return this.addWaypointForEvent(b), 
b.consume(), void 0;
if (null == this.error) {
var c = null != this.previous ? this.previous.cell :null, d = null;
null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && (d = this.constraintHandler.currentFocus.cell), 
null == d && this.marker.hasValidState() && (d = this.marker.validState.cell), this.connect(c, d, b.getEvent(), b.getCell());
} else null != this.previous && null != this.marker.validState && this.previous.cell == this.marker.validState.cell && this.graph.selectCellForEvent(this.marker.source, evt), 
0 < this.error.length && this.graph.validationAlert(this.error);
this.destroyIcons(), b.consume();
}
null != this.first && this.reset(), this.tapAndHoldValid = this.tapAndHoldInProgress = !1;
}, mxConnectionHandler.prototype.reset = function() {
null != this.shape && (this.shape.destroy(), this.shape = null), this.destroyIcons(), 
this.marker.reset(), this.constraintHandler.reset(), this.sourceConstraint = this.error = this.previous = this.edgeState = null, 
this.mouseDownCounter = 0, this.first = null, this.fireEvent(new mxEventObject(mxEvent.RESET));
}, mxConnectionHandler.prototype.drawPreview = function() {
var a = null == this.error;
this.shape.strokewidth = this.getEdgeWidth(a), a = this.getEdgeColor(a), this.shape.stroke = a, 
this.shape.redraw();
}, mxConnectionHandler.prototype.getEdgeColor = function(a) {
return a ? mxConstants.VALID_COLOR :mxConstants.INVALID_COLOR;
}, mxConnectionHandler.prototype.getEdgeWidth = function(a) {
return a ? 3 :1;
}, mxConnectionHandler.prototype.connect = function(a, b, c, d) {
if (null != b || this.isCreateTarget() || this.graph.allowDanglingEdges) {
var e = this.graph.getModel(), f = null;
e.beginUpdate();
try {
if (null != a && null == b && this.isCreateTarget() && (b = this.createTargetVertex(c, a), 
null != b)) {
if (d = this.graph.getDropTarget([ b ], c, d), null != d && this.graph.getModel().isEdge(d)) d = this.graph.getDefaultParent(); else {
var g = this.graph.getView().getState(d);
if (null != g) {
var h = e.getGeometry(b);
h.x -= g.origin.x, h.y -= g.origin.y;
}
}
this.graph.addCell(b, d);
}
var k = this.graph.getDefaultParent();
if (null != a && null != b && e.getParent(a) == e.getParent(b) && e.getParent(e.getParent(a)) != e.getRoot() && (k = e.getParent(a), 
null != a.geometry && a.geometry.relative && null != b.geometry && b.geometry.relative && (k = e.getParent(k))), 
h = g = null, null != this.edgeState && (g = this.edgeState.cell.value, h = this.edgeState.cell.style), 
f = this.insertEdge(k, null, g, a, b, h), null != f) {
this.graph.setConnectionConstraint(f, a, !0, this.sourceConstraint), this.graph.setConnectionConstraint(f, b, !1, this.constraintHandler.currentConstraint), 
null != this.edgeState && e.setGeometry(f, this.edgeState.cell.geometry);
var l = e.getGeometry(f);
if (null == l && (l = new mxGeometry(), l.relative = !0, e.setGeometry(f, l)), null != this.waypoints && 0 < this.waypoints.length) {
var m = this.graph.view.scale, n = this.graph.view.translate;
for (l.points = [], a = 0; a < this.waypoints.length; a++) {
var p = this.waypoints[a];
l.points.push(new mxPoint(p.x / m - n.x, p.y / m - n.y));
}
}
null == b && (p = this.graph.getPointForEvent(c, !1), p.x -= this.graph.panDx / this.graph.view.scale, 
p.y -= this.graph.panDy / this.graph.view.scale, l.setTerminalPoint(p, !1)), this.fireEvent(new mxEventObject(mxEvent.CONNECT, "cell", f, "event", c, "target", d));
}
} catch (q) {
mxLog.show(), mxLog.debug(q.message);
} finally {
e.endUpdate();
}
this.select && this.selectCells(f, b);
}
}, mxConnectionHandler.prototype.selectCells = function(a) {
this.graph.setSelectionCell(a);
}, mxConnectionHandler.prototype.insertEdge = function(a, b, c, d, e, f) {
return null == this.factoryMethod ? this.graph.insertEdge(a, b, c, d, e, f) :(b = this.createEdge(c, d, e, f), 
b = this.graph.addEdge(b, a, d, e));
}, mxConnectionHandler.prototype.createTargetVertex = function(a, b) {
for (var c = this.graph.getCellGeometry(b); null != c && c.relative; ) b = this.graph.getModel().getParent(b), 
c = this.graph.getCellGeometry(b);
var d = this.graph.cloneCells([ b ])[0], c = this.graph.getModel().getGeometry(d);
if (null != c) {
var e = this.graph.getPointForEvent(a);
if (c.x = this.graph.snap(e.x - c.width / 2) - this.graph.panDx / this.graph.view.scale, 
c.y = this.graph.snap(e.y - c.height / 2) - this.graph.panDy / this.graph.view.scale, 
null != this.first) {
var f = this.graph.view.getState(b);
if (null != f) {
var g = this.getAlignmentTolerance();
Math.abs(this.graph.snap(this.first.x) - this.graph.snap(e.x)) <= g ? c.x = f.x :Math.abs(this.graph.snap(this.first.y) - this.graph.snap(e.y)) <= g && (c.y = f.y);
}
}
}
return d;
}, mxConnectionHandler.prototype.getAlignmentTolerance = function() {
return this.graph.isGridEnabled() ? this.graph.gridSize :this.graph.tolerance;
}, mxConnectionHandler.prototype.createEdge = function(a, b, c, d) {
var e = null;
return null != this.factoryMethod && (e = this.factoryMethod(b, c, d)), null == e && (e = new mxCell(a || ""), 
e.setEdge(!0), e.setStyle(d), a = new mxGeometry(), a.relative = !0, e.setGeometry(a)), 
e;
}, mxConnectionHandler.prototype.destroy = function() {
this.graph.removeMouseListener(this), null != this.shape && (this.shape.destroy(), 
this.shape = null), null != this.marker && (this.marker.destroy(), this.marker = null), 
null != this.constraintHandler && (this.constraintHandler.destroy(), this.constraintHandler = null), 
null != this.changeHandler && (this.graph.getModel().removeListener(this.changeHandler), 
this.graph.getView().removeListener(this.changeHandler), this.changeHandler = null), 
null != this.drillHandler && (this.graph.removeListener(this.drillHandler), this.graph.getView().removeListener(this.drillHandler), 
this.drillHandler = null);
}, mxConstraintHandler.prototype.pointImage = new mxImage(mxClient.imageBasePath + "/point.gif", 5, 5), 
mxConstraintHandler.prototype.graph = null, mxConstraintHandler.prototype.enabled = !0, 
mxConstraintHandler.prototype.highlightColor = mxConstants.DEFAULT_VALID_COLOR, 
mxConstraintHandler.prototype.isEnabled = function() {
return this.enabled;
}, mxConstraintHandler.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxConstraintHandler.prototype.reset = function() {
if (null != this.focusIcons) {
for (var a = 0; a < this.focusIcons.length; a++) this.focusIcons[a].destroy();
this.focusIcons = null;
}
null != this.focusHighlight && (this.focusHighlight.destroy(), this.focusHighlight = null), 
this.focusPoints = this.currentFocus = this.currentPoint = this.currentFocusArea = this.currentConstraint = null;
}, mxConstraintHandler.prototype.getTolerance = function() {
return this.graph.getTolerance();
}, mxConstraintHandler.prototype.getImageForConstraint = function() {
return this.pointImage;
}, mxConstraintHandler.prototype.isEventIgnored = function() {
return !1;
}, mxConstraintHandler.prototype.isStateIgnored = function() {
return !1;
}, mxConstraintHandler.prototype.destroyIcons = function() {
if (null != this.focusIcons) {
for (var a = 0; a < this.focusIcons.length; a++) this.focusIcons[a].destroy();
this.focusPoints = this.focusIcons = null;
}
}, mxConstraintHandler.prototype.destroyFocusHighlight = function() {
null != this.focusHighlight && (this.focusHighlight.destroy(), this.focusHighlight = null);
}, mxConstraintHandler.prototype.update = function(a, b) {
if (this.isEnabled() && !this.isEventIgnored(a)) {
var c = this.getTolerance(), d = new mxRectangle(a.getGraphX() - c, a.getGraphY() - c, 2 * c, 2 * c), e = null != a.getCell() ? this.graph.isCellConnectable(a.getCell()) :!1;
if ((null == this.currentFocusArea || !mxUtils.intersects(this.currentFocusArea, d) || null != a.getState() && null != this.currentFocus && e) && (this.currentFocusArea = null, 
a.getState() != this.currentFocus)) if (this.currentFocus = null, this.constraints = null != a.getState() && e && !this.isStateIgnored(a.getState(), b) ? this.graph.getAllConnectionConstraints(a.getState(), b) :null, 
null != this.constraints) {
if (this.currentFocus = a.getState(), this.currentFocusArea = new mxRectangle(a.getState().x, a.getState().y, a.getState().width, a.getState().height), 
null != this.focusIcons) {
for (e = 0; e < this.focusIcons.length; e++) this.focusIcons[e].destroy();
this.focusPoints = this.focusIcons = null;
}
for (this.focusIcons = [], this.focusPoints = [], e = 0; e < this.constraints.length; e++) {
var f = this.graph.getConnectionPoint(a.getState(), this.constraints[e]), g = this.getImageForConstraint(a.getState(), this.constraints[e], f), h = g.src, g = new mxRectangle(f.x - g.width / 2, f.y - g.height / 2, g.width, g.height), g = new mxImageShape(g, h);
g.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML :mxConstants.DIALECT_SVG, 
g.preserveImageAspect = !1, g.init(this.graph.getView().getOverlayPane()), null != g.node.previousSibling && g.node.parentNode.insertBefore(g.node, g.node.parentNode.firstChild), 
h = mxUtils.bind(this, function() {
return null != this.currentFocus ? this.currentFocus :a.getState();
}), g.redraw(), mxEvent.redirectMouseEvents(g.node, this.graph, h), this.currentFocusArea.add(g.bounds), 
this.focusIcons.push(g), this.focusPoints.push(f);
}
this.currentFocusArea.grow(c);
} else this.destroyIcons(), this.destroyFocusHighlight();
if (this.currentPoint = this.currentConstraint = null, null != this.focusIcons && null != this.constraints && (null == a.getState() || this.currentFocus == a.getState())) for (e = 0; e < this.focusIcons.length; e++) if (mxUtils.intersects(this.focusIcons[e].bounds, d)) {
this.currentConstraint = this.constraints[e], this.currentPoint = this.focusPoints[e], 
c = this.focusIcons[e].bounds.clone(), c.grow(mxClient.IS_IE ? 3 :2), mxClient.IS_IE && (c.width -= 1, 
c.height -= 1), null == this.focusHighlight ? (c = new mxRectangleShape(c, null, this.highlightColor, 3), 
c.dialect = this.graph.dialect == mxConstants.DIALECT_SVG ? mxConstants.DIALECT_SVG :mxConstants.DIALECT_VML, 
c.init(this.graph.getView().getOverlayPane()), this.focusHighlight = c, h = mxUtils.bind(this, function() {
return null != this.currentFocus ? this.currentFocus :a.getState();
}), mxEvent.redirectMouseEvents(c.node, this.graph, h)) :(this.focusHighlight.bounds = c, 
this.focusHighlight.redraw());
break;
}
null == this.currentConstraint && this.destroyFocusHighlight();
}
}, mxConstraintHandler.prototype.destroy = function() {
this.reset();
}, mxRubberband.prototype.defaultOpacity = 20, mxRubberband.prototype.enabled = !0, 
mxRubberband.prototype.div = null, mxRubberband.prototype.sharedDiv = null, mxRubberband.prototype.currentX = 0, 
mxRubberband.prototype.currentY = 0, mxRubberband.prototype.isEnabled = function() {
return this.enabled;
}, mxRubberband.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxRubberband.prototype.mouseDown = function(a, b) {
if (!b.isConsumed() && this.isEnabled() && this.graph.isEnabled() && (this.graph.isForceMarqueeEvent(b.getEvent()) || null == b.getState())) {
var c = mxUtils.getOffset(this.graph.container), d = mxUtils.getScrollOrigin(this.graph.container);
if (d.x -= c.x, d.y -= c.y, this.start(b.getX() + d.x, b.getY() + d.y), mxClient.IS_NS && !mxClient.IS_SF && !mxClient.IS_GC) {
var e = this.graph.container, f = function(a) {
a = new mxMouseEvent(a);
var b = mxUtils.convertPoint(e, a.getX(), a.getY());
return a.graphX = b.x, a.graphY = b.y, a;
};
this.dragHandler = mxUtils.bind(this, function(a) {
this.mouseMove(this.graph, f(a));
}), this.dropHandler = mxUtils.bind(this, function(a) {
this.mouseUp(this.graph, f(a));
}), mxEvent.addListener(document, "mousemove", this.dragHandler), mxEvent.addListener(document, "mouseup", this.dropHandler);
}
b.consume(!1);
}
}, mxRubberband.prototype.start = function(a, b) {
this.first = new mxPoint(a, b);
}, mxRubberband.prototype.mouseMove = function(a, b) {
if (!b.isConsumed() && null != this.first) {
var c = mxUtils.getScrollOrigin(this.graph.container), d = mxUtils.getOffset(this.graph.container);
c.x -= d.x, c.y -= d.y;
var d = b.getX() + c.x, c = b.getY() + c.y, e = this.first.x - d, f = this.first.y - c, g = this.graph.tolerance;
(null != this.div || Math.abs(e) > g || Math.abs(f) > g) && (null == this.div && (this.div = this.createShape()), 
mxUtils.clearSelection(), this.update(d, c), b.consume());
}
}, mxRubberband.prototype.createShape = function() {
return null == this.sharedDiv && (this.sharedDiv = document.createElement("div"), 
this.sharedDiv.className = "mxRubberband", mxUtils.setOpacity(this.sharedDiv, this.defaultOpacity)), 
this.graph.container.appendChild(this.sharedDiv), this.sharedDiv;
}, mxRubberband.prototype.mouseUp = function(a, b) {
var c = null != this.div;
this.reset(), c && (c = new mxRectangle(this.x, this.y, this.width, this.height), 
this.graph.selectRegion(c, b.getEvent()), b.consume());
}, mxRubberband.prototype.reset = function() {
null != this.div && this.div.parentNode.removeChild(this.div), null != this.dragHandler && (mxEvent.removeListener(document, "mousemove", this.dragHandler), 
this.dragHandler = null), null != this.dropHandler && (mxEvent.removeListener(document, "mouseup", this.dropHandler), 
this.dropHandler = null), this.currentY = this.currentX = 0, this.div = this.first = null;
}, mxRubberband.prototype.update = function(a, b) {
this.currentX = a, this.currentY = b, this.repaint();
}, mxRubberband.prototype.repaint = function() {
if (null != this.div) {
var a = this.currentX - this.graph.panDx, b = this.currentY - this.graph.panDy;
this.x = Math.min(this.first.x, a), this.y = Math.min(this.first.y, b), this.width = Math.max(this.first.x, a) - this.x, 
this.height = Math.max(this.first.y, b) - this.y, a = mxClient.IS_VML ? this.graph.panDy :0, 
this.div.style.left = this.x + (mxClient.IS_VML ? this.graph.panDx :0) + "px", this.div.style.top = this.y + a + "px", 
this.div.style.width = Math.max(1, this.width) + "px", this.div.style.height = Math.max(1, this.height) + "px";
}
}, mxRubberband.prototype.destroy = function() {
this.destroyed || (this.destroyed = !0, this.graph.removeMouseListener(this), this.graph.removeListener(this.panHandler), 
this.reset(), null != this.sharedDiv && (this.sharedDiv = null));
}, mxVertexHandler.prototype.graph = null, mxVertexHandler.prototype.state = null, 
mxVertexHandler.prototype.singleSizer = !1, mxVertexHandler.prototype.index = null, 
mxVertexHandler.prototype.allowHandleBoundsCheck = !0, mxVertexHandler.prototype.handleImage = null, 
mxVertexHandler.prototype.tolerance = 0, mxVertexHandler.prototype.rotationEnabled = !1, 
mxVertexHandler.prototype.rotationRaster = !0, mxVertexHandler.prototype.livePreview = !1, 
mxVertexHandler.prototype.init = function() {
if (this.graph = this.state.view.graph, this.selectionBounds = this.getSelectionBounds(this.state), 
this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height), 
this.selectionBorder = this.createSelectionShape(this.bounds), this.selectionBorder.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
this.selectionBorder.pointerEvents = !1, this.selectionBorder.init(this.graph.getView().getOverlayPane()), 
this.graph.isCellMovable(this.state.cell) && (this.selectionBorder.node.style.cursor = mxConstants.CURSOR_MOVABLE_VERTEX), 
mxEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state), 
0 >= mxGraphHandler.prototype.maxCells || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells) {
var a = this.graph.isCellResizable(this.state.cell);
if (this.sizers = [], a || this.graph.isLabelMovable(this.state.cell) && 2 <= this.state.width && 2 <= this.state.height) {
var b = 0;
a && (this.singleSizer || (this.sizers.push(this.createSizer("nw-resize", b++)), 
this.sizers.push(this.createSizer("n-resize", b++)), this.sizers.push(this.createSizer("ne-resize", b++)), 
this.sizers.push(this.createSizer("w-resize", b++)), this.sizers.push(this.createSizer("e-resize", b++)), 
this.sizers.push(this.createSizer("sw-resize", b++)), this.sizers.push(this.createSizer("s-resize", b++))), 
this.sizers.push(this.createSizer("se-resize", b++))), a = this.graph.model.getGeometry(this.state.cell), 
null != a && !a.relative && !this.graph.isSwimlane(this.state.cell) && this.graph.isLabelMovable(this.state.cell) && (this.labelShape = this.createSizer(mxConstants.CURSOR_LABEL_HANDLE, mxEvent.LABEL_HANDLE, mxConstants.LABEL_HANDLE_SIZE, mxConstants.LABEL_HANDLE_FILLCOLOR), 
this.sizers.push(this.labelShape));
} else this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && 2 > this.state.width && 2 > this.state.height && (this.labelShape = this.createSizer(mxConstants.CURSOR_MOVABLE_VERTEX, null, null, mxConstants.LABEL_HANDLE_FILLCOLOR), 
this.sizers.push(this.labelShape));
}
this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) && (0 >= mxGraphHandler.prototype.maxCells || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells) && (this.rotationShape = this.createSizer("pointer", mxEvent.ROTATION_HANDLE, mxConstants.HANDLE_SIZE + 3, mxConstants.HANDLE_FILLCOLOR), 
this.sizers.push(this.rotationShape)), this.redraw();
}, mxVertexHandler.prototype.getSelectionBounds = function(a) {
return new mxRectangle(Math.round(a.x), Math.round(a.y), Math.round(a.width), Math.round(a.height));
}, mxVertexHandler.prototype.createSelectionShape = function(a) {
return a = new mxRectangleShape(a, null, this.getSelectionColor()), a.strokewidth = this.getSelectionStrokeWidth(), 
a.isDashed = this.isSelectionDashed(), a;
}, mxVertexHandler.prototype.getSelectionColor = function() {
return mxConstants.VERTEX_SELECTION_COLOR;
}, mxVertexHandler.prototype.getSelectionStrokeWidth = function() {
return mxConstants.VERTEX_SELECTION_STROKEWIDTH;
}, mxVertexHandler.prototype.isSelectionDashed = function() {
return mxConstants.VERTEX_SELECTION_DASHED;
}, mxVertexHandler.prototype.createSizer = function(a, b, c, d) {
return c = c || mxConstants.HANDLE_SIZE, c = new mxRectangle(0, 0, c, c), d = this.createSizerShape(c, b, d), 
d.isHtmlAllowed() && null != this.state.text && this.state.text.node.parentNode == this.graph.container ? (d.bounds.height -= 1, 
d.bounds.width -= 1, d.dialect = mxConstants.DIALECT_STRICTHTML, d.init(this.graph.container)) :(d.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML :mxConstants.DIALECT_SVG, 
d.init(this.graph.getView().getOverlayPane())), mxEvent.redirectMouseEvents(d.node, this.graph, this.state), 
this.graph.isEnabled() && (d.node.style.cursor = a), this.isSizerVisible(b) || (d.node.style.visibility = "hidden"), 
d;
}, mxVertexHandler.prototype.isSizerVisible = function() {
return !0;
}, mxVertexHandler.prototype.createSizerShape = function(a, b, c) {
return null != this.handleImage ? (a.width = this.handleImage.width, a.height = this.handleImage.height, 
new mxImageShape(a, this.handleImage.src)) :b == mxEvent.ROTATION_HANDLE ? new mxEllipse(a, c || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR) :new mxRectangleShape(a, c || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
}, mxVertexHandler.prototype.moveSizerTo = function(a, b, c) {
null != a && (a.bounds.x = Math.round(b - a.bounds.width / 2), a.bounds.y = Math.round(c - a.bounds.height / 2), 
a.redraw());
}, mxVertexHandler.prototype.getHandleForEvent = function(a) {
if (a.isSource(this.rotationShape)) return mxEvent.ROTATION_HANDLE;
if (a.isSource(this.labelShape)) return mxEvent.LABEL_HANDLE;
if (null != this.sizers) for (var b = this.tolerance, b = this.allowHandleBoundsCheck && (mxClient.IS_IE || b > 0) ? new mxRectangle(a.getGraphX() - b, a.getGraphY() - b, 2 * b, 2 * b) :null, c = 0; c < this.sizers.length; c++) if (a.isSource(this.sizers[c]) || null != b && mxUtils.intersects(this.sizers[c].bounds, b)) return c;
return null;
}, mxVertexHandler.prototype.mouseDown = function(a, b) {
if (!b.isConsumed() && this.graph.isEnabled() && !this.graph.isForceMarqueeEvent(b.getEvent()) && (0 < this.tolerance || b.getState() == this.state)) {
var c = this.getHandleForEvent(b);
null != c && (this.start(b.getX(), b.getY(), c), b.consume());
}
}, mxVertexHandler.prototype.start = function(a, b, c) {
a = mxUtils.convertPoint(this.graph.container, a, b), this.startX = a.x, this.startY = a.y, 
this.index = c, this.selectionBorder.node.style.display = c == mxEvent.ROTATION_HANDLE ? "inline" :"none", 
this.livePreview || (this.preview = this.createSelectionShape(this.bounds), mxClient.IS_SVG && 0 != Number(this.state.style[mxConstants.STYLE_ROTATION] || "0") || null == this.state.text || this.state.text.node.parentNode != this.graph.container ? (this.preview.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
this.preview.init(this.graph.view.getOverlayPane())) :(this.preview.dialect = mxConstants.DIALECT_STRICTHTML, 
this.preview.init(this.graph.container)));
}, mxVertexHandler.prototype.mouseMove = function(a, b) {
if (b.isConsumed() || null == this.index) null != this.getHandleForEvent(b) && b.consume(!1); else {
var c = new mxPoint(b.getGraphX(), b.getGraphY()), d = this.graph.isGridEnabledEvent(b.getEvent()), e = this.graph.getView().scale;
if (this.index == mxEvent.LABEL_HANDLE) d && (c.x = this.graph.snap(c.x / e) * e, 
c.y = this.graph.snap(c.y / e) * e), this.moveSizerTo(this.sizers[this.sizers.length - 1], c.x, c.y); else if (this.index == mxEvent.ROTATION_HANDLE) {
var f = this.state.x + this.state.width / 2 - c.x, g = this.state.y + this.state.height / 2 - c.y;
this.currentAlpha = 0 != f ? 180 * Math.atan(g / f) / Math.PI + 90 :0 > g ? 180 :0, 
f > 0 && (this.currentAlpha -= 180), this.rotationRaster && this.graph.isGridEnabledEvent(b.getEvent()) && (f = c.x - this.state.getCenterX(), 
g = c.y - this.state.getCenterY(), e = Math.abs(Math.sqrt(f * f + g * g) - this.state.height / 2 - 20), 
e = Math.max(1, 5 * Math.min(3, Math.max(0, Math.round(80 / Math.abs(e))))), this.currentAlpha = Math.round(this.currentAlpha / e) * e), 
this.selectionBorder.rotation = this.currentAlpha, this.selectionBorder.redraw();
} else {
var h = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0"), k = Math.cos(-h), l = Math.sin(-h), m = new mxPoint(this.state.getCenterX(), this.state.getCenterY()), f = c.x - this.startX, g = c.y - this.startY, c = this.graph.view.translate, n = l * f + k * g, f = k * f - l * g;
this.bounds = this.union(this.selectionBounds, f, n, this.index, d, e, c), k = Math.cos(h), 
l = Math.sin(h), g = new mxPoint(this.bounds.getCenterX(), this.bounds.getCenterY()), 
f = g.x - m.x, g = g.y - m.y, m = l * f + k * g - g, this.bounds.x += k * f - l * g - f, 
this.bounds.y += m, this.livePreview ? (f = new mxRectangle(this.state.x, this.state.y, this.state.width, this.state.height), 
k = this.state.origin, this.state.x = this.bounds.x, this.state.y = this.bounds.y, 
this.state.origin = new mxPoint(this.state.x / e - c.x, this.state.y / e - c.y), 
this.state.width = this.bounds.width, this.state.height = this.bounds.height, this.state.view.graph.cellRenderer.redraw(this.state, !0), 
this.redrawHandles(), this.state.view.invalidate(this.state.cell), this.state.invalid = !1, 
this.state.view.validate(), this.state.x = f.x, this.state.y = f.y, this.state.width = f.width, 
this.state.height = f.height, this.state.origin = k) :this.drawPreview();
}
b.consume();
}
}, mxVertexHandler.prototype.mouseUp = function(a, b) {
if (!b.isConsumed() && null != this.index && null != this.state) {
var c = new mxPoint(b.getGraphX(), b.getGraphY());
this.graph.getModel().beginUpdate();
try {
if (this.index == mxEvent.ROTATION_HANDLE) {
if (null != this.currentAlpha) {
var d = this.currentAlpha - (this.state.style[mxConstants.STYLE_ROTATION] || 0);
0 != d && this.rotateCell(this.state.cell, d);
}
} else {
var e = this.graph.isGridEnabledEvent(b.getEvent()), f = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0"), g = Math.cos(-f), h = Math.sin(-f), k = c.x - this.startX, l = c.y - this.startY, c = h * k + g * l, k = g * k - h * l, l = c, m = this.graph.view.scale;
this.resizeCell(this.state.cell, k / m, l / m, this.index, e);
}
} finally {
this.graph.getModel().endUpdate();
}
this.reset(), b.consume();
}
}, mxVertexHandler.prototype.rotateCell = function(a, b) {
var c = this.graph.getModel();
if (c.isVertex(a)) {
var d = a == this.state ? this.state :this.graph.view.getState(a);
if (null != d && this.graph.setCellStyles(mxConstants.STYLE_ROTATION, (d.style[mxConstants.STYLE_ROTATION] || 0) + b, [ a ]), 
this.state.cell != a && (d = this.graph.getCellGeometry(a), null != d && !d.relative && 0 != b)) {
var e = this.graph.getModel().getParent(a), f = this.graph.getCellGeometry(e);
if (!d.relative && null != f) {
var g = mxUtils.toRadians(b), e = Math.cos(g), g = Math.sin(g), h = new mxPoint(d.getCenterX(), d.getCenterY()), f = new mxPoint(f.width / 2, f.height / 2), e = mxUtils.getRotatedPoint(h, e, g, f), d = d.clone();
d.x = e.x - d.width / 2, d.y = e.y - d.height / 2, c.setGeometry(a, d);
}
}
for (d = c.getChildCount(a), e = 0; d > e; e++) this.rotateCell(c.getChildAt(a, e), b);
}
}, mxVertexHandler.prototype.reset = function() {
null != this.sizers && null != this.index && null != this.sizers[this.index] && "none" == this.sizers[this.index].node.style.display && (this.sizers[this.index].node.style.display = ""), 
this.index = this.currentAlpha = null, null != this.preview && (this.preview.destroy(), 
this.preview = null), null != this.selectionBorder && (this.selectionBorder.node.style.display = "inline", 
this.selectionBounds = this.getSelectionBounds(this.state), this.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height), 
this.drawPreview());
}, mxVertexHandler.prototype.resizeCell = function(a, b, c, d, e) {
var f = this.graph.model.getGeometry(a);
if (null != f) if (d == mxEvent.LABEL_HANDLE) d = this.graph.view.scale, b = (this.labelShape.bounds.getCenterX() - this.startX) / d, 
c = (this.labelShape.bounds.getCenterY() - this.startY) / d, f = f.clone(), null == f.offset ? f.offset = new mxPoint(b, c) :(f.offset.x += b, 
f.offset.y += c), this.graph.model.setGeometry(a, f); else {
d = this.union(f, b, c, d, e, 1, new mxPoint(0, 0));
var g = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0");
if (0 != g) {
b = d.getCenterX() - f.getCenterX(), c = d.getCenterY() - f.getCenterY(), e = Math.cos(g);
var h = Math.sin(g), g = e * b - h * c - b;
b = h * b + e * c - c, c = d.x - f.x;
var k = d.y - f.y, l = e * c - h * k;
e = h * c + e * k, d.x += g, d.y += b, this.graph.isCellCollapsed(a) || 0 == g && 0 == b || (c = f.x - d.x + l, 
k = f.y - d.y + e, this.moveChildren(a, c, k));
}
this.graph.resizeCell(a, d);
}
}, mxVertexHandler.prototype.moveChildren = function(a, b, c) {
for (var d = this.graph.getModel(), e = d.getChildCount(a), f = 0; e > f; f++) {
var g = d.getChildAt(a, f);
if (d.isVertex(g)) {
var h = this.graph.getCellGeometry(g);
null != h && !h.relative && (h = h.clone(), h.x += b, h.y += c, d.setGeometry(g, h));
}
}
}, mxVertexHandler.prototype.union = function(a, b, c, d, e, f, g) {
if (this.singleSizer) {
g = a.x + a.width + b;
var h = a.y + a.height + c;
return e && (g = this.graph.snap(g / f) * f, h = this.graph.snap(h / f) * f), f = new mxRectangle(a.x, a.y, 0, 0), 
f.add(new mxRectangle(g, h, 0, 0)), f;
}
var h = a.x - g.x * f, k = h + a.width, l = a.y - g.y * f;
return a = l + a.height, d > 4 ? (a += c, e && (a = this.graph.snap(a / f) * f)) :3 > d && (l += c, 
e && (l = this.graph.snap(l / f) * f)), 0 == d || 3 == d || 5 == d ? (h += b, e && (h = this.graph.snap(h / f) * f)) :(2 == d || 4 == d || 7 == d) && (k += b, 
e && (k = this.graph.snap(k / f) * f)), e = k - h, a -= l, 0 > e && (h += e, e = Math.abs(e)), 
0 > a && (l += a, a = Math.abs(a)), new mxRectangle(h + g.x * f, l + g.y * f, e, a);
}, mxVertexHandler.prototype.redraw = function() {
this.selectionBounds = this.getSelectionBounds(this.state), this.bounds = new mxRectangle(this.state.x, this.state.y, this.state.width, this.state.height), 
this.redrawHandles(), this.drawPreview();
}, mxVertexHandler.prototype.redrawHandles = function() {
var a = this.state;
if (null != this.sizers) {
var b = a.x + a.width, c = a.y + a.height;
if (this.singleSizer) this.moveSizerTo(this.sizers[0], b, c); else {
var d = a.x + a.width / 2, e = a.y + a.height / 2;
if (1 < this.sizers.length) {
var f = mxUtils.toRadians(a.style[mxConstants.STYLE_ROTATION] || "0"), g = Math.cos(f), f = Math.sin(f), h = new mxPoint(a.getCenterX(), a.getCenterY()), k = mxUtils.getRotatedPoint(new mxPoint(a.x, a.y), g, f, h);
this.moveSizerTo(this.sizers[0], k.x, k.y), k.x = d, k.y = a.y, k = mxUtils.getRotatedPoint(k, g, f, h), 
this.moveSizerTo(this.sizers[1], k.x, k.y), k.x = b, k.y = a.y, k = mxUtils.getRotatedPoint(k, g, f, h), 
this.moveSizerTo(this.sizers[2], k.x, k.y), k.x = a.x, k.y = e, k = mxUtils.getRotatedPoint(k, g, f, h), 
this.moveSizerTo(this.sizers[3], k.x, k.y), k.x = b, k.y = e, k = mxUtils.getRotatedPoint(k, g, f, h), 
this.moveSizerTo(this.sizers[4], k.x, k.y), k.x = a.x, k.y = c, k = mxUtils.getRotatedPoint(k, g, f, h), 
this.moveSizerTo(this.sizers[5], k.x, k.y), k.x = d, k.y = c, k = mxUtils.getRotatedPoint(k, g, f, h), 
this.moveSizerTo(this.sizers[6], k.x, k.y), k.x = b, k.y = c, k = mxUtils.getRotatedPoint(k, g, f, h), 
this.moveSizerTo(this.sizers[7], k.x, k.y), this.moveSizerTo(this.sizers[8], d + a.absoluteOffset.x, e + a.absoluteOffset.y);
} else 2 <= this.state.width && 2 <= this.state.height ? this.moveSizerTo(this.sizers[0], d + a.absoluteOffset.x, e + a.absoluteOffset.y) :this.moveSizerTo(this.sizers[0], a.x, a.y);
}
}
null != this.rotationShape && (f = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || "0"), 
g = Math.cos(f), f = Math.sin(f), h = new mxPoint(this.state.getCenterX(), this.state.getCenterY()), 
k = mxUtils.getRotatedPoint(new mxPoint(a.x + a.width / 2, a.y - 16), g, f, h), 
this.moveSizerTo(this.rotationShape, k.x, k.y)), this.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0");
}, mxVertexHandler.prototype.drawPreview = function() {
null != this.preview && (this.preview.bounds = this.bounds, this.preview.node.parentNode == this.graph.container && (this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1), 
this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1)), this.preview.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0"), 
this.preview.redraw()), this.selectionBorder.bounds = this.bounds, this.selectionBorder.redraw();
}, mxVertexHandler.prototype.destroy = function() {
if (null != this.preview && (this.preview.destroy(), this.preview = null), this.selectionBorder.destroy(), 
this.labelShape = this.selectionBorder = null, null != this.sizers) for (var a = 0; a < this.sizers.length; a++) this.sizers[a].destroy(), 
this.sizers[a] = null;
}, mxEdgeHandler.prototype.graph = null, mxEdgeHandler.prototype.state = null, mxEdgeHandler.prototype.marker = null, 
mxEdgeHandler.prototype.constraintHandler = null, mxEdgeHandler.prototype.error = null, 
mxEdgeHandler.prototype.shape = null, mxEdgeHandler.prototype.bends = null, mxEdgeHandler.prototype.labelShape = null, 
mxEdgeHandler.prototype.cloneEnabled = !0, mxEdgeHandler.prototype.addEnabled = !1, 
mxEdgeHandler.prototype.removeEnabled = !1, mxEdgeHandler.prototype.preferHtml = !1, 
mxEdgeHandler.prototype.allowHandleBoundsCheck = !0, mxEdgeHandler.prototype.snapToTerminals = !1, 
mxEdgeHandler.prototype.handleImage = null, mxEdgeHandler.prototype.tolerance = 0, 
mxEdgeHandler.prototype.livePreview = !1, mxEdgeHandler.prototype.init = function() {
if (this.graph = this.state.view.graph, this.marker = this.createMarker(), this.constraintHandler = new mxConstraintHandler(this.graph), 
this.points = [], this.abspoints = this.getSelectionPoints(this.state), this.shape = this.createSelectionShape(this.abspoints), 
this.shape.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML :mxConstants.DIALECT_SVG, 
this.shape.init(this.graph.getView().getOverlayPane()), this.shape.svgStrokeTolerance = 0, 
this.shape.node.style.cursor = mxConstants.CURSOR_MOVABLE_EDGE, mxEvent.addListener(this.shape.node, "dblclick", mxUtils.bind(this, function(a) {
this.graph.dblClick(a, this.state.cell);
})), mxEvent.addGestureListeners(this.shape.node, mxUtils.bind(this, function(a) {
this.addEnabled && this.isAddPointEvent(a) ? this.addPoint(this.state, a) :this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(a, this.state));
}), mxUtils.bind(this, function(a) {
var c = this.state.cell;
if (null != this.index) {
var d = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(a), mxEvent.getClientY(a)), c = this.graph.getCellAt(d.x, d.y);
this.graph.isSwimlane(c) && this.graph.hitsSwimlaneContent(c, d.x, d.y) && (c = null);
}
this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(a, this.graph.getView().getState(c)));
}), mxUtils.bind(this, function(a) {
this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(a, this.state));
})), this.preferHtml = null != this.state.text && this.state.text.node.parentNode == this.graph.container, 
!this.preferHtml) {
var a = this.state.getVisibleTerminalState(!0);
null != a && (this.preferHtml = null != a.text && a.text.node.parentNode == this.graph.container), 
this.preferHtml || (a = this.state.getVisibleTerminalState(!1), null != a && (this.preferHtml = null != a.text && a.text.node.parentNode == this.graph.container));
}
(this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells || 0 >= mxGraphHandler.prototype.maxCells) && (this.bends = this.createBends()), 
this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y), 
this.labelShape = new mxRectangleShape(new mxRectangle(), mxConstants.LABEL_HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR), 
this.labelShape.pointerEvents = !1, this.initBend(this.labelShape), this.labelShape.node.style.cursor = mxConstants.CURSOR_LABEL_HANDLE, 
mxEvent.redirectMouseEvents(this.labelShape.node, this.graph, this.state), this.redraw();
}, mxEdgeHandler.prototype.isAddPointEvent = function(a) {
return mxEvent.isShiftDown(a);
}, mxEdgeHandler.prototype.isRemovePointEvent = function(a) {
return mxEvent.isShiftDown(a);
}, mxEdgeHandler.prototype.getSelectionPoints = function(a) {
return a.absolutePoints;
}, mxEdgeHandler.prototype.createSelectionShape = function(a) {
return a = new mxPolyline(a, this.getSelectionColor()), a.strokewidth = this.getSelectionStrokeWidth(), 
a.isDashed = this.isSelectionDashed(), a;
}, mxEdgeHandler.prototype.getSelectionColor = function() {
return mxConstants.EDGE_SELECTION_COLOR;
}, mxEdgeHandler.prototype.getSelectionStrokeWidth = function() {
return mxConstants.EDGE_SELECTION_STROKEWIDTH;
}, mxEdgeHandler.prototype.isSelectionDashed = function() {
return mxConstants.EDGE_SELECTION_DASHED;
}, mxEdgeHandler.prototype.isConnectableCell = function() {
return !0;
}, mxEdgeHandler.prototype.createMarker = function() {
var a = new mxCellMarker(this.graph), b = this;
return a.getCell = function() {
var d = mxCellMarker.prototype.getCell.apply(this, arguments);
if (!b.isConnectableCell(d)) return null;
var e = b.graph.getModel();
return (d == b.state.cell || null != d && !b.graph.connectableEdges && e.isEdge(d)) && (d = null), 
d;
}, a.isValidState = function(a) {
var d = b.graph.getModel(), d = b.graph.view.getTerminalPort(a, b.graph.view.getState(d.getTerminal(b.state.cell, !b.isSource)), !b.isSource), d = null != d ? d.cell :null;
return b.error = b.validateConnection(b.isSource ? a.cell :d, b.isSource ? d :a.cell), 
null == b.error;
}, a;
}, mxEdgeHandler.prototype.validateConnection = function(a, b) {
return this.graph.getEdgeValidationError(this.state.cell, a, b);
}, mxEdgeHandler.prototype.createBends = function() {
for (var a = this.state.cell, b = [], c = 0; c < this.abspoints.length; c++) if (this.isHandleVisible(c)) {
var d = c == this.abspoints.length - 1;
if ((d = 0 == c || d) || this.graph.isCellBendable(a)) {
var e = this.createHandleShape(c);
if (this.initBend(e), this.isHandleEnabled(c)) if (mxClient.IS_TOUCH) {
var f = mxUtils.bind(this, function(a) {
return a = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(a), mxEvent.getClientY(a)), 
this.graph.view.getState(this.graph.getCellAt(a.x, a.y));
});
mxEvent.redirectMouseEvents(e.node, this.graph, f);
} else e.node.style.cursor = mxConstants.CURSOR_BEND_HANDLE, mxEvent.redirectMouseEvents(e.node, this.graph, this.state);
b.push(e), d || (this.points.push(new mxPoint(0, 0)), e.node.style.visibility = "hidden");
}
}
return b;
}, mxEdgeHandler.prototype.isHandleEnabled = function() {
return !0;
}, mxEdgeHandler.prototype.isHandleVisible = function() {
return !0;
}, mxEdgeHandler.prototype.createHandleShape = function(a) {
return null != this.handleImage ? new mxImageShape(new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src) :(a = mxConstants.HANDLE_SIZE, 
this.preferHtml && (a -= 1), new mxRectangleShape(new mxRectangle(0, 0, a, a), mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR));
}, mxEdgeHandler.prototype.initBend = function(a) {
this.preferHtml ? (a.dialect = mxConstants.DIALECT_STRICTHTML, a.init(this.graph.container)) :(a.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_MIXEDHTML :mxConstants.DIALECT_SVG, 
a.init(this.graph.getView().getOverlayPane()));
}, mxEdgeHandler.prototype.getHandleForEvent = function(a) {
if (null != this.bends) for (var b = this.tolerance, b = this.allowHandleBoundsCheck && (mxClient.IS_IE || b > 0) ? new mxRectangle(a.getGraphX() - b, a.getGraphY() - b, 2 * b, 2 * b) :null, c = 0; c < this.bends.length; c++) if ((a.isSource(this.bends[c]) || null != b && mxUtils.intersects(this.bends[c].bounds, b)) && "hidden" != this.bends[c].node.style.visibility) return c;
return !(a.isSource(this.labelShape) && "hidden" != this.labelShape.node.style.visibility || a.isSource(this.state.text)) || (mxClient.IS_SF || mxClient.IS_GC) && "SELECT" == a.getSource().nodeName ? null :mxEvent.LABEL_HANDLE;
}, mxEdgeHandler.prototype.mouseDown = function(a, b) {
var c = null, c = this.getHandleForEvent(b);
null != c && !b.isConsumed() && this.graph.isEnabled() && !this.graph.isForceMarqueeEvent(b.getEvent()) && (this.removeEnabled && this.isRemovePointEvent(b.getEvent()) ? this.removePoint(this.state, c) :(c != mxEvent.LABEL_HANDLE || this.graph.isLabelMovable(b.getCell())) && this.start(b.getX(), b.getY(), c), 
b.consume());
}, mxEdgeHandler.prototype.start = function(a, b, c) {
this.startX = a, this.startY = b, this.isSource = null == this.bends ? !1 :0 == c, 
this.isTarget = null == this.bends ? !1 :c == this.bends.length - 1, this.isLabel = c == mxEvent.LABEL_HANDLE, 
this.isSource || this.isTarget ? (a = this.state.cell, b = this.graph.model.getTerminal(a, this.isSource), 
(null == b && this.graph.isTerminalPointMovable(a, this.isSource) || null != b && this.graph.isCellDisconnectable(a, b, this.isSource)) && (this.index = c)) :this.index = c, 
this.livePreview && (this.shape.node.style.visibility = "hidden", (this.isSource || this.isTarget) && null != this.bends[c]) && (this.bends[c].node.style.display = "none");
}, mxEdgeHandler.prototype.clonePreviewState = function() {
return this.state.clone();
}, mxEdgeHandler.prototype.getSnapToTerminalTolerance = function() {
return this.graph.gridSize * this.graph.view.scale / 2;
}, mxEdgeHandler.prototype.getPointForEvent = function(a) {
var b = new mxPoint(a.getGraphX(), a.getGraphY()), c = this.getSnapToTerminalTolerance(), d = this.graph.getView(), e = !1, f = !1;
if (this.snapToTerminals && c > 0) {
var g = function(a) {
if (null != a) {
var d = a.x;
Math.abs(b.x - d) < c && (b.x = d, e = !0), a = a.y, Math.abs(b.y - a) < c && (b.y = a, 
f = !0);
}
}, h = function(a) {
null != a && g.call(this, new mxPoint(d.getRoutingCenterX(a), d.getRoutingCenterY(a)));
};
if (h.call(this, this.state.getVisibleTerminalState(!0)), h.call(this, this.state.getVisibleTerminalState(!1)), 
null != this.abspoints) for (h = 0; h < this.abspoints; h++) h != this.index && g.call(this, this.abspoints[h]);
}
return this.graph.isGridEnabledEvent(a.getEvent()) && (a = d.scale, h = d.translate, 
e || (b.x = (this.graph.snap(b.x / a - h.x) + h.x) * a), f || (b.y = (this.graph.snap(b.y / a - h.y) + h.y) * a)), 
b;
}, mxEdgeHandler.prototype.getPreviewTerminalState = function(a) {
this.constraintHandler.update(a, this.isSource), this.marker.process(a), a = this.marker.getValidState();
var b = null;
return null != this.constraintHandler.currentFocus && null != this.constraintHandler.currentConstraint && this.marker.reset(), 
null != a ? b = a :null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && (b = this.constraintHandler.currentFocus), 
b;
}, mxEdgeHandler.prototype.getPreviewPoints = function(a) {
var b = this.graph.getCellGeometry(this.state.cell), b = null != b.points ? b.points.slice() :null;
return this.isSource || this.isTarget ? this.graph.resetEdgesOnConnect && (b = null) :(this.convertPoint(a, !1), 
null == b ? b = [ a ] :b[this.index - 1] = a), b;
}, mxEdgeHandler.prototype.updatePreviewState = function(a, b, c) {
var d = this.isSource ? c :this.state.getVisibleTerminalState(!0), e = this.isTarget ? c :this.state.getVisibleTerminalState(!1), f = this.graph.getConnectionConstraint(a, d, !0), g = this.graph.getConnectionConstraint(a, e, !1), h = this.constraintHandler.currentConstraint;
null == h && (h = new mxConnectionConstraint()), this.isSource ? f = h :this.isTarget && (g = h), 
(!this.isSource || null != d) && a.view.updateFixedTerminalPoint(a, d, !0, f), (!this.isTarget || null != e) && a.view.updateFixedTerminalPoint(a, e, !1, g), 
(this.isSource || this.isTarget) && null == c && (a.setAbsoluteTerminalPoint(b, this.isSource), 
null == this.marker.getMarkedState() && (this.error = this.graph.allowDanglingEdges ? null :"")), 
a.view.updatePoints(a, this.points, d, e), a.view.updateFloatingTerminalPoints(a, d, e);
}, mxEdgeHandler.prototype.mouseMove = function(a, b) {
if (null != this.index && null != this.marker) {
var c = this.getPointForEvent(b);
if (this.isLabel) this.label.x = c.x, this.label.y = c.y; else {
this.points = this.getPreviewPoints(c);
var d = this.isSource || this.isTarget ? this.getPreviewTerminalState(b) :null, e = this.clonePreviewState(c, null != d ? d.cell :null);
this.updatePreviewState(e, c, d), this.setPreviewColor(null == this.error ? this.marker.validColor :this.marker.invalidColor), 
this.abspoints = e.absolutePoints, this.active = !0;
}
this.livePreview ? (d = this.state.absolutePoints, this.isLabel ? this.state.absoluteOffset = c :(this.state.absolutePoints = this.abspoints, 
this.state.view.updateEdgeBounds(this.state), this.state.view.updateEdgeLabelOffset(this.state)), 
this.state.view.graph.cellRenderer.redraw(this.state, !0), this.redrawHandles(), 
this.state.view.invalidate(this.state.cell), this.state.invalid = !1, this.state.view.validate(), 
this.state.absolutePoints = d, this.state.view.updateEdgeBounds(this.state), this.state.view.updateEdgeLabelOffset(this.state)) :this.drawPreview(), 
mxEvent.consume(b.getEvent()), b.consume();
} else mxClient.IS_IE && null != this.getHandleForEvent(b) && b.consume(!1);
}, mxEdgeHandler.prototype.mouseUp = function(a, b) {
if (null != this.index && null != this.marker) {
var c = this.state.cell;
if (b.getX() != this.startX || b.getY() != this.startY) if (null != this.error) 0 < this.error.length && this.graph.validationAlert(this.error); else if (this.isLabel) this.moveLabel(this.state, this.label.x, this.label.y); else if (this.isSource || this.isTarget) {
var d = null;
if (null != this.constraintHandler.currentConstraint && null != this.constraintHandler.currentFocus && (d = this.constraintHandler.currentFocus.cell), 
null == d && this.marker.hasValidState() && (d = this.marker.validState.cell), null != d) c = this.connect(c, d, this.isSource, this.graph.isCloneEvent(b.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable(), b); else if (this.graph.isAllowDanglingEdges()) {
d = this.abspoints[this.isSource ? 0 :this.abspoints.length - 1], d.x = d.x / this.graph.view.scale - this.graph.view.translate.x, 
d.y = d.y / this.graph.view.scale - this.graph.view.translate.y;
var e = this.graph.getView().getState(this.graph.getModel().getParent(c));
null != e && (d.x -= e.origin.x, d.y -= e.origin.y), d.x -= this.graph.panDx / this.graph.view.scale, 
d.y -= this.graph.panDy / this.graph.view.scale, this.changeTerminalPoint(c, d, this.isSource);
}
} else this.active ? this.changePoints(c, this.points) :(this.graph.getView().invalidate(this.state.cell), 
this.graph.getView().revalidate(this.state.cell));
null != this.marker && (this.reset(), c != this.state.cell && this.graph.setSelectionCell(c)), 
b.consume();
}
}, mxEdgeHandler.prototype.reset = function() {
null != this.bends && null != this.index && null != this.bends[this.index] && "none" == this.bends[this.index].node.style.display && (this.bends[this.index].node.style.display = ""), 
this.points = this.label = this.index = this.error = null, this.isTarget = this.isSource = this.isLabel = this.active = !1, 
this.marker.reset(), this.constraintHandler.reset(), this.setPreviewColor(mxConstants.EDGE_SELECTION_COLOR), 
this.redraw();
}, mxEdgeHandler.prototype.setPreviewColor = function(a) {
null != this.shape && (this.shape.stroke = a);
}, mxEdgeHandler.prototype.convertPoint = function(a, b) {
var c = this.graph.getView().getScale(), d = this.graph.getView().getTranslate();
return b && (a.x = this.graph.snap(a.x), a.y = this.graph.snap(a.y)), a.x = Math.round(a.x / c - d.x), 
a.y = Math.round(a.y / c - d.y), c = this.graph.getView().getState(this.graph.getModel().getParent(this.state.cell)), 
null != c && (a.x -= c.origin.x, a.y -= c.origin.y), a;
}, mxEdgeHandler.prototype.moveLabel = function(a, b, c) {
var d = this.graph.getModel(), e = d.getGeometry(a.cell);
if (null != e) {
var e = e.clone(), f = this.graph.getView().getRelativePoint(a, b, c);
e.x = f.x, e.y = f.y;
var g = this.graph.getView().scale;
e.offset = new mxPoint(0, 0), f = this.graph.view.getPoint(a, e), e.offset = new mxPoint((b - f.x) / g, (c - f.y) / g), 
d.setGeometry(a.cell, e);
}
}, mxEdgeHandler.prototype.connect = function(a, b, c, d, e) {
e = this.graph.getModel();
var f = e.getParent(a);
e.beginUpdate();
try {
if (d) {
var g = a.clone();
e.add(f, g, e.getChildCount(f));
var h = e.getTerminal(a, !c);
this.graph.connectCell(g, h, !c), a = g;
}
var k = this.constraintHandler.currentConstraint;
null == k && (k = new mxConnectionConstraint()), this.graph.connectCell(a, b, c, k);
} finally {
e.endUpdate();
}
return a;
}, mxEdgeHandler.prototype.changeTerminalPoint = function(a, b, c) {
var d = this.graph.getModel(), e = d.getGeometry(a);
if (null != e) {
d.beginUpdate();
try {
e = e.clone(), e.setTerminalPoint(b, c), d.setGeometry(a, e), this.graph.connectCell(a, null, c, new mxConnectionConstraint());
} finally {
d.endUpdate();
}
}
}, mxEdgeHandler.prototype.changePoints = function(a, b) {
var c = this.graph.getModel(), d = c.getGeometry(a);
null != d && (d = d.clone(), d.points = b, c.setGeometry(a, d));
}, mxEdgeHandler.prototype.addPoint = function(a, b) {
var c = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(b), mxEvent.getClientY(b)), d = this.graph.isGridEnabledEvent(b);
this.convertPoint(c, d), this.addPointAt(a, c.x, c.y), mxEvent.consume(b);
}, mxEdgeHandler.prototype.addPointAt = function(a, b, c) {
var d = this.graph.getCellGeometry(a.cell);
if (b = new mxPoint(b, c), null != d) {
d = d.clone(), c = this.graph.view.translate;
var e = this.graph.view.scale;
c = mxUtils.findNearestSegment(a, (b.x + c.x) * e, (b.y + c.y) * e), null == d.points ? d.points = [ b ] :d.points.splice(c, 0, b), 
this.graph.getModel().setGeometry(a.cell, d), this.destroy(), this.init();
}
}, mxEdgeHandler.prototype.removePoint = function(a, b) {
if (b > 0 && b < this.abspoints.length - 1) {
var c = this.graph.getCellGeometry(this.state.cell);
null != c && null != c.points && (c = c.clone(), c.points.splice(b - 1, 1), this.graph.getModel().setGeometry(a.cell, c), 
this.destroy(), this.init());
}
}, mxEdgeHandler.prototype.getHandleFillColor = function(a) {
a = 0 == a;
var b = this.state.cell, c = this.graph.getModel().getTerminal(b, a), d = mxConstants.HANDLE_FILLCOLOR;
return null != c && !this.graph.isCellDisconnectable(b, c, a) || null == c && !this.graph.isTerminalPointMovable(b, a) ? d = mxConstants.LOCKED_HANDLE_FILLCOLOR :null != c && this.graph.isCellDisconnectable(b, c, a) && (d = mxConstants.CONNECT_HANDLE_FILLCOLOR), 
d;
}, mxEdgeHandler.prototype.redraw = function() {
this.abspoints = this.state.absolutePoints.slice(), this.redrawHandles();
var a = this.graph.getModel().getGeometry(this.state.cell).points;
if (null != this.bends && 0 < this.bends.length && null != a) {
null == this.points && (this.points = []);
for (var b = 1; b < this.bends.length - 1; b++) null != this.bends[b] && null != this.abspoints[b] && (this.points[b - 1] = a[b - 1]);
}
this.drawPreview();
}, mxEdgeHandler.prototype.redrawHandles = function() {
var a = this.state.cell, b = mxConstants.LABEL_HANDLE_SIZE;
if (this.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y), 
this.labelShape.bounds = new mxRectangle(Math.round(this.label.x - b / 2), Math.round(this.label.y - b / 2), b, b), 
this.labelShape.redraw(), b = this.graph.getLabel(a), this.labelShape.node.style.visibility = null != b && 0 < b.length && this.graph.isLabelMovable(a) ? "visible" :"hidden", 
null != this.bends && 0 < this.bends.length) {
var c = this.abspoints.length - 1, a = this.abspoints[0], d = this.abspoints[0].y, b = this.bends[0].bounds;
this.bends[0].bounds = new mxRectangle(Math.round(this.abspoints[0].x - b.width / 2), Math.round(d - b.height / 2), b.width, b.height), 
this.bends[0].fill = this.getHandleFillColor(0), this.bends[0].redraw();
var d = this.abspoints[c], e = this.abspoints[c].x, c = this.abspoints[c].y, f = this.bends.length - 1, b = this.bends[f].bounds;
this.bends[f].bounds = new mxRectangle(Math.round(e - b.width / 2), Math.round(c - b.height / 2), b.width, b.height), 
this.bends[f].fill = this.getHandleFillColor(f), this.bends[f].redraw(), this.redrawInnerBends(a, d);
}
}, mxEdgeHandler.prototype.redrawInnerBends = function() {
for (var c = 1; c < this.bends.length - 1; c++) if (null != this.bends[c]) if (null != this.abspoints[c]) {
var d = this.abspoints[c].x, e = this.abspoints[c].y, f = this.bends[c].bounds;
this.bends[c].node.style.visibility = "visible", this.bends[c].bounds = new mxRectangle(Math.round(d - f.width / 2), Math.round(e - f.height / 2), f.width, f.height), 
this.bends[c].redraw();
} else this.bends[c].destroy(), this.bends[c] = null;
}, mxEdgeHandler.prototype.drawPreview = function() {
if (this.isLabel) {
var a = mxConstants.LABEL_HANDLE_SIZE, a = new mxRectangle(Math.round(this.label.x - a / 2), Math.round(this.label.y - a / 2), a, a);
this.labelShape.bounds = a, this.labelShape.redraw();
} else this.shape.points = this.abspoints, this.shape.redraw();
}, mxEdgeHandler.prototype.destroy = function() {
if (null != this.marker && (this.marker.destroy(), this.marker = null), null != this.shape && (this.shape.destroy(), 
this.shape = null), null != this.labelShape && (this.labelShape.destroy(), this.labelShape = null), 
null != this.constraintHandler && (this.constraintHandler.destroy(), this.constraintHandler = null), 
null != this.bends) for (var a = 0; a < this.bends.length; a++) null != this.bends[a] && (this.bends[a].destroy(), 
this.bends[a] = null);
}, mxUtils.extend(mxElbowEdgeHandler, mxEdgeHandler), mxElbowEdgeHandler.prototype = new mxEdgeHandler(), 
mxElbowEdgeHandler.prototype.constructor = mxElbowEdgeHandler, mxElbowEdgeHandler.prototype.flipEnabled = !0, 
mxElbowEdgeHandler.prototype.doubleClickOrientationResource = "none" != mxClient.language ? "doubleClickOrientation" :"", 
mxElbowEdgeHandler.prototype.createBends = function() {
var a = [], b = this.createHandleShape(0);
return this.initBend(b), b.node.style.cursor = mxConstants.CURSOR_BEND_HANDLE, mxEvent.redirectMouseEvents(b.node, this.graph, this.state), 
a.push(b), mxClient.IS_TOUCH && b.node.setAttribute("pointer-events", "none"), a.push(this.createVirtualBend()), 
this.points.push(new mxPoint(0, 0)), b = this.createHandleShape(2), this.initBend(b), 
b.node.style.cursor = mxConstants.CURSOR_BEND_HANDLE, mxEvent.redirectMouseEvents(b.node, this.graph, this.state), 
a.push(b), mxClient.IS_TOUCH && b.node.setAttribute("pointer-events", "none"), a;
}, mxElbowEdgeHandler.prototype.createVirtualBend = function() {
var a = this.createHandleShape();
this.initBend(a);
var b = this.getCursorForBend();
return a.node.style.cursor = b, b = mxUtils.bind(this, function(a) {
!mxEvent.isConsumed(a) && this.flipEnabled && (this.graph.flipEdge(this.state.cell, a), 
mxEvent.consume(a));
}), mxEvent.redirectMouseEvents(a.node, this.graph, this.state, null, null, null, b), 
this.graph.isCellBendable(this.state.cell) || (a.node.style.display = "none"), a;
}, mxElbowEdgeHandler.prototype.getCursorForBend = function() {
return this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.TopToBottom || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_TOPTOBOTTOM || (this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.ElbowConnector || this.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_ELBOW) && this.state.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL ? "row-resize" :"col-resize";
}, mxElbowEdgeHandler.prototype.getTooltipForNode = function(a) {
var b = null;
return null == this.bends || null == this.bends[1] || a != this.bends[1].node && a.parentNode != this.bends[1].node || (b = this.doubleClickOrientationResource, 
b = mxResources.get(b) || b), b;
}, mxElbowEdgeHandler.prototype.convertPoint = function(a, b) {
var c = this.graph.getView().getScale(), d = this.graph.getView().getTranslate(), e = this.state.origin;
b && (a.x = this.graph.snap(a.x), a.y = this.graph.snap(a.y)), a.x = Math.round(a.x / c - d.x - e.x), 
a.y = Math.round(a.y / c - d.y - e.y);
}, mxElbowEdgeHandler.prototype.redrawInnerBends = function(a, b) {
var c = this.graph.getModel().getGeometry(this.state.cell).points, c = null != c ? c[0] :null, c = null == c ? new mxPoint(a.x + (b.x - a.x) / 2, a.y + (b.y - a.y) / 2) :new mxPoint(this.graph.getView().scale * (c.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale * (c.y + this.graph.getView().translate.y + this.state.origin.y)), d = this.bends[1].bounds, e = d.width, d = d.height;
null == this.handleImage && (d = e = mxConstants.HANDLE_SIZE);
var f = new mxRectangle(Math.round(c.x - e / 2), Math.round(c.y - d / 2), e, d);
null == this.handleImage && "hidden" != this.labelShape.node.style.visibility && mxUtils.intersects(f, this.labelShape.bounds) && (e += 3, 
d += 3, f = new mxRectangle(Math.round(c.x - e / 2), Math.round(c.y - d / 2), e, d)), 
this.bends[1].bounds = f, this.bends[1].redraw();
}, mxUtils.extend(mxEdgeSegmentHandler, mxEdgeHandler), mxEdgeSegmentHandler.prototype = new mxElbowEdgeHandler(), 
mxEdgeSegmentHandler.prototype.constructor = mxEdgeSegmentHandler, mxEdgeSegmentHandler.prototype.getPreviewPoints = function(a) {
if (this.isSource || this.isTarget) return mxElbowEdgeHandler.prototype.getPreviewPoints.apply(this, arguments);
this.convertPoint(a, !1);
var b = this.state.absolutePoints, c = b[0].clone();
this.convertPoint(c, !1);
for (var d = [], e = 1; e < b.length; e++) {
var f = b[e].clone();
this.convertPoint(f, !1), e == this.index && (c.x == f.x ? (c.x = a.x, f.x = a.x) :(c.y = a.y, 
f.y = a.y)), e < b.length - 1 && d.push(f), c = f;
}
if (1 == d.length) {
if (c = this.state.view, e = this.state.getVisibleTerminalState(!0), f = this.state.getVisibleTerminalState(!1), 
null != f & null != e) {
var g = this.state.origin.x, h = this.state.origin.y;
mxUtils.contains(f, d[0].x + g, d[0].y + h) ? b[1].y == b[2].y ? d[0].y = c.getRoutingCenterY(e) - h :d[0].x = c.getRoutingCenterX(e) - g :mxUtils.contains(e, d[0].x + g, d[0].y + h) && (b[1].y == b[0].y ? d[0].y = c.getRoutingCenterY(f) - h :d[0].x = c.getRoutingCenterX(f) - g);
}
} else 0 == d.length && (d = [ a ]);
return d;
}, mxEdgeSegmentHandler.prototype.createBends = function() {
var a = [], b = this.createHandleShape(0);
this.initBend(b), b.node.style.cursor = mxConstants.CURSOR_BEND_HANDLE, mxEvent.redirectMouseEvents(b.node, this.graph, this.state), 
a.push(b), mxClient.IS_TOUCH && b.node.setAttribute("pointer-events", "none");
var c = this.state.absolutePoints;
if (this.graph.isCellBendable(this.state.cell)) {
null == this.points && (this.points = []);
for (var d = 0; d < c.length - 1; d++) b = this.createVirtualBend(), a.push(b), 
b.node.style.cursor = 0 == c[d].x - c[d + 1].x ? "col-resize" :"row-resize", this.points.push(new mxPoint(0, 0)), 
mxClient.IS_TOUCH && b.node.setAttribute("pointer-events", "none");
}
return b = this.createHandleShape(c.length), this.initBend(b), b.node.style.cursor = mxConstants.CURSOR_BEND_HANDLE, 
mxEvent.redirectMouseEvents(b.node, this.graph, this.state), a.push(b), mxClient.IS_TOUCH && b.node.setAttribute("pointer-events", "none"), 
a;
}, mxEdgeSegmentHandler.prototype.redraw = function() {
this.refresh(), mxEdgeHandler.prototype.redraw.apply(this, arguments);
}, mxEdgeSegmentHandler.prototype.refresh = function() {
if (null != this.bends) {
for (var a = 0; a < this.bends.length; a++) null != this.bends[a] && (this.bends[a].destroy(), 
this.bends[a] = null);
this.bends = this.createBends();
}
}, mxEdgeSegmentHandler.prototype.redrawInnerBends = function(a, b) {
if (this.graph.isCellBendable(this.state.cell)) {
var c = mxConstants.HANDLE_SIZE, d = this.state.absolutePoints;
if (null != d && 1 < d.length) for (var e = 0; e < this.state.absolutePoints.length - 1; e++) if (null != this.bends[e + 1]) {
a = d[e], b = d[e + 1];
var f = new mxPoint(a.x + (b.x - a.x) / 2, a.y + (b.y - a.y) / 2);
this.bends[e + 1].bounds = new mxRectangle(Math.round(f.x - c / 2), Math.round(f.y - c / 2), c, c), 
this.bends[e + 1].redraw();
}
}
}, mxEdgeSegmentHandler.prototype.changePoints = function(a, b) {
b = [];
var c = this.abspoints;
if (1 < c.length) for (var d = c[0], e = c[1], f = 2; f < c.length; f++) {
var g = c[f];
Math.round(d.x) == Math.round(e.x) && Math.round(e.x) == Math.round(g.x) || Math.round(d.y) == Math.round(e.y) && Math.round(e.y) == Math.round(g.y) || (d = e, 
e = e.clone(), this.convertPoint(e, !1), b.push(e)), e = g;
}
mxElbowEdgeHandler.prototype.changePoints.apply(this, arguments);
}, mxKeyHandler.prototype.graph = null, mxKeyHandler.prototype.target = null, mxKeyHandler.prototype.normalKeys = null, 
mxKeyHandler.prototype.shiftKeys = null, mxKeyHandler.prototype.controlKeys = null, 
mxKeyHandler.prototype.controlShiftKeys = null, mxKeyHandler.prototype.enabled = !0, 
mxKeyHandler.prototype.isEnabled = function() {
return this.enabled;
}, mxKeyHandler.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxKeyHandler.prototype.bindKey = function(a, b) {
this.normalKeys[a] = b;
}, mxKeyHandler.prototype.bindShiftKey = function(a, b) {
this.shiftKeys[a] = b;
}, mxKeyHandler.prototype.bindControlKey = function(a, b) {
this.controlKeys[a] = b;
}, mxKeyHandler.prototype.bindControlShiftKey = function(a, b) {
this.controlShiftKeys[a] = b;
}, mxKeyHandler.prototype.isControlDown = function(a) {
return mxEvent.isControlDown(a);
}, mxKeyHandler.prototype.getFunction = function(a) {
return null != a ? this.isControlDown(a) ? mxEvent.isShiftDown(a) ? this.controlShiftKeys[a.keyCode] :this.controlKeys[a.keyCode] :mxEvent.isShiftDown(a) ? this.shiftKeys[a.keyCode] :this.normalKeys[a.keyCode] :null;
}, mxKeyHandler.prototype.isGraphEvent = function(a) {
if (a = mxEvent.getSource(a), a == this.target || a.parentNode == this.target || null != this.graph.cellEditor && a == this.graph.cellEditor.textarea) return !0;
for (;null != a; ) {
if (a == this.graph.container) return !0;
a = a.parentNode;
}
return !1;
}, mxKeyHandler.prototype.keyDown = function(a) {
if (this.graph.isEnabled() && !mxEvent.isConsumed(a) && this.isGraphEvent(a) && this.isEnabled()) if (27 == a.keyCode) this.escape(a); else if (!this.graph.isEditing()) {
var b = this.getFunction(a);
null != b && (b(a), mxEvent.consume(a));
}
}, mxKeyHandler.prototype.escape = function(a) {
this.graph.isEscapeEnabled() && this.graph.escape(a);
}, mxKeyHandler.prototype.destroy = function() {
this.target = null;
}, mxTooltipHandler.prototype.zIndex = 10005, mxTooltipHandler.prototype.graph = null, 
mxTooltipHandler.prototype.delay = null, mxTooltipHandler.prototype.hideOnHover = !1, 
mxTooltipHandler.prototype.enabled = !0, mxTooltipHandler.prototype.isEnabled = function() {
return this.enabled;
}, mxTooltipHandler.prototype.setEnabled = function(a) {
this.enabled = a;
}, mxTooltipHandler.prototype.isHideOnHover = function() {
return this.hideOnHover;
}, mxTooltipHandler.prototype.setHideOnHover = function(a) {
this.hideOnHover = a;
}, mxTooltipHandler.prototype.init = function() {
null != document.body && (this.div = document.createElement("div"), this.div.className = "mxTooltip", 
this.div.style.visibility = "hidden", document.body.appendChild(this.div), mxEvent.addGestureListeners(this.div, mxUtils.bind(this, function() {
this.hideTooltip();
})));
}, mxTooltipHandler.prototype.mouseDown = function(a, b) {
this.reset(b, !1), this.hideTooltip();
}, mxTooltipHandler.prototype.mouseMove = function(a, b) {
(b.getX() != this.lastX || b.getY() != this.lastY) && (this.reset(b, !0), (this.isHideOnHover() || b.getState() != this.state || b.getSource() != this.node && (!this.stateSource || null != b.getState() && this.stateSource == (b.isSource(b.getState().shape) || !b.isSource(b.getState().text)))) && this.hideTooltip()), 
this.lastX = b.getX(), this.lastY = b.getY();
}, mxTooltipHandler.prototype.mouseUp = function(a, b) {
this.reset(b, !0), this.hideTooltip();
}, mxTooltipHandler.prototype.resetTimer = function() {
null != this.thread && (window.clearTimeout(this.thread), this.thread = null);
}, mxTooltipHandler.prototype.reset = function(a, b) {
if (this.resetTimer(), b && this.isEnabled() && null != a.getState() && (null == this.div || "hidden" == this.div.style.visibility)) {
var c = a.getState(), d = a.getSource(), e = a.getX(), f = a.getY(), g = a.isSource(c.shape) || a.isSource(c.text);
this.thread = window.setTimeout(mxUtils.bind(this, function() {
if (!this.graph.isEditing() && !this.graph.panningHandler.isMenuShowing()) {
var a = this.graph.getTooltip(c, d, e, f);
this.show(a, e, f), this.state = c, this.node = d, this.stateSource = g;
}
}), this.delay);
}
}, mxTooltipHandler.prototype.hide = function() {
this.resetTimer(), this.hideTooltip();
}, mxTooltipHandler.prototype.hideTooltip = function() {
null != this.div && (this.div.style.visibility = "hidden");
}, mxTooltipHandler.prototype.show = function(a, b, c) {
if (null != a && 0 < a.length) {
null == this.div && this.init();
var d = mxUtils.getScrollOrigin();
this.div.style.zIndex = this.zIndex, this.div.style.left = b + d.x + "px", this.div.style.top = c + mxConstants.TOOLTIP_VERTICAL_OFFSET + d.y + "px", 
mxUtils.isNode(a) ? (this.div.innerHTML = "", this.div.appendChild(a)) :this.div.innerHTML = a.replace(/\n/g, "<br>"), 
this.div.style.visibility = "", mxUtils.fit(this.div);
}
}, mxTooltipHandler.prototype.destroy = function() {
this.graph.removeMouseListener(this), mxEvent.release(this.div), null != this.div && null != this.div.parentNode && this.div.parentNode.removeChild(this.div), 
this.div = null;
}, mxUtils.extend(mxCellTracker, mxCellMarker), mxCellTracker.prototype.mouseDown = function() {}, 
mxCellTracker.prototype.mouseMove = function(a, b) {
this.isEnabled() && this.process(b);
}, mxCellTracker.prototype.mouseUp = function() {
this.reset();
}, mxCellTracker.prototype.destroy = function() {
this.destroyed || (this.destroyed = !0, this.graph.removeMouseListener(this), mxCellMarker.prototype.destroy.apply(this));
}, mxCellHighlight.prototype.keepOnTop = !1, mxCellHighlight.prototype.graph = !0, 
mxCellHighlight.prototype.state = null, mxCellHighlight.prototype.spacing = 2, mxCellHighlight.prototype.resetHandler = null, 
mxCellHighlight.prototype.setHighlightColor = function(a) {
this.highlightColor = a, null != this.shape && (this.shape.stroke = a);
}, mxCellHighlight.prototype.drawHighlight = function() {
this.shape = this.createShape(), this.repaint(), !this.keepOnTop && this.shape.node.parentNode.firstChild != this.shape.node && this.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);
}, mxCellHighlight.prototype.createShape = function() {
var a = null, a = this.graph.model.isEdge(this.state.cell) ? new mxPolyline(this.state.absolutePoints, this.highlightColor, this.strokeWidth) :new mxRectangleShape(new mxRectangle(), null, this.highlightColor, this.strokeWidth);
return a.dialect = this.graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
a.init(this.graph.getView().getOverlayPane()), mxEvent.redirectMouseEvents(a.node, this.graph, this.state), 
a.svgStrokeTolerance = 0, a.pointerEvents = !1, a.isDashed = this.dashed, a;
}, mxCellHighlight.prototype.repaint = function() {
null != this.state && null != this.shape && (this.graph.model.isEdge(this.state.cell) ? this.shape.points = this.state.absolutePoints :(this.shape.bounds = new mxRectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing), 
this.shape.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || "0")), 
null != this.state.shape && this.shape.setCursor(this.state.shape.getCursor()), 
this.shape.redraw());
}, mxCellHighlight.prototype.hide = function() {
this.highlight(null);
}, mxCellHighlight.prototype.highlight = function(a) {
this.state != a && (null != this.shape && (this.shape.destroy(), this.shape = null), 
this.state = a, null != this.state && this.drawHighlight());
}, mxCellHighlight.prototype.destroy = function() {
this.graph.getView().removeListener(this.repaintHandler), this.graph.getModel().removeListener(this.repaintHandler), 
this.graph.getView().removeListener(this.resetHandler), this.graph.getModel().removeListener(this.resetHandler), 
null != this.shape && (this.shape.destroy(), this.shape = null);
}, mxDefaultKeyHandler.prototype.editor = null, mxDefaultKeyHandler.prototype.handler = null, 
mxDefaultKeyHandler.prototype.bindAction = function(a, b, c) {
var d = mxUtils.bind(this, function() {
this.editor.execute(b);
});
c ? this.handler.bindControlKey(a, d) :this.handler.bindKey(a, d);
}, mxDefaultKeyHandler.prototype.destroy = function() {
this.handler.destroy(), this.handler = null;
}, mxDefaultPopupMenu.prototype.imageBasePath = null, mxDefaultPopupMenu.prototype.config = null, 
mxDefaultPopupMenu.prototype.createMenu = function(a, b, c, d) {
if (null != this.config) {
var e = this.createConditions(a, c, d);
this.addItems(a, b, c, d, e, this.config.firstChild, null);
}
}, mxDefaultPopupMenu.prototype.addItems = function(a, b, c, d, e, f, g) {
for (var h = !1; null != f; ) {
if ("add" == f.nodeName) {
var k = f.getAttribute("if");
if (null == k || e[k]) {
var k = f.getAttribute("as"), k = mxResources.get(k) || k, l = mxUtils.eval(mxUtils.getTextContent(f)), m = f.getAttribute("action"), n = f.getAttribute("icon"), p = f.getAttribute("iconCls");
h && (b.addSeparator(g), h = !1), null != n && this.imageBasePath && (n = this.imageBasePath + n), 
k = this.addAction(b, a, k, n, l, m, c, g, p), this.addItems(a, b, c, d, e, f.firstChild, k);
}
} else "separator" == f.nodeName && (h = !0);
f = f.nextSibling;
}
}, mxDefaultPopupMenu.prototype.addAction = function(a, b, c, d, e, f, g, h, k) {
return a.addItem(c, d, function(a) {
"function" == typeof e && e.call(b, b, g, a), null != f && b.execute(f, g, a);
}, h, k);
}, mxDefaultPopupMenu.prototype.createConditions = function(a, b, c) {
var d = a.graph.getModel(), e = d.getChildCount(b), f = [];
for (f.nocell = null == b, f.ncells = 1 < a.graph.getSelectionCount(), f.notRoot = d.getRoot() != d.getParent(a.graph.getDefaultParent()), 
f.cell = null != b, d = null != b && 1 == a.graph.getSelectionCount(), f.nonEmpty = d && e > 0, 
f.expandable = d && a.graph.isCellFoldable(b, !1), f.collapsable = d && a.graph.isCellFoldable(b, !0), 
f.validRoot = d && a.graph.isValidRoot(b), f.emptyValidRoot = f.validRoot && 0 == e, 
f.swimlane = d && a.graph.isSwimlane(b), e = this.config.getElementsByTagName("condition"), 
d = 0; d < e.length; d++) {
var g = mxUtils.eval(mxUtils.getTextContent(e[d])), h = e[d].getAttribute("name");
null != h && "function" == typeof g && (f[h] = g(a, b, c));
}
return f;
}, mxDefaultToolbar.prototype.editor = null, mxDefaultToolbar.prototype.toolbar = null, 
mxDefaultToolbar.prototype.resetHandler = null, mxDefaultToolbar.prototype.spacing = 4, 
mxDefaultToolbar.prototype.connectOnDrop = !1, mxDefaultToolbar.prototype.init = function(a) {
null != a && (this.toolbar = new mxToolbar(a), this.toolbar.addListener(mxEvent.SELECT, mxUtils.bind(this, function(a, c) {
var d = c.getProperty("function");
this.editor.insertFunction = null != d ? mxUtils.bind(this, function() {
d.apply(this, arguments), this.toolbar.resetMode();
}) :null;
})), this.resetHandler = mxUtils.bind(this, function() {
null != this.toolbar && this.toolbar.resetMode(!0);
}), this.editor.graph.addListener(mxEvent.DOUBLE_CLICK, this.resetHandler), this.editor.addListener(mxEvent.ESCAPE, this.resetHandler));
}, mxDefaultToolbar.prototype.addItem = function(a, b, c, d) {
var e = mxUtils.bind(this, function() {
null != c && 0 < c.length && this.editor.execute(c);
});
return this.toolbar.addItem(a, b, e, d);
}, mxDefaultToolbar.prototype.addSeparator = function(a) {
a = a || mxClient.imageBasePath + "/separator.gif", this.toolbar.addSeparator(a);
}, mxDefaultToolbar.prototype.addCombo = function() {
return this.toolbar.addCombo();
}, mxDefaultToolbar.prototype.addActionCombo = function(a) {
return this.toolbar.addActionCombo(a);
}, mxDefaultToolbar.prototype.addActionOption = function(a, b, c) {
var d = mxUtils.bind(this, function() {
this.editor.execute(c);
});
this.addOption(a, b, d);
}, mxDefaultToolbar.prototype.addOption = function(a, b, c) {
return this.toolbar.addOption(a, b, c);
}, mxDefaultToolbar.prototype.addMode = function(a, b, c, d, e) {
var f = mxUtils.bind(this, function() {
this.editor.setMode(c), null != e && e(this.editor);
});
return this.toolbar.addSwitchMode(a, b, f, d);
}, mxDefaultToolbar.prototype.addPrototype = function(a, b, c, d, e, f) {
var g = function() {
return "function" == typeof c ? c() :null != c ? c.clone() :null;
}, h = mxUtils.bind(this, function(a, b) {
"function" == typeof e ? e(this.editor, g(), a, b) :this.drop(g(), a, b), this.toolbar.resetMode(), 
mxEvent.consume(a);
});
return a = this.toolbar.addMode(a, b, h, d, null, f), this.installDropHandler(a, function(a, b, c) {
h(b, c);
}), a;
}, mxDefaultToolbar.prototype.drop = function(a, b, c) {
var d = this.editor.graph, e = d.getModel();
if (null != c && !e.isEdge(c) && this.connectOnDrop && d.isCellConnectable(c)) this.connect(a, b, c); else {
for (;null != c && !d.isValidDropTarget(c, [ a ], b); ) c = e.getParent(c);
this.insert(a, b, c);
}
}, mxDefaultToolbar.prototype.insert = function(a, b, c) {
var d = this.editor.graph;
if (d.canImportCell(a)) {
var e = mxEvent.getClientX(b), f = mxEvent.getClientY(b), e = mxUtils.convertPoint(d.container, e, f);
return d.isSplitEnabled() && d.isSplitTarget(c, [ a ], b) ? d.splitEdge(c, [ a ], null, e.x, e.y) :this.editor.addVertex(c, a, e.x, e.y);
}
return null;
}, mxDefaultToolbar.prototype.connect = function(a, b, c) {
b = this.editor.graph;
var d = b.getModel();
if (null != c && b.isCellConnectable(a) && b.isEdgeValid(null, c, a)) {
var e = null;
d.beginUpdate();
try {
var f = d.getGeometry(c), g = d.getGeometry(a).clone();
g.x = f.x + (f.width - g.width) / 2, g.y = f.y + (f.height - g.height) / 2;
var h = this.spacing * b.gridSize, k = 20 * d.getDirectedEdgeCount(c, !0);
this.editor.horizontalFlow ? g.x += (g.width + f.width) / 2 + h + k :g.y += (g.height + f.height) / 2 + h + k, 
a.setGeometry(g);
var l = d.getParent(c);
if (b.addCell(a, l), b.constrainChild(a), e = this.editor.createEdge(c, a), null == d.getGeometry(e)) {
var m = new mxGeometry();
m.relative = !0, d.setGeometry(e, m);
}
b.addEdge(e, l, c, a);
} finally {
d.endUpdate();
}
b.setSelectionCells([ a, e ]), b.scrollCellToVisible(a);
}
}, mxDefaultToolbar.prototype.installDropHandler = function(a, b) {
var c = document.createElement("img");
c.setAttribute("src", a.getAttribute("src"));
var d = mxUtils.bind(this, function() {
c.style.width = 2 * a.offsetWidth + "px", c.style.height = 2 * a.offsetHeight + "px", 
mxUtils.makeDraggable(a, this.editor.graph, b, c), mxEvent.removeListener(c, "load", d);
});
mxClient.IS_IE ? d() :mxEvent.addListener(c, "load", d);
}, mxDefaultToolbar.prototype.destroy = function() {
null != this.resetHandler && (this.editor.graph.removeListener("dblclick", this.resetHandler), 
this.editor.removeListener("escape", this.resetHandler), this.resetHandler = null), 
null != this.toolbar && (this.toolbar.destroy(), this.toolbar = null);
}, mxLoadResources && mxResources.add(mxClient.basePath + "/resources/editor"), 
mxEditor.prototype = new mxEventSource(), mxEditor.prototype.constructor = mxEditor, 
mxEditor.prototype.askZoomResource = "none" != mxClient.language ? "askZoom" :"", 
mxEditor.prototype.lastSavedResource = "none" != mxClient.language ? "lastSaved" :"", 
mxEditor.prototype.currentFileResource = "none" != mxClient.language ? "currentFile" :"", 
mxEditor.prototype.propertiesResource = "none" != mxClient.language ? "properties" :"", 
mxEditor.prototype.tasksResource = "none" != mxClient.language ? "tasks" :"", mxEditor.prototype.helpResource = "none" != mxClient.language ? "help" :"", 
mxEditor.prototype.outlineResource = "none" != mxClient.language ? "outline" :"", 
mxEditor.prototype.outline = null, mxEditor.prototype.graph = null, mxEditor.prototype.graphRenderHint = null, 
mxEditor.prototype.toolbar = null, mxEditor.prototype.session = null, mxEditor.prototype.status = null, 
mxEditor.prototype.popupHandler = null, mxEditor.prototype.undoManager = null, mxEditor.prototype.keyHandler = null, 
mxEditor.prototype.actions = null, mxEditor.prototype.dblClickAction = "edit", mxEditor.prototype.swimlaneRequired = !1, 
mxEditor.prototype.disableContextMenu = !0, mxEditor.prototype.insertFunction = null, 
mxEditor.prototype.forcedInserting = !1, mxEditor.prototype.templates = null, mxEditor.prototype.defaultEdge = null, 
mxEditor.prototype.defaultEdgeStyle = null, mxEditor.prototype.defaultGroup = null, 
mxEditor.prototype.groupBorderSize = null, mxEditor.prototype.filename = null, mxEditor.prototype.linefeed = "&#xa;", 
mxEditor.prototype.postParameterName = "xml", mxEditor.prototype.escapePostData = !0, 
mxEditor.prototype.urlPost = null, mxEditor.prototype.urlImage = null, mxEditor.prototype.urlInit = null, 
mxEditor.prototype.urlNotify = null, mxEditor.prototype.urlPoll = null, mxEditor.prototype.horizontalFlow = !1, 
mxEditor.prototype.layoutDiagram = !1, mxEditor.prototype.swimlaneSpacing = 0, mxEditor.prototype.maintainSwimlanes = !1, 
mxEditor.prototype.layoutSwimlanes = !1, mxEditor.prototype.cycleAttributeValues = null, 
mxEditor.prototype.cycleAttributeIndex = 0, mxEditor.prototype.cycleAttributeName = "fillColor", 
mxEditor.prototype.tasks = null, mxEditor.prototype.tasksWindowImage = null, mxEditor.prototype.tasksTop = 20, 
mxEditor.prototype.help = null, mxEditor.prototype.helpWindowImage = null, mxEditor.prototype.urlHelp = null, 
mxEditor.prototype.helpWidth = 300, mxEditor.prototype.helpHeight = 260, mxEditor.prototype.propertiesWidth = 240, 
mxEditor.prototype.propertiesHeight = null, mxEditor.prototype.movePropertiesDialog = !1, 
mxEditor.prototype.validating = !1, mxEditor.prototype.modified = !1, mxEditor.prototype.isModified = function() {
return this.modified;
}, mxEditor.prototype.setModified = function(a) {
this.modified = a;
}, mxEditor.prototype.addActions = function() {
this.addAction("save", function(a) {
a.save();
}), this.addAction("print", function(a) {
new mxPrintPreview(a.graph, 1).open();
}), this.addAction("show", function(a) {
mxUtils.show(a.graph, null, 10, 10);
}), this.addAction("exportImage", function(a) {
var b = a.getUrlImage();
if (null == b || mxClient.IS_LOCAL) a.execute("show"); else {
var c = mxUtils.getViewXml(a.graph, 1), c = mxUtils.getXml(c, "\n");
mxUtils.submit(b, a.postParameterName + "=" + encodeURIComponent(c), document, "_blank");
}
}), this.addAction("refresh", function(a) {
a.graph.refresh();
}), this.addAction("cut", function(a) {
a.graph.isEnabled() && mxClipboard.cut(a.graph);
}), this.addAction("copy", function(a) {
a.graph.isEnabled() && mxClipboard.copy(a.graph);
}), this.addAction("paste", function(a) {
a.graph.isEnabled() && mxClipboard.paste(a.graph);
}), this.addAction("delete", function(a) {
a.graph.isEnabled() && a.graph.removeCells();
}), this.addAction("group", function(a) {
a.graph.isEnabled() && a.graph.setSelectionCell(a.groupCells());
}), this.addAction("ungroup", function(a) {
a.graph.isEnabled() && a.graph.setSelectionCells(a.graph.ungroupCells());
}), this.addAction("removeFromParent", function(a) {
a.graph.isEnabled() && a.graph.removeCellsFromParent();
}), this.addAction("undo", function(a) {
a.graph.isEnabled() && a.undo();
}), this.addAction("redo", function(a) {
a.graph.isEnabled() && a.redo();
}), this.addAction("zoomIn", function(a) {
a.graph.zoomIn();
}), this.addAction("zoomOut", function(a) {
a.graph.zoomOut();
}), this.addAction("actualSize", function(a) {
a.graph.zoomActual();
}), this.addAction("fit", function(a) {
a.graph.fit();
}), this.addAction("showProperties", function(a, b) {
a.showProperties(b);
}), this.addAction("selectAll", function(a) {
a.graph.isEnabled() && a.graph.selectAll();
}), this.addAction("selectNone", function(a) {
a.graph.isEnabled() && a.graph.clearSelection();
}), this.addAction("selectVertices", function(a) {
a.graph.isEnabled() && a.graph.selectVertices();
}), this.addAction("selectEdges", function(a) {
a.graph.isEnabled() && a.graph.selectEdges();
}), this.addAction("edit", function(a, b) {
a.graph.isEnabled() && a.graph.isCellEditable(b) && a.graph.startEditingAtCell(b);
}), this.addAction("toBack", function(a) {
a.graph.isEnabled() && a.graph.orderCells(!0);
}), this.addAction("toFront", function(a) {
a.graph.isEnabled() && a.graph.orderCells(!1);
}), this.addAction("enterGroup", function(a, b) {
a.graph.enterGroup(b);
}), this.addAction("exitGroup", function(a) {
a.graph.exitGroup();
}), this.addAction("home", function(a) {
a.graph.home();
}), this.addAction("selectPrevious", function(a) {
a.graph.isEnabled() && a.graph.selectPreviousCell();
}), this.addAction("selectNext", function(a) {
a.graph.isEnabled() && a.graph.selectNextCell();
}), this.addAction("selectParent", function(a) {
a.graph.isEnabled() && a.graph.selectParentCell();
}), this.addAction("selectChild", function(a) {
a.graph.isEnabled() && a.graph.selectChildCell();
}), this.addAction("collapse", function(a) {
a.graph.isEnabled() && a.graph.foldCells(!0);
}), this.addAction("collapseAll", function(a) {
if (a.graph.isEnabled()) {
var b = a.graph.getChildVertices();
a.graph.foldCells(!0, !1, b);
}
}), this.addAction("expand", function(a) {
a.graph.isEnabled() && a.graph.foldCells(!1);
}), this.addAction("expandAll", function(a) {
if (a.graph.isEnabled()) {
var b = a.graph.getChildVertices();
a.graph.foldCells(!1, !1, b);
}
}), this.addAction("bold", function(a) {
a.graph.isEnabled() && a.graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_BOLD);
}), this.addAction("italic", function(a) {
a.graph.isEnabled() && a.graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_ITALIC);
}), this.addAction("underline", function(a) {
a.graph.isEnabled() && a.graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_UNDERLINE);
}), this.addAction("shadow", function(a) {
a.graph.isEnabled() && a.graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, mxConstants.FONT_SHADOW);
}), this.addAction("alignCellsLeft", function(a) {
a.graph.isEnabled() && a.graph.alignCells(mxConstants.ALIGN_LEFT);
}), this.addAction("alignCellsCenter", function(a) {
a.graph.isEnabled() && a.graph.alignCells(mxConstants.ALIGN_CENTER);
}), this.addAction("alignCellsRight", function(a) {
a.graph.isEnabled() && a.graph.alignCells(mxConstants.ALIGN_RIGHT);
}), this.addAction("alignCellsTop", function(a) {
a.graph.isEnabled() && a.graph.alignCells(mxConstants.ALIGN_TOP);
}), this.addAction("alignCellsMiddle", function(a) {
a.graph.isEnabled() && a.graph.alignCells(mxConstants.ALIGN_MIDDLE);
}), this.addAction("alignCellsBottom", function(a) {
a.graph.isEnabled() && a.graph.alignCells(mxConstants.ALIGN_BOTTOM);
}), this.addAction("alignFontLeft", function(a) {
a.graph.setCellStyles(mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);
}), this.addAction("alignFontCenter", function(a) {
a.graph.isEnabled() && a.graph.setCellStyles(mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER);
}), this.addAction("alignFontRight", function(a) {
a.graph.isEnabled() && a.graph.setCellStyles(mxConstants.STYLE_ALIGN, mxConstants.ALIGN_RIGHT);
}), this.addAction("alignFontTop", function(a) {
a.graph.isEnabled() && a.graph.setCellStyles(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_TOP);
}), this.addAction("alignFontMiddle", function(a) {
a.graph.isEnabled() && a.graph.setCellStyles(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);
}), this.addAction("alignFontBottom", function(a) {
a.graph.isEnabled() && a.graph.setCellStyles(mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_BOTTOM);
}), this.addAction("zoom", function(a) {
var b = 100 * a.graph.getView().scale, b = parseFloat(mxUtils.prompt(mxResources.get(a.askZoomResource) || a.askZoomResource, b)) / 100;
isNaN(b) || a.graph.getView().setScale(b);
}), this.addAction("toggleTasks", function(a) {
null != a.tasks ? a.tasks.setVisible(!a.tasks.isVisible()) :a.showTasks();
}), this.addAction("toggleHelp", function(a) {
null != a.help ? a.help.setVisible(!a.help.isVisible()) :a.showHelp();
}), this.addAction("toggleOutline", function(a) {
null == a.outline ? a.showOutline() :a.outline.setVisible(!a.outline.isVisible());
}), this.addAction("toggleConsole", function() {
mxLog.setVisible(!mxLog.isVisible());
});
}, mxEditor.prototype.createSession = function() {
var a = mxUtils.bind(this, function(a) {
this.fireEvent(new mxEventObject(mxEvent.SESSION, "session", a));
});
return this.connect(this.urlInit, this.urlPoll, this.urlNotify, a);
}, mxEditor.prototype.configure = function(a) {
null != a && (new mxCodec(a.ownerDocument).decode(a, this), this.resetHistory());
}, mxEditor.prototype.resetFirstTime = function() {
document.cookie = "mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/";
}, mxEditor.prototype.resetHistory = function() {
this.lastSnapshot = new Date().getTime(), this.undoManager.clear(), this.ignoredChanges = 0, 
this.setModified(!1);
}, mxEditor.prototype.addAction = function(a, b) {
this.actions[a] = b;
}, mxEditor.prototype.execute = function(a) {
var d = this.actions[a];
if (null != d) try {
var e = arguments;
e[0] = this, d.apply(this, e);
} catch (f) {
throw mxUtils.error("Cannot execute " + a + ": " + f.message, 280, !0), f;
} else mxUtils.error("Cannot find action " + a, 280, !0);
}, mxEditor.prototype.addTemplate = function(a, b) {
this.templates[a] = b;
}, mxEditor.prototype.getTemplate = function(a) {
return this.templates[a];
}, mxEditor.prototype.createGraph = function() {
var a = new mxGraph(null, null, this.graphRenderHint);
return a.setTooltips(!0), a.setPanning(!0), this.installDblClickHandler(a), this.installUndoHandler(a), 
this.installDrillHandler(a), this.installChangeHandler(a), this.installInsertHandler(a), 
a.panningHandler.factoryMethod = mxUtils.bind(this, function(a, c, d) {
return this.createPopupMenu(a, c, d);
}), a.connectionHandler.factoryMethod = mxUtils.bind(this, function(a, c) {
return this.createEdge(a, c);
}), this.createSwimlaneManager(a), this.createLayoutManager(a), a;
}, mxEditor.prototype.createSwimlaneManager = function(a) {
return a = new mxSwimlaneManager(a, !1), a.isHorizontal = mxUtils.bind(this, function() {
return this.horizontalFlow;
}), a.isEnabled = mxUtils.bind(this, function() {
return this.maintainSwimlanes;
}), a;
}, mxEditor.prototype.createLayoutManager = function(a) {
var b = new mxLayoutManager(a), c = this;
return b.getLayout = function(b) {
var e = null, f = c.graph.getModel();
return null != f.getParent(b) && (c.layoutSwimlanes && a.isSwimlane(b) ? (null == c.swimlaneLayout && (c.swimlaneLayout = c.createSwimlaneLayout()), 
e = c.swimlaneLayout) :c.layoutDiagram && (a.isValidRoot(b) || null == f.getParent(f.getParent(b))) && (null == c.diagramLayout && (c.diagramLayout = c.createDiagramLayout()), 
e = c.diagramLayout)), e;
}, b;
}, mxEditor.prototype.setGraphContainer = function(a) {
null == this.graph.container && (this.graph.init(a), this.rubberband = new mxRubberband(this.graph), 
this.disableContextMenu && mxEvent.disableContextMenu(a), mxClient.IS_QUIRKS && new mxDivResizer(a));
}, mxEditor.prototype.installDblClickHandler = function(a) {
a.addListener(mxEvent.DOUBLE_CLICK, mxUtils.bind(this, function(b, c) {
var d = c.getProperty("cell");
null != d && a.isEnabled() && null != this.dblClickAction && (this.execute(this.dblClickAction, d), 
c.consume());
}));
}, mxEditor.prototype.installUndoHandler = function(a) {
var b = mxUtils.bind(this, function(a, b) {
var e = b.getProperty("edit");
this.undoManager.undoableEditHappened(e);
});
a.getModel().addListener(mxEvent.UNDO, b), a.getView().addListener(mxEvent.UNDO, b), 
b = function(b, d) {
var e = d.getProperty("edit").changes;
a.setSelectionCells(a.getSelectionCellsForChanges(e));
}, this.undoManager.addListener(mxEvent.UNDO, b), this.undoManager.addListener(mxEvent.REDO, b);
}, mxEditor.prototype.installDrillHandler = function(a) {
var b = mxUtils.bind(this, function() {
this.fireEvent(new mxEventObject(mxEvent.ROOT));
});
a.getView().addListener(mxEvent.DOWN, b), a.getView().addListener(mxEvent.UP, b);
}, mxEditor.prototype.installChangeHandler = function(a) {
var b = mxUtils.bind(this, function(b, d) {
this.setModified(!0), 1 == this.validating && a.validateGraph();
for (var e = d.getProperty("edit").changes, f = 0; f < e.length; f++) {
var g = e[f];
if (g instanceof mxRootChange || g instanceof mxValueChange && g.cell == this.graph.model.root || g instanceof mxCellAttributeChange && g.cell == this.graph.model.root) {
this.fireEvent(new mxEventObject(mxEvent.ROOT));
break;
}
}
});
a.getModel().addListener(mxEvent.CHANGE, b);
}, mxEditor.prototype.installInsertHandler = function(a) {
var b = this;
a.addMouseListener({
mouseDown:function(a, d) {
null == b.insertFunction || d.isPopupTrigger() || !b.forcedInserting && null != d.getState() || (b.graph.clearSelection(), 
b.insertFunction(d.getEvent(), d.getCell()), this.isActive = !0, d.consume());
},
mouseMove:function(a, b) {
this.isActive && b.consume();
},
mouseUp:function(a, b) {
this.isActive && (this.isActive = !1, b.consume());
}
});
}, mxEditor.prototype.createDiagramLayout = function() {
var a = this.graph.gridSize, b = new mxStackLayout(this.graph, !this.horizontalFlow, this.swimlaneSpacing, 2 * a, 2 * a);
return b.isVertexIgnored = function(a) {
return !b.graph.isSwimlane(a);
}, b;
}, mxEditor.prototype.createSwimlaneLayout = function() {
return new mxCompactTreeLayout(this.graph, this.horizontalFlow);
}, mxEditor.prototype.createToolbar = function() {
return new mxDefaultToolbar(null, this);
}, mxEditor.prototype.setToolbarContainer = function(a) {
this.toolbar.init(a), mxClient.IS_QUIRKS && new mxDivResizer(a);
}, mxEditor.prototype.setStatusContainer = function(a) {
null == this.status && (this.status = a, this.addListener(mxEvent.SAVE, mxUtils.bind(this, function() {
var a = new Date().toLocaleString();
this.setStatus((mxResources.get(this.lastSavedResource) || this.lastSavedResource) + ": " + a);
})), this.addListener(mxEvent.OPEN, mxUtils.bind(this, function() {
this.setStatus((mxResources.get(this.currentFileResource) || this.currentFileResource) + ": " + this.filename);
})), mxClient.IS_QUIRKS && new mxDivResizer(a));
}, mxEditor.prototype.setStatus = function(a) {
null != this.status && null != a && (this.status.innerHTML = a);
}, mxEditor.prototype.setTitleContainer = function(a) {
this.addListener(mxEvent.ROOT, mxUtils.bind(this, function() {
a.innerHTML = this.getTitle();
})), mxClient.IS_QUIRKS && new mxDivResizer(a);
}, mxEditor.prototype.treeLayout = function(a, b) {
null != a && new mxCompactTreeLayout(this.graph, b).execute(a);
}, mxEditor.prototype.getTitle = function() {
for (var a = "", b = this.graph, c = b.getCurrentRoot(); null != c && null != b.getModel().getParent(b.getModel().getParent(c)); ) b.isValidRoot(c) && (a = " > " + b.convertValueToString(c) + a), 
c = b.getModel().getParent(c);
return this.getRootTitle() + a;
}, mxEditor.prototype.getRootTitle = function() {
var a = this.graph.getModel().getRoot();
return this.graph.convertValueToString(a);
}, mxEditor.prototype.undo = function() {
this.undoManager.undo();
}, mxEditor.prototype.redo = function() {
this.undoManager.redo();
}, mxEditor.prototype.groupCells = function() {
var a = null != this.groupBorderSize ? this.groupBorderSize :this.graph.gridSize;
return this.graph.groupCells(this.createGroup(), a);
}, mxEditor.prototype.createGroup = function() {
return this.graph.getModel().cloneCell(this.defaultGroup);
}, mxEditor.prototype.open = function(a) {
if (null != a) {
var b = mxUtils.load(a).getXml();
this.readGraphModel(b.documentElement), this.filename = a, this.fireEvent(new mxEventObject(mxEvent.OPEN, "filename", a));
}
}, mxEditor.prototype.readGraphModel = function(a) {
new mxCodec(a.ownerDocument).decode(a, this.graph.getModel()), this.resetHistory();
}, mxEditor.prototype.save = function(a, b) {
if (a = a || this.getUrlPost(), null != a && 0 < a.length) {
var c = this.writeGraphModel(b);
this.postDiagram(a, c), this.setModified(!1);
}
this.fireEvent(new mxEventObject(mxEvent.SAVE, "url", a));
}, mxEditor.prototype.postDiagram = function(a, b) {
this.escapePostData && (b = encodeURIComponent(b)), mxUtils.post(a, this.postParameterName + "=" + b, mxUtils.bind(this, function(c) {
this.fireEvent(new mxEventObject(mxEvent.POST, "request", c, "url", a, "data", b));
}));
}, mxEditor.prototype.writeGraphModel = function(a) {
a = null != a ? a :this.linefeed;
var b = new mxCodec().encode(this.graph.getModel());
return mxUtils.getXml(b, a);
}, mxEditor.prototype.getUrlPost = function() {
return this.urlPost;
}, mxEditor.prototype.getUrlImage = function() {
return this.urlImage;
}, mxEditor.prototype.connect = function(a, b, c, d) {
var e = null;
return mxClient.IS_LOCAL || (e = new mxSession(this.graph.getModel(), a, b, c), 
e.addListener(mxEvent.RECEIVE, mxUtils.bind(this, function(a, b) {
null != b.getProperty("node").getAttribute("namespace") && this.resetHistory();
})), e.addListener(mxEvent.DISCONNECT, d), e.addListener(mxEvent.CONNECT, d), e.addListener(mxEvent.NOTIFY, d), 
e.addListener(mxEvent.GET, d), e.start()), e;
}, mxEditor.prototype.swapStyles = function(a, b) {
var c = this.graph.getStylesheet().styles[b];
this.graph.getView().getStylesheet().putCellStyle(b, this.graph.getStylesheet().styles[a]), 
this.graph.getStylesheet().putCellStyle(a, c), this.graph.refresh();
}, mxEditor.prototype.showProperties = function(a) {
if (a = a || this.graph.getSelectionCell(), null == a && (a = this.graph.getCurrentRoot(), 
null == a && (a = this.graph.getModel().getRoot())), null != a) {
this.graph.stopEditing(!0);
var b = mxUtils.getOffset(this.graph.container), c = b.x + 10, b = b.y;
if (null == this.properties || this.movePropertiesDialog) {
var d = this.graph.getCellBounds(a);
null != d && (c += d.x + Math.min(200, d.width), b += d.y);
} else c = this.properties.getX(), b = this.properties.getY();
this.hideProperties(), a = this.createProperties(a), null != a && (this.properties = new mxWindow(mxResources.get(this.propertiesResource) || this.propertiesResource, a, c, b, this.propertiesWidth, this.propertiesHeight, !1), 
this.properties.setVisible(!0));
}
}, mxEditor.prototype.isPropertiesVisible = function() {
return null != this.properties;
}, mxEditor.prototype.createProperties = function(a) {
var b = this.graph.getModel(), c = b.getValue(a);
if (mxUtils.isNode(c)) {
var d = new mxForm("properties");
d.addText("ID", a.getId()).setAttribute("readonly", "true");
var e = null, f = null, g = null, h = null, k = null;
b.isVertex(a) && (e = b.getGeometry(a), null != e && (f = d.addText("top", e.y), 
g = d.addText("left", e.x), h = d.addText("width", e.width), k = d.addText("height", e.height)));
for (var l = b.getStyle(a), m = d.addText("Style", l || ""), n = c.attributes, p = [], c = 0; c < n.length; c++) p[c] = d.addTextarea(n[c].nodeName, n[c].nodeValue, "label" == n[c].nodeName ? 4 :2);
return c = mxUtils.bind(this, function() {
this.hideProperties(), b.beginUpdate();
try {
null != e && (e = e.clone(), e.x = parseFloat(g.value), e.y = parseFloat(f.value), 
e.width = parseFloat(h.value), e.height = parseFloat(k.value), b.setGeometry(a, e)), 
0 < m.value.length ? b.setStyle(a, m.value) :b.setStyle(a, null);
for (var c = 0; c < n.length; c++) {
var d = new mxCellAttributeChange(a, n[c].nodeName, p[c].value);
b.execute(d);
}
this.graph.isAutoSizeCell(a) && this.graph.updateCellSize(a);
} finally {
b.endUpdate();
}
}), l = mxUtils.bind(this, function() {
this.hideProperties();
}), d.addButtons(c, l), d.table;
}
return null;
}, mxEditor.prototype.hideProperties = function() {
null != this.properties && (this.properties.destroy(), this.properties = null);
}, mxEditor.prototype.showTasks = function() {
if (null == this.tasks) {
var a = document.createElement("div");
a.style.padding = "4px", a.style.paddingLeft = "20px";
var b = document.body.clientWidth, b = new mxWindow(mxResources.get(this.tasksResource) || this.tasksResource, a, b - 220, this.tasksTop, 200);
b.setClosable(!0), b.destroyOnClose = !1;
var c = mxUtils.bind(this, function() {
mxEvent.release(a), a.innerHTML = "", this.createTasks(a);
});
this.graph.getModel().addListener(mxEvent.CHANGE, c), this.graph.getSelectionModel().addListener(mxEvent.CHANGE, c), 
this.graph.addListener(mxEvent.ROOT, c), null != this.tasksWindowImage && b.setImage(this.tasksWindowImage), 
this.tasks = b, this.createTasks(a);
}
this.tasks.setVisible(!0);
}, mxEditor.prototype.refreshTasks = function(a) {
null != this.tasks && (a = this.tasks.content, mxEvent.release(a), a.innerHTML = "", 
this.createTasks(a));
}, mxEditor.prototype.createTasks = function() {}, mxEditor.prototype.showHelp = function(a) {
if (null == this.help) {
var b = document.createElement("iframe");
b.setAttribute("src", mxResources.get("urlHelp") || this.urlHelp), b.setAttribute("height", "100%"), 
b.setAttribute("width", "100%"), b.setAttribute("frameBorder", "0"), b.style.backgroundColor = "white", 
a = document.body.clientWidth;
var c = document.body.clientHeight || document.documentElement.clientHeight, d = new mxWindow(mxResources.get(this.helpResource) || this.helpResource, b, (a - this.helpWidth) / 2, (c - this.helpHeight) / 3, this.helpWidth, this.helpHeight);
d.setMaximizable(!0), d.setClosable(!0), d.destroyOnClose = !1, d.setResizable(!0), 
null != this.helpWindowImage && d.setImage(this.helpWindowImage), mxClient.IS_NS && (a = function() {
b.setAttribute("height", d.div.offsetHeight - 26 + "px");
}, d.addListener(mxEvent.RESIZE_END, a), d.addListener(mxEvent.MAXIMIZE, a), d.addListener(mxEvent.NORMALIZE, a), 
d.addListener(mxEvent.SHOW, a)), this.help = d;
}
this.help.setVisible(!0);
}, mxEditor.prototype.showOutline = function() {
if (null == this.outline) {
var a = document.createElement("div");
a.style.overflow = "hidden", a.style.width = "100%", a.style.height = "100%", a.style.background = "white", 
a.style.cursor = "move";
var b = new mxWindow(mxResources.get(this.outlineResource) || this.outlineResource, a, 600, 480, 200, 200, !1), c = new mxOutline(this.graph, a);
b.setClosable(!0), b.setResizable(!0), b.destroyOnClose = !1, b.addListener(mxEvent.RESIZE_END, function() {
c.update();
}), this.outline = b, this.outline.outline = c;
}
this.outline.setVisible(!0), this.outline.outline.update(!0);
}, mxEditor.prototype.setMode = function(a) {
"select" == a ? (this.graph.panningHandler.useLeftButtonForPanning = !1, this.graph.setConnectable(!1)) :"connect" == a ? (this.graph.panningHandler.useLeftButtonForPanning = !1, 
this.graph.setConnectable(!0)) :"pan" == a && (this.graph.panningHandler.useLeftButtonForPanning = !0, 
this.graph.setConnectable(!1));
}, mxEditor.prototype.createPopupMenu = function(a, b, c) {
this.popupHandler.createMenu(this, a, b, c);
}, mxEditor.prototype.createEdge = function() {
var c = null;
if (null != this.defaultEdge) c = this.graph.getModel().cloneCell(this.defaultEdge); else {
c = new mxCell(""), c.setEdge(!0);
var d = new mxGeometry();
d.relative = !0, c.setGeometry(d);
}
return d = this.getEdgeStyle(), null != d && c.setStyle(d), c;
}, mxEditor.prototype.getEdgeStyle = function() {
return this.defaultEdgeStyle;
}, mxEditor.prototype.consumeCycleAttribute = function(a) {
return null != this.cycleAttributeValues && 0 < this.cycleAttributeValues.length && this.graph.isSwimlane(a) ? this.cycleAttributeValues[this.cycleAttributeIndex++ % this.cycleAttributeValues.length] :null;
}, mxEditor.prototype.cycleAttribute = function(a) {
if (null != this.cycleAttributeName) {
var b = this.consumeCycleAttribute(a);
null != b && a.setStyle(a.getStyle() + ";" + this.cycleAttributeName + "=" + b);
}
}, mxEditor.prototype.addVertex = function(a, b, c, d) {
for (var e = this.graph.getModel(); null != a && !this.graph.isValidDropTarget(a); ) a = e.getParent(a);
a = null != a ? a :this.graph.getSwimlaneAt(c, d);
var f = this.graph.getView().scale, g = e.getGeometry(b), h = e.getGeometry(a);
if (this.graph.isSwimlane(b) && !this.graph.swimlaneNesting) a = null; else {
if (null == a && this.swimlaneRequired) return null;
if (null != a && null != h) {
var k = this.graph.getView().getState(a);
if (null != k) {
if (c -= k.origin.x * f, d -= k.origin.y * f, this.graph.isConstrainedMoving) {
var h = g.width, l = g.height, m = k.x + k.width;
c + h > m && (c -= c + h - m), m = k.y + k.height, d + l > m && (d -= d + l - m);
}
} else null != h && (c -= h.x * f, d -= h.y * f);
}
}
g = g.clone(), g.x = this.graph.snap(c / f - this.graph.getView().translate.x - this.graph.gridSize / 2), 
g.y = this.graph.snap(d / f - this.graph.getView().translate.y - this.graph.gridSize / 2), 
b.setGeometry(g), null == a && (a = this.graph.getDefaultParent()), this.cycleAttribute(b), 
this.fireEvent(new mxEventObject(mxEvent.BEFORE_ADD_VERTEX, "vertex", b, "parent", a)), 
e.beginUpdate();
try {
b = this.graph.addCell(b, a), null != b && (this.graph.constrainChild(b), this.fireEvent(new mxEventObject(mxEvent.ADD_VERTEX, "vertex", b)));
} finally {
e.endUpdate();
}
return null != b && (this.graph.setSelectionCell(b), this.graph.scrollCellToVisible(b), 
this.fireEvent(new mxEventObject(mxEvent.AFTER_ADD_VERTEX, "vertex", b))), b;
}, mxEditor.prototype.destroy = function() {
this.destroyed || (this.destroyed = !0, null != this.tasks && this.tasks.destroy(), 
null != this.outline && this.outline.destroy(), null != this.properties && this.properties.destroy(), 
null != this.keyHandler && this.keyHandler.destroy(), null != this.rubberband && this.rubberband.destroy(), 
null != this.toolbar && this.toolbar.destroy(), null != this.graph && this.graph.destroy(), 
this.templates = this.status = null);
};

var mxCodecRegistry = {
codecs:[],
aliases:[],
register:function(a) {
if (null != a) {
var b = a.getName();
mxCodecRegistry.codecs[b] = a;
var c = mxUtils.getFunctionName(a.template.constructor);
c != b && mxCodecRegistry.addAlias(c, b);
}
return a;
},
addAlias:function(a, b) {
mxCodecRegistry.aliases[a] = b;
},
getCodec:function(a) {
var b = null;
if (null != a) {
var b = mxUtils.getFunctionName(a), c = mxCodecRegistry.aliases[b];
if (null != c && (b = c), b = mxCodecRegistry.codecs[b], null == b) try {
b = new mxObjectCodec(new a()), mxCodecRegistry.register(b);
} catch (d) {}
}
return b;
}
};

mxCodec.prototype.document = null, mxCodec.prototype.objects = null, mxCodec.prototype.encodeDefaults = !1, 
mxCodec.prototype.putObject = function(a, b) {
return this.objects[a] = b;
}, mxCodec.prototype.getObject = function(a) {
var b = null;
return null != a && (b = this.objects[a], null == b && (b = this.lookup(a), null == b && (a = this.getElementById(a), 
null != a && (b = this.decode(a))))), b;
}, mxCodec.prototype.lookup = function() {
return null;
}, mxCodec.prototype.getElementById = function(a, b) {
return mxUtils.findNodeByAttribute(this.document.documentElement, null != b ? b :"id", a);
}, mxCodec.prototype.getId = function(a) {
var b = null;
return null != a && (b = this.reference(a), null == b && a instanceof mxCell && (b = a.getId(), 
null == b && (b = mxCellPath.create(a), 0 == b.length && (b = "root")))), b;
}, mxCodec.prototype.reference = function() {
return null;
}, mxCodec.prototype.encode = function(a) {
var b = null;
if (null != a && null != a.constructor) {
var c = mxCodecRegistry.getCodec(a.constructor);
null != c ? b = c.encode(this, a) :mxUtils.isNode(a) ? b = mxClient.IS_IE ? a.cloneNode(!0) :this.document.importNode(a, !0) :mxLog.warn("mxCodec.encode: No codec for " + mxUtils.getFunctionName(a.constructor));
}
return b;
}, mxCodec.prototype.decode = function(a, b) {
var c = null;
if (null != a && a.nodeType == mxConstants.NODETYPE_ELEMENT) {
var d = null;
try {
d = eval(a.nodeName);
} catch (e) {}
try {
var f = mxCodecRegistry.getCodec(d);
null != f ? c = f.decode(this, a, b) :(c = a.cloneNode(!0), c.removeAttribute("as"));
} catch (g) {
mxLog.debug("Cannot decode " + a.nodeName + ": " + g.message);
}
}
return c;
}, mxCodec.prototype.encodeCell = function(a, b, c) {
if (b.appendChild(this.encode(a)), null == c || c) {
c = a.getChildCount();
for (var d = 0; c > d; d++) this.encodeCell(a.getChildAt(d), b);
}
}, mxCodec.prototype.isCellCodec = function(a) {
return null != a && "function" == typeof a.isCellCodec ? a.isCellCodec() :!1;
}, mxCodec.prototype.decodeCell = function(a, b) {
b = null != b ? b :!0;
var c = null;
if (null != a && a.nodeType == mxConstants.NODETYPE_ELEMENT) {
if (c = mxCodecRegistry.getCodec(a.nodeName), !this.isCellCodec(c)) for (var d = a.firstChild; null != d && !this.isCellCodec(c); ) c = mxCodecRegistry.getCodec(d.nodeName), 
d = d.nextSibling;
this.isCellCodec(c) || (c = mxCodecRegistry.getCodec(mxCell)), c = c.decode(this, a), 
b && this.insertIntoGraph(c);
}
return c;
}, mxCodec.prototype.insertIntoGraph = function(a) {
var b = a.parent, c = a.getTerminal(!0), d = a.getTerminal(!1);
a.setTerminal(null, !1), a.setTerminal(null, !0), a.parent = null, null != b && b.insert(a), 
null != c && c.insertEdge(a, !0), null != d && d.insertEdge(a, !1);
}, mxCodec.prototype.setAttribute = function(a, b, c) {
null != b && null != c && a.setAttribute(b, c);
}, mxObjectCodec.prototype.template = null, mxObjectCodec.prototype.exclude = null, 
mxObjectCodec.prototype.idrefs = null, mxObjectCodec.prototype.mapping = null, mxObjectCodec.prototype.reverse = null, 
mxObjectCodec.prototype.getName = function() {
return mxUtils.getFunctionName(this.template.constructor);
}, mxObjectCodec.prototype.cloneTemplate = function() {
return new this.template.constructor();
}, mxObjectCodec.prototype.getFieldName = function(a) {
if (null != a) {
var b = this.reverse[a];
null != b && (a = b);
}
return a;
}, mxObjectCodec.prototype.getAttributeName = function(a) {
if (null != a) {
var b = this.mapping[a];
null != b && (a = b);
}
return a;
}, mxObjectCodec.prototype.isExcluded = function(a, b) {
return b == mxObjectIdentity.FIELD_NAME || 0 <= mxUtils.indexOf(this.exclude, b);
}, mxObjectCodec.prototype.isReference = function(a, b) {
return 0 <= mxUtils.indexOf(this.idrefs, b);
}, mxObjectCodec.prototype.encode = function(a, b) {
var c = a.document.createElement(this.getName());
return b = this.beforeEncode(a, b, c), this.encodeObject(a, b, c), this.afterEncode(a, b, c);
}, mxObjectCodec.prototype.encodeObject = function(a, b, c) {
a.setAttribute(c, "id", a.getId(b));
for (var d in b) {
var e = d, f = b[e];
null != f && !this.isExcluded(b, e, f, !0) && (mxUtils.isNumeric(e) && (e = null), 
this.encodeValue(a, b, e, f, c));
}
}, mxObjectCodec.prototype.encodeValue = function(a, b, c, d, e) {
if (null != d) {
if (this.isReference(b, c, d, !0)) {
var f = a.getId(d);
if (null == f) return mxLog.warn("mxObjectCodec.encode: No ID for " + this.getName() + "." + c + "=" + d), 
void 0;
d = f;
}
f = this.template[c], (null == c || a.encodeDefaults || f != d) && (c = this.getAttributeName(c), 
this.writeAttribute(a, b, c, d, e));
}
}, mxObjectCodec.prototype.writeAttribute = function(a, b, c, d, e) {
"object" != typeof d ? this.writePrimitiveAttribute(a, b, c, d, e) :this.writeComplexAttribute(a, b, c, d, e);
}, mxObjectCodec.prototype.writePrimitiveAttribute = function(a, b, c, d, e) {
d = this.convertValueToXml(d), null == c ? (b = a.document.createElement("add"), 
"function" == typeof d ? b.appendChild(a.document.createTextNode(d)) :a.setAttribute(b, "value", d), 
e.appendChild(b)) :"function" != typeof d && a.setAttribute(e, c, d);
}, mxObjectCodec.prototype.writeComplexAttribute = function(a, b, c, d, e) {
a = a.encode(d), null != a ? (null != c && a.setAttribute("as", c), e.appendChild(a)) :mxLog.warn("mxObjectCodec.encode: No node for " + this.getName() + "." + c + ": " + d);
}, mxObjectCodec.prototype.convertValueToXml = function(a) {
return "undefined" != typeof a.length || 1 != a && 0 != a || (a = 1 == a ? "1" :"0"), 
a;
}, mxObjectCodec.prototype.convertValueFromXml = function(a) {
return mxUtils.isNumeric(a) && (a = parseFloat(a)), a;
}, mxObjectCodec.prototype.beforeEncode = function(a, b) {
return b;
}, mxObjectCodec.prototype.afterEncode = function(a, b, c) {
return c;
}, mxObjectCodec.prototype.decode = function(a, b, c) {
var d = b.getAttribute("id"), e = a.objects[d];
return null == e && (e = c || this.cloneTemplate(), null != d && a.putObject(d, e)), 
b = this.beforeDecode(a, b, e), this.decodeNode(a, b, e), this.afterDecode(a, b, e);
}, mxObjectCodec.prototype.decodeNode = function(a, b, c) {
null != b && (this.decodeAttributes(a, b, c), this.decodeChildren(a, b, c));
}, mxObjectCodec.prototype.decodeAttributes = function(a, b, c) {
if (b = b.attributes, null != b) for (var d = 0; d < b.length; d++) this.decodeAttribute(a, b[d], c);
}, mxObjectCodec.prototype.decodeAttribute = function(a, b, c) {
var d = b.nodeName;
if ("as" != d && "id" != d) {
b = this.convertValueFromXml(b.nodeValue);
var e = this.getFieldName(d);
if (this.isReference(c, e, b, !1)) {
if (a = a.getObject(b), null == a) return mxLog.warn("mxObjectCodec.decode: No object for " + this.getName() + "." + d + "=" + b), 
void 0;
b = a;
}
this.isExcluded(c, d, b, !1) || (c[d] = b);
}
}, mxObjectCodec.prototype.decodeChildren = function(a, b, c) {
for (b = b.firstChild; null != b; ) {
var d = b.nextSibling;
b.nodeType == mxConstants.NODETYPE_ELEMENT && !this.processInclude(a, b, c) && this.decodeChild(a, b, c), 
b = d;
}
}, mxObjectCodec.prototype.decodeChild = function(a, b, c) {
var d = this.getFieldName(b.getAttribute("as"));
if (null == d || !this.isExcluded(c, d, b, !1)) {
var e = this.getFieldTemplate(c, d, b), f = null;
"add" == b.nodeName ? (f = b.getAttribute("value"), null == f && (f = mxUtils.eval(mxUtils.getTextContent(b)))) :f = a.decode(b, e), 
this.addObjectValue(c, d, f, e);
}
}, mxObjectCodec.prototype.getFieldTemplate = function(a, b) {
return a = a[b], a instanceof Array && 0 < a.length && (a = null), a;
}, mxObjectCodec.prototype.addObjectValue = function(a, b, c, d) {
null != c && c != d && (null != b && 0 < b.length ? a[b] = c :a.push(c));
}, mxObjectCodec.prototype.processInclude = function(a, b, c) {
if ("include" == b.nodeName) {
if (b = b.getAttribute("name"), null != b) try {
var d = mxUtils.load(b).getDocumentElement();
null != d && a.decode(d, c);
} catch (e) {}
return !0;
}
return !1;
}, mxObjectCodec.prototype.beforeDecode = function(a, b) {
return b;
}, mxObjectCodec.prototype.afterDecode = function(a, b, c) {
return c;
}, mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxCell(), [ "children", "edges", "overlays", "mxTransient" ], [ "parent", "source", "target" ]);
return a.isCellCodec = function() {
return !0;
}, a.isExcluded = function(a, c, d, e) {
return mxObjectCodec.prototype.isExcluded.apply(this, arguments) || e && "value" == c && d.nodeType == mxConstants.NODETYPE_ELEMENT;
}, a.afterEncode = function(a, c, d) {
if (null != c.value && c.value.nodeType == mxConstants.NODETYPE_ELEMENT) {
var e = d;
d = mxClient.IS_IE ? c.value.cloneNode(!0) :a.document.importNode(c.value, !0), 
d.appendChild(e), a = e.getAttribute("id"), d.setAttribute("id", a), e.removeAttribute("id");
}
return d;
}, a.beforeDecode = function(a, c, d) {
var e = c, f = this.getName();
if (c.nodeName != f ? (e = c.getElementsByTagName(f)[0], null != e && e.parentNode == c ? (mxUtils.removeWhitespace(e, !0), 
mxUtils.removeWhitespace(e, !1), e.parentNode.removeChild(e)) :e = null, d.value = c.cloneNode(!0), 
c = d.value.getAttribute("id"), null != c && (d.setId(c), d.value.removeAttribute("id"))) :d.setId(c.getAttribute("id")), 
null != e) for (c = 0; c < this.idrefs.length; c++) {
var f = this.idrefs[c], g = e.getAttribute(f);
if (null != g) {
e.removeAttribute(f);
var h = a.objects[g] || a.lookup(g);
null == h && (g = a.getElementById(g), null != g && (h = (mxCodecRegistry.codecs[g.nodeName] || this).decode(a, g))), 
d[f] = h;
}
}
return e;
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxGraphModel());
return a.encodeObject = function(a, c, d) {
var e = a.document.createElement("root");
a.encodeCell(c.getRoot(), e), d.appendChild(e);
}, a.decodeChild = function(a, c, d) {
"root" == c.nodeName ? this.decodeRoot(a, c, d) :mxObjectCodec.prototype.decodeChild.apply(this, arguments);
}, a.decodeRoot = function(a, c, d) {
var e = null;
for (c = c.firstChild; null != c; ) {
var f = a.decodeCell(c);
null != f && null == f.getParent() && (e = f), c = c.nextSibling;
}
null != e && d.setRoot(e);
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxRootChange(), [ "model", "previous", "root" ]);
return a.afterEncode = function(a, c, d) {
return a.encodeCell(c.root, d), d;
}, a.beforeDecode = function(a, c, d) {
if (null != c.firstChild && c.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
c = c.cloneNode(!0);
var e = c.firstChild;
for (d.root = a.decodeCell(e, !1), d = e.nextSibling, e.parentNode.removeChild(e), 
e = d; null != e; ) d = e.nextSibling, a.decodeCell(e), e.parentNode.removeChild(e), 
e = d;
}
return c;
}, a.afterDecode = function(a, c, d) {
return d.previous = d.root, d;
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxChildChange(), [ "model", "child", "previousIndex" ], [ "parent", "previous" ]);
return a.isReference = function(a, c, d, e) {
return "child" != c || null == a.previous && e ? 0 <= mxUtils.indexOf(this.idrefs, c) :!0;
}, a.afterEncode = function(a, c, d) {
return this.isReference(c, "child", c.child, !0) ? d.setAttribute("child", a.getId(c.child)) :a.encodeCell(c.child, d), 
d;
}, a.beforeDecode = function(a, c, d) {
if (null != c.firstChild && c.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT) {
c = c.cloneNode(!0);
var e = c.firstChild;
for (d.child = a.decodeCell(e, !1), d = e.nextSibling, e.parentNode.removeChild(e), 
e = d; null != e; ) {
if (d = e.nextSibling, e.nodeType == mxConstants.NODETYPE_ELEMENT) {
var f = e.getAttribute("id");
null == a.lookup(f) && a.decodeCell(e);
}
e.parentNode.removeChild(e), e = d;
}
} else e = c.getAttribute("child"), d.child = a.getObject(e);
return c;
}, a.afterDecode = function(a, c, d) {
return d.child.parent = d.previous, d.previous = d.parent, d.previousIndex = d.index, 
d;
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxTerminalChange(), [ "model", "previous" ], [ "cell", "terminal" ]);
return a.afterDecode = function(a, c, d) {
return d.previous = d.terminal, d;
}, a;
}());

var mxGenericChangeCodec = function(a, b) {
var c = new mxObjectCodec(a, [ "model", "previous" ], [ "cell" ]);
return c.afterDecode = function(a, c, f) {
return mxUtils.isNode(f.cell) && (f.cell = a.decodeCell(f.cell, !1)), f.previous = f[b], 
f;
}, c;
};

mxCodecRegistry.register(mxGenericChangeCodec(new mxValueChange(), "value")), mxCodecRegistry.register(mxGenericChangeCodec(new mxStyleChange(), "style")), 
mxCodecRegistry.register(mxGenericChangeCodec(new mxGeometryChange(), "geometry")), 
mxCodecRegistry.register(mxGenericChangeCodec(new mxCollapseChange(), "collapsed")), 
mxCodecRegistry.register(mxGenericChangeCodec(new mxVisibleChange(), "visible")), 
mxCodecRegistry.register(mxGenericChangeCodec(new mxCellAttributeChange(), "value")), 
mxCodecRegistry.register(function() {
return new mxObjectCodec(new mxGraph(), "graphListeners eventListeners view container cellRenderer editor selection".split(" "));
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxGraphView());
return a.encode = function(a, c) {
return this.encodeCell(a, c, c.graph.getModel().getRoot());
}, a.encodeCell = function(a, c, d) {
var e = c.graph.getModel(), f = c.getState(d), g = e.getParent(d);
if (null == g || null != f) {
var h = e.getChildCount(d), k = c.graph.getCellGeometry(d), l = null;
if (g == e.getRoot() ? l = "layer" :null == g ? l = "graph" :e.isEdge(d) ? l = "edge" :h > 0 && null != k ? l = "group" :e.isVertex(d) && (l = "vertex"), 
null != l) {
var m = a.document.createElement(l);
if (null != c.graph.getLabel(d) && (m.setAttribute("label", c.graph.getLabel(d)), 
c.graph.isHtmlLabel(d) && m.setAttribute("html", !0)), null == g) {
var n = c.getGraphBounds();
null != n && (m.setAttribute("x", Math.round(n.x)), m.setAttribute("y", Math.round(n.y)), 
m.setAttribute("width", Math.round(n.width)), m.setAttribute("height", Math.round(n.height))), 
m.setAttribute("scale", c.scale);
} else if (null != f && null != k) {
for (n in f.style) g = f.style[n], "function" == typeof g && "object" == typeof g && (g = mxStyleRegistry.getName(g)), 
null != g && "function" != typeof g && "object" != typeof g && m.setAttribute(n, g);
if (g = f.absolutePoints, null != g && 0 < g.length) {
for (k = Math.round(g[0].x) + "," + Math.round(g[0].y), n = 1; n < g.length; n++) k += " " + Math.round(g[n].x) + "," + Math.round(g[n].y);
m.setAttribute("points", k);
} else m.setAttribute("x", Math.round(f.x)), m.setAttribute("y", Math.round(f.y)), 
m.setAttribute("width", Math.round(f.width)), m.setAttribute("height", Math.round(f.height));
n = f.absoluteOffset, null != n && (0 != n.x && m.setAttribute("dx", Math.round(n.x)), 
0 != n.y && m.setAttribute("dy", Math.round(n.y)));
}
for (n = 0; h > n; n++) f = this.encodeCell(a, c, e.getChildAt(d, n)), null != f && m.appendChild(f);
}
}
return m;
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxStylesheet());
return a.encode = function(a, c) {
var e, d = a.document.createElement(this.getName());
for (e in c.styles) {
var f = c.styles[e], g = a.document.createElement("add");
if (null != e) {
g.setAttribute("as", e);
for (var h in f) {
var k = this.getStringValue(h, f[h]);
if (null != k) {
var l = a.document.createElement("add");
l.setAttribute("value", k), l.setAttribute("as", h), g.appendChild(l);
}
}
0 < g.childNodes.length && d.appendChild(g);
}
}
return d;
}, a.getStringValue = function(a, c) {
var d = typeof c;
return "function" == d ? c = mxStyleRegistry.getName(style[j]) :"object" == d && (c = null), 
c;
}, a.decode = function(a, c, d) {
d = d || new this.template.constructor();
var e = c.getAttribute("id");
for (null != e && (a.objects[e] = d), c = c.firstChild; null != c; ) {
if (!this.processInclude(a, c, d) && "add" == c.nodeName && (e = c.getAttribute("as"), 
null != e)) {
var f = c.getAttribute("extend"), g = null != f ? mxUtils.clone(d.styles[f]) :null;
for (null == g && (null != f && mxLog.warn("mxStylesheetCodec.decode: stylesheet " + f + " not found to extend"), 
g = {}), f = c.firstChild; null != f; ) {
if (f.nodeType == mxConstants.NODETYPE_ELEMENT) {
var h = f.getAttribute("as");
if ("add" == f.nodeName) {
var k = mxUtils.getTextContent(f), l = null;
null != k && 0 < k.length ? l = mxUtils.eval(k) :(l = f.getAttribute("value"), mxUtils.isNumeric(l) && (l = parseFloat(l))), 
null != l && (g[h] = l);
} else "remove" == f.nodeName && delete g[h];
}
f = f.nextSibling;
}
d.putCellStyle(e, g);
}
c = c.nextSibling;
}
return d;
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxDefaultKeyHandler());
return a.encode = function() {
return null;
}, a.decode = function(a, c, d) {
if (null != d) for (c = c.firstChild; null != c; ) {
if (!this.processInclude(a, c, d) && "add" == c.nodeName) {
var e = c.getAttribute("as"), f = c.getAttribute("action"), g = c.getAttribute("control");
d.bindAction(e, f, g);
}
c = c.nextSibling;
}
return d;
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxDefaultToolbar());
return a.encode = function() {
return null;
}, a.decode = function(a, c, d) {
if (null != d) {
var e = d.editor;
for (c = c.firstChild; null != c; ) {
if (c.nodeType == mxConstants.NODETYPE_ELEMENT && !this.processInclude(a, c, d)) if ("separator" == c.nodeName) d.addSeparator(); else if ("br" == c.nodeName) d.toolbar.addBreak(); else if ("hr" == c.nodeName) d.toolbar.addLine(); else if ("add" == c.nodeName) {
var f = c.getAttribute("as"), f = mxResources.get(f) || f, g = c.getAttribute("icon"), h = c.getAttribute("pressedIcon"), k = c.getAttribute("action"), l = c.getAttribute("mode"), m = c.getAttribute("template"), n = "0" != c.getAttribute("toggle"), p = mxUtils.getTextContent(c), q = null;
if (null != k) q = d.addItem(f, g, k, h); else if (null != l) var s = mxUtils.eval(p), q = d.addMode(f, g, l, h, s); else if (null != m || null != p && 0 < p.length) q = e.templates[m], 
m = c.getAttribute("style"), null != q && null != m && (q = q.clone(), q.setStyle(m)), 
m = null, null != p && 0 < p.length && (m = mxUtils.eval(p)), q = d.addPrototype(f, g, q, h, m, n); else if (h = mxUtils.getChildNodes(c), 
0 < h.length) if (null == g) for (m = d.addActionCombo(f), f = 0; f < h.length; f++) n = h[f], 
"separator" == n.nodeName ? d.addOption(m, "---") :"add" == n.nodeName && (g = n.getAttribute("as"), 
n = n.getAttribute("action"), d.addActionOption(m, g, n)); else {
var r = null, t = d.addPrototype(f, g, function() {
var a = e.templates[r.value];
if (null != a) {
var a = a.clone(), b = r.options[r.selectedIndex].cellStyle;
return null != b && a.setStyle(b), a;
}
return mxLog.warn("Template " + a + " not found"), null;
}, null, null, n), r = d.addCombo();
for (mxEvent.addListener(r, "change", function() {
d.toolbar.selectMode(t, function(a) {
return a = mxUtils.convertPoint(e.graph.container, mxEvent.getClientX(a), mxEvent.getClientY(a)), 
e.addVertex(null, s(), a.x, a.y);
}), d.toolbar.noReset = !1;
}), f = 0; f < h.length; f++) n = h[f], "separator" == n.nodeName ? d.addOption(r, "---") :"add" == n.nodeName && (g = n.getAttribute("as"), 
p = n.getAttribute("template"), d.addOption(r, g, p || m).cellStyle = n.getAttribute("style"));
}
null != q && (m = c.getAttribute("id"), null != m && 0 < m.length && q.setAttribute("id", m));
}
c = c.nextSibling;
}
}
return d;
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxDefaultPopupMenu());
return a.encode = function() {
return null;
}, a.decode = function(a, c, d) {
var e = c.getElementsByTagName("include")[0];
return null != e ? this.processInclude(a, e, d) :null != d && (d.config = c), d;
}, a;
}()), mxCodecRegistry.register(function() {
var a = new mxObjectCodec(new mxEditor(), "modified lastSnapshot ignoredChanges undoManager graphContainer toolbarContainer".split(" "));
return a.afterDecode = function(a, c, d) {
return a = c.getAttribute("defaultEdge"), null != a && (c.removeAttribute("defaultEdge"), 
d.defaultEdge = d.templates[a]), a = c.getAttribute("defaultGroup"), null != a && (c.removeAttribute("defaultGroup"), 
d.defaultGroup = d.templates[a]), d;
}, a.decodeChild = function(a, c, d) {
if ("Array" == c.nodeName) {
if ("templates" == c.getAttribute("as")) return this.decodeTemplates(a, c, d), void 0;
} else if ("ui" == c.nodeName) return this.decodeUi(a, c, d), void 0;
mxObjectCodec.prototype.decodeChild.apply(this, arguments);
}, a.decodeUi = function(a, c, d) {
for (a = c.firstChild; null != a; ) {
if ("add" == a.nodeName) {
c = a.getAttribute("as");
var e = a.getAttribute("element"), f = a.getAttribute("style"), g = null;
if (null != e) g = document.getElementById(e), null != g && null != f && (g.style.cssText += ";" + f); else {
var e = parseInt(a.getAttribute("x")), h = parseInt(a.getAttribute("y")), k = a.getAttribute("width"), l = a.getAttribute("height"), g = document.createElement("div");
g.style.cssText = f, new mxWindow(mxResources.get(c) || c, g, e, h, k, l, !1, !0).setVisible(!0);
}
"graph" == c ? d.setGraphContainer(g) :"toolbar" == c ? d.setToolbarContainer(g) :"title" == c ? d.setTitleContainer(g) :"status" == c ? d.setStatusContainer(g) :"map" == c && d.setMapContainer(g);
} else "resource" == a.nodeName ? mxResources.add(a.getAttribute("basename")) :"stylesheet" == a.nodeName && mxClient.link("stylesheet", a.getAttribute("name"));
a = a.nextSibling;
}
}, a.decodeTemplates = function(a, c, d) {
null == d.templates && (d.templates = []), c = mxUtils.getChildNodes(c);
for (var e = 0; e < c.length; e++) {
for (var f = c[e].getAttribute("as"), g = c[e].firstChild; null != g && 1 != g.nodeType; ) g = g.nextSibling;
null != g && (d.templates[f] = a.decodeCell(g));
}
}, a;
}());

/**
 * $Id: Editor.js,v 1.17 2013/05/23 16:00:22 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
var useLocalStorage = (mxClient.IS_TOUCH || "local" == urlParams.storage) && "undefined" != typeof localStorage, fileSupport = null != window.File && null != window.FileReader && null != window.FileList, touchStyle = mxClient.IS_TOUCH || "1" == urlParams.touch, counter = 0;

try {
for (var op = window; null != op.opener && !isNaN(op.opener.counter); ) op = op.opener;
null != op && (op.counter++, counter = op.counter);
} catch (e) {}

Editor = function() {
mxEventSource.call(this), this.init(), this.initStencilRegistry(), this.graph = new Graph(), 
this.outline = new mxOutline(this.graph), this.outline.updateOnPan = !0, this.undoManager = this.createUndoManager(), 
this.status = "", this.filename = null, this.getOrCreateFilename = function() {
return this.filename || mxResources.get("drawing", [ counter ]) + ".xml";
}, this.getFilename = function() {
return this.filename;
}, this.setStatus = function(value) {
this.status = value, this.fireEvent(new mxEventObject("statusChanged"));
}, this.getStatus = function() {
return this.status;
}, this.modified = !1, this.graphChangeListener = function() {
this.modified = !0;
}, this.graph.getModel().addListener(mxEvent.CHANGE, mxUtils.bind(this, function() {
this.graphChangeListener.apply(this, arguments);
})), this.graph.resetViewOnRootChange = !1, this.graph.scrollbars = !0, this.graph.background = null;
}, mxUtils.extend(Editor, mxEventSource), Editor.prototype.gridImage = IMAGE_PATH + "/grid.gif", 
Editor.prototype.transparentImage = IMAGE_PATH + "/transparent.gif", Editor.prototype.setGraphXml = function(node) {
var dec = new mxCodec(node.ownerDocument);
if ("mxGraphModel" != node.nodeName) {
var nodes = node.getElementsByTagName("mxGraphModel");
null != nodes && nodes.length > 0 && (node = nodes[0]);
}
if ("mxGraphModel" == node.nodeName) {
this.graph.view.scale = 1, this.graph.gridEnabled = "0" != node.getAttribute("grid"), 
this.graph.graphHandler.guidesEnabled = "0" != node.getAttribute("guides"), this.graph.setTooltips("0" != node.getAttribute("tooltips")), 
this.graph.setConnectable("0" != node.getAttribute("connect")), this.graph.foldingEnabled = "0" != node.getAttribute("fold"), 
this.graph.scrollbars = "0" != node.getAttribute("scrollbars"), this.graph.scrollbars || (this.graph.container.scrollLeft = 0, 
this.graph.container.scrollTop = 0, this.graph.view.translate.x = Number(node.getAttribute("dx") || 0), 
this.graph.view.translate.y = Number(node.getAttribute("dy") || 0)), this.graph.pageVisible = "1" == node.getAttribute("page"), 
this.graph.pageBreaksVisible = this.graph.pageVisible, this.graph.preferPageSize = this.graph.pageBreaksVisible;
var ps = node.getAttribute("pageScale");
this.graph.pageScale = null != ps ? ps :1.5;
var bg = (node.getAttribute("pageWidth"), node.getAttribute("pageHeight"), node.getAttribute("background"));
null != bg && bg.length > 0 && (this.graph.background = bg), dec.decode(node, this.graph.getModel()), 
this.updateGraphComponents();
} else {
var wrapper = dec.document.createElement("mxGraphModel");
wrapper.appendChild(node), dec.decode(wrapper, this.graph.getModel()), this.updateGraphComponents();
}
}, Editor.prototype.getGraphXml = function() {
var enc = new mxCodec(mxUtils.createXmlDocument()), node = enc.encode(this.graph.getModel());
return (0 != this.graph.view.translate.x || 0 != this.graph.view.translate.y) && (node.setAttribute("dx", Math.round(100 * this.graph.view.translate.x) / 100), 
node.setAttribute("dy", Math.round(100 * this.graph.view.translate.y) / 100)), node.setAttribute("grid", this.graph.isGridEnabled() ? "1" :"0"), 
node.setAttribute("guides", this.graph.graphHandler.guidesEnabled ? "1" :"0"), node.setAttribute("guides", this.graph.graphHandler.guidesEnabled ? "1" :"0"), 
node.setAttribute("tooltips", this.graph.tooltipHandler.isEnabled() ? "1" :"0"), 
node.setAttribute("connect", this.graph.connectionHandler.isEnabled() ? "1" :"0"), 
node.setAttribute("fold", this.graph.foldingEnabled ? "1" :"0"), node.setAttribute("page", this.graph.pageVisible ? "1" :"0"), 
node.setAttribute("pageScale", this.graph.pageScale), node.setAttribute("pageWidth", this.graph.pageFormat.width), 
node.setAttribute("pageHeight", this.graph.pageFormat.height), this.graph.scrollbars || node.setAttribute("scrollbars", "0"), 
null != this.graph.background && node.setAttribute("background", this.graph.background), 
node;
}, Editor.prototype.updateGraphComponents = function() {
var graph = this.graph, outline = this.outline;
if (null != graph.container && null != outline.outline.container) {
null != graph.background ? "none" == graph.background ? graph.container.style.backgroundColor = "transparent" :(null != graph.view.backgroundPageShape && (graph.view.backgroundPageShape.fill = graph.background, 
graph.view.backgroundPageShape.reconfigure()), graph.container.style.backgroundColor = graph.background) :graph.container.style.backgroundColor = "", 
graph.pageVisible ? (graph.container.style.backgroundColor = "#ebebeb", graph.container.style.borderStyle = "solid", 
graph.container.style.borderColor = "#e5e5e5", graph.container.style.borderTopWidth = "1px", 
graph.container.style.borderLeftWidth = "1px", graph.container.style.borderRightWidth = "0px", 
graph.container.style.borderBottomWidth = "0px") :graph.container.style.border = "", 
outline.outline.container.style.backgroundColor = graph.container.style.backgroundColor, 
(outline.outline.pageVisible != graph.pageVisible || outline.outline.pageScale != graph.pageScale) && (outline.outline.pageScale = graph.pageScale, 
outline.outline.pageVisible = graph.pageVisible, outline.outline.view.validate()), 
graph.scrollbars && "hidden" == graph.container.style.overflow && !touchStyle ? graph.container.style.overflow = "auto" :(!graph.scrollbars || touchStyle) && (graph.container.style.overflow = "hidden");
var noBackground = mxClient.IS_IE && document.documentMode >= 9 ? "url(" + this.transparentImage + ")" :"none";
graph.container.style.backgroundImage = !graph.pageVisible && graph.isGridEnabled() ? "url(" + this.gridImage + ")" :noBackground, 
null != graph.view.backgroundPageShape && (graph.view.backgroundPageShape.node.style.backgroundImage = this.graph.isGridEnabled() ? "url(" + this.gridImage + ")" :"none");
}
}, Editor.prototype.init = function() {
mxClient.IS_IE6 && mxClient.link("stylesheet", CSS_PATH + "/grapheditor-ie6.css"), 
mxResources.loadDefaultBundle = !1, mxResources.add(RESOURCE_BASE), mxConstants.DEFAULT_HOTSPOT = .3;
var mxConnectionHandlerCreateMarker = mxConnectionHandler.prototype.createMarker;
mxConnectionHandler.prototype.createMarker = function() {
var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);
return marker.intersects = mxUtils.bind(this, function() {
return this.isConnecting() ? !0 :mxCellMarker.prototype.intersects.apply(marker, arguments);
}), marker;
}, mxConstants.SHADOWCOLOR = "#d0d0d0", mxConstants.HANDLE_FILLCOLOR = "#99ccff", 
mxConstants.HANDLE_STROKECOLOR = "#0088cf", mxConstants.VERTEX_SELECTION_COLOR = "#00a8ff", 
mxConstants.OUTLINE_COLOR = "#00a8ff", mxConstants.OUTLINE_HANDLE_FILLCOLOR = "#99ccff", 
mxConstants.OUTLINE_HANDLE_STROKECOLOR = "#00a8ff", mxConstants.CONNECT_HANDLE_FILLCOLOR = "#cee7ff", 
mxConstants.EDGE_SELECTION_COLOR = "#00a8ff", mxConstants.DEFAULT_VALID_COLOR = "#00a8ff", 
mxConstants.LABEL_HANDLE_FILLCOLOR = "#cee7ff", mxConstants.GUIDE_COLOR = "#0088cf", 
mxGraph.prototype.pageBreakColor = "#c0c0c0", mxGraph.prototype.pageScale = 1, mxRubberband.prototype.defaultOpacity = 30, 
mxGraphView.prototype.createBackgroundPageShape = function(bounds) {
return new mxRectangleShape(bounds, this.graph.background || "white", "#cacaca");
}, mxGraphView.prototype.getBackgroundPageBounds = function() {
var gb = this.getGraphBounds(), x = gb.width > 0 ? gb.x / this.scale - this.translate.x :0, y = gb.height > 0 ? gb.y / this.scale - this.translate.y :0, w = gb.width / this.scale, h = gb.height / this.scale, fmt = this.graph.pageFormat, ps = this.graph.pageScale, pw = fmt.width * ps, ph = fmt.height * ps, x0 = Math.floor(Math.min(0, x) / pw), y0 = Math.floor(Math.min(0, y) / ph), xe = Math.ceil(Math.max(1, x + w) / pw), ye = Math.ceil(Math.max(1, y + h) / ph), rows = xe - x0, cols = ye - y0, bounds = new mxRectangle(this.scale * (this.translate.x + x0 * pw), this.scale * (this.translate.y + y0 * ph), this.scale * rows * pw, this.scale * cols * ph);
return bounds;
};
var graphPanGraph = mxGraph.prototype.panGraph;
mxGraph.prototype.panGraph = function(dx, dy) {
graphPanGraph.apply(this, arguments), this.dialect == mxConstants.DIALECT_SVG || null == this.view.backgroundPageShape || this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container) || (this.view.backgroundPageShape.node.style.marginLeft = dx + "px", 
this.view.backgroundPageShape.node.style.marginTop = dy + "px");
};
var editor = this;
mxGraphView.prototype.validateBackground = function() {
var bg = this.graph.getBackgroundImage();
if (null != bg) {
if (null == this.backgroundImage || this.backgroundImage.image != bg.src) {
null != this.backgroundImage && this.backgroundImage.destroy();
var bounds = new mxRectangle(0, 0, 1, 1);
this.backgroundImage = new mxImageShape(bounds, bg.src), this.backgroundImage.dialect = this.graph.dialect, 
this.backgroundImage.init(this.backgroundPane), this.backgroundImage.redraw();
}
this.redrawBackgroundImage(this.backgroundImage, bg);
} else null != this.backgroundImage && (this.backgroundImage.destroy(), this.backgroundImage = null);
if (this.graph.pageVisible) {
var bounds = this.getBackgroundPageBounds();
null == this.backgroundPageShape ? (this.backgroundPageShape = this.createBackgroundPageShape(bounds), 
this.backgroundPageShape.scale = 1, this.backgroundPageShape.isShadow = !0, this.backgroundPageShape.dialect = mxConstants.DIALECT_STRICTHTML, 
this.backgroundPageShape.init(this.graph.container), this.graph.container.firstChild.style.position = "absolute", 
this.graph.container.insertBefore(this.backgroundPageShape.node, this.graph.container.firstChild), 
this.backgroundPageShape.redraw(), this.backgroundPageShape.node.className = "geBackgroundPage", 
this.backgroundPageShape.node.style.backgroundPosition = "-1px -1px", mxEvent.addListener(this.backgroundPageShape.node, "dblclick", mxUtils.bind(this, function(evt) {
this.graph.dblClick(evt);
})), mxEvent.addGestureListeners(this.backgroundPageShape.node, mxUtils.bind(this, function(evt) {
this.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
}), mxUtils.bind(this, function(evt) {
null != this.graph.tooltipHandler && this.graph.tooltipHandler.isHideOnHover() && this.graph.tooltipHandler.hide(), 
this.graph.isMouseDown && !mxEvent.isConsumed(evt) && this.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
}), mxUtils.bind(this, function(evt) {
this.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
}))) :(this.backgroundPageShape.scale = 1, this.backgroundPageShape.bounds = bounds, 
this.backgroundPageShape.redraw()), this.backgroundPageShape.node.style.backgroundImage = this.graph.isGridEnabled() ? "url(" + editor.gridImage + ")" :"none";
} else null != this.backgroundPageShape && (this.backgroundPageShape.destroy(), 
this.backgroundPageShape = null);
}, mxGraph.prototype.updatePageBreaks = function(visible, width, height) {
var scale = this.view.scale, tr = this.view.translate, fmt = this.pageFormat, ps = scale * this.pageScale, bounds2 = this.view.getBackgroundPageBounds();
width = bounds2.width, height = bounds2.height;
var bounds = new mxRectangle(scale * tr.x, scale * tr.y, fmt.width * ps, fmt.height * ps);
visible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;
var horizontalCount = visible ? Math.ceil(width / bounds.width) - 1 :0, verticalCount = visible ? Math.ceil(height / bounds.height) - 1 :0, right = bounds2.x + width, bottom = bounds2.y + height;
if (null == this.horizontalPageBreaks && horizontalCount > 0 && (this.horizontalPageBreaks = []), 
null != this.horizontalPageBreaks) {
for (var i = 0; horizontalCount >= i; i++) {
var pts = [ new mxPoint(bounds2.x + (i + 1) * bounds.width, bounds2.y), new mxPoint(bounds2.x + (i + 1) * bounds.width, bottom) ];
if (null != this.horizontalPageBreaks[i]) this.horizontalPageBreaks[i].scale = 1, 
this.horizontalPageBreaks[i].points = pts, this.horizontalPageBreaks[i].redraw(); else {
var pageBreak = new mxPolyline(pts, this.pageBreakColor, this.scale);
pageBreak.dialect = this.dialect, pageBreak.isDashed = this.pageBreakDashed, pageBreak.addPipe = !1, 
pageBreak.scale = scale, pageBreak.init(this.view.backgroundPane), pageBreak.redraw(), 
this.horizontalPageBreaks[i] = pageBreak;
}
}
for (var i = horizontalCount; i < this.horizontalPageBreaks.length; i++) this.horizontalPageBreaks[i].destroy();
this.horizontalPageBreaks.splice(horizontalCount, this.horizontalPageBreaks.length - horizontalCount);
}
if (null == this.verticalPageBreaks && verticalCount > 0 && (this.verticalPageBreaks = []), 
null != this.verticalPageBreaks) {
for (var i = 0; verticalCount >= i; i++) {
var pts = [ new mxPoint(bounds2.x, bounds2.y + (i + 1) * bounds.height), new mxPoint(right, bounds2.y + (i + 1) * bounds.height) ];
if (null != this.verticalPageBreaks[i]) this.verticalPageBreaks[i].scale = 1, this.verticalPageBreaks[i].points = pts, 
this.verticalPageBreaks[i].redraw(); else {
var pageBreak = new mxPolyline(pts, this.pageBreakColor, scale);
pageBreak.dialect = this.dialect, pageBreak.isDashed = this.pageBreakDashed, pageBreak.addPipe = !1, 
pageBreak.scale = scale, pageBreak.init(this.view.backgroundPane), pageBreak.redraw(), 
this.verticalPageBreaks[i] = pageBreak;
}
}
for (var i = verticalCount; i < this.verticalPageBreaks.length; i++) this.verticalPageBreaks[i].destroy();
this.verticalPageBreaks.splice(verticalCount, this.verticalPageBreaks.length - verticalCount);
}
}, mxEdgeHandler.prototype.snapToTerminals = !0, mxGraphHandler.prototype.guidesEnabled = !0;
var mxGraphHandlerShouldRemoveCellsFromParent = mxGraphHandler.prototype.shouldRemoveCellsFromParent;
mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(parent, cells) {
for (var i = 0; i < cells.length; i++) if (this.graph.getModel().isVertex(cells[i])) {
var geo = this.graph.getCellGeometry(cells[i]);
if (null != geo && geo.relative) return !1;
}
return mxGraphHandlerShouldRemoveCellsFromParent.apply(this, arguments);
}, mxGuide.prototype.isEnabledForEvent = function(evt) {
return !mxEvent.isAltDown(evt);
}, mxPopupMenuAddItem = mxPopupMenu.prototype.addItem, mxPopupMenu.prototype.addItem = function(title, image, funct, parent, iconCls, enabled) {
var result = mxPopupMenuAddItem.apply(this, arguments);
return null == enabled || enabled || mxEvent.addListener(result, "mousedown", function(evt) {
mxEvent.consume(evt);
}), result;
};
var graphHandlerGetInitialCellForEvent = mxGraphHandler.prototype.getInitialCellForEvent;
mxGraphHandler.prototype.getInitialCellForEvent = function() {
var model = this.graph.getModel(), psel = model.getParent(this.graph.getSelectionCell()), cell = graphHandlerGetInitialCellForEvent.apply(this, arguments), parent = model.getParent(cell);
if (null == psel || psel != cell && psel != parent) for (;!this.graph.isCellSelected(cell) && !this.graph.isCellSelected(parent) && model.isVertex(parent) && !this.graph.isValidRoot(parent); ) cell = parent, 
parent = this.graph.getModel().getParent(cell);
return cell;
};
var graphHandlerIsDelayedSelection = mxGraphHandler.prototype.isDelayedSelection;
mxGraphHandler.prototype.isDelayedSelection = function(cell) {
var result = graphHandlerIsDelayedSelection.apply(this, arguments), model = this.graph.getModel(), psel = model.getParent(this.graph.getSelectionCell()), parent = model.getParent(cell);
return (null == psel || psel != cell && psel != parent) && (this.graph.isCellSelected(cell) || !model.isVertex(parent) || this.graph.isValidRoot(parent) || (result = !0)), 
result;
}, mxGraphHandler.prototype.selectDelayed = function(me) {
var cell = me.getCell();
null == cell && (cell = this.cell);
for (var model = this.graph.getModel(), parent = model.getParent(cell); this.graph.isCellSelected(cell) && model.isVertex(parent) && !this.graph.isValidRoot(parent); ) cell = parent, 
parent = model.getParent(cell);
this.graph.selectCellForEvent(cell, me.getEvent());
}, mxPanningHandler.prototype.getCellForPopupEvent = function(me) {
for (var cell = me.getCell(), model = this.graph.getModel(), parent = model.getParent(cell); model.isVertex(parent) && !this.graph.isValidRoot(parent); ) this.graph.isCellSelected(parent) && (cell = parent), 
parent = model.getParent(parent);
return cell;
};
}, Editor.prototype.createUndoManager = function() {
var graph = this.graph, undoMgr = new mxUndoManager(), listener = function(sender, evt) {
undoMgr.undoableEditHappened(evt.getProperty("edit"));
};
graph.getModel().addListener(mxEvent.UNDO, listener), graph.getView().addListener(mxEvent.UNDO, listener);
var undoHandler = function(sender, evt) {
for (var cand = graph.getSelectionCellsForChanges(evt.getProperty("edit").changes), cells = [], i = 0; i < cand.length; i++) null != graph.view.getState(cand[i]) && cells.push(cand[i]);
graph.setSelectionCells(cells);
};
return undoMgr.addListener(mxEvent.UNDO, undoHandler), undoMgr.addListener(mxEvent.REDO, undoHandler), 
undoMgr;
}, Editor.prototype.initStencilRegistry = function() {
mxStencilRegistry.loadStencilSet(STENCIL_PATH + "/general.xml");
}, function() {
mxStencilRegistry.libraries = {}, mxStencilRegistry.packages = [], mxStencilRegistry.getStencil = function(name) {
var result = mxStencilRegistry.stencils[name];
if (null == result) {
var basename = mxStencilRegistry.getBasenameForStencil(name);
if (null != basename) {
var libs = mxStencilRegistry.libraries[basename];
if (null != libs) {
if (null == mxStencilRegistry.packages[basename]) {
mxStencilRegistry.packages[basename] = 1;
for (var i = 0; i < libs.length; i++) {
var fname = libs[i];
if (".xml" == fname.toLowerCase().substring(fname.length - 4, fname.length)) mxStencilRegistry.loadStencilSet(fname, null); else if (".js" == fname.toLowerCase().substring(fname.length - 3, fname.length)) {
var req = mxUtils.load(fname);
null != req && eval.call(window, req.getText());
}
}
}
} else mxStencilRegistry.loadStencilSet(STENCIL_PATH + "/" + basename + ".xml", null);
result = mxStencilRegistry.stencils[name];
}
}
return result;
}, mxStencilRegistry.getBasenameForStencil = function(name) {
var parts = name.split("."), tmp = null;
if (parts.length > 0 && "mxgraph" == parts[0]) {
tmp = parts[1];
for (var i = 2; i < parts.length - 1; i++) tmp += "/" + parts[i];
}
return tmp;
}, mxStencilRegistry.loadStencilSet = function(stencilFile, postStencilLoad, force) {
force = null != force ? force :!1;
var xmlDoc = mxStencilRegistry.packages[stencilFile];
if (force || null == xmlDoc) {
var install = !1;
if (null == xmlDoc) {
var req = mxUtils.load(stencilFile);
xmlDoc = req.getXml(), mxStencilRegistry.packages[stencilFile] = xmlDoc, install = !0;
}
mxStencilRegistry.parseStencilSet(xmlDoc, postStencilLoad, install);
}
}, mxStencilRegistry.parseStencilSet = function(xmlDocument, postStencilLoad, install) {
install = null != install ? install :!0;
var root = xmlDocument.documentElement, shape = root.firstChild, packageName = "", name = root.getAttribute("name");
for (null != name && (packageName = name + "."); null != shape; ) {
if (shape.nodeType == mxConstants.NODETYPE_ELEMENT && (name = shape.getAttribute("name"), 
null != name)) {
packageName = packageName.toLowerCase();
var stencilName = name.replace(/ /g, "_");
if (install && mxStencilRegistry.addStencil(packageName + stencilName.toLowerCase(), new mxStencil(shape)), 
null != postStencilLoad) {
var w = shape.getAttribute("w"), h = shape.getAttribute("h");
w = null == w ? 80 :parseInt(w, 10), h = null == h ? 80 :parseInt(h, 10), postStencilLoad(packageName, stencilName, name, w, h);
}
}
shape = shape.nextSibling;
}
};
}(), OpenFile = function(done) {
this.producer = null, this.consumer = null, this.done = done;
}, OpenFile.prototype.setConsumer = function(value) {
this.consumer = value, this.execute();
}, OpenFile.prototype.setData = function(value, filename) {
this.data = value, this.filename = filename, this.execute();
}, OpenFile.prototype.error = function(msg) {
this.cancel(), mxUtils.alert(msg);
}, OpenFile.prototype.execute = function() {
null != this.consumer && null != this.data && (this.consumer(this.data, this.filename), 
this.cancel());
}, OpenFile.prototype.cancel = function() {
null != this.done && this.done();
}, /**
 * $Id: EditorUi.js,v 1.25 2013/05/01 16:17:21 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
EditorUi = function(editor, choices, container) {
if (this.editor = editor || new Editor(), this.choices = choices || [ "all" ], !container) return null;
this.container = container || document.body;
var graph = editor.graph;
this.container.style.overflow = "hidden", new Image().src = mxPopupMenu.prototype.submenuImage, 
null != mxConnectionHandler.prototype.connectImage && (new Image().src = mxConnectionHandler.prototype.connectImage.src), 
this.actions = new Actions(this), this.menus = new Menus(this), this.createDivs(), 
this.refresh(), this.createUi();
var textEditing = mxUtils.bind(this, function(evt) {
return null == evt && (evt = window.event), this.isSelectionAllowed(evt) ? !0 :graph.isEditing();
});
this.container == document.body && (this.menubarContainer.onselectstart = textEditing, 
this.menubarContainer.onmousedown = textEditing, this.toolbarContainer.onselectstart = textEditing, 
this.toolbarContainer.onmousedown = textEditing, this.diagramContainer.onselectstart = textEditing, 
this.diagramContainer.onmousedown = textEditing, this.sidebarContainer.onselectstart = textEditing, 
this.sidebarContainer.onmousedown = textEditing, this.footerContainer.onselectstart = textEditing, 
this.footerContainer.onmousedown = textEditing), mxClient.IS_IE && ("undefined" == typeof document.documentMode || document.documentMode < 9) ? mxEvent.addListener(this.diagramContainer, "contextmenu", textEditing) :this.diagramContainer.oncontextmenu = textEditing, 
graph.init(this.diagramContainer), graph.refresh(), graph.container.setAttribute("tabindex", "0"), 
graph.container.style.overflow = touchStyle ? "hidden" :"auto", graph.container.style.cursor = "default", 
graph.container.style.backgroundImage = "url(" + editor.gridImage + ")", graph.container.style.backgroundPosition = "-1px -1px", 
graph.container.focus();
var graphFireMouseEvent = graph.fireMouseEvent;
graph.fireMouseEvent = function(evtName) {
evtName == mxEvent.MOUSE_DOWN && this.container.focus(), graphFireMouseEvent.apply(this, arguments);
}, graph.panningHandler.autoExpand = !0, graph.panningHandler.factoryMethod = mxUtils.bind(this, function(menu, cell, evt) {
this.menus.createPopupMenu(menu, cell, evt);
}), editor.outline.init(this.outlineContainer), mxEvent.addGestureListeners(document, mxUtils.bind(this, function() {
graph.panningHandler.hideMenu();
})), mxClient.IS_TOUCH && (mxEvent.addListener(graph.container, "gesturechange", mxUtils.bind(this, function(evt) {
graph.view.getDrawPane().setAttribute("transform", "scale(" + evt.scale + ")"), 
graph.view.getOverlayPane().style.visibility = "hidden", mxEvent.consume(evt);
})), mxEvent.addListener(graph.container, "gestureend", mxUtils.bind(this, function(evt) {
graph.view.getDrawPane().removeAttribute("transform"), graph.view.setScale(graph.view.scale * evt.scale), 
graph.view.getOverlayPane().style.visibility = "visible", mxEvent.consume(evt);
})), graph.handleGesture = function() {});
var keyHandler = this.createKeyHandler(editor);
this.getKeyHandler = function() {
return keyHandler;
}, mxEvent.addListener(window, "resize", mxUtils.bind(this, function() {
this.refresh(), graph.sizeDidChange(), this.editor.outline.update(!1), this.editor.outline.outline.sizeDidChange();
})), this.init(), this.open();
}, EditorUi.prototype.splitSize = mxClient.IS_TOUCH ? 16 :8, EditorUi.prototype.menubarHeight = 0, 
EditorUi.prototype.toolbarHeight = 36, EditorUi.prototype.footerHeight = 0, EditorUi.prototype.sidebarFooterHeight = 34, 
EditorUi.prototype.hsplitPosition = 204, EditorUi.prototype.vsplitPosition = 0, 
EditorUi.prototype.init = function() {
this.addUndoListener(), this.addSelectionListener();
var paste = this.actions.get("paste"), updatePaste = function() {
paste.setEnabled(!mxClipboard.isEmpty());
}, mxClipboardCut = mxClipboard.cut;
mxClipboard.cut = function() {
mxClipboardCut.apply(this, arguments), updatePaste();
};
var mxClipboardCopy = mxClipboard.copy;
mxClipboard.copy = function() {
mxClipboardCopy.apply(this, arguments), updatePaste();
};
}, EditorUi.prototype.isSelectionAllowed = function() {
return !1;
}, EditorUi.prototype.open = function() {
try {
null != window.opener && null != window.opener.openFile && window.opener.openFile.setConsumer(mxUtils.bind(this, function(xml, filename) {
try {
var doc = mxUtils.parseXml(xml);
this.editor.setGraphXml(doc.documentElement), this.editor.modified = !1, this.editor.undoManager.clear(), 
null != filename && (this.editor.filename = filename);
} catch (e) {
mxUtils.alert(mxResources.get("invalidOrMissingFile") + ": " + e.message);
}
}));
} catch (e) {}
}, EditorUi.prototype.save = function(name) {
if (null != name) {
var xml = mxUtils.getXml(this.editor.getGraphXml());
try {
if (useLocalStorage) {
if (null != localStorage.getItem(name) && !mxUtils.confirm(mxResources.get("replace", [ name ]))) return;
localStorage.setItem(name, xml), this.editor.setStatus(mxResources.get("saved") + " " + new Date());
} else {
if (!(xml.length < MAX_REQUEST_SIZE)) return mxUtils.alert(mxResources.get("drawingTooLarge")), 
mxUtils.popup(xml), void 0;
xml = encodeURIComponent(xml), new mxXmlRequest(SAVE_URL, "filename=" + name + "&xml=" + xml).simulate(document, "_blank");
}
this.editor.filename = name, this.editor.modified = !1;
} catch (e) {
this.editor.setStatus("Error saving file");
}
}
}, EditorUi.prototype.getUrl = function(pathname) {
var href = null != pathname ? pathname :window.location.pathname, parms = href.indexOf("?") > 0 ? 1 :0;
for (var key in urlParams) href += 0 == parms ? "?" :"&", href += key + "=" + urlParams[key], 
parms++;
return href;
}, EditorUi.prototype.addUndoListener = function() {
var undo = this.actions.get("undo"), redo = this.actions.get("redo"), undoMgr = this.editor.undoManager, undoListener = function() {
undo.setEnabled(undoMgr.canUndo()), redo.setEnabled(undoMgr.canRedo());
};
undoMgr.addListener(mxEvent.ADD, undoListener), undoMgr.addListener(mxEvent.UNDO, undoListener), 
undoMgr.addListener(mxEvent.REDO, undoListener), undoMgr.addListener(mxEvent.CLEAR, undoListener), 
undoListener();
}, EditorUi.prototype.addSelectionListener = function() {
var selectionListener = mxUtils.bind(this, function() {
var graph = this.editor.graph, selected = !graph.isSelectionEmpty(), vertexSelected = !1, edgeSelected = !1, cells = graph.getSelectionCells();
if (null != cells) for (var i = 0; i < cells.length; i++) {
var cell = cells[i];
if (graph.getModel().isEdge(cell) && (edgeSelected = !0), graph.getModel().isVertex(cell) && (vertexSelected = !0), 
edgeSelected && vertexSelected) break;
}
for (var actions = [ "cut", "copy", "delete", "duplicate", "bold", "italic", "style", "fillColor", "gradientColor", "underline", "fontColor", "strokeColor", "backgroundColor", "borderColor", "toFront", "toBack", "dashed", "rounded", "shadow", "tilt", "autosize", "lockUnlock" ], i = 0; i < actions.length; i++) this.actions.get(actions[i]).setEnabled(selected);
this.actions.get("curved").setEnabled(edgeSelected), this.actions.get("rotation").setEnabled(vertexSelected), 
this.actions.get("wordWrap").setEnabled(vertexSelected), this.actions.get("group").setEnabled(graph.getSelectionCount() > 1), 
this.actions.get("ungroup").setEnabled(1 == graph.getSelectionCount() && graph.getModel().getChildCount(graph.getSelectionCell()) > 0);
var oneVertexSelected = vertexSelected && 1 == graph.getSelectionCount();
this.actions.get("removeFromGroup").setEnabled(oneVertexSelected && graph.getModel().isVertex(graph.getModel().getParent(graph.getSelectionCell())));
for (var menus = [ "fontFamily", "fontSize", "alignment", "position", "text", "format", "arrange", "linewidth", "spacing", "gradient" ], i = 0; i < menus.length; i++) this.menus.get(menus[i]).setEnabled(selected);
menus = [ "line", "lineend", "linestart" ];
for (var i = 0; i < menus.length; i++) this.menus.get(menus[i]).setEnabled(edgeSelected);
this.actions.get("setAsDefaultEdge").setEnabled(edgeSelected), this.menus.get("align").setEnabled(graph.getSelectionCount() > 1), 
this.menus.get("direction").setEnabled(vertexSelected || edgeSelected && graph.isLoop(graph.view.getState(graph.getSelectionCell()))), 
this.menus.get("navigation").setEnabled(graph.foldingEnabled && (null != graph.view.currentRoot || 1 == graph.getSelectionCount() && graph.isValidRoot(graph.getSelectionCell()))), 
this.menus.get("layers").setEnabled(null == graph.view.currentRoot), this.actions.get("home").setEnabled(null != graph.view.currentRoot), 
this.actions.get("exitGroup").setEnabled(null != graph.view.currentRoot);
var groupEnabled = 1 == graph.getSelectionCount() && graph.isValidRoot(graph.getSelectionCell());
this.actions.get("enterGroup").setEnabled(groupEnabled), this.actions.get("expand").setEnabled(groupEnabled), 
this.actions.get("collapse").setEnabled(groupEnabled), this.actions.get("editLink").setEnabled(1 == graph.getSelectionCount()), 
this.actions.get("openLink").setEnabled(1 == graph.getSelectionCount() && null != graph.getLinkForCell(graph.getSelectionCell()));
});
this.editor.graph.getSelectionModel().addListener(mxEvent.CHANGE, selectionListener), 
selectionListener();
}, EditorUi.prototype.refresh = function() {
var quirks = mxClient.IS_IE && (null == document.documentMode || 5 == document.documentMode), w = this.container.clientWidth, h = this.container.clientHeight;
this.container == document.body && (w = document.body.clientWidth || document.documentElement.clientWidth, 
h = quirks ? document.body.clientHeight || document.documentElement.clientHeight :document.documentElement.clientHeight);
var effHsplitPosition = Math.max(0, Math.min(this.hsplitPosition, w - this.splitSize - 20)), effVsplitPosition = Math.max(0, Math.min(this.vsplitPosition, h - this.menubarHeight - this.toolbarHeight - this.footerHeight - this.splitSize - 1));
this.menubarContainer.style.height = this.menubarHeight + "px", this.toolbarContainer.style.top = this.menubarHeight + "px", 
this.toolbarContainer.style.height = this.toolbarHeight + "px";
var tmp = this.menubarHeight + this.toolbarHeight;
mxClient.IS_QUIRKS || (tmp += 1);
var sidebarFooterHeight = 0;
if (null != this.sidebarFooterContainer) {
var bottom = effVsplitPosition + this.splitSize + this.footerHeight;
sidebarFooterHeight = Math.max(0, Math.min(h - tmp - bottom, this.sidebarFooterHeight)), 
this.sidebarFooterContainer.style.width = effHsplitPosition + "px", this.sidebarFooterContainer.style.height = sidebarFooterHeight + "px", 
this.sidebarFooterContainer.style.bottom = bottom + "px";
}
if (this.sidebarContainer.style.top = tmp + "px", this.sidebarContainer.style.width = effHsplitPosition + "px", 
this.outlineContainer.style.width = effHsplitPosition + "px", this.outlineContainer.style.height = effVsplitPosition + "px", 
this.outlineContainer.style.bottom = this.footerHeight + "px", this.diagramContainer.style.left = effHsplitPosition + this.splitSize + "px", 
this.diagramContainer.style.top = this.sidebarContainer.style.top, this.footerContainer.style.height = this.footerHeight + "px", 
this.hsplit.style.top = this.sidebarContainer.style.top, this.hsplit.style.bottom = this.outlineContainer.style.bottom, 
this.hsplit.style.left = effHsplitPosition + "px", this.vsplit.style.width = this.sidebarContainer.style.width, 
this.vsplit.style.bottom = effVsplitPosition + this.footerHeight + "px", quirks) {
this.menubarContainer.style.width = w + "px", this.toolbarContainer.style.width = this.menubarContainer.style.width;
var sidebarHeight = Math.max(0, h - effVsplitPosition - this.splitSize - this.footerHeight - this.menubarHeight - this.toolbarHeight);
this.sidebarContainer.style.height = sidebarHeight - sidebarFooterHeight + "px", 
this.diagramContainer.style.width = Math.max(0, w - effHsplitPosition - this.splitSize) + "px";
var diagramHeight = Math.max(0, h - this.footerHeight - this.menubarHeight - this.toolbarHeight);
this.diagramContainer.style.height = diagramHeight + "px", this.footerContainer.style.width = this.menubarContainer.style.width, 
this.hsplit.style.height = diagramHeight + "px";
} else this.sidebarContainer.style.bottom = effVsplitPosition + this.splitSize + this.footerHeight + sidebarFooterHeight + "px", 
this.diagramContainer.style.bottom = this.outlineContainer.style.bottom;
}, EditorUi.prototype.createDivs = function() {
this.menubarContainer = this.createDiv("geMenubarContainer"), this.toolbarContainer = this.createDiv("geToolbarContainer"), 
this.sidebarContainer = this.createDiv("geSidebarContainer"), this.outlineContainer = this.createDiv("geOutlineContainer"), 
this.diagramContainer = this.createDiv("geDiagramContainer"), this.footerContainer = this.createDiv("geFooterContainer"), 
this.hsplit = this.createDiv("geHsplit"), this.vsplit = this.createDiv("geVsplit"), 
this.menubarContainer.style.top = "0px", this.menubarContainer.style.left = "0px", 
this.menubarContainer.style.right = "0px", this.toolbarContainer.style.left = "0px", 
this.toolbarContainer.style.right = "0px", this.sidebarContainer.style.left = "0px", 
this.outlineContainer.style.left = "0px", this.diagramContainer.style.right = "0px", 
this.footerContainer.style.left = "0px", this.footerContainer.style.right = "0px", 
this.footerContainer.style.bottom = "0px", this.vsplit.style.left = "0px", this.vsplit.style.height = this.splitSize + "px", 
this.hsplit.style.width = this.splitSize + "px", this.sidebarFooterContainer = this.createSidebarFooterContainer(), 
this.sidebarFooterContainer && (this.sidebarFooterContainer.style.left = "0px");
}, EditorUi.prototype.createSidebarFooterContainer = function() {
return null;
}, EditorUi.prototype.createUi = function() {
this.menubar = this.menus.createMenubar(this.createDiv("geMenubar")), this.menubarContainer.appendChild(this.menubar.container), 
this.toolbar = this.createToolbar(this.createDiv("geToolbar")), this.toolbarContainer.appendChild(this.toolbar.container), 
this.sidebar = this.createSidebar(this.sidebarContainer), this.footerContainer.appendChild(this.createFooter()), 
this.statusContainer = this.createStatusContainer(), this.editor.addListener("statusChanged", mxUtils.bind(this, function() {
this.setStatusText(this.editor.getStatus());
})), this.setStatusText(this.editor.getStatus()), this.menubar.container.appendChild(this.statusContainer), 
this.container.appendChild(this.menubarContainer), this.container.appendChild(this.toolbarContainer), 
this.container.appendChild(this.sidebarContainer), this.container.appendChild(this.outlineContainer), 
this.container.appendChild(this.diagramContainer), this.container.appendChild(this.footerContainer), 
this.container.appendChild(this.hsplit), this.container.appendChild(this.vsplit), 
this.sidebarFooterContainer && this.container.appendChild(this.sidebarFooterContainer), 
this.addSplitHandler(this.hsplit, !0, 0, mxUtils.bind(this, function(value) {
this.hsplitPosition = value, this.refresh(), this.editor.graph.sizeDidChange(), 
this.editor.outline.update(!1), this.editor.outline.outline.sizeDidChange();
})), this.addSplitHandler(this.vsplit, !1, this.footerHeight, mxUtils.bind(this, function(value) {
this.vsplitPosition = value, this.refresh(), this.editor.outline.update(!1), this.editor.outline.outline.sizeDidChange();
}));
}, EditorUi.prototype.createStatusContainer = function() {
var container = document.createElement("a");
return container.className = "geItem geStatus", container;
}, EditorUi.prototype.setStatusText = function(value) {
this.statusContainer.innerHTML = value;
}, EditorUi.prototype.createToolbar = function(container) {
return new Toolbar(this, container);
}, EditorUi.prototype.createSidebar = function(container) {
return new Sidebar(this, container, this.choices);
}, EditorUi.prototype.createFooter = function() {
return this.createDiv("geFooter");
}, EditorUi.prototype.createDiv = function(classname) {
var elt = document.createElement("div");
return elt.className = classname, elt;
}, EditorUi.prototype.addSplitHandler = function(elt, horizontal, dx, onChange) {
function getValue() {
return parseInt(horizontal ? elt.style.left :elt.style.bottom);
}
function moveHandler(evt) {
if (null != start) {
var pt = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
onChange(Math.max(0, initial + (horizontal ? pt.x - start.x :start.y - pt.y) - dx)), 
mxEvent.consume(evt);
}
}
function dropHandler(evt) {
moveHandler(evt), start = null, initial = null;
}
var start = null, initial = null;
mxEvent.addGestureListeners(elt, function(evt) {
start = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt)), initial = getValue(), 
mxEvent.consume(evt);
}), mxEvent.addListener(document, "mousemove", moveHandler), mxEvent.addListener(document, "touchmove", moveHandler), 
mxEvent.addListener(document, "mouseup", dropHandler), mxEvent.addListener(document, "touchend", dropHandler);
}, EditorUi.prototype.showDialog = function(elt, w, h, modal, closable, onClose) {
this.hideDialog(), this.dialog = new Dialog(this, elt, w, mxClient.IS_VML ? h - 12 :h, modal, closable, onClose);
}, EditorUi.prototype.hideDialog = function() {
null != this.dialog && (this.dialog.close(), this.dialog = null, this.editor.graph.container.focus());
}, EditorUi.prototype.executeLayout = function(layout, animate, ignoreChildCount, exec, post) {
var graph = this.editor.graph, cell = graph.getSelectionCell();
animate = null != this.animate ? this.animate :animate, graph.getModel().beginUpdate();
try {
null != exec ? exec() :layout.execute(graph.getDefaultParent(), cell);
} catch (e) {
throw e;
} finally {
if (animate && navigator.userAgent.indexOf("Camino") < 0) {
var morph = new mxMorphing(graph);
morph.addListener(mxEvent.DONE, mxUtils.bind(this, function() {
graph.getModel().endUpdate(), null != post && post();
})), morph.startAnimation();
} else graph.getModel().endUpdate();
}
}, EditorUi.prototype.createKeyHandler = function() {
function nudge(keyCode) {
if (!graph.isSelectionEmpty()) {
var dx = 0, dy = 0;
37 == keyCode ? dx = -1 :38 == keyCode ? dy = -1 :39 == keyCode ? dx = 1 :40 == keyCode && (dy = 1), 
graph.moveCells(graph.getSelectionCells(), dx, dy), graph.scrollCellToVisible(graph.getSelectionCell());
}
}
var graph = this.editor.graph, keyHandler = new mxKeyHandler(graph);
keyHandler.isControlDown = function(evt) {
return mxEvent.isControlDown(evt) || mxClient.IS_MAC && evt.metaKey;
};
var bindAction = mxUtils.bind(this, function(code, control, key, shift) {
var action = this.actions.get(key);
if (null != action) {
var f = function() {
action.enabled && action.funct();
};
control ? shift ? keyHandler.bindControlShiftKey(code, f) :keyHandler.bindControlKey(code, f) :shift ? keyHandler.bindShiftKey(code, f) :keyHandler.bindKey(code, f);
}
}), ui = this, keyHandleEscape = keyHandler.escape;
return keyHandler.escape = function() {
ui.hideDialog(), keyHandleEscape.apply(this, arguments);
}, keyHandler.enter = function() {}, keyHandler.bindShiftKey(13, function() {
graph.foldCells(!0);
}), keyHandler.bindKey(13, function() {
graph.foldCells(!1);
}), keyHandler.bindKey(33, function() {
graph.exitGroup();
}), keyHandler.bindKey(34, function() {
graph.enterGroup();
}), keyHandler.bindKey(36, function() {
graph.home();
}), keyHandler.bindKey(35, function() {
graph.refresh();
}), keyHandler.bindKey(37, function() {
nudge(37);
}), keyHandler.bindKey(38, function() {
nudge(38);
}), keyHandler.bindKey(39, function() {
nudge(39);
}), keyHandler.bindKey(40, function() {
nudge(40);
}), keyHandler.bindKey(113, function() {
graph.startEditingAtCell();
}), keyHandler.bindKey(8, function() {
graph.foldCells(!0);
}), bindAction(8, !1, "delete"), bindAction(46, !1, "delete"), bindAction(46, !1, "delete"), 
bindAction(82, !0, "tilt"), bindAction(107, !1, "zoomIn"), bindAction(109, !1, "zoomOut"), 
bindAction(65, !0, "selectAll"), bindAction(86, !0, "selectVertices", !0), bindAction(69, !0, "selectEdges", !0), 
bindAction(66, !0, "toBack"), bindAction(70, !0, "toFront"), bindAction(68, !0, "duplicate"), 
bindAction(90, !0, "undo"), bindAction(89, !0, "redo"), bindAction(88, !0, "cut"), 
bindAction(67, !0, "copy"), bindAction(81, !0, "connect"), bindAction(86, !0, "paste"), 
bindAction(71, !0, "group"), bindAction(71, !0, "grid", !0), bindAction(76, !0, "lockUnlock"), 
bindAction(85, !0, "ungroup"), keyHandler;
}, Actions.prototype.init = function() {
var ui = this.editorUi, editor = ui.editor, graph = editor.graph;
this.addAction("new", function() {
window.open(ui.getUrl());
}), this.addAction("open", function() {
window.openNew = !0, window.openKey = "open", ui.openFile();
}), this.addAction("import", function() {
window.openNew = !1, window.openKey = "import", window.openFile = new OpenFile(mxUtils.bind(this, function() {
ui.hideDialog();
})), window.openFile.setConsumer(mxUtils.bind(this, function(xml) {
try {
var doc = mxUtils.parseXml(xml), model = new mxGraphModel(), codec = new mxCodec(doc);
codec.decode(doc.documentElement, model);
var children = model.getChildren(model.getChildAt(model.getRoot(), 0));
editor.graph.setSelectionCells(editor.graph.importCells(children));
} catch (e) {
mxUtils.alert(mxResources.get("invalidOrMissingFile") + ": " + e.message);
}
})), ui.showDialog(new OpenDialog(this).container, 300, 180, !0, !0, function() {
window.openFile = null;
});
}), this.addAction("save", function() {
ui.saveFile(!1);
}, null, null, "Ctrl+S"), this.addAction("saveAs", function() {
ui.saveFile(!0);
}, null, null, "Ctrl+Shift-S"), this.addAction("export", function() {
ui.showDialog(new ExportDialog(ui).container, 300, 200, !0, !0);
}, null, null, "Ctrl+E"), this.put("editFile", new Action(mxResources.get("edit"), mxUtils.bind(this, function() {
this.editorUi.showDialog(new EditFileDialog(ui).container, 620, 420, !0, !0);
}))), this.addAction("pageSetup", function() {
ui.showDialog(new PageSetupDialog(ui).container, 300, 200, !0, !0);
}), this.addAction("print", function() {
ui.showDialog(new PrintDialog(ui).container, 300, 200, !0, !0);
}, null, "sprite-print", "Ctrl+P"), this.addAction("preview", function() {
mxUtils.show(graph, null, 10, 10);
}), this.addAction("undo", function() {
editor.undoManager.undo();
}, null, "sprite-undo", "Ctrl+Z"), this.addAction("redo", function() {
editor.undoManager.redo();
}, null, "sprite-redo", "Ctrl+Y"), this.addAction("cut", function() {
mxClipboard.cut(graph);
}, null, "sprite-cut", "Ctrl+X"), this.addAction("copy", function() {
mxClipboard.copy(graph);
}, null, "sprite-copy", "Ctrl+C"), this.addAction("paste", function() {
mxClipboard.paste(graph);
}, !1, "sprite-paste", "Ctrl+V"), this.addAction("delete", function() {
graph.connectionHandler.isConnecting() ? graph.connectionHandler.reset() :graph.removeCells();
}, null, null, "Delete"), this.addAction("duplicate", function() {
var s = graph.gridSize;
graph.setSelectionCells(graph.moveCells(graph.getSelectionCells(), s, s, !0));
}, null, null, "Ctrl+D"), this.addAction("selectVertices", function() {
graph.selectVertices();
}, null, null, "Ctrl+Shift+V"), this.addAction("selectEdges", function() {
graph.selectEdges();
}, null, null, "Ctrl+Shift+E"), this.addAction("selectAll", function() {
graph.selectAll();
}, null, null, "Ctrl+A"), this.addAction("lockUnlock", function() {
graph.getModel().beginUpdate();
try {
graph.toggleCellStyles(mxConstants.STYLE_RESIZABLE, 1), graph.toggleCellStyles(mxConstants.STYLE_MOVABLE, 1), 
graph.toggleCellStyles(mxConstants.STYLE_ROTATABLE, 1);
} finally {
graph.getModel().endUpdate();
}
}, null, null, "Ctrl+L"), this.addAction("home", function() {
graph.home();
}, null, null, "Home"), this.addAction("exitGroup", function() {
graph.exitGroup();
}, null, null, "Page Up"), this.addAction("enterGroup", function() {
graph.enterGroup();
}, null, null, "Page Down"), this.addAction("expand", function() {
graph.foldCells(!1);
}, null, null, "Enter"), this.addAction("collapse", function() {
graph.foldCells(!0);
}, null, null, "Backspace"), this.addAction("toFront", function() {
graph.orderCells(!1);
}, null, null, "Ctrl+F"), this.addAction("toBack", function() {
graph.orderCells(!0);
}, null, null, "Ctrl+B"), this.addAction("group", function() {
graph.setSelectionCell(graph.groupCells(null, 0));
}, null, null, "Ctrl+G"), this.addAction("ungroup", function() {
graph.setSelectionCells(graph.ungroupCells());
}, null, null, "Ctrl+U"), this.addAction("removeFromGroup", function() {
graph.removeCellsFromParent();
}), this.addAction("editLink", function() {
var cell = graph.getSelectionCell(), link = graph.getLinkForCell(cell);
null == link && (link = ""), link = mxUtils.prompt(mxResources.get("enterValue"), link), 
null != link && graph.setLinkForCell(cell, link);
}), this.addAction("openLink", function() {
var cell = graph.getSelectionCell(), link = graph.getLinkForCell(cell);
null != link && window.open(link);
}), this.addAction("autosize", function() {
var cells = graph.getSelectionCells();
if (null != cells) {
graph.getModel().beginUpdate();
try {
for (var i = 0; i < cells.length; i++) {
var cell = cells[i];
graph.getModel().getChildCount(cell) ? graph.updateGroupBounds([ cell ], 20) :graph.updateCellSize(cell);
}
} finally {
graph.getModel().endUpdate();
}
}
}), this.addAction("wordWrap", function() {
var state = graph.getView().getState(graph.getSelectionCell()), value = "wrap";
null != state && "wrap" == state.style[mxConstants.STYLE_WHITE_SPACE] && (value = null), 
graph.setCellStyles(mxConstants.STYLE_WHITE_SPACE, value);
}), this.addAction("rotation", function() {
var value = "0", state = graph.getView().getState(graph.getSelectionCell());
null != state && (value = state.style[mxConstants.STYLE_ROTATION] || value), value = mxUtils.prompt(mxResources.get("enterValue") + " (" + mxResources.get("rotation") + " 0-360)", value), 
null != value && graph.setCellStyles(mxConstants.STYLE_ROTATION, value);
}), this.addAction("tilt", function() {
var cells = graph.getSelectionCells();
if (null != cells) {
graph.getModel().beginUpdate();
try {
for (var i = 0; i < cells.length; i++) {
var cell = cells[i];
if (graph.getModel().isVertex(cell) && 0 == graph.getModel().getChildCount(cell)) {
var geo = graph.getCellGeometry(cell);
if (null != geo) {
geo = geo.clone(), geo.x += geo.width / 2 - geo.height / 2, geo.y += geo.height / 2 - geo.width / 2;
var tmp = geo.width;
geo.width = geo.height, geo.height = tmp, graph.getModel().setGeometry(cell, geo);
var state = graph.view.getState(cell);
if (null != state) {
var dir = state.style[mxConstants.STYLE_DIRECTION] || "east";
"east" == dir ? dir = "south" :"south" == dir ? dir = "west" :"west" == dir ? dir = "north" :"north" == dir && (dir = "east"), 
graph.setCellStyles(mxConstants.STYLE_DIRECTION, dir, [ cell ]);
}
}
}
}
} finally {
graph.getModel().endUpdate();
}
}
}, null, null, "Ctrl+R"), this.addAction("actualSize", function() {
graph.zoomTo(1);
}), this.addAction("zoomIn", function() {
graph.zoomIn();
}, null, null, "Add"), this.addAction("zoomOut", function() {
graph.zoomOut();
}, null, null, "Subtract"), this.addAction("fitWindow", function() {
graph.fit();
}), this.addAction("fitPage", mxUtils.bind(this, function() {
graph.pageVisible || this.get("pageView").funct();
var fmt = graph.pageFormat, ps = graph.pageScale, cw = graph.container.clientWidth - 20, ch = graph.container.clientHeight - 20, scale = Math.floor(100 * Math.min(cw / fmt.width / ps, ch / fmt.height / ps)) / 100;
graph.zoomTo(scale), graph.container.scrollLeft = Math.round(graph.view.translate.x * scale - Math.max(10, (graph.container.clientWidth - fmt.width * ps * scale) / 2)), 
graph.container.scrollTop = Math.round(graph.view.translate.y * scale - Math.max(10, (graph.container.clientHeight - fmt.height * ps * scale) / 2));
})), this.addAction("fitPageWidth", mxUtils.bind(this, function() {
graph.pageVisible || this.get("pageView").funct();
var fmt = graph.pageFormat, ps = graph.pageScale, cw = graph.container.clientWidth - 20, scale = Math.floor(100 * cw / fmt.width / ps) / 100;
graph.zoomTo(scale), graph.container.scrollLeft = Math.round(graph.view.translate.x * scale - Math.max(10, (graph.container.clientWidth - fmt.width * ps * scale) / 2)), 
graph.container.scrollTop = Math.round(graph.view.translate.y * scale - Math.max(10, (graph.container.clientHeight - fmt.height * ps * scale) / 2));
})), this.put("customZoom", new Action(mxResources.get("custom"), function() {
var value = mxUtils.prompt(mxResources.get("enterValue") + " (%)", parseInt(100 * graph.getView().getScale()));
null != value && value.length > 0 && !isNaN(parseInt(value)) && graph.zoomTo(parseInt(value) / 100);
}));
var action = null;
action = this.addAction("grid", function() {
graph.setGridEnabled(!graph.isGridEnabled()), editor.updateGraphComponents();
}, null, null, "Ctrl+Shift+G"), action.setToggleAction(!0), action.setSelectedCallback(function() {
return graph.isGridEnabled();
}), action = this.addAction("guides", function() {
graph.graphHandler.guidesEnabled = !graph.graphHandler.guidesEnabled;
}), action.setToggleAction(!0), action.setSelectedCallback(function() {
return graph.graphHandler.guidesEnabled;
}), action = this.addAction("tooltips", function() {
graph.tooltipHandler.setEnabled(!graph.tooltipHandler.isEnabled());
}), action.setToggleAction(!0), action.setSelectedCallback(function() {
return graph.tooltipHandler.isEnabled();
}), action = this.addAction("navigation", function() {
graph.foldingEnabled = !graph.foldingEnabled, graph.view.revalidate();
}), action.setToggleAction(!0), action.setSelectedCallback(function() {
return graph.foldingEnabled;
}), action = this.addAction("scrollbars", function() {
if (graph.scrollbars = !graph.scrollbars, editor.updateGraphComponents(), graph.scrollbars) {
var dx = graph.view.translate.x, dy = graph.view.translate.y;
graph.view.translate.x = 0, graph.view.translate.y = 0, graph.sizeDidChange(), graph.container.scrollLeft -= Math.round(dx * graph.view.scale), 
graph.container.scrollTop -= Math.round(dy * graph.view.scale);
} else {
var t = graph.view.translate;
graph.view.setTranslate(t.x - graph.container.scrollLeft / graph.view.scale, t.y - graph.container.scrollTop / graph.view.scale), 
graph.container.scrollLeft = 0, graph.container.scrollTop = 0, graph.sizeDidChange();
}
}, !mxClient.IS_TOUCH), action.setToggleAction(!0), action.setSelectedCallback(function() {
return "auto" == graph.container.style.overflow;
}), action = this.addAction("pageView", mxUtils.bind(this, function() {
graph.pageVisible = !graph.pageVisible, graph.pageBreaksVisible = graph.pageVisible, 
graph.preferPageSize = graph.pageBreaksVisible, graph.view.validate(), graph.sizeDidChange(), 
editor.updateGraphComponents(), editor.outline.update(), mxUtils.hasScrollbars(graph.container) && (graph.pageVisible ? (graph.container.scrollLeft -= 20, 
graph.container.scrollTop -= 20) :(graph.container.scrollLeft += 20, graph.container.scrollTop += 20));
})), action.setToggleAction(!0), action.setSelectedCallback(function() {
return graph.pageVisible;
}), this.put("pageBackgroundColor", new Action(mxResources.get("backgroundColor"), function() {
var apply = function(color) {
graph.background = color, editor.updateGraphComponents();
}, cd = new ColorDialog(ui, graph.background || "none", apply);
ui.showDialog(cd.container, 220, 400, !0, !1), mxClient.IS_TOUCH || cd.colorInput.focus();
})), action = this.addAction("connect", function() {
graph.setConnectable(!graph.connectionHandler.isEnabled());
}, null, null, "Ctrl+Q"), action.setToggleAction(!0), action.setSelectedCallback(function() {
return graph.connectionHandler.isEnabled();
}), action = this.addAction("copyConnect", function() {
graph.connectionHandler.setCreateTarget(!graph.connectionHandler.isCreateTarget());
}), action.setToggleAction(!0), action.setSelectedCallback(function() {
return graph.connectionHandler.isCreateTarget();
}), this.addAction("help", function() {
var ext = "";
mxResources.isLanguageSupported(mxClient.language) && (ext = "_" + mxClient.language), 
window.open(RESOURCES_PATH + "/help" + ext + ".html");
}), this.put("about", new Action(mxResources.get("about") + " Graph Editor", function() {
ui.showDialog(new AboutDialog(ui).container, 320, 280, !0, !0);
}, null, null, "F1"));
var toggleFontStyle = mxUtils.bind(this, function(key, style) {
this.addAction(key, function() {
graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, style);
});
});
toggleFontStyle("bold", mxConstants.FONT_BOLD), toggleFontStyle("italic", mxConstants.FONT_ITALIC), 
toggleFontStyle("underline", mxConstants.FONT_UNDERLINE), this.addAction("fontColor", function() {
ui.menus.pickColor(mxConstants.STYLE_FONTCOLOR);
}), this.addAction("strokeColor", function() {
ui.menus.pickColor(mxConstants.STYLE_STROKECOLOR);
}), this.addAction("fillColor", function() {
ui.menus.pickColor(mxConstants.STYLE_FILLCOLOR);
}), this.addAction("gradientColor", function() {
ui.menus.pickColor(mxConstants.STYLE_GRADIENTCOLOR);
}), this.addAction("backgroundColor", function() {
ui.menus.pickColor(mxConstants.STYLE_LABEL_BACKGROUNDCOLOR);
}), this.addAction("borderColor", function() {
ui.menus.pickColor(mxConstants.STYLE_LABEL_BORDERCOLOR);
}), this.addAction("shadow", function() {
graph.toggleCellStyles(mxConstants.STYLE_SHADOW);
}), this.addAction("dashed", function() {
graph.toggleCellStyles(mxConstants.STYLE_DASHED);
}), this.addAction("rounded", function() {
graph.toggleCellStyles(mxConstants.STYLE_ROUNDED);
}), this.addAction("curved", function() {
graph.toggleCellStyles(mxConstants.STYLE_CURVED);
}), this.addAction("style", function() {
var cells = graph.getSelectionCells();
if (null != cells && cells.length > 0) {
var model = graph.getModel(), style = mxUtils.prompt(mxResources.get("enterValue") + " (" + mxResources.get("style") + ")", model.getStyle(cells[0]) || "");
null != style && graph.setCellStyle(style, cells);
}
}), this.addAction("setAsDefaultEdge", function() {
graph.setDefaultEdge(graph.getSelectionCell());
}), this.addAction("addWaypoint", function() {
var cell = graph.getSelectionCell();
if (null != cell && graph.getModel().isEdge(cell)) {
var handler = editor.graph.selectionCellsHandler.getHandler(cell);
if (handler instanceof mxEdgeHandler) {
var t = graph.view.translate, s = graph.view.scale, dx = t.x, dy = t.y, parent = graph.getModel().getParent(cell), pgeo = graph.getCellGeometry(parent);
graph.getModel().isVertex(parent) && null != pgeo && (dx += pgeo.x, dy += pgeo.y), 
handler.addPointAt(handler.state, graph.panningHandler.triggerX / s - dx, graph.panningHandler.triggerY / s - dy);
}
}
}), this.addAction("removeWaypoint", function() {
var rmWaypointAction = ui.actions.get("removeWaypoint");
null != rmWaypointAction.handler && rmWaypointAction.handler.removePoint(rmWaypointAction.handler.state, rmWaypointAction.index);
}), this.addAction("image", function() {
function updateImage(value, w, h) {
var select = null, cells = graph.getSelectionCells();
graph.getModel().beginUpdate();
try {
if (0 == cells.length) {
var gs = graph.getGridSize();
cells = [ graph.insertVertex(graph.getDefaultParent(), null, "", gs, gs, w, h) ], 
select = cells;
}
if (graph.setCellStyles(mxConstants.STYLE_IMAGE, value, cells), graph.setCellStyles(mxConstants.STYLE_SHAPE, "image", cells), 
1 == graph.getSelectionCount() && null != w && null != h) {
var cell = cells[0], geo = graph.getModel().getGeometry(cell);
null != geo && (geo = geo.clone(), geo.width = w, geo.height = h, graph.getModel().setGeometry(cell, geo));
}
} finally {
graph.getModel().endUpdate();
}
null != select && (graph.setSelectionCells(select), graph.scrollCellToVisible(select[0]));
}
var value = "", state = graph.getView().getState(graph.getSelectionCell());
if (null != state && (value = state.style[mxConstants.STYLE_IMAGE] || value), value = mxUtils.prompt(mxResources.get("enterValue") + " (" + mxResources.get("url") + ")", value), 
null != value && value.length > 0) {
var img = new Image();
img.onload = function() {
updateImage(value, img.width, img.height);
}, img.onerror = function() {
mxUtils.alert(mxResources.get("fileNotFound"));
}, img.src = value;
}
});
}, Actions.prototype.addAction = function(key, funct, enabled, iconCls, shortcut) {
return this.put(key, new Action(mxResources.get(key), funct, enabled, iconCls, shortcut));
}, Actions.prototype.put = function(name, action) {
return this.actions[name] = action, action;
}, Actions.prototype.get = function(name) {
return this.actions[name];
}, mxUtils.extend(Action, mxEventSource), Action.prototype.setEnabled = function(value) {
this.enabled != value && (this.enabled = value, this.fireEvent(new mxEventObject("stateChanged")));
}, Action.prototype.setToggleAction = function(value) {
this.toggleAction = value;
}, Action.prototype.setSelectedCallback = function(funct) {
this.selectedCallback = funct;
}, Action.prototype.isSelected = function() {
return this.selectedCallback();
}, Dialog.prototype.close = function() {
null != this.onDialogClose && (this.onDialogClose(), this.onDialogClose = null), 
null != this.dialogImg && (this.dialogImg.parentNode.removeChild(this.dialogImg), 
this.dialogImg = null), this.container.parentNode.removeChild(this.container), this.bg.parentNode.removeChild(this.bg);
}, ColorDialog.prototype.createApplyFunction = function() {
return mxUtils.bind(this, function(color) {
this.editorUi.editor.graph.setCellStyles(this.currentColorKey, "none" == color ? "none" :color);
});
};

var mxGraphFiles = {
save:function(editorUi) {
var graph = editorUi.editor.graph, bounds = graph.getGraphBounds(), imgExport = (Math.ceil(bounds.width / scale), 
Math.ceil(bounds.height / scale), new mxImageExport()), xml = mxUtils.getXml(editorUi.editor.getGraphXml()), b = 1, scale = 1, bounds = graph.getGraphBounds(), vs = graph.view.scale, svgDoc = mxUtils.createXmlDocument(), root = null != svgDoc.createElementNS ? svgDoc.createElementNS(mxConstants.NS_SVG, "svg") :svgDoc.createElement("svg");
null != graph.background && (null != root.style ? root.style.backgroundColor = graph.background :root.setAttribute("style", "background-color:" + graph.background)), 
null == svgDoc.createElementNS && root.setAttribute("xmlns", mxConstants.NS_SVG), 
root.setAttribute("width", Math.ceil(bounds.width * scale / vs + 2 * b) + "px"), 
root.setAttribute("height", Math.ceil(bounds.height * scale / vs + 2 * b) + "px"), 
root.setAttribute("xmlns:xlink", mxConstants.NS_XLINK), root.setAttribute("version", "1.1");
var group = null != svgDoc.createElementNS ? svgDoc.createElementNS(mxConstants.NS_SVG, "g") :svgDoc.createElement("g");
group.setAttribute("transform", "translate(0.5,0.5)"), root.appendChild(group), 
svgDoc.appendChild(root);
var svgCanvas = new mxSvgCanvas2D(group);
svgCanvas.translate(Math.floor((b / scale - bounds.x) / vs), Math.floor((b / scale - bounds.y) / vs)), 
svgCanvas.scale(scale / vs), imgExport.drawState(graph.getView().getState(graph.model.root), svgCanvas);
var xml_svg = mxUtils.getXml(root);
if (xml_svg.length < MAX_REQUEST_SIZE) {
$("#draw_xml").val(xml), $("#draw_svg").val(xml_svg);
var result = {
xml:xml,
svg:xml_svg
};
return result;
}
},
load_xml:function(editorUi, xml) {
var doc = mxUtils.parseXml(xml);
editorUi.editor.setGraphXml(doc.documentElement);
}
};

/**
 * $Id: Graph.js,v 1.20 2013/05/04 20:16:05 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
Graph = function(container, model, renderHint, stylesheet) {
mxGraph.call(this, container, model, renderHint, stylesheet), this.setConnectable(!0), 
this.setDropEnabled(!0), this.setPanning(!0), this.setTooltips(!mxClient.IS_TOUCH), 
this.setAllowLoops(!0), this.allowAutoPanning = !0, this.resetEdgesOnConnect = !1, 
this.constrainChildren = !1, this.connectionHandler.setCreateTarget(!0), this.connectionHandler.isValidSource = function() {
return mxConnectionHandler.prototype.isValidSource.apply(this, arguments) && "2" != urlParams.connect && null != urlParams.connect;
}, this.alternateEdgeStyle = "vertical", null == stylesheet && this.loadStylesheet();
var rubberband = new mxRubberband(this);
this.getRubberband = function() {
return rubberband;
}, this.panningHandler.addListener(mxEvent.PAN_START, mxUtils.bind(this, function() {
this.container.style.cursor = "pointer";
})), this.panningHandler.addListener(mxEvent.PAN_END, mxUtils.bind(this, function() {
this.container.style.cursor = "default";
})), this.isHtmlLabel = function(cell) {
var state = this.view.getState(cell), style = null != state ? state.style :this.getCellStyle(cell);
return "1" == style.html || "wrap" == style.whiteSpace;
}, this.cellRenderer.getLabelValue = function(state) {
var result = mxCellRenderer.prototype.getLabelValue.apply(this, arguments);
return "wrap" == state.style.whiteSpace && 1 != state.style.html && (result = mxUtils.htmlEntities(result, !1)), 
result;
}, this.isCellLocked = function() {
return !1;
}, this.connectionHandler.tapAndHoldTolerance = 16;
var connectionHandlerTapAndHold = this.connectionHandler.tapAndHold;
this.connectionHandler.tapAndHold = function(me, state) {
null == state ? this.graph.panningHandler.active || (rubberband.start(me.getGraphX(), me.getGraphY()), 
this.graph.panningHandler.panningTrigger = !1) :tapAndHoldStartsConnection ? connectionHandlerTapAndHold.apply(this, arguments) :this.graph.isCellSelected(state.cell) && this.graph.getSelectionCount() > 1 && this.graph.removeSelectionCell(state.cell);
}, this.connectionHandler.selectCells = function(edge, target) {
this.graph.setSelectionCell(target || edge);
}, this.connectionHandler.constraintHandler.isStateIgnored = function(state, source) {
return source && state.view.graph.isCellSelected(state.cell);
}, this.selectionModel.addListener(mxEvent.CHANGE, mxUtils.bind(this, function() {
var ch = this.connectionHandler.constraintHandler;
null != ch.currentFocus && ch.isStateIgnored(ch.currentFocus, !0) && (ch.currentFocus = null, 
ch.constraints = null, ch.destroyIcons()), ch.destroyFocusHighlight();
})), touchStyle && this.initTouch();
}, mxUtils.extend(Graph, mxGraph), Graph.prototype.minFitScale = null, Graph.prototype.maxFitScale = null, 
Graph.prototype.loadStylesheet = function() {
var node = mxUtils.load(STYLE_PATH + "/default.xml").getDocumentElement(), dec = new mxCodec(node.ownerDocument);
dec.decode(node, this.getStylesheet());
}, Graph.prototype.flipEdge = function(edge) {
if (null != edge) {
var state = this.view.getState(edge), style = null != state ? state.style :this.getCellStyle(edge);
if (null != style) {
var elbow = mxUtils.getValue(style, mxConstants.STYLE_ELBOW, mxConstants.ELBOW_HORIZONTAL), value = elbow == mxConstants.ELBOW_HORIZONTAL ? mxConstants.ELBOW_VERTICAL :mxConstants.ELBOW_HORIZONTAL;
this.setCellStyles(mxConstants.STYLE_ELBOW, value, [ edge ]);
}
}
}, Graph.prototype.setDefaultEdge = function(cell) {
if (null != cell && this.getModel().isEdge(cell)) {
var proto = this.getModel().cloneCell(cell);
null != proto.geometry && (proto.geometry.points = null);
var style = proto.getStyle();
style = mxUtils.setStyle(style, mxConstants.STYLE_ENTRY_X, null), style = mxUtils.setStyle(style, mxConstants.STYLE_ENTRY_Y, null), 
style = mxUtils.setStyle(style, mxConstants.STYLE_EXIT_X, null), style = mxUtils.setStyle(style, mxConstants.STYLE_EXIT_Y, null), 
proto.setStyle(style), this.connectionHandler.createEdgeState = function() {
return this.graph.view.createState(proto);
}, this.connectionHandler.factoryMethod = function() {
return this.graph.cloneCells([ proto ])[0];
};
}
}, Graph.prototype.isCellFoldable = function(cell) {
return this.foldingEnabled && this.isSwimlane(cell);
}, Graph.prototype.isValidRoot = function(cell) {
return this.isSwimlane(cell);
}, Graph.prototype.createGroupCell = function() {
var group = mxGraph.prototype.createGroupCell.apply(this, arguments);
return group.setStyle("group"), group;
}, Graph.prototype.getTooltipForCell = function(cell) {
var tip = "";
if (this.getModel().isVertex(cell)) {
var geo = this.getCellGeometry(cell), f2 = function(x) {
return Math.round(100 * parseFloat(x)) / 100;
};
null != geo && (null == tip ? tip = "" :tip.length > 0 && (tip += "\n"), tip += "X: " + f2(geo.x) + "\nY: " + f2(geo.y) + "\nW: " + f2(geo.width) + "\nH: " + f2(geo.height));
} else this.getModel().isEdge(cell) && (tip = mxGraph.prototype.getTooltipForCell.apply(this, arguments));
return tip;
}, Graph.prototype.convertValueToString = function(cell) {
return null != cell.value && "object" == typeof cell.value ? cell.value.getAttribute("label") :mxGraph.prototype.convertValueToString.apply(this, arguments);
}, Graph.prototype.cellLabelChanged = function(cell, value) {
if (null != cell.value && "object" == typeof cell.value) {
var tmp = cell.value.cloneNode(!0);
tmp.setAttribute("label", value), value = tmp;
}
mxGraph.prototype.cellLabelChanged.apply(this, arguments);
}, Graph.prototype.setLinkForCell = function(cell, link) {
var value = null;
if (null != cell.value && "object" == typeof cell.value) value = cell.value.cloneNode(!0); else {
var doc = mxUtils.createXmlDocument();
value = doc.createElement("UserObject"), value.setAttribute("label", cell.value);
}
null != link && link.length > 0 ? value.setAttribute("link", link) :value.removeAttribute("link"), 
this.model.setValue(cell, value);
}, Graph.prototype.getLinkForCell = function(cell) {
return null != cell.value && "object" == typeof cell.value ? cell.value.getAttribute("link") :null;
}, Graph.prototype.initTouch = function() {
this.connectionHandler.marker.isEnabled = function() {
return null != this.graph.connectionHandler.first;
}, this.addListener(mxEvent.START_EDITING, function() {
this.panningHandler.hideMenu();
});
var showMenu = !1, menuCell = null;
this.updateMouseEvent = function(me) {
if (mxGraph.prototype.updateMouseEvent.apply(this, arguments), null == me.getState()) {
var cell = this.getCellAt(me.graphX, me.graphY);
this.getModel().isEdge(cell) && (me.state = this.view.getState(cell), null != me.state && null != me.state.shape && (this.container.style.cursor = me.state.shape.node.style.cursor));
}
null == me.getState() && (this.container.style.cursor = "default");
}, this.fireMouseEvent = function(evtName, me) {
if (evtName == mxEvent.MOUSE_DOWN) this.panningHandler.isMenuShowing() ? (showMenu = !1, 
menuCell = null) :(menuCell = me.getCell(), showMenu = null != menuCell ? this.isCellSelected(menuCell) :this.isSelectionEmpty()); else if (evtName == mxEvent.MOUSE_UP) {
if (showMenu && !this.isEditing()) {
if (!this.panningHandler.isMenuShowing()) {
var x = mxEvent.getClientX(me.getEvent()), y = mxEvent.getClientY(me.getEvent());
this.panningHandler.popup(x + 16, y, menuCell, me.getEvent());
}
return showMenu = !1, menuCell = null, me.consume(), void 0;
}
showMenu = !1, menuCell = null;
}
mxGraph.prototype.fireMouseEvent.apply(this, arguments), evtName == mxEvent.MOUSE_MOVE && me.isConsumed() && (showMenu = !1, 
menuCell = null);
};
}, function() {
if (mxVertexHandler.prototype.rotationEnabled = !0, mxVertexHandler.prototype.livePreview = !mxClient.IS_TOUCH, 
mxEdgeHandler.prototype.livePreview = !mxClient.IS_TOUCH, mxText.prototype.baseSpacingTop = 5, 
mxText.prototype.baseSpacingBottom = 1, touchStyle) {
mxConstants.HANDLE_SIZE = 16, mxConstants.LABEL_HANDLE_SIZE = 7, mxClient.IS_TOUCH && (mxVertexHandler.prototype.tolerance = 4, 
mxEdgeHandler.prototype.tolerance = 6, Graph.prototype.tolerance = 14, Graph.prototype.gridSize = 20, 
mxPanningHandler.prototype.selectOnPopup = !1, mxPanningHandler.prototype.useLeftButtonForPanning = !0, 
mxPanningHandler.prototype.isPanningTrigger = function(me) {
var evt = me.getEvent();
return this.useLeftButtonForPanning && (this.ignoreCell || null == me.getState()) || mxEvent.isControlDown(evt) && mxEvent.isShiftDown(evt) || this.usePopupTrigger && mxEvent.isPopupTrigger(evt);
});
var graphHandlerMouseDown = mxGraphHandler.prototype.mouseDown;
mxGraphHandler.prototype.mouseDown = function(sender, me) {
graphHandlerMouseDown.apply(this, arguments), this.graph.isCellSelected(me.getCell()) && this.graph.getSelectionCount() > 1 && (this.delayedSelection = !1);
}, Graph.prototype.createHandlers = function() {
this.tooltipHandler = new mxTooltipHandler(this), this.tooltipHandler.setEnabled(!1), 
this.selectionCellsHandler = new mxSelectionCellsHandler(this), this.panningHandler = new mxPanningHandler(this), 
this.panningHandler.panningEnabled = !1, this.connectionHandler = new mxConnectionHandler(this), 
this.connectionHandler.setEnabled(!1), this.graphHandler = new mxGraphHandler(this);
};
var graphDblClick = mxGraph.prototype.dblClick;
Graph.prototype.dblClick = function(evt, cell) {
if (null == cell) {
var pt = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
cell = this.getCellAt(pt.x, pt.y);
}
graphDblClick.call(this, evt, cell);
};
var touchHandle = new mxImage(IMAGE_PATH + "/touch-handle.png", 16, 16);
mxVertexHandler.prototype.handleImage = touchHandle, mxEdgeHandler.prototype.handleImage = touchHandle, 
mxOutline.prototype.sizerImage = touchHandle, new Image().src = touchHandle.src;
var connectorSrc = IMAGE_PATH + "/touch-connector.png", vertexHandlerInit = mxVertexHandler.prototype.init;
mxVertexHandler.prototype.init = function() {
vertexHandlerInit.apply(this, arguments), showConnectorImg && this.graph.connectionHandler.isEnabled() && this.graph.isCellConnectable(this.state.cell) && !this.graph.isValidRoot(this.state.cell) && 1 == this.graph.getSelectionCount() && (this.connectorImg = mxUtils.createImage(connectorSrc), 
this.connectorImg.style.cursor = "pointer", this.connectorImg.style.width = "29px", 
this.connectorImg.style.height = "29px", this.connectorImg.style.position = "absolute", 
mxClient.IS_TOUCH || (this.connectorImg.setAttribute("title", mxResources.get("connect")), 
mxEvent.redirectMouseEvents(this.connectorImg, this.graph, this.state)), this.connectorImg.style.padding = "2px", 
mxEvent.addGestureListeners(this.connectorImg, mxUtils.bind(this, function(evt) {
this.graph.panningHandler.hideMenu();
var pt = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
this.graph.connectionHandler.start(this.state, pt.x, pt.y), this.graph.isMouseDown = !0, 
mxEvent.consume(evt);
})), this.graph.container.appendChild(this.connectorImg)), this.redrawTools();
};
var vertexHandlerRedrawHandles = mxVertexHandler.prototype.redrawHandles;
mxVertexHandler.prototype.redrawHandles = function() {
vertexHandlerRedrawHandles.apply(this), this.redrawTools();
}, mxVertexHandler.prototype.redrawTools = function() {
if (null != this.state && null != this.connectorImg) {
var pt = new mxPoint(), s = this.state;
mxVertexHandler.prototype.singleSizer ? (pt.x = s.x + s.width - this.connectorImg.offsetWidth / 2, 
pt.y = s.y - this.connectorImg.offsetHeight / 2) :(pt.x = s.x + s.width + mxConstants.HANDLE_SIZE / 2 + 4 + this.connectorImg.offsetWidth / 2, 
pt.y = s.y + s.height / 2);
var alpha = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION, 0));
if (0 != alpha) {
var cos = Math.cos(alpha), sin = Math.sin(alpha), ct = new mxPoint(s.getCenterX(), s.getCenterY());
pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
}
this.connectorImg.style.left = pt.x - this.connectorImg.offsetWidth / 2 + "px", 
this.connectorImg.style.top = pt.y - this.connectorImg.offsetHeight / 2 + "px";
}
};
var vertexHandlerDestroy = mxVertexHandler.prototype.destroy;
mxVertexHandler.prototype.destroy = function() {
vertexHandlerDestroy.apply(this, arguments), null != this.connectorImg && (this.connectorImg.parentNode.removeChild(this.connectorImg), 
this.connectorImg = null);
}, new Image().src = connectorSrc;
} else {
var img = new mxImage(IMAGE_PATH + "/connector.png", 15, 15);
if (mxConnectionHandler.prototype.connectImage = img, new Image().src = img.src, 
null == urlParams.connect || "2" == urlParams.connect) {
var img = new mxImage(IMAGE_PATH + "/connector.png", 15, 15), vertexHandlerInit = mxVertexHandler.prototype.init;
mxVertexHandler.prototype.init = function() {
this.singleSizer = this.state.width < 30 && this.state.height < 30, vertexHandlerInit.apply(this, arguments), 
showConnectorImg && this.graph.connectionHandler.isEnabled() && this.graph.isCellConnectable(this.state.cell) && !this.graph.isValidRoot(this.state.cell) && 1 == this.graph.getSelectionCount() && (mxClient.IS_IE && !mxClient.IS_SVG ? (this.connectorImg = document.createElement("div"), 
this.connectorImg.style.backgroundImage = "url(" + img.src + ")", this.connectorImg.style.backgroundPosition = "center", 
this.connectorImg.style.backgroundRepeat = "no-repeat", this.connectorImg.style.width = img.width + 4 + "px", 
this.connectorImg.style.height = img.height + 4 + "px", this.connectorImg.style.display = mxClient.IS_QUIRKS ? "inline" :"inline-block") :(this.connectorImg = mxUtils.createImage(img.src), 
this.connectorImg.style.width = img.width + "px", this.connectorImg.style.height = img.height + "px"), 
this.connectorImg.style.cursor = "pointer", this.connectorImg.style.position = "absolute", 
this.connectorImg.setAttribute("title", mxResources.get("connect")), mxEvent.redirectMouseEvents(this.connectorImg, this.graph, this.state), 
this.connectorImg.style.padding = "2px", mxEvent.addListener(this.connectorImg, "mousedown", mxUtils.bind(this, function(evt) {
this.graph.panningHandler.hideMenu();
var pt = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
this.graph.connectionHandler.start(this.state, pt.x, pt.y), this.graph.isMouseDown = !0, 
mxEvent.consume(evt);
})), this.graph.container.appendChild(this.connectorImg)), this.redrawTools();
};
var vertexHandlerRedrawHandles = mxVertexHandler.prototype.redrawHandles;
mxVertexHandler.prototype.redrawHandles = function() {
vertexHandlerRedrawHandles.apply(this), this.redrawTools();
}, mxVertexHandler.prototype.redrawTools = function() {
if (null != this.state && null != this.connectorImg) {
var pt = new mxPoint(), s = this.state;
mxVertexHandler.prototype.singleSizer ? (pt.x = s.x + s.width - this.connectorImg.offsetWidth / 2, 
pt.y = s.y) :(pt.x = s.x + s.width + mxConstants.HANDLE_SIZE / 2 + 2 + this.connectorImg.offsetWidth / 2, 
pt.y = s.y + s.height / 2);
var alpha = mxUtils.toRadians(mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION, 0));
if (0 != alpha) {
var cos = Math.cos(alpha), sin = Math.sin(alpha), ct = new mxPoint(s.getCenterX(), s.getCenterY());
pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
}
this.connectorImg.style.left = pt.x - this.connectorImg.offsetWidth / 2 + "px", 
this.connectorImg.style.top = pt.y - this.connectorImg.offsetHeight / 2 + "px";
}
};
var vertexHandlerDestroy = mxVertexHandler.prototype.destroy;
mxVertexHandler.prototype.destroy = function() {
vertexHandlerDestroy.apply(this, arguments), null != this.connectorImg && (this.connectorImg.parentNode.removeChild(this.connectorImg), 
this.connectorImg = null);
};
}
}
}(), /**
 * $Id: Menus.js,v 1.16 2013/05/07 09:48:56 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
Menus = function(editorUi) {
this.editorUi = editorUi, this.menus = new Object(), this.init(), new Image().src = IMAGE_PATH + "/checkmark.gif";
}, Menus.prototype.init = function() {
var graph = this.editorUi.editor.graph;
this.put("fontFamily", new Menu(mxUtils.bind(this, function(menu, parent) {
for (var fonts = [ "Helvetica", "Verdana", "Times New Roman", "Garamond", "Comic Sans MS", "Courier New", "Georgia", "Lucida Console", "Tahoma" ], i = 0; i < fonts.length; i++) {
var tr = this.styleChange(menu, fonts[i], [ mxConstants.STYLE_FONTFAMILY ], [ fonts[i] ], null, parent);
tr.firstChild.nextSibling.style.fontFamily = fonts[i];
}
menu.addSeparator(parent), this.promptChange(menu, mxResources.get("custom"), "", mxConstants.DEFAULT_FONTFAMILY, mxConstants.STYLE_FONTFAMILY, parent);
}))), this.put("fontSize", new Menu(mxUtils.bind(this, function(menu, parent) {
for (var sizes = [ 6, 8, 9, 10, 11, 12, 14, 18, 24, 36, 48, 72 ], i = 0; i < sizes.length; i++) this.styleChange(menu, sizes[i], [ mxConstants.STYLE_FONTSIZE ], [ sizes[i] ], null, parent);
menu.addSeparator(parent), this.promptChange(menu, mxResources.get("custom"), "(pt)", "12", mxConstants.STYLE_FONTSIZE, parent);
}))), this.put("linewidth", new Menu(mxUtils.bind(this, function(menu, parent) {
for (var sizes = [ 1, 2, 3, 4, 8, 12, 16, 24 ], i = 0; i < sizes.length; i++) this.styleChange(menu, sizes[i] + "px", [ mxConstants.STYLE_STROKEWIDTH ], [ sizes[i] ], null, parent);
menu.addSeparator(parent), this.promptChange(menu, mxResources.get("custom"), "(px)", "1", mxConstants.STYLE_STROKEWIDTH, parent);
}))), this.put("line", new Menu(mxUtils.bind(this, function(menu, parent) {
this.styleChange(menu, mxResources.get("straight"), [ mxConstants.STYLE_EDGE ], [ null ], null, parent), 
this.styleChange(menu, mxResources.get("entityRelation"), [ mxConstants.STYLE_EDGE ], [ "entityRelationEdgeStyle" ], null, parent), 
menu.addSeparator(parent), this.styleChange(menu, mxResources.get("horizontal"), [ mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW ], [ "elbowEdgeStyle", "horizontal" ], null, parent), 
this.styleChange(menu, mxResources.get("vertical"), [ mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW ], [ "elbowEdgeStyle", "vertical" ], null, parent), 
menu.addSeparator(parent), this.styleChange(menu, mxResources.get("manual"), [ mxConstants.STYLE_EDGE ], [ "segmentEdgeStyle" ], null, parent), 
this.styleChange(menu, mxResources.get("automatic"), [ mxConstants.STYLE_EDGE ], [ "orthogonalEdgeStyle" ], null, parent);
}))), this.put("lineend", new Menu(mxUtils.bind(this, function(menu, parent) {
this.styleChange(menu, mxResources.get("classic"), [ mxConstants.STYLE_ENDARROW ], [ mxConstants.ARROW_CLASSIC ], null, parent), 
this.styleChange(menu, mxResources.get("openArrow"), [ mxConstants.STYLE_ENDARROW ], [ mxConstants.ARROW_OPEN ], null, parent), 
this.styleChange(menu, mxResources.get("block"), [ mxConstants.STYLE_ENDARROW ], [ mxConstants.ARROW_BLOCK ], null, parent), 
menu.addSeparator(parent), this.styleChange(menu, mxResources.get("oval"), [ mxConstants.STYLE_ENDARROW ], [ mxConstants.ARROW_OVAL ], null, parent), 
this.styleChange(menu, mxResources.get("diamond"), [ mxConstants.STYLE_ENDARROW ], [ mxConstants.ARROW_DIAMOND ], null, parent), 
this.styleChange(menu, mxResources.get("diamondThin"), [ mxConstants.STYLE_ENDARROW ], [ mxConstants.ARROW_DIAMOND_THIN ], null, parent), 
menu.addSeparator(parent), this.styleChange(menu, mxResources.get("none"), [ mxConstants.STYLE_ENDARROW ], [ mxConstants.NONE ], null, parent), 
menu.addSeparator(parent), menu.addItem(mxResources.get("transparent"), null, function() {
graph.toggleCellStyles("endFill", !0);
}, parent, null, !0), menu.addSeparator(parent), this.promptChange(menu, mxResources.get("size"), "(px)", mxConstants.DEFAULT_MARKERSIZE, mxConstants.STYLE_ENDSIZE, parent);
}))), this.put("linestart", new Menu(mxUtils.bind(this, function(menu, parent) {
this.styleChange(menu, mxResources.get("classic"), [ mxConstants.STYLE_STARTARROW ], [ mxConstants.ARROW_CLASSIC ], null, parent), 
this.styleChange(menu, mxResources.get("openArrow"), [ mxConstants.STYLE_STARTARROW ], [ mxConstants.ARROW_OPEN ], null, parent), 
this.styleChange(menu, mxResources.get("block"), [ mxConstants.STYLE_STARTARROW ], [ mxConstants.ARROW_BLOCK ], null, parent), 
menu.addSeparator(parent), this.styleChange(menu, mxResources.get("oval"), [ mxConstants.STYLE_STARTARROW ], [ mxConstants.ARROW_OVAL ], null, parent), 
this.styleChange(menu, mxResources.get("diamond"), [ mxConstants.STYLE_STARTARROW ], [ mxConstants.ARROW_DIAMOND ], null, parent), 
this.styleChange(menu, mxResources.get("diamondThin"), [ mxConstants.STYLE_STARTARROW ], [ mxConstants.ARROW_DIAMOND_THIN ], null, parent), 
menu.addSeparator(parent), this.styleChange(menu, mxResources.get("none"), [ mxConstants.STYLE_STARTARROW ], [ mxConstants.NONE ], null, parent), 
menu.addSeparator(parent), menu.addItem(mxResources.get("transparent"), null, function() {
graph.toggleCellStyles("startFill", !0);
}, parent, null, !0), menu.addSeparator(parent), this.promptChange(menu, mxResources.get("size"), "(px)", mxConstants.DEFAULT_MARKERSIZE, mxConstants.STYLE_STARTSIZE, parent);
}))), this.put("spacing", new Menu(mxUtils.bind(this, function(menu, parent) {
var vertexSelected = this.editorUi.actions.get("shadow").enabled, edgeSelected = this.get("line").enabled;
(vertexSelected || menu.showDisabled) && (this.promptChange(menu, mxResources.get("top"), "(px)", "0", mxConstants.STYLE_SPACING_TOP, parent, vertexSelected), 
this.promptChange(menu, mxResources.get("right"), "(px)", "0", mxConstants.STYLE_SPACING_RIGHT, parent, vertexSelected), 
this.promptChange(menu, mxResources.get("bottom"), "(px)", "0", mxConstants.STYLE_SPACING_BOTTOM, parent, vertexSelected), 
this.promptChange(menu, mxResources.get("left"), "(px)", "0", mxConstants.STYLE_SPACING_LEFT, parent, vertexSelected), 
menu.addSeparator(parent), this.promptChange(menu, mxResources.get("global"), "(px)", "0", mxConstants.STYLE_SPACING, parent, vertexSelected), 
this.promptChange(menu, mxResources.get("perimeter"), "(px)", "0", mxConstants.STYLE_PERIMETER_SPACING, parent, vertexSelected)), 
(edgeSelected || menu.showDisabled) && (menu.addSeparator(parent), this.promptChange(menu, mxResources.get("sourceSpacing"), "(px)", "0", mxConstants.STYLE_SOURCE_PERIMETER_SPACING, parent, edgeSelected), 
this.promptChange(menu, mxResources.get("targetSpacing"), "(px)", "0", mxConstants.STYLE_TARGET_PERIMETER_SPACING, parent, edgeSelected));
}))), this.put("format", new Menu(mxUtils.bind(this, function(menu, parent) {
this.addMenuItems(menu, [ "fillColor" ], parent), this.addSubmenu("gradient", menu, parent), 
this.addMenuItems(menu, [ "-", "shadow" ], parent), this.promptChange(menu, mxResources.get("opacity"), "(%)", "100", mxConstants.STYLE_OPACITY, parent, this.get("format").enabled), 
this.addMenuItems(menu, [ "-", "curved", "rounded", "dashed", "-", "strokeColor" ], parent), 
this.addSubmenu("linewidth", menu, parent), this.addMenuItems(menu, [ "-" ], parent), 
this.addSubmenu("line", menu, parent), this.addMenuItems(menu, [ "-" ], parent), 
this.addSubmenu("linestart", menu, parent), this.addSubmenu("lineend", menu, parent), 
menu.addSeparator(parent), this.addMenuItem(menu, "style", parent);
}))), this.put("gradient", new Menu(mxUtils.bind(this, function(menu, parent) {
this.addMenuItems(menu, [ "gradientColor", "-" ], parent), this.styleChange(menu, mxResources.get("north"), [ mxConstants.STYLE_GRADIENT_DIRECTION ], [ mxConstants.DIRECTION_NORTH ], null, parent), 
this.styleChange(menu, mxResources.get("east"), [ mxConstants.STYLE_GRADIENT_DIRECTION ], [ mxConstants.DIRECTION_EAST ], null, parent), 
this.styleChange(menu, mxResources.get("south"), [ mxConstants.STYLE_GRADIENT_DIRECTION ], [ mxConstants.DIRECTION_SOUTH ], null, parent), 
this.styleChange(menu, mxResources.get("west"), [ mxConstants.STYLE_GRADIENT_DIRECTION ], [ mxConstants.DIRECTION_WEST ], null, parent);
}))), this.put("text", new Menu(mxUtils.bind(this, function(menu, parent) {
var enabled = this.get("text").enabled;
menu.addSeparator(parent), this.addMenuItem(menu, "fontColor", parent), this.addMenuItems(menu, [ "backgroundColor", "borderColor", "-" ], parent), 
this.addSubmenu("fontFamily", menu, parent), this.addSubmenu("fontSize", menu, parent), 
this.addMenuItems(menu, [ "-", "bold", "italic", "underline", "-" ], parent), this.addSubmenu("alignment", menu, parent), 
this.addMenuItem(menu, "wordWrap", parent), menu.addSeparator(parent), this.promptChange(menu, mxResources.get("textOpacity"), "(%)", "100", mxConstants.STYLE_TEXT_OPACITY, parent, enabled), 
menu.addItem(mxResources.get("hide"), null, function() {
graph.toggleCellStyles(mxConstants.STYLE_NOLABEL, !1);
}, parent, null, enabled);
}))), this.put("alignment", new Menu(mxUtils.bind(this, function(menu, parent) {
this.styleChange(menu, mxResources.get("leftAlign"), [ mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_LEFT ], null, parent), 
this.styleChange(menu, mxResources.get("center"), [ mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_CENTER ], null, parent), 
this.styleChange(menu, mxResources.get("rightAlign"), [ mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_RIGHT ], null, parent), 
menu.addSeparator(parent), this.styleChange(menu, mxResources.get("topAlign"), [ mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_TOP ], null, parent), 
this.styleChange(menu, mxResources.get("middle"), [ mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_MIDDLE ], null, parent), 
this.styleChange(menu, mxResources.get("bottomAlign"), [ mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_BOTTOM ], null, parent), 
menu.addSeparator(parent), this.addSubmenu("position", menu, parent), this.addSubmenu("spacing", menu, parent), 
menu.addSeparator(parent);
var enabled = this.get("text").enabled;
menu.addItem(mxResources.get("vertical"), null, function() {
graph.toggleCellStyles(mxConstants.STYLE_HORIZONTAL, !0);
}, parent, null, enabled);
}))), this.put("position", new Menu(mxUtils.bind(this, function(menu, parent) {
this.styleChange(menu, mxResources.get("left"), [ mxConstants.STYLE_LABEL_POSITION, mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_LEFT, mxConstants.ALIGN_RIGHT ], null, parent), 
this.styleChange(menu, mxResources.get("center"), [ mxConstants.STYLE_LABEL_POSITION, mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_CENTER, mxConstants.ALIGN_CENTER ], null, parent), 
this.styleChange(menu, mxResources.get("right"), [ mxConstants.STYLE_LABEL_POSITION, mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_LEFT ], null, parent), 
menu.addSeparator(parent), this.styleChange(menu, mxResources.get("top"), [ mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_TOP, mxConstants.ALIGN_BOTTOM ], null, parent), 
this.styleChange(menu, mxResources.get("middle"), [ mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_MIDDLE, mxConstants.ALIGN_MIDDLE ], null, parent), 
this.styleChange(menu, mxResources.get("bottom"), [ mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_BOTTOM, mxConstants.ALIGN_TOP ], null, parent);
}))), this.put("direction", new Menu(mxUtils.bind(this, function(menu, parent) {
menu.addItem(mxResources.get("flipH"), null, function() {
graph.toggleCellStyles(mxConstants.STYLE_FLIPH, !1);
}, parent), menu.addItem(mxResources.get("flipV"), null, function() {
graph.toggleCellStyles(mxConstants.STYLE_FLIPV, !1);
}, parent), this.addMenuItems(menu, [ "-", "tilt", "rotation" ], parent);
}))), this.put("align", new Menu(mxUtils.bind(this, function(menu, parent) {
menu.addItem(mxResources.get("leftAlign"), null, function() {
graph.alignCells(mxConstants.ALIGN_LEFT);
}, parent), menu.addItem(mxResources.get("center"), null, function() {
graph.alignCells(mxConstants.ALIGN_CENTER);
}, parent), menu.addItem(mxResources.get("rightAlign"), null, function() {
graph.alignCells(mxConstants.ALIGN_RIGHT);
}, parent), menu.addSeparator(parent), menu.addItem(mxResources.get("topAlign"), null, function() {
graph.alignCells(mxConstants.ALIGN_TOP);
}, parent), menu.addItem(mxResources.get("middle"), null, function() {
graph.alignCells(mxConstants.ALIGN_MIDDLE);
}, parent), menu.addItem(mxResources.get("bottomAlign"), null, function() {
graph.alignCells(mxConstants.ALIGN_BOTTOM);
}, parent);
}))), this.put("layers", new Menu(mxUtils.bind(this, function(menu, parent) {
var p = graph.getDefaultParent(), selectedLayer = mxResources.get("background"), item = menu.addItem(selectedLayer, null, mxUtils.bind(this, function() {
graph.setDefaultParent(null);
}), parent);
p == graph.model.getChildAt(graph.model.root, 0) && this.addCheckmark(item);
for (var layerCount = graph.model.getChildCount(graph.model.root), i = 1; layerCount > i; i++) mxUtils.bind(this, function(child) {
var title = child.value || mxResources.get("layer") + " " + i;
graph.model.isVisible(child) || (title += " (" + mxResources.get("hidden") + ")");
var item = menu.addItem(title, null, function() {
graph.model.isVisible(child) || (graph.model.setVisible(child, !0), graph.view.invalidate()), 
graph.setDefaultParent(child);
}, parent);
p == child && (this.addCheckmark(item), selectedLayer = title);
})(graph.model.getChildAt(graph.model.root, i));
var notBackground = p != graph.model.getChildAt(graph.model.root, 0);
menu.addSeparator(parent), menu.addItem(mxResources.get("removeIt", [ selectedLayer ]), null, mxUtils.bind(this, function() {
graph.removeCells([ p ]), graph.setDefaultParent(null);
}), parent, null, notBackground), menu.addItem(mxResources.get("renameIt", [ selectedLayer ]), null, mxUtils.bind(this, function() {
var newName = mxUtils.prompt(mxResources.get("enterName"), selectedLayer);
null != newName && newName.length > 0 && graph.getModel().setValue(p, newName);
}), parent, null, notBackground), menu.addItem(mxResources.get("hideIt", [ selectedLayer ]), null, mxUtils.bind(this, function() {
if (graph.model.isVisible(p)) {
graph.model.beginUpdate();
try {
graph.model.setVisible(p, !graph.model.isVisible(p)), graph.view.invalidate();
} finally {
graph.model.endUpdate();
}
graph.setDefaultParent(null);
}
}), parent, null, notBackground), menu.addSeparator(parent), menu.addItem(mxResources.get("moveSelectionTo", [ selectedLayer ]), null, mxUtils.bind(this, function() {
graph.moveCells(graph.getSelectionCells(), 0, 0, !1, p);
}), parent, null, !graph.isSelectionEmpty()), menu.addSeparator(parent), menu.addItem(mxResources.get("addLayer"), null, mxUtils.bind(this, function() {
var cell = graph.addCell(new mxCell(), graph.model.root);
graph.setDefaultParent(cell);
}), parent);
}))), this.put("layout", new Menu(mxUtils.bind(this, function(menu, parent) {
menu.addItem(mxResources.get("horizontalTree"), null, mxUtils.bind(this, function() {
if (!graph.isSelectionEmpty()) {
var layout = new mxCompactTreeLayout(graph, !0);
layout.edgeRouting = !1, layout.levelDistance = 30, this.editorUi.executeLayout(layout, !0, !0);
}
}), parent), menu.addItem(mxResources.get("verticalTree"), null, mxUtils.bind(this, function() {
if (!graph.isSelectionEmpty()) {
var layout = new mxCompactTreeLayout(graph, !1);
layout.edgeRouting = !1, layout.levelDistance = 30, this.editorUi.executeLayout(layout, !0, !0);
}
}), parent), menu.addSeparator(parent), menu.addItem(mxResources.get("horizontalFlow"), null, mxUtils.bind(this, function() {
var layout = new mxHierarchicalLayout(graph, mxConstants.DIRECTION_WEST);
this.editorUi.executeLayout(layout, !0, !0);
}), parent), menu.addItem(mxResources.get("verticalFlow"), null, mxUtils.bind(this, function() {
var layout = new mxHierarchicalLayout(graph, mxConstants.DIRECTION_NORTH);
this.editorUi.executeLayout(layout, !0, !0);
}), parent), menu.addSeparator(parent), menu.addItem(mxResources.get("organic"), null, mxUtils.bind(this, function() {
var layout = new mxFastOrganicLayout(graph);
this.editorUi.executeLayout(layout, !0, !0);
}), parent), menu.addItem(mxResources.get("circle"), null, mxUtils.bind(this, function() {
var layout = new mxCircleLayout(graph);
this.editorUi.executeLayout(layout, !0, !0, graph.getSelectionCells());
}), parent);
}))), this.put("navigation", new Menu(mxUtils.bind(this, function(menu, parent) {
this.addMenuItems(menu, [ "home", "-", "exitGroup", "enterGroup", "-", "expand", "collapse" ], parent);
}))), this.put("arrange", new Menu(mxUtils.bind(this, function(menu, parent) {
this.addMenuItems(menu, [ "toFront", "toBack", "-" ], parent), this.addSubmenu("direction", menu, parent), 
this.addSubmenu("layout", menu, parent), this.addSubmenu("align", menu, parent), 
menu.addSeparator(parent), this.addSubmenu("layers", menu, parent), this.addSubmenu("navigation", menu, parent), 
this.addMenuItems(menu, [ "-", "group", "ungroup", "removeFromGroup", "-", "lockUnlock", "-", "autosize" ], parent);
}))), this.put("view", new Menu(mxUtils.bind(this, function(menu, parent) {
this.addMenuItems(menu, [ "actualSize" ], parent), menu.addSeparator();
for (var scales = [ .25, .5, .75, 1, 1.5, 2, 4 ], i = 0; i < scales.length; i++) !function(scale) {
menu.addItem(100 * scale + "%", null, function() {
graph.zoomTo(scale);
}, parent);
}(scales[i]);
this.addMenuItems(menu, [ "-", "zoomIn", "zoomOut", "-", "fitWindow", "customZoom", "-", "fitPage", "fitPageWidth" ], parent);
}))), this.put("file", new Menu(mxUtils.bind(this, function(menu, parent) {
this.addMenuItems(menu, [ "new", "open", "-", "save", "saveAs", "-", "import", "export", "-", "editFile", "-", "pageSetup", "print" ], parent);
}))), this.put("edit", new Menu(mxUtils.bind(this, function(menu) {
this.addMenuItems(menu, [ "undo", "redo", "-", "cut", "copy", "paste", "delete", "-", "duplicate", "-", "editLink", "openLink", "-", "selectVertices", "selectEdges", "selectAll", "-", "setAsDefaultEdge" ]);
}))), this.put("options", new Menu(mxUtils.bind(this, function(menu) {
this.addMenuItems(menu, [ "grid", "guides", "tooltips", "-", "connect", "copyConnect", "navigation", "-", "scrollbars", "pageView", "-", "pageBackgroundColor" ]);
}))), this.put("help", new Menu(mxUtils.bind(this, function(menu) {
this.addMenuItems(menu, [ "help", "-", "about" ]);
})));
}, Menus.prototype.put = function(name, menu) {
this.menus[name] = menu;
}, Menus.prototype.get = function(name) {
return this.menus[name];
}, Menus.prototype.addSubmenu = function(name, menu, parent) {
var enabled = this.get(name).enabled;
if (menu.showDisabled || enabled) {
var submenu = menu.addItem(mxResources.get(name), null, null, parent, null, enabled);
this.addMenu(name, menu, submenu);
}
}, Menus.prototype.addMenu = function(name, popupMenu, parent) {
var menu = this.get(name);
null != menu && (popupMenu.showDisabled || menu.enabled) && this.get(name).execute(popupMenu, parent);
}, Menus.prototype.styleChange = function(menu, label, keys, values, sprite, parent) {
return menu.addItem(label, null, mxUtils.bind(this, function() {
var graph = this.editorUi.editor.graph;
graph.getModel().beginUpdate();
try {
for (var i = 0; i < keys.length; i++) graph.setCellStyles(keys[i], values[i]);
} finally {
graph.getModel().endUpdate();
}
}), parent, sprite);
}, Menus.prototype.promptChange = function(menu, label, hint, defaultValue, key, parent, enabled) {
return menu.addItem(label, null, mxUtils.bind(this, function() {
var graph = this.editorUi.editor.graph, value = defaultValue, state = graph.getView().getState(graph.getSelectionCell());
null != state && (value = state.style[key] || value), value = mxUtils.prompt(mxResources.get("enterValue") + (hint.length > 0 ? " " + hint :""), value), 
null != value && value.length > 0 && graph.setCellStyles(key, value);
}), parent, null, enabled);
}, Menus.prototype.pickColor = function(key) {
null == this.colorDialog && (this.colorDialog = new ColorDialog(this.editorUi)), 
this.colorDialog.currentColorKey = key;
var graph = this.editorUi.editor.graph, state = graph.getView().getState(graph.getSelectionCell()), color = "none";
null != state && (color = state.style[key] || color), "none" == color ? (color = "ffffff", 
this.colorDialog.picker.fromString("ffffff"), this.colorDialog.colorInput.value = "none") :this.colorDialog.picker.fromString(color), 
this.editorUi.showDialog(this.colorDialog.container, 220, 400, !0, !1), mxClient.IS_TOUCH || this.colorDialog.colorInput.focus();
}, Menus.prototype.addMenuItem = function(menu, key, parent) {
var action = this.editorUi.actions.get(key);
if (null != action && (menu.showDisabled || action.enabled)) {
var item = menu.addItem(action.label, null, action.funct, parent, null, action.enabled);
return action.toggleAction && action.isSelected() && this.addCheckmark(item), this.addShortcut(item, action), 
item;
}
return null;
}, Menus.prototype.addShortcut = function(item, action) {
if (null != action.shortcut) {
var td = item.firstChild.nextSibling.nextSibling, span = document.createElement("span");
span.style.color = "gray", mxUtils.write(span, action.shortcut), td.appendChild(span);
}
}, Menus.prototype.addCheckmark = function(item) {
var td = item.firstChild.nextSibling;
td.style.backgroundImage = "url(" + IMAGE_PATH + "/checkmark.gif)", td.style.backgroundRepeat = "no-repeat", 
td.style.backgroundPosition = "2px 50%";
}, Menus.prototype.addMenuItems = function(menu, keys, parent) {
for (var i = 0; i < keys.length; i++) "-" == keys[i] ? menu.addSeparator(parent) :this.addMenuItem(menu, keys[i], parent);
}, Menus.prototype.createPopupMenu = function(menu, cell, evt) {
var graph = this.editorUi.editor.graph;
if (menu.smartSeparators = !0, graph.isSelectionEmpty() ? this.addMenuItems(menu, [ "undo", "redo", "-", "paste", "-" ]) :(this.addMenuItems(menu, [ "delete", "-", "cut", "copy", "-", "duplicate" ]), 
1 == graph.getSelectionCount() && graph.getModel().isEdge(graph.getSelectionCell()) && this.addMenuItems(menu, [ "setAsDefaultEdge" ]), 
menu.addSeparator()), graph.getSelectionCount() > 0) {
if (this.addMenuItems(menu, [ "toFront", "toBack", "-" ]), graph.getModel().isEdge(graph.getSelectionCell())) {
var isWaypoint = !1, cell = graph.getSelectionCell();
if (null != cell && graph.getModel().isEdge(cell)) {
var handler = graph.selectionCellsHandler.getHandler(cell);
if (handler instanceof mxEdgeHandler && null != handler.bends && handler.bends.length > 2) {
var index = handler.getHandleForEvent(new mxMouseEvent(evt)), rmWaypointAction = this.editorUi.actions.get("removeWaypoint");
rmWaypointAction.handler = handler, rmWaypointAction.index = index, isWaypoint = index > 0 && index < handler.bends.length;
}
}
this.addMenuItems(menu, [ "-", isWaypoint ? "removeWaypoint" :"addWaypoint" ]);
} else graph.getSelectionCount() > 1 && (menu.addSeparator(), this.addMenuItems(menu, [ "group" ]));
if (menu.addSeparator(), 1 == graph.getSelectionCount()) {
var link = graph.getLinkForCell(graph.getSelectionCell());
null != link && this.addMenuItems(menu, [ "openLink" ]);
}
} else this.addMenuItems(menu, [ "-", "selectVertices", "selectEdges", "-", "selectAll" ]);
}, Menus.prototype.createMenubar = function(container) {
for (var menubar = new Menubar(this.editorUi, container), menus = [ "file", "edit", "view", "format", "text", "arrange", "options", "help" ], i = 0; i < menus.length; i++) menubar.addMenu(mxResources.get(menus[i]), this.get(menus[i]).funct);
return menubar;
}, Menubar.prototype.hideMenu = function() {
null != this.currentMenu && this.currentMenu.hideMenu();
}, Menubar.prototype.addMenu = function(label, funct) {
var elt = document.createElement("a");
return elt.setAttribute("href", "javascript:void(0);"), elt.className = "geItem", 
mxUtils.write(elt, label), this.addMenuHandler(elt, funct), this.container.appendChild(elt), 
elt;
}, Menubar.prototype.addMenuHandler = function(elt, funct) {
if (null != funct) {
var show = !0, clickHandler = mxUtils.bind(this, function(evt) {
if (show && null == elt.enabled || elt.enabled) {
this.editorUi.editor.graph.panningHandler.hideMenu();
var menu = new mxPopupMenu(funct);
menu.div.className += " geMenubarMenu", menu.smartSeparators = !0, menu.showDisabled = !0, 
menu.autoExpand = !0, menu.hideMenu = mxUtils.bind(this, function() {
mxPopupMenu.prototype.hideMenu.apply(menu, arguments), menu.destroy(), this.currentMenu = null, 
this.currentElt = null;
}), menu.popup(elt.offsetLeft + 4, elt.offsetTop + elt.offsetHeight + 4, null, evt), 
this.currentMenu = menu, this.currentElt = elt;
}
show = !0, mxEvent.consume(evt);
});
mxEvent.addListener(elt, "mousemove", mxUtils.bind(this, function(evt) {
null != this.currentMenu && this.currentElt != elt && (this.hideMenu(), clickHandler(evt));
})), mxEvent.addListener(elt, "mousedown", mxUtils.bind(this, function() {
show = this.currentElt != elt;
})), mxEvent.addListener(elt, "click", clickHandler);
}
}, mxUtils.extend(Menu, mxEventSource), Menu.prototype.setEnabled = function(value) {
this.enabled != value && (this.enabled = value, this.fireEvent(new mxEventObject("stateChanged")));
}, Menu.prototype.execute = function(menu, parent) {
this.funct(menu, parent);
}, /**
 * $Id: Shapes.js,v 1.16 2013/05/03 14:43:42 gaudenz Exp $
 * Copyright (c) 2006-2012, JGraph Ltd
 */
function() {
function CubeShape() {}
function NoteShape() {}
function FolderShape() {}
function CardShape() {}
function TapeShape() {}
function DocumentShape() {}
function ParallelogramShape() {}
function TrapezoidShape() {}
function ProcessShape() {
mxRectangleShape.call(this);
}
function StepShape() {}
function PlusShape() {
mxRectangleShape.call(this);
}
function ExtendedShape() {
mxRectangleShape.call(this);
}
function MessageShape() {}
function UmlActorShape() {}
function LollipopShape() {}
function ComponentShape() {}
function StateShape() {}
function StartStateShape() {}
function LinkShape() {
mxArrow.call(this);
}
function mxExtVertexHandler(state) {
mxVertexHandler.call(this, state);
}
function mxFolderHandler(state) {
mxExtVertexHandler.call(this, state);
}
function mxSwimlaneHandler(state) {
mxFolderHandler.call(this, state);
}
function mxCubeHandler(state) {
mxFolderHandler.call(this, state);
}
function mxCardHandler(state) {
mxCubeHandler.call(this, state);
}
function mxNoteHandler(state) {
mxCubeHandler.call(this, state);
}
function mxStepHandler(state) {
mxCubeHandler.call(this, state);
}
function mxTapeHandler(state) {
mxCubeHandler.call(this, state);
}
function mxProcessHandler(state) {
mxCubeHandler.call(this, state);
}
function mxTrapezoidHandler(state) {
mxCubeHandler.call(this, state);
}
function mxParallelogramHandler(state) {
mxTrapezoidHandler.call(this, state);
}
function mxDocumentHandler(state) {
mxCubeHandler.call(this, state);
}
CubeShape.prototype = new mxCylinder(), CubeShape.prototype.constructor = CubeShape, 
CubeShape.prototype.size = 20, CubeShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var s = Math.min(w, Math.min(h, mxUtils.getValue(this.style, "size", this.size)));
isForeground ? (path.moveTo(s, h), path.lineTo(s, s), path.lineTo(0, 0), path.moveTo(s, s), 
path.lineTo(w, s), path.end()) :(path.moveTo(0, 0), path.lineTo(w - s, 0), path.lineTo(w, s), 
path.lineTo(w, h), path.lineTo(s, h), path.lineTo(0, h - s), path.lineTo(0, 0), 
path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.cube = CubeShape, NoteShape.prototype = new mxCylinder(), 
NoteShape.prototype.constructor = NoteShape, NoteShape.prototype.size = 30, NoteShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var s = Math.min(w, Math.min(h, mxUtils.getValue(this.style, "size", this.size)));
isForeground ? (path.moveTo(w - s, 0), path.lineTo(w - s, s), path.lineTo(w, s), 
path.end()) :(path.moveTo(0, 0), path.lineTo(w - s, 0), path.lineTo(w, s), path.lineTo(w, h), 
path.lineTo(0, h), path.lineTo(0, 0), path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.note = NoteShape, FolderShape.prototype = new mxCylinder(), 
FolderShape.prototype.constructor = FolderShape, FolderShape.prototype.tabWidth = 60, 
FolderShape.prototype.tabHeight = 20, FolderShape.prototype.tabPosition = "right", 
FolderShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var tw = mxUtils.getValue(this.style, "tabWidth", this.tabWidth), th = mxUtils.getValue(this.style, "tabHeight", this.tabHeight), tp = mxUtils.getValue(this.style, "tabPosition", this.tabPosition), dx = Math.min(w, tw), dy = Math.min(h, th);
isForeground ? ("left" == tp ? (path.moveTo(0, dy), path.lineTo(dx, dy)) :(path.moveTo(w - dx, dy), 
path.lineTo(w, dy)), path.end()) :("left" == tp ? (path.moveTo(0, 0), path.lineTo(dx, 0), 
path.lineTo(dx, dy), path.lineTo(w, dy)) :(path.moveTo(0, dy), path.lineTo(w - dx, dy), 
path.lineTo(w - dx, 0), path.lineTo(w, 0)), path.lineTo(w, h), path.lineTo(0, h), 
path.lineTo(0, dy), path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.folder = FolderShape, CardShape.prototype = new mxCylinder(), 
CardShape.prototype.constructor = CardShape, CardShape.prototype.size = 30, CardShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var s = Math.min(w, Math.min(h, mxUtils.getValue(this.style, "size", this.size)));
isForeground || (path.moveTo(s, 0), path.lineTo(w, 0), path.lineTo(w, h), path.lineTo(0, h), 
path.lineTo(0, s), path.lineTo(s, 0), path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.card = CardShape, TapeShape.prototype = new mxCylinder(), 
TapeShape.prototype.constructor = TapeShape, TapeShape.prototype.size = .4, TapeShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var s = mxUtils.getValue(this.style, "size", this.size), dy = h * s, fy = 1.4;
isForeground || (path.moveTo(0, dy / 2), path.quadTo(w / 4, dy * fy, w / 2, dy / 2), 
path.quadTo(3 * w / 4, dy * (1 - fy), w, dy / 2), path.lineTo(w, h - dy / 2), path.quadTo(3 * w / 4, h - dy * fy, w / 2, h - dy / 2), 
path.quadTo(w / 4, h - dy * (1 - fy), 0, h - dy / 2), path.lineTo(0, dy / 2), path.close(), 
path.end());
}, mxCellRenderer.prototype.defaultShapes.tape = TapeShape, DocumentShape.prototype = new mxCylinder(), 
DocumentShape.prototype.constructor = DocumentShape, DocumentShape.prototype.size = .3, 
DocumentShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var s = mxUtils.getValue(this.style, "size", this.size), dy = h * s, fy = 1.4;
isForeground || (path.moveTo(0, 0), path.lineTo(w, 0), path.lineTo(w, h - dy / 2), 
path.quadTo(3 * w / 4, h - dy * fy, w / 2, h - dy / 2), path.quadTo(w / 4, h - dy * (1 - fy), 0, h - dy / 2), 
path.lineTo(0, dy / 2), path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.document = DocumentShape, ParallelogramShape.prototype = new mxCylinder(), 
ParallelogramShape.prototype.constructor = ParallelogramShape, ParallelogramShape.prototype.size = .2, 
ParallelogramShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var dx = Math.min(w, Math.min(w, mxUtils.getValue(this.style, "size", this.size) * w));
isForeground || (path.moveTo(0, h), path.lineTo(dx, 0), path.lineTo(w, 0), path.lineTo(w - dx, h), 
path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.parallelogram = ParallelogramShape, TrapezoidShape.prototype = new mxCylinder(), 
TrapezoidShape.prototype.constructor = TrapezoidShape, TrapezoidShape.prototype.size = .2, 
TrapezoidShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var dx = Math.min(w, Math.min(w, mxUtils.getValue(this.style, "size", this.size) * w));
isForeground || (path.moveTo(0, h), path.lineTo(dx, 0), path.lineTo(w - dx, 0), 
path.lineTo(w, h), path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.trapezoid = TrapezoidShape, mxUtils.extend(ProcessShape, mxRectangleShape), 
ProcessShape.prototype.size = .1, ProcessShape.prototype.isHtmlAllowed = function() {
return !1;
}, ProcessShape.prototype.getLabelBounds = function(rect) {
var w = rect.width, h = rect.height, r = new mxRectangle(rect.x, rect.y, w, h), inset = Math.min(w, Math.min(w, mxUtils.getValue(this.style, "size", this.size) * w) + this.strokewidth);
if (this.isRounded) {
var f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
inset = Math.max(inset, Math.min(w * f, h * f));
}
return r.x += inset, r.width -= 2 * inset, r;
}, ProcessShape.prototype.paintForeground = function(c, x, y, w, h) {
var inset = Math.min(w, Math.min(w, mxUtils.getValue(this.style, "size", this.size) * w) + this.strokewidth);
if (this.isRounded) {
var f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, 100 * mxConstants.RECTANGLE_ROUNDING_FACTOR) / 100;
inset = Math.max(inset, Math.min(w * f, h * f));
}
c.begin(), c.moveTo(x + inset, y), c.lineTo(x + inset, y + h), c.moveTo(x + w - inset, y), 
c.lineTo(x + w - inset, y + h), c.end(), c.stroke(), mxRectangleShape.prototype.paintForeground.apply(this, arguments);
}, mxCellRenderer.prototype.defaultShapes.process = ProcessShape, StepShape.prototype = new mxCylinder(), 
StepShape.prototype.constructor = StepShape, StepShape.prototype.size = .2, StepShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var s = w * mxUtils.getValue(this.style, "size", this.size);
isForeground || (path.moveTo(0, 0), path.lineTo(w - s, 0), path.lineTo(w, h / 2), 
path.lineTo(w - s, h), path.lineTo(0, h), path.lineTo(s, h / 2), path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.step = StepShape, mxUtils.extend(PlusShape, mxRectangleShape), 
PlusShape.prototype.isHtmlAllowed = function() {
return !1;
}, PlusShape.prototype.paintForeground = function(c, x, y, w, h) {
var border = Math.min(w / 5, h / 5) + 1;
c.begin(), c.moveTo(x + w / 2, y + border), c.lineTo(x + w / 2, y + h - border), 
c.moveTo(x + border, y + h / 2), c.lineTo(x + w - border, y + h / 2), c.end(), c.stroke(), 
mxRectangleShape.prototype.paintForeground.apply(this, arguments);
}, mxCellRenderer.prototype.defaultShapes.plus = PlusShape, mxUtils.extend(ExtendedShape, mxRectangleShape), 
ExtendedShape.prototype.isHtmlAllowed = function() {
return !1;
}, ExtendedShape.prototype.paintForeground = function(c, x, y, w, h) {
if (null != this.style) {
if (1 == this.style["double"]) {
var inset = Math.max(2, this.strokewidth + 1);
mxRectangleShape.prototype.paintBackground.call(this, c, x + inset, y + inset, w - 2 * inset, h - 2 * inset), 
mxRectangleShape.prototype.paintForeground.apply(this, arguments), x += inset, y += inset, 
w -= 2 * inset, h -= 2 * inset;
}
c.setDashed(!1);
var counter = 0, shape = null;
do {
if (shape = mxCellRenderer.prototype.defaultShapes[this.style["symbol" + counter]], 
null != shape) {
var align = this.style["symbol" + counter + "Align"], valign = this.style["symbol" + counter + "VerticalAlign"], width = this.style["symbol" + counter + "Width"], height = this.style["symbol" + counter + "Height"], spacing = this.style["symbol" + counter + "Spacing"] || 0, arcspacing = this.style["symbol" + counter + "ArcSpacing"];
null != arcspacing && (spacing += this.getArcSize(w + this.strokewidth, h + this.strokewidth) * arcspacing);
var x2 = x, y2 = y;
x2 += align == mxConstants.ALIGN_CENTER ? (w - width) / 2 :align == mxConstants.ALIGN_RIGHT ? w - width - spacing :spacing, 
y2 += valign == mxConstants.ALIGN_MIDDLE ? (h - height) / 2 :valign == mxConstants.ALIGN_BOTTOM ? h - height - spacing :spacing, 
c.save();
var tmp = new shape();
tmp.style = this.style, shape.prototype.paintVertexShape.call(tmp, c, x2, y2, width, height), 
c.restore();
}
counter++;
} while (null != shape);
}
}, mxCellRenderer.prototype.defaultShapes.ext = ExtendedShape, MessageShape.prototype = new mxCylinder(), 
MessageShape.prototype.constructor = MessageShape, MessageShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
isForeground ? (path.moveTo(0, 0), path.lineTo(w / 2, h / 2), path.lineTo(w, 0), 
path.end()) :(path.moveTo(0, 0), path.lineTo(w, 0), path.lineTo(w, h), path.lineTo(0, h), 
path.close());
}, mxCellRenderer.prototype.defaultShapes.message = MessageShape, UmlActorShape.prototype = new mxCylinder(), 
UmlActorShape.prototype.constructor = UmlActorShape, UmlActorShape.prototype.addPipe = !0, 
UmlActorShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var width = w / 3, height = h / 4;
isForeground || (path.moveTo(w / 2, height), path.curveTo(w / 2 - width, height, w / 2 - width, 0, w / 2, 0), 
path.curveTo(w / 2 + width, 0, w / 2 + width, height, w / 2, height), path.close(), 
path.moveTo(w / 2, height), path.lineTo(w / 2, 2 * h / 3), path.moveTo(w / 2, h / 3), 
path.lineTo(0, h / 3), path.moveTo(w / 2, h / 3), path.lineTo(w, h / 3), path.moveTo(w / 2, 2 * h / 3), 
path.lineTo(0, h), path.moveTo(w / 2, 2 * h / 3), path.lineTo(w, h), path.end());
}, mxCellRenderer.prototype.defaultShapes.umlActor = UmlActorShape, LollipopShape.prototype = new mxCylinder(), 
LollipopShape.prototype.constructor = LollipopShape, LollipopShape.prototype.size = 10, 
LollipopShape.prototype.addPipe = !0, LollipopShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var ss = mxUtils.getValue(this.style, "size", this.size), width = 2 * ss / 3, height = ss;
isForeground || (path.moveTo(w / 2, height), path.curveTo(w / 2 - width, height, w / 2 - width, 0, w / 2, 0), 
path.curveTo(w / 2 + width, 0, w / 2 + width, height, w / 2, height), path.close(), 
path.moveTo(w / 2, height), path.lineTo(w / 2, h), path.end());
}, mxCellRenderer.prototype.defaultShapes.lollipop = LollipopShape, ComponentShape.prototype = new mxCylinder(), 
ComponentShape.prototype.constructor = ComponentShape, ComponentShape.prototype.jettyWidth = 32, 
ComponentShape.prototype.jettyHeight = 12, ComponentShape.prototype.redrawPath = function(path, x, y, w, h, isForeground) {
var dx = mxUtils.getValue(this.style, "jettyWidth", this.jettyWidth), dy = mxUtils.getValue(this.style, "jettyHeight", this.jettyHeight), x0 = dx / 2, x1 = x0 + dx / 2, y0 = .3 * h - dy / 2, y1 = .7 * h - dy / 2;
isForeground ? (path.moveTo(x0, y0), path.lineTo(x1, y0), path.lineTo(x1, y0 + dy), 
path.lineTo(x0, y0 + dy), path.moveTo(x0, y1), path.lineTo(x1, y1), path.lineTo(x1, y1 + dy), 
path.lineTo(x0, y1 + dy), path.end()) :(path.moveTo(x0, 0), path.lineTo(w, 0), path.lineTo(w, h), 
path.lineTo(x0, h), path.lineTo(x0, y1 + dy), path.lineTo(0, y1 + dy), path.lineTo(0, y1), 
path.lineTo(x0, y1), path.lineTo(x0, y0 + dy), path.lineTo(0, y0 + dy), path.lineTo(0, y0), 
path.lineTo(x0, y0), path.close(), path.end());
}, mxCellRenderer.prototype.defaultShapes.component = ComponentShape, StateShape.prototype = new mxDoubleEllipse(), 
StateShape.prototype.constructor = StateShape, StateShape.prototype.outerStroke = !0, 
StateShape.prototype.paintVertexShape = function(c, x, y, w, h) {
var inset = Math.min(4, Math.min(w / 5, h / 5));
w > 0 && h > 0 && (c.ellipse(x + inset, y + inset, w - 2 * inset, h - 2 * inset), 
c.fillAndStroke()), c.setShadow(!1), this.outerStroke && (c.ellipse(x, y, w, h), 
c.stroke());
}, mxCellRenderer.prototype.defaultShapes.endState = StateShape, StartStateShape.prototype = new StateShape(), 
StartStateShape.prototype.constructor = StartStateShape, StartStateShape.prototype.outerStroke = !1, 
mxCellRenderer.prototype.defaultShapes.startState = StartStateShape;
var imageExportInitShapes = mxImageExport.prototype.initShapes;
mxImageExport.prototype.initShapes = function() {
function createStateShape(outerStroke) {
return {
drawShape:function(canvas, state, bounds, background) {
var x = bounds.x, y = bounds.y, w = bounds.width, h = bounds.height;
if (background) {
var inset = Math.min(4, Math.min(w / 5, h / 5));
return x += inset, y += inset, w -= 2 * inset, h -= 2 * inset, w > 0 && h > 0 && canvas.ellipse(x, y, w, h), 
!0;
}
canvas.fillAndStroke(), outerStroke && (canvas.ellipse(x, y, w, h), canvas.stroke());
}
};
}
imageExportInitShapes.apply(this, arguments), this.shapes.endState = createStateShape(!0), 
this.shapes.startState = createStateShape(!1);
}, mxUtils.extend(LinkShape, mxArrow), LinkShape.prototype.paintEdgeShape = function(c, pts) {
var width = 10, p0 = pts[0], pe = pts[pts.length - 1], dx = pe.x - p0.x, dy = pe.y - p0.y, dist = Math.sqrt(dx * dx + dy * dy), length = dist, nx = dx / dist, ny = dy / dist, basex = length * nx, basey = length * ny, floorx = width * ny / 3, floory = -width * nx / 3, p0x = p0.x - floorx / 2, p0y = p0.y - floory / 2, p1x = p0x + floorx, p1y = p0y + floory, p2x = p1x + basex, p2y = p1y + basey, p3x = p2x + floorx, p3y = p2y + floory, p5x = p3x - 3 * floorx, p5y = p3y - 3 * floory;
c.begin(), c.moveTo(p1x, p1y), c.lineTo(p2x, p2y), c.moveTo(p5x + floorx, p5y + floory), 
c.lineTo(p0x, p0y), c.stroke();
}, mxCellRenderer.prototype.defaultShapes.link = LinkShape, mxMarker.addMarker("dash", function(canvas, shape, type, pe, unitX, unitY, size, source, sw) {
var nx = unitX * (size + sw + 1), ny = unitY * (size + sw + 1);
return function() {
canvas.begin(), canvas.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2), canvas.lineTo(pe.x + ny / 2 - 3 * nx / 2, pe.y - 3 * ny / 2 - nx / 2), 
canvas.stroke();
};
});
var SPECIAL_HANDLE_INDEX = -99;
if ("undefined" != typeof mxVertexHandler) {
mxUtils.extend(mxExtVertexHandler, mxVertexHandler), mxExtVertexHandler.prototype.useGridForSpecialHandle = !1, 
mxExtVertexHandler.prototype.init = function() {
this.horizontal = mxUtils.getValue(this.state.style, mxConstants.STYLE_HORIZONTAL, !0);
var graph = this.state.view.graph;
if (null != this.handleImage) {
var bounds = new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height);
this.specialHandle = new mxImageShape(bounds, this.handleImage.src);
} else {
var size = 10, bounds = new mxRectangle(0, 0, size, size);
this.specialHandle = new mxRhombus(bounds, mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
}
this.specialHandle.dialect = graph.dialect != mxConstants.DIALECT_SVG ? mxConstants.DIALECT_VML :mxConstants.DIALECT_SVG, 
this.specialHandle.init(graph.getView().getOverlayPane()), this.specialHandle.node.style.cursor = this.getSpecialHandleCursor(), 
graph.isCellRotatable(this.state.cell) || (this.specialHandle.node.style.display = "none"), 
mxEvent.redirectMouseEvents(this.specialHandle.node, graph, this.state), mxVertexHandler.prototype.init.apply(this, arguments);
}, mxExtVertexHandler.prototype.getSpecialHandleCursor = function() {
return "default";
}, mxExtVertexHandler.prototype.redrawHandles = function() {
mxVertexHandler.prototype.redrawHandles.apply(this, arguments);
var size = this.specialHandle.bounds.width;
this.specialHandle.bounds = this.getSpecialHandleBounds(size), this.specialHandle.redraw();
}, mxExtVertexHandler.prototype.destroy = function() {
mxVertexHandler.prototype.destroy.apply(this, arguments), null != this.specialHandle && (this.specialHandle.destroy(), 
this.specialHandle = null);
}, mxExtVertexHandler.prototype.getHandleForEvent = function(me) {
return me.isSource(this.specialHandle) ? SPECIAL_HANDLE_INDEX :mxVertexHandler.prototype.getHandleForEvent.apply(this, arguments);
}, mxExtVertexHandler.prototype.mouseMove = function(sender, me) {
if (me.isConsumed() || this.index != SPECIAL_HANDLE_INDEX) mxVertexHandler.prototype.mouseMove.apply(this, arguments); else {
var point = new mxPoint(me.getGraphX(), me.getGraphY());
this.constrainPoint(point);
var gridEnabled = this.graph.isGridEnabledEvent(me.getEvent()), scale = this.graph.getView().scale;
gridEnabled && this.useGridForSpecialHandle && (point.x = this.graph.snap(point.x / scale) * scale, 
point.y = this.graph.snap(point.y / scale) * scale), this.updateStyle(point), this.state.view.graph.cellRenderer.redraw(this.state, !0), 
mxClient.IS_TOUCH || this.moveSizerTo(this.specialHandle, point.x, point.y), me.consume();
}
}, mxExtVertexHandler.prototype.mouseUp = function(sender, me) {
me.isConsumed() || this.index != SPECIAL_HANDLE_INDEX ? mxVertexHandler.prototype.mouseUp.apply(this, arguments) :(this.applyStyle(), 
this.reset(), me.consume());
}, mxExtVertexHandler.prototype.getSpecialHandleBounds = function(size) {
var rotation = this.state.shape.getShapeRotation(), alpha = mxUtils.toRadians(rotation), cos = Math.cos(alpha), sin = Math.sin(alpha), bounds = new mxRectangle(this.state.x, this.state.y, this.state.width, this.state.height);
if (this.state.shape.isPaintBoundsInverted()) {
var t = (bounds.width - bounds.height) / 2;
bounds.x += t, bounds.y -= t;
var tmp = bounds.width;
bounds.width = bounds.height, bounds.height = tmp;
}
var pt = this.getSpecialHandlePoint(bounds);
return this.state.shape.flipH && (pt.x = 2 * bounds.x + bounds.width - pt.x), this.state.shape.flipV && (pt.y = 2 * bounds.y + bounds.height - pt.y), 
pt = mxUtils.getRotatedPoint(pt, cos, sin, new mxPoint(this.state.getCenterX(), this.state.getCenterY())), 
new mxRectangle(pt.x - size / 2, pt.y - size / 2, size, size);
}, mxExtVertexHandler.prototype.getSpecialHandlePoint = function() {
return null;
}, mxExtVertexHandler.prototype.updateStyle = function() {}, mxExtVertexHandler.prototype.constrainPoint = function(point) {
point.x = Math.max(this.state.x, Math.min(this.state.x + this.state.width, point.x)), 
point.y = Math.max(this.state.y, Math.min(this.state.y + this.state.height, point.y));
}, mxExtVertexHandler.prototype.applyStyle = function() {}, mxUtils.extend(mxFolderHandler, mxExtVertexHandler), 
mxFolderHandler.prototype.getSpecialHandlePoint = function(bounds) {
var scale = this.graph.getView().scale, tw = Math.min(bounds.width, mxUtils.getValue(this.state.style, "tabWidth", 60) * scale), th = Math.min(bounds.height, mxUtils.getValue(this.state.style, "tabHeight", 20) * scale), tp = mxUtils.getValue(this.state.style, "tabPosition", "right"), x = "left" == tp ? bounds.x + tw :bounds.x + bounds.width - tw;
return new mxPoint(x, bounds.y + th);
}, mxFolderHandler.prototype.updateStyle = function(point) {
var rotation = this.state.shape.getShapeRotation(), alpha = mxUtils.toRadians(rotation), cos = Math.cos(-alpha), sin = Math.sin(-alpha), bounds = new mxRectangle(this.state.x, this.state.y, this.state.width, this.state.height);
if (this.state.shape.isPaintBoundsInverted()) {
var t = (bounds.width - bounds.height) / 2;
bounds.x += t, bounds.y -= t;
var tmp = bounds.width;
bounds.width = bounds.height, bounds.height = tmp;
}
var pt = new mxPoint(point.x, point.y);
pt = mxUtils.getRotatedPoint(pt, cos, sin, new mxPoint(this.state.getCenterX(), this.state.getCenterY())), 
this.state.shape.flipH && (pt.x = 2 * bounds.x + bounds.width - pt.x), this.state.shape.flipV && (pt.y = 2 * bounds.y + bounds.height - pt.y);
var result = this.updateStyleUnrotated(pt, bounds);
null != result && (this.state.shape.flipH && (result.x = 2 * bounds.x + bounds.width - result.x), 
this.state.shape.flipV && (result.y = 2 * bounds.y + bounds.height - result.y), 
cos = Math.cos(alpha), sin = Math.sin(alpha), result = mxUtils.getRotatedPoint(result, cos, sin, new mxPoint(this.state.getCenterX(), this.state.getCenterY())), 
point.x = result.x, point.y = result.y);
}, mxFolderHandler.prototype.updateStyleUnrotated = function(pt, bounds) {
var tp = mxUtils.getValue(this.state.style, "tabPosition", "right"), tw = "left" == tp ? pt.x - bounds.x :bounds.x + bounds.width - pt.x, th = pt.y - bounds.y, scale = this.graph.getView().scale;
this.state.style.tabWidth = Math.round(Math.max(1, tw) / scale), this.state.style.tabHeight = Math.round(Math.max(1, th) / scale);
}, mxFolderHandler.prototype.applyStyle = function() {
var model = this.graph.getModel();
model.beginUpdate();
try {
this.state.view.graph.setCellStyles("tabWidth", this.state.style.tabWidth, [ this.state.cell ]), 
this.state.view.graph.setCellStyles("tabHeight", this.state.style.tabHeight, [ this.state.cell ]);
} finally {
model.endUpdate();
}
}, mxUtils.extend(mxSwimlaneHandler, mxFolderHandler), mxSwimlaneHandler.prototype.getSpecialHandlePoint = function(bounds) {
var scale = this.graph.getView().scale, startSize = mxUtils.getValue(this.state.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE);
return new mxPoint(bounds.x + bounds.width / 2, bounds.y + Math.min(bounds.height, startSize * scale));
}, mxSwimlaneHandler.prototype.updateStyleUnrotated = function(point, bounds) {
point.x = bounds.x + bounds.width / 2, startSize = point.y - bounds.y;
var scale = this.graph.getView().scale;
return this.state.style.startSize = Math.round(Math.max(1, startSize) / scale), 
point;
}, mxSwimlaneHandler.prototype.applyStyle = function() {
this.state.view.graph.setCellStyles("startSize", this.state.style.startSize, [ this.state.cell ]);
}, mxUtils.extend(mxCubeHandler, mxFolderHandler), mxCubeHandler.prototype.defaultValue = 20, 
mxCubeHandler.prototype.scaleFactor = 1, mxCubeHandler.prototype.getSpecialHandlePoint = function(bounds) {
var scale = this.graph.getView().scale, sz = Math.min(bounds.width, Math.min(bounds.height, mxUtils.getValue(this.state.style, "size", this.defaultValue) * scale / this.scaleFactor));
return new mxPoint(bounds.x + sz, bounds.y + sz);
}, mxCubeHandler.prototype.updateStyleUnrotated = function(pt, bounds) {
var size = Math.max(0, Math.min(Math.min(bounds.width / this.scaleFactor, pt.x - bounds.x), Math.min(bounds.height / this.scaleFactor, pt.y - bounds.y))), scale = this.graph.getView().scale;
return this.state.style.size = Math.round(Math.max(1, size) / scale) * this.scaleFactor, 
new mxPoint(bounds.x + size, bounds.y + size);
}, mxCubeHandler.prototype.applyStyle = function() {
this.state.view.graph.setCellStyles("size", this.state.style.size, [ this.state.cell ]);
}, mxUtils.extend(mxCardHandler, mxCubeHandler), mxCardHandler.prototype.defaultValue = 30, 
mxCardHandler.prototype.scaleFactor = 2, mxUtils.extend(mxNoteHandler, mxCubeHandler), 
mxNoteHandler.prototype.defaultValue = 30, mxNoteHandler.prototype.scaleFactor = 1, 
mxNoteHandler.prototype.getSpecialHandlePoint = function(bounds) {
var scale = this.graph.getView().scale, sz = Math.min(bounds.width, Math.min(bounds.height, mxUtils.getValue(this.state.style, "size", this.defaultValue) * scale / this.scaleFactor));
return new mxPoint(bounds.x + bounds.width - sz, bounds.y + sz);
}, mxNoteHandler.prototype.updateStyleUnrotated = function(pt, bounds) {
var size = Math.max(0, Math.min(Math.min(bounds.width / this.scaleFactor, pt.x - bounds.x + bounds.width), Math.min(bounds.height / this.scaleFactor, pt.y - bounds.y))), scale = this.graph.getView().scale;
return this.state.style.size = Math.round(Math.max(1, size) / scale) * this.scaleFactor, 
new mxPoint(bounds.x + bounds.width - size, bounds.y + size);
}, mxUtils.extend(mxStepHandler, mxCubeHandler), mxStepHandler.prototype.defaultValue = .2, 
mxStepHandler.prototype.scaleFactor = 1, mxStepHandler.prototype.getSpecialHandlePoint = function(bounds) {
var sz = mxUtils.getValue(this.state.style, "size", this.defaultValue);
return new mxPoint(bounds.x + bounds.width * sz, bounds.y + bounds.height / 2);
}, mxStepHandler.prototype.updateStyleUnrotated = function(pt, bounds) {
var size = Math.min(1, (pt.x - bounds.x) / bounds.width);
return this.state.style.size = size, new mxPoint(bounds.x + size * bounds.width, bounds.y + bounds.height / 2);
}, mxUtils.extend(mxTapeHandler, mxCubeHandler), mxTapeHandler.prototype.defaultValue = .4, 
mxTapeHandler.prototype.scaleFactor = 1, mxTapeHandler.prototype.getSpecialHandlePoint = function(bounds) {
var sz = mxUtils.getValue(this.state.style, "size", this.defaultValue);
return new mxPoint(bounds.x + bounds.width / 2, bounds.y + sz * bounds.height / 2);
}, mxTapeHandler.prototype.updateStyleUnrotated = function(pt, bounds) {
var size = Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2));
return this.state.style.size = size, new mxPoint(bounds.x + bounds.width / 2, bounds.y + size * bounds.height / 2);
}, mxUtils.extend(mxProcessHandler, mxCubeHandler), mxProcessHandler.prototype.defaultValue = .1, 
mxProcessHandler.prototype.scaleFactor = 1, mxProcessHandler.prototype.getSpecialHandlePoint = function(bounds) {
var sz = mxUtils.getValue(this.state.style, "size", this.defaultValue);
return new mxPoint(bounds.x + sz * bounds.width, bounds.y + bounds.height / 4);
}, mxProcessHandler.prototype.updateStyleUnrotated = function(pt, bounds) {
var size = Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width));
return this.state.style.size = size, new mxPoint(bounds.x + size * bounds.width, bounds.y + bounds.height / 4);
}, mxUtils.extend(mxTrapezoidHandler, mxCubeHandler), mxTrapezoidHandler.prototype.defaultValue = .2, 
mxTrapezoidHandler.prototype.scaleFactor = 1, mxTrapezoidHandler.prototype.maxSize = .5, 
mxTrapezoidHandler.prototype.getSpecialHandlePoint = function(bounds) {
var size = mxUtils.getValue(this.state.style, "size", this.defaultValue);
return new mxPoint(bounds.x + size * bounds.width * .75, bounds.y + bounds.height / 4);
}, mxTrapezoidHandler.prototype.updateStyleUnrotated = function(pt, bounds) {
var size = Math.max(0, Math.min(this.maxSize, (pt.x - bounds.x) / (.75 * bounds.width)));
return this.state.style.size = size, new mxPoint(bounds.x + size * bounds.width * .75, bounds.y + bounds.height / 4);
}, mxUtils.extend(mxParallelogramHandler, mxTrapezoidHandler), mxParallelogramHandler.prototype.maxSize = 1, 
mxUtils.extend(mxDocumentHandler, mxCubeHandler), mxDocumentHandler.prototype.defaultValue = .3, 
mxDocumentHandler.prototype.fy = 1.4, mxDocumentHandler.prototype.scaleFactor = 1, 
mxDocumentHandler.prototype.getSpecialHandlePoint = function(bounds) {
var dy = mxUtils.getValue(this.state.style, "size", this.defaultValue) * bounds.height;
return new mxPoint(bounds.x + 3 * bounds.width / 4, bounds.y + bounds.height - dy);
}, mxDocumentHandler.prototype.updateStyleUnrotated = function(pt, bounds) {
var size = Math.max(0, Math.min(1, (bounds.y + bounds.height - pt.y) / bounds.height));
return this.state.style.size = size, new mxPoint(bounds.x + 3 * bounds.width / 4, bounds.y + bounds.height - size * bounds.height);
};
var handlers = {
swimlane:mxSwimlaneHandler,
folder:mxFolderHandler,
cube:mxCubeHandler,
card:mxCardHandler,
note:mxNoteHandler,
step:mxStepHandler,
tape:mxTapeHandler,
process:mxProcessHandler,
document:mxDocumentHandler,
trapezoid:mxTrapezoidHandler,
parallelogram:mxParallelogramHandler
}, mxGraphCreateHandler = mxGraph.prototype.createHandler;
mxGraph.prototype.createHandler = function(state) {
if (null != state) {
var ctor = handlers[state.style.shape];
if (null != ctor) return new ctor(state);
}
return mxGraphCreateHandler.apply(this, arguments);
};
}
mxGraph.prototype.getAllConnectionConstraints = function(terminal) {
if (null != terminal && null != terminal.shape) if (null != terminal.shape.stencil) {
if (null != terminal.shape.stencil) return terminal.shape.stencil.constraints;
} else if (null != terminal.shape.constraints) return terminal.shape.constraints;
return null;
}, mxRectangleShape.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.25, 0), !0), new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.75, 0), !0), new mxConnectionConstraint(new mxPoint(0, .25), !0), new mxConnectionConstraint(new mxPoint(0, .5), !0), new mxConnectionConstraint(new mxPoint(0, .75), !0), new mxConnectionConstraint(new mxPoint(1, .25), !0), new mxConnectionConstraint(new mxPoint(1, .5), !0), new mxConnectionConstraint(new mxPoint(1, .75), !0), new mxConnectionConstraint(new mxPoint(.25, 1), !0), new mxConnectionConstraint(new mxPoint(.5, 1), !0), new mxConnectionConstraint(new mxPoint(.75, 1), !0) ], 
mxLabel.prototype.constraints = mxRectangleShape.prototype.constraints, mxImageShape.prototype.constraints = mxRectangleShape.prototype.constraints, 
mxSwimlane.prototype.constraints = mxRectangleShape.prototype.constraints, PlusShape.prototype.constraints = mxRectangleShape.prototype.constraints, 
NoteShape.prototype.constraints = mxRectangleShape.prototype.constraints, CardShape.prototype.constraints = mxRectangleShape.prototype.constraints, 
CubeShape.prototype.constraints = mxRectangleShape.prototype.constraints, FolderShape.prototype.constraints = mxRectangleShape.prototype.constraints, 
mxCylinder.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.15, .05), !1), new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.85, .05), !1), new mxConnectionConstraint(new mxPoint(0, .3), !0), new mxConnectionConstraint(new mxPoint(0, .5), !0), new mxConnectionConstraint(new mxPoint(0, .7), !0), new mxConnectionConstraint(new mxPoint(1, .3), !0), new mxConnectionConstraint(new mxPoint(1, .5), !0), new mxConnectionConstraint(new mxPoint(1, .7), !0), new mxConnectionConstraint(new mxPoint(.15, .95), !1), new mxConnectionConstraint(new mxPoint(.5, 1), !0), new mxConnectionConstraint(new mxPoint(.85, .95), !1) ], 
UmlActorShape.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.25, .1), !1), new mxConnectionConstraint(new mxPoint(.5, 0), !1), new mxConnectionConstraint(new mxPoint(.75, .1), !1), new mxConnectionConstraint(new mxPoint(0, 1 / 3), !1), new mxConnectionConstraint(new mxPoint(0, 1), !1), new mxConnectionConstraint(new mxPoint(1, 1 / 3), !1), new mxConnectionConstraint(new mxPoint(1, 1), !1), new mxConnectionConstraint(new mxPoint(.5, .5), !1) ], 
ComponentShape.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.25, 0), !0), new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.75, 0), !0), new mxConnectionConstraint(new mxPoint(0, .3), !0), new mxConnectionConstraint(new mxPoint(0, .7), !0), new mxConnectionConstraint(new mxPoint(1, .25), !0), new mxConnectionConstraint(new mxPoint(1, .5), !0), new mxConnectionConstraint(new mxPoint(1, .75), !0), new mxConnectionConstraint(new mxPoint(.25, 1), !0), new mxConnectionConstraint(new mxPoint(.5, 1), !0), new mxConnectionConstraint(new mxPoint(.75, 1), !0) ], 
mxActor.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.25, .2), !1), new mxConnectionConstraint(new mxPoint(.1, .5), !1), new mxConnectionConstraint(new mxPoint(0, .75), !0), new mxConnectionConstraint(new mxPoint(.75, .25), !1), new mxConnectionConstraint(new mxPoint(.9, .5), !1), new mxConnectionConstraint(new mxPoint(1, .75), !0), new mxConnectionConstraint(new mxPoint(.25, 1), !0), new mxConnectionConstraint(new mxPoint(.5, 1), !0), new mxConnectionConstraint(new mxPoint(.75, 1), !0) ], 
TapeShape.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(0, .35), !1), new mxConnectionConstraint(new mxPoint(0, .5), !1), new mxConnectionConstraint(new mxPoint(0, .65), !1), new mxConnectionConstraint(new mxPoint(1, .35), !1), new mxConnectionConstraint(new mxPoint(1, .5), !1), new mxConnectionConstraint(new mxPoint(1, .65), !1), new mxConnectionConstraint(new mxPoint(.25, 1), !1), new mxConnectionConstraint(new mxPoint(.75, 0), !1) ], 
StepShape.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.25, 0), !0), new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.75, 0), !0), new mxConnectionConstraint(new mxPoint(.25, 1), !0), new mxConnectionConstraint(new mxPoint(.5, 1), !0), new mxConnectionConstraint(new mxPoint(.75, 1), !0), new mxConnectionConstraint(new mxPoint(.1, .25), !1), new mxConnectionConstraint(new mxPoint(.2, .5), !1), new mxConnectionConstraint(new mxPoint(.1, .75), !1), new mxConnectionConstraint(new mxPoint(.9, .25), !1), new mxConnectionConstraint(new mxPoint(1, .5), !1), new mxConnectionConstraint(new mxPoint(.9, .75), !1) ], 
mxLine.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(0, .5), !1), new mxConnectionConstraint(new mxPoint(.25, .5), !1), new mxConnectionConstraint(new mxPoint(.75, .5), !1), new mxConnectionConstraint(new mxPoint(1, .5), !1) ], 
LollipopShape.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.5, 0), !1), new mxConnectionConstraint(new mxPoint(.5, 1), !1) ], 
mxEllipse.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(0, 0), !0), new mxConnectionConstraint(new mxPoint(1, 0), !0), new mxConnectionConstraint(new mxPoint(0, 1), !0), new mxConnectionConstraint(new mxPoint(1, 1), !0), new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.5, 1), !0), new mxConnectionConstraint(new mxPoint(0, .5), !0), new mxConnectionConstraint(new mxPoint(1, .5)) ], 
mxDoubleEllipse.prototype.constraints = mxEllipse.prototype.constraints, mxRhombus.prototype.constraints = mxEllipse.prototype.constraints, 
mxTriangle.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(0, .25), !0), new mxConnectionConstraint(new mxPoint(0, .5), !0), new mxConnectionConstraint(new mxPoint(0, .75), !0), new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.5, 1), !0), new mxConnectionConstraint(new mxPoint(1, .5), !0) ], 
mxHexagon.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.375, 0), !0), new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.625, 0), !0), new mxConnectionConstraint(new mxPoint(.125, .25), !1), new mxConnectionConstraint(new mxPoint(0, .5), !0), new mxConnectionConstraint(new mxPoint(.125, .75), !1), new mxConnectionConstraint(new mxPoint(.875, .25), !1), new mxConnectionConstraint(new mxPoint(0, .5), !0), new mxConnectionConstraint(new mxPoint(1, .5), !0), new mxConnectionConstraint(new mxPoint(.875, .75), !1), new mxConnectionConstraint(new mxPoint(.375, 1), !0), new mxConnectionConstraint(new mxPoint(.5, 1), !0), new mxConnectionConstraint(new mxPoint(.625, 1), !0) ], 
mxCloud.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.25, .25), !1), new mxConnectionConstraint(new mxPoint(.4, .1), !1), new mxConnectionConstraint(new mxPoint(.16, .55), !1), new mxConnectionConstraint(new mxPoint(.07, .4), !1), new mxConnectionConstraint(new mxPoint(.31, .8), !1), new mxConnectionConstraint(new mxPoint(.13, .77), !1), new mxConnectionConstraint(new mxPoint(.8, .8), !1), new mxConnectionConstraint(new mxPoint(.55, .95), !1), new mxConnectionConstraint(new mxPoint(.875, .5), !1), new mxConnectionConstraint(new mxPoint(.96, .7), !1), new mxConnectionConstraint(new mxPoint(.625, .2), !1), new mxConnectionConstraint(new mxPoint(.88, .25), !1) ], 
ParallelogramShape.prototype.constraints = mxRectangleShape.prototype.constraints, 
TrapezoidShape.prototype.constraints = mxRectangleShape.prototype.constraints, DocumentShape.prototype.constraints = [ new mxConnectionConstraint(new mxPoint(.25, 0), !0), new mxConnectionConstraint(new mxPoint(.5, 0), !0), new mxConnectionConstraint(new mxPoint(.75, 0), !0), new mxConnectionConstraint(new mxPoint(0, .25), !0), new mxConnectionConstraint(new mxPoint(0, .5), !0), new mxConnectionConstraint(new mxPoint(0, .75), !0), new mxConnectionConstraint(new mxPoint(1, .25), !0), new mxConnectionConstraint(new mxPoint(1, .5), !0), new mxConnectionConstraint(new mxPoint(1, .75), !0) ], 
mxArrow.prototype.constraints = null;
}(), Sidebar.prototype.init = function() {
for (var dir = STENCIL_PATH, i = 0; i < this.choices.length; i++) element = this.choices[i], 
"general" == element ? this.addGeneralPalette(!0) :"basic" == element ? this.addStencilPalette("basic", mxResources.get("basic"), dir + "/basic.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2") :"arrows" == element ? this.addStencilPalette("arrows", mxResources.get("arrows"), dir + "/arrows.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2") :"uml" == element ? this.addUmlPalette(!0) :"bmpn" == element ? this.addBpmnPalette(dir, !1) :"electrical" == element ? (this.addStencilPalette("electrical", "Electrical / Abstract ", dir + "/electrical/abstract.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Capacitors", dir + "/electrical/capacitors.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Diodes ", dir + "/electrical/diodes.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Electro-mechanical ", dir + "/electrical/electro-mechanical.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / IEC Logic Gates ", dir + "/electrical/iec_logic_gates.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Inductors ", dir + "/electrical/inductors.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Instruments ", dir + "/electrical/instruments.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Logic Gates ", dir + "/electrical/logic_gates.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Miscellaneous ", dir + "/electrical/miscellaneous.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Op Amps ", dir + "/electrical/op_amps.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Opto-Electronics ", dir + "/electrical/opto-electronics.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / PLC Ladder ", dir + "/electrical/plc_ladder.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Power Semiconductors ", dir + "/electrical/power_semiconductors.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Radio ", dir + "/electrical/radio.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Resistors ", dir + "/electrical/resistors.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Signal Sources ", dir + "/electrical/signal_sources.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Thermionic Devices ", dir + "/electrical/thermionic_devices.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Transistors", dir + "/electrical/transistors.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("electrical", "Electrical / Waveforms ", dir + "/electrical/waveforms.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2")) :"flowchart" == element ? this.addStencilPalette("flowchart", "Flowchart", dir / 0/0, ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2") :"aws" == element ? (this.addStencilPalette("aws", "AWS / Compute ", dir + "/aws/compute.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Content Delivery ", dir + "/aws/content_delivery.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Database ", dir + "/aws/database.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Deployment ", dir + "/aws/deployment_management.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Groups ", dir + "/aws/groups.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Messaging ", dir + "/aws/messaging.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Miscellaneous ", dir + "/aws/misc.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Networking ", dir + "/aws/networking.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Non Service Specific ", dir + "/aws/non_service_specific.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / On Demand ", dir + "/aws/on_demand_workforce.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2"), 
this.addStencilPalette("aws", "AWS / Storage ", dir + "/aws/storage.xml", ";fillColor=#ffffff;strokeColor=#000000;strokeWidth=2")) :"image" == element && this.addImagePalette("clipart", mxResources.get("clipart"), dir + "/clipart/", "_128x128.png", [ "Earth_globe", "Empty_Folder", "Full_Folder", "Gear", "Lock", "Software", "Virus", "Email", "Database", "Router_Icon", "iPad", "iMac", "Laptop", "MacBook", "Monitor_Tower", "Printer", "Server_Tower", "Workstation", "Firewall_02", "Wireless_Router_N", "Credit_Card", "Piggy_Bank", "Graph", "Safe", "Shopping_Cart", "Suit1", "Suit2", "Suit3", "Pilot1", "Worker1", "Soldier1", "Doctor1", "Tech1", "Security1", "Telesales1" ]);
}, Sidebar.prototype.enableTooltips = !mxClient.IS_TOUCH, Sidebar.prototype.tooltipBorder = 16, 
Sidebar.prototype.thumbBorder = 3, Sidebar.prototype.tooltipDelay = 300, Sidebar.prototype.installEdges = !0, 
Sidebar.prototype.gearImage = STENCIL_PATH + "/clipart/Gear_128x128.png", Sidebar.prototype.thumbWidth = 34, 
Sidebar.prototype.thumbHeight = 34, Sidebar.prototype.thumbPadding = 2, Sidebar.prototype.sidebarTitleSize = 9, 
Sidebar.prototype.sidebarTitles = !0, Sidebar.prototype.tooltipTitles = !0, Sidebar.prototype.showTooltip = function(elt, cells, title, showLabel) {
if (this.enableTooltips && this.showTooltips && this.currentElt != elt) {
null != this.thread && (window.clearTimeout(this.thread), this.thread = null);
var show = mxUtils.bind(this, function() {
null == this.tooltip && (this.tooltip = document.createElement("div"), this.tooltip.className = "geSidebarTooltip", 
document.body.appendChild(this.tooltip), this.graph2 = new Graph(this.tooltip, null, null, this.editorUi.editor.graph.getStylesheet()), 
this.graph2.view.setTranslate(this.tooltipBorder, this.tooltipBorder), this.graph2.resetViewOnRootChange = !1, 
this.graph2.foldingEnabled = !1, this.graph2.autoScroll = !1, this.graph2.setTooltips(!1), 
this.graph2.setConnectable(!1), this.graph2.setEnabled(!1), mxClient.IS_SVG || (this.graph2.view.canvas.style.position = "relative"), 
this.tooltipImage = mxUtils.createImage(IMAGE_PATH + "/tooltip.png"), this.tooltipImage.style.position = "absolute", 
this.tooltipImage.style.width = "14px", this.tooltipImage.style.height = "27px", 
document.body.appendChild(this.tooltipImage)), this.tooltip.style.display = "block", 
this.graph2.labelsVisible = null == showLabel || showLabel, this.graph2.model.clear(), 
this.graph2.addCells(cells);
var bounds = this.graph2.getGraphBounds(), width = bounds.width + 2 * this.tooltipBorder, height = bounds.height + 2 * this.tooltipBorder;
if (mxClient.IS_QUIRKS ? (width += 4, height += 4, this.tooltip.style.overflow = "hidden") :this.tooltip.style.overflow = "visible", 
this.tooltipImage.style.visibility = "visible", this.tooltip.style.width = width + "px", 
this.tooltipTitles && null != title && title.length > 0) {
null == this.tooltipTitle ? (this.tooltipTitle = document.createElement("div"), 
this.tooltipTitle.style.borderTop = "1px solid gray", this.tooltipTitle.style.textAlign = "center", 
this.tooltipTitle.style.width = "100%", this.tooltipTitle.style.overflow = "hidden", 
mxClient.IS_SVG ? this.tooltipTitle.style.paddingTop = "2px" :(this.tooltipTitle.style.position = "absolute", 
this.tooltipTitle.style.paddingTop = "6px"), this.tooltip.appendChild(this.tooltipTitle)) :this.tooltipTitle.innerHTML = "", 
this.tooltipTitle.style.display = "", mxUtils.write(this.tooltipTitle, title);
var dy = this.tooltipTitle.offsetHeight + 10;
height += dy, mxClient.IS_SVG ? this.tooltipTitle.style.marginTop = -dy + "px" :(height -= 6, 
this.tooltipTitle.style.top = height - dy + "px");
} else null != this.tooltipTitle && null != this.tooltipTitle.parentNode && (this.tooltipTitle.style.display = "none");
this.tooltip.style.height = height + "px";
var x0 = -Math.min(0, bounds.x - this.tooltipBorder), y0 = -Math.min(0, bounds.y - this.tooltipBorder), left = this.container.offsetWidth + this.editorUi.splitSize + 107, top = Math.max(0, this.container.offsetTop + elt.offsetTop - this.container.scrollTop - height / 2 + 16);
mxClient.IS_SVG ? this.graph2.view.canvas.setAttribute("transform", "translate(" + x0 + "," + y0 + ")") :(this.graph2.view.drawPane.style.left = x0 + "px", 
this.graph2.view.drawPane.style.top = y0 + "px"), this.tooltip.style.position = "absolute", 
this.tooltip.style.left = left + "px", this.tooltip.style.top = top + $(".question").height() + 220 + "px", 
this.tooltipImage.style.left = left - 13 + "px", this.tooltipImage.style.top = top + height / 2 - 13 + $(".question").height() + 220 + "px";
});
null != this.tooltip && "none" != this.tooltip.style.display ? show() :this.thread = window.setTimeout(show, this.tooltipDelay), 
this.currentElt = elt;
}
}, Sidebar.prototype.hideTooltip = function() {
null != this.thread && (window.clearTimeout(this.thread), this.thread = null), null != this.tooltip && (this.tooltip.style.display = "none", 
this.tooltipImage.style.visibility = "hidden", this.currentElt = null);
}, Sidebar.prototype.addGeneralPalette = function(expand) {
this.addPalette("general", mxResources.get("general"), expand || !0, mxUtils.bind(this, function(content) {
content.appendChild(this.createVertexTemplate("swimlane;whiteSpace=wrap", 200, 200, "Container", "Container", !0)), 
content.appendChild(this.createVertexTemplate("whiteSpace=wrap", 120, 60, "", "Rectangle", !0)), 
content.appendChild(this.createVertexTemplate("rounded=1;whiteSpace=wrap", 120, 60, "", "Rounded Rectangle", !0)), 
content.appendChild(this.createVertexTemplate("text;spacingTop=-5;", 30, 20, "Text", "Text", !0)), 
content.appendChild(this.createVertexTemplate("ellipse;whiteSpace=wrap", 80, 80, "", "Circle", !0)), 
content.appendChild(this.createVertexTemplate("ellipse;shape=doubleEllipse;whiteSpace=wrap", 80, 80, "", "Double Ellipse", !0)), 
content.appendChild(this.createVertexTemplate("shape=ext;double=1;whiteSpace=wrap", 120, 60, "Double Rectangle", "Double Rectangle", !0)), 
content.appendChild(this.createVertexTemplate("shape=ext;double=1;rounded=1;whiteSpace=wrap", 120, 60, "Double\nRounded Rectangle", "Double Rounded Rectangle", !0)), 
content.appendChild(this.createVertexTemplate("shape=process;whiteSpace=wrap", 120, 60, "", "Process", !0)), 
content.appendChild(this.createVertexTemplate("shape=parallelogram;whiteSpace=wrap", 120, 60, "", "Parallelogram", !0)), 
content.appendChild(this.createVertexTemplate("shape=trapezoid;whiteSpace=wrap", 120, 60, "", "Trapezoid", !0)), 
content.appendChild(this.createVertexTemplate("shape=document;whiteSpace=wrap", 120, 80, "", "Document", !0)), 
content.appendChild(this.createVertexTemplate("triangle;whiteSpace=wrap", 60, 80, "", "Triangle", !0)), 
content.appendChild(this.createVertexTemplate("rhombus;whiteSpace=wrap", 80, 80, "", "Rhombus", !0)), 
content.appendChild(this.createVertexTemplate("shape=hexagon;whiteSpace=wrap", 120, 80, "", "Hexagon", !0)), 
content.appendChild(this.createVertexTemplate("shape=step;whiteSpace=wrap", 120, 80, "", "Step", !0)), 
content.appendChild(this.createVertexTemplate("shape=cylinder;whiteSpace=wrap", 60, 80, "", "Cylinder", !0)), 
content.appendChild(this.createVertexTemplate("shape=tape;whiteSpace=wrap", 120, 100, "", "Tape", !0)), 
content.appendChild(this.createVertexTemplate("shape=xor;whiteSpace=wrap", 60, 80, "", "Exclusive Or", !0)), 
content.appendChild(this.createVertexTemplate("shape=or;whiteSpace=wrap", 60, 80, "", "Or", !0)), 
content.appendChild(this.createVertexTemplate("shape=cube;whiteSpace=wrap", 120, 80, "", "Cube", !0)), 
content.appendChild(this.createVertexTemplate("shape=note;whiteSpace=wrap", 80, 100, "", "Note", !0)), 
content.appendChild(this.createVertexTemplate("shape=folder;whiteSpace=wrap", 120, 120, "", "Folder", !0)), 
content.appendChild(this.createVertexTemplate("shape=card;whiteSpace=wrap", 60, 80, "", "Card", !0)), 
content.appendChild(this.createVertexTemplate("shape=message;whiteSpace=wrap", 60, 40, "", "Message", !0)), 
content.appendChild(this.createVertexTemplate("shape=actor;whiteSpace=wrap", 40, 60, "", "Actor 1", !0)), 
content.appendChild(this.createVertexTemplate("icon;image=" + this.gearImage, 60, 60, "Image", "Image", !1)), 
content.appendChild(this.createVertexTemplate("whiteSpace=wrap;label;image=" + this.gearImage, 140, 60, "Label", "Label", !0)), 
content.appendChild(this.createVertexTemplate("shape=umlActor;verticalLabelPosition=bottom;verticalAlign=top", 30, 60, "", "Actor 2", !0)), 
content.appendChild(this.createVertexTemplate("ellipse;shape=cloud;whiteSpace=wrap", 120, 80, "", "Cloud", !0)), 
content.appendChild(this.createVertexTemplate("line", 160, 10, "", "Horizontal Line", !0)), 
content.appendChild(this.createVertexTemplate("line;direction=south", 10, 160, "", "Vertical Line", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=none;endArrow=none;", 100, 100, "", "Line", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=none;endArrow=none;dashed=1;", 100, 100, "", "Dashed Line", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=none;endArrow=none;dashed=1;dashPattern=1 4", 100, 100, "", "Dotted Line", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=none", 100, 100, "", "Connection", !0));
var cells = [ new mxCell("", new mxGeometry(0, 0, 100, 100), "curved=1") ];
cells[0].geometry.setTerminalPoint(new mxPoint(0, 100), !0), cells[0].geometry.setTerminalPoint(new mxPoint(100, 0), !1), 
cells[0].geometry.points = [ new mxPoint(100, 100), new mxPoint(0, 0) ], cells[0].geometry.relative = !0, 
cells[0].edge = !0, content.appendChild(this.createEdgeTemplateFromCells(cells, 100, 100, "Curve", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=elbowEdgeStyle;elbow=horizontal", 100, 100, "", "Horizontal Elbow", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=elbowEdgeStyle;elbow=vertical", 100, 100, "", "Vertical Elbow", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=entityRelationEdgeStyle", 100, 100, "", "Entity Relation", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=segmentEdgeStyle", 100, 100, "", "Manual Line", !0)), 
content.appendChild(this.createEdgeTemplate("edgeStyle=orthogonalEdgeStyle", 100, 100, "", "Automatic Line", !0)), 
content.appendChild(this.createEdgeTemplate("shape=link", 100, 100, "", "Link", !0)), 
content.appendChild(this.createEdgeTemplate("arrow", 100, 100, "", "Arrow", !0));
}));
}, Sidebar.prototype.addUmlPalette = function(expand) {
this.addPalette("uml", "UML", expand || !1, mxUtils.bind(this, function(content) {
content.appendChild(this.createVertexTemplate("", 110, 50, "Object", "Object", !0));
var classCell = new mxCell('<p style="margin:0px;margin-top:4px;text-align:center;"><b>Class</b></p><hr/><div style="height:2px;"></div><hr/>', new mxGeometry(0, 0, 140, 60), "verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1");
classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 140, 60, "Class 1", !0));
var classCell = new mxCell('<p style="margin:0px;margin-top:4px;text-align:center;"><b>Class</b></p><hr/><p style="margin:0px;margin-left:4px;">+ field: Type</p><hr/><p style="margin:0px;margin-left:4px;">+ method(): Type</p>', new mxGeometry(0, 0, 160, 90), "verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1");
classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 160, 90, "Class 2", !0));
var classCell = new mxCell('<p style="margin:0px;margin-top:4px;text-align:center;"><i>&lt;&lt;Interface&gt;&gt;</i><br/><b>Interface</b></p><hr/><p style="margin:0px;margin-left:4px;">+ field1: Type<br/>+ field2: Type</p><hr/><p style="margin:0px;margin-left:4px;">+ method1(Type): Type<br/>+ method2(Type, Type): Type</p>', new mxGeometry(0, 0, 190, 140), "verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1");
classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 190, 140, "Interface", !0));
var classCell = new mxCell("Module", new mxGeometry(0, 0, 120, 60), "shape=component;align=left;spacingLeft=36");
classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 120, 60, "Module", !0));
var classCell = new mxCell("&lt;&lt;component&gt;&gt;<br/><b>Component</b>", new mxGeometry(0, 0, 180, 90), "shape=ext;symbol0=component;symbol0Width=20;symbol0Height=20;symbol0Align=right;symbol0VerticalAlign=top;symbol0Spacing=4;symbol0ArcSpacing=0.25;jettyWidth=8;jettyHeight=4;overflow=fill;html=1", "Component", !0);
classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 180, 90, "Component", !0));
var classCell = new mxCell('<p style="margin:0px;margin-top:6px;text-align:center;"><b>Component</b></p><hr/><p style="margin:0px;margin-left:8px;">+ Attribute1: Type<br/>+ Attribute2: Type</p>', new mxGeometry(0, 0, 180, 90), "shape=ext;symbol0=component;symbol0Width=20;symbol0Height=20;symbol0Align=right;symbol0VerticalAlign=top;symbol0ArcSpacing=0.25;jettyWidth=8;jettyHeight=4;verticalAlign=top;align=left;overflow=fill;html=1");
classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 180, 90, "Component with Attributes", !0)), 
content.appendChild(this.createVertexTemplate("shape=lollipop;direction=south;", 30, 10, "", "Lollipop", !0));
var cardCell = new mxCell("Block", new mxGeometry(0, 0, 180, 120), "verticalAlign=top;align=left;spacingTop=8;spacingLeft=2;spacingRight=12;shape=cube;size=10;direction=south;fontStyle=4;");
cardCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ cardCell ], 180, 120, "Block", !0)), 
content.appendChild(this.createVertexTemplate("shape=folder;fontStyle=1;spacingTop=10;tabWidth=40;tabHeight=14;tabPosition=left;", 70, 50, "package", "Package", !0));
var classCell = new mxCell('<p style="margin:0px;margin-top:4px;text-align:center;text-decoration:underline;"><b>Object:Type</b></p><hr/><p style="margin:0px;margin-left:8px;">field1 = value1<br/>field2 = value2<br>field3 = value3</p>', new mxGeometry(0, 0, 160, 90), "verticalAlign=top;align=left;overflow=fill;fontSize=12;fontFamily=Helvetica;html=1");
classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 160, 90, "Object", !0));
var tableCell = new mxCell('<table style="width:100%;font-size:10px;"><tr><td colspan="2" style="background:#e4e4e4;padding:2px;">Tablename</td></tr><tr><td>PK</td><td style="padding:2px;">uniqueId</td></tr><tr><td>FK1</td><td style="padding:2px;">foreignKey</td></tr><tr><td></td><td style="padding:2px;">fieldname</td></tr></table>', new mxGeometry(0, 0, 180, 90), "verticalAlign=top;align=left;overflow=fill;html=1");
tableCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ tableCell ], 180, 90, "Entity", !0)), 
content.appendChild(this.createVertexTemplate("shape=note", 80, 100, "", "Note", !0)), 
content.appendChild(this.createVertexTemplate("shape=umlActor;verticalLabelPosition=bottom;verticalAlign=top", 40, 80, "Actor", "Actor", !1)), 
content.appendChild(this.createVertexTemplate("ellipse", 140, 70, "Use Case", "Use Case", !0));
var cardCell = new mxCell("", new mxGeometry(0, 0, 30, 30), "ellipse;shape=startState;fillColor=#000000;strokeColor=#ff0000;");
cardCell.vertex = !0;
var assoc2 = new mxCell("", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=horizontal;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
assoc2.geometry.setTerminalPoint(new mxPoint(15, 70), !1), assoc2.edge = !0, cardCell.insertEdge(assoc2, !0), 
content.appendChild(this.createVertexTemplateFromCells([ cardCell, assoc2 ], 30, 30, "Start", !0));
var cardCell = new mxCell("Activity", new mxGeometry(0, 0, 120, 40), "rounded=1;arcSize=40;fillColor=#ffffc0;strokeColor=#ff0000;");
cardCell.vertex = !0;
var assoc2 = new mxCell("", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=horizontal;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
assoc2.geometry.setTerminalPoint(new mxPoint(60, 80), !1), assoc2.edge = !0, cardCell.insertEdge(assoc2, !0), 
content.appendChild(this.createVertexTemplateFromCells([ cardCell, assoc2 ], 120, 40, "Activity", !0));
var cardCell = new mxCell('<div style="margin-top:8px;"><b>Composite State</b><hr/>Subtitle</div>', new mxGeometry(0, 0, 160, 60), "rounded=1;arcSize=40;overflow=fill;html=1;verticalAlign=top;fillColor=#ffffc0;strokeColor=#ff0000;");
cardCell.vertex = !0;
var assoc2 = new mxCell("", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=horizontal;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
assoc2.geometry.setTerminalPoint(new mxPoint(80, 100), !1), assoc2.edge = !0, cardCell.insertEdge(assoc2, !0), 
content.appendChild(this.createVertexTemplateFromCells([ cardCell, assoc2 ], 160, 60, "Composite State", !0));
var cardCell = new mxCell("Condition", new mxGeometry(0, 0, 80, 40), "rhombus;fillColor=#ffffc0;strokeColor=#ff0000;");
cardCell.vertex = !0;
var assoc1 = new mxCell("no", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=horizontal;align=left;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
assoc1.geometry.setTerminalPoint(new mxPoint(120, 20), !1), assoc1.geometry.relative = !0, 
assoc1.geometry.x = -1, assoc1.edge = !0, cardCell.insertEdge(assoc1, !0);
var assoc2 = new mxCell("yes", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=horizontal;align=left;verticalAlign=top;endArrow=open;endSize=8;strokeColor=#ff0000;");
assoc2.geometry.setTerminalPoint(new mxPoint(40, 80), !1), assoc2.geometry.relative = !0, 
assoc2.geometry.x = -1, assoc2.edge = !0, cardCell.insertEdge(assoc2, !0), content.appendChild(this.createVertexTemplateFromCells([ cardCell, assoc1, assoc2 ], 80, 40, "Condition", !0));
var cardCell = new mxCell("", new mxGeometry(0, 0, 200, 10), "shape=line;strokeWidth=6;strokeColor=#ff0000;");
cardCell.vertex = !0;
var assoc2 = new mxCell("", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=horizontal;verticalAlign=bottom;endArrow=open;endSize=8;strokeColor=#ff0000;");
assoc2.geometry.setTerminalPoint(new mxPoint(100, 50), !1), assoc2.edge = !0, cardCell.insertEdge(assoc2, !0), 
content.appendChild(this.createVertexTemplateFromCells([ cardCell, assoc2 ], 200, 10, "Fork/Join", !0)), 
content.appendChild(this.createVertexTemplate("ellipse;shape=endState;fillColor=#000000;strokeColor=#ff0000", 30, 30, "", "End", !0));
var classCell1 = new mxCell(":Object", new mxGeometry(0, 0, 100, 50));
classCell1.vertex = !0;
var classCell2 = new mxCell("", new mxGeometry(40, 50, 20, 240), "shape=line;direction=north;dashed=1");
classCell2.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell1, classCell2 ], 100, 290, "Class/Object", !0));
var classCell1 = new mxCell("", new mxGeometry(100, 0, 20, 70));
classCell1.vertex = !0;
var assoc1 = new mxCell("invoke", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=vertical;verticalAlign=bottom;endArrow=block;");
assoc1.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc1.edge = !0, classCell1.insertEdge(assoc1, !1), 
content.appendChild(this.createVertexTemplateFromCells([ classCell1, assoc1 ], 120, 70, "Invocation", !0));
var classCell1 = new mxCell("", new mxGeometry(100, 0, 20, 70));
classCell1.vertex = !0;
var assoc1 = new mxCell("invoke", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=vertical;verticalAlign=bottom;endArrow=block;");
assoc1.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc1.edge = !0, classCell1.insertEdge(assoc1, !1);
var assoc2 = new mxCell("return", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=vertical;verticalAlign=bottom;dashed=1;endArrow=open;endSize=8;");
assoc2.geometry.setTerminalPoint(new mxPoint(0, 70), !1), assoc2.edge = !0, classCell1.insertEdge(assoc2, !0);
var assoc3 = new mxCell("invoke", new mxGeometry(0, 0, 0, 0), "edgeStyle=elbowEdgeStyle;elbow=vertical;align=left;endArrow=open;");
assoc3.edge = !0, classCell1.insertEdge(assoc3, !0), classCell1.insertEdge(assoc3, !1), 
content.appendChild(this.createVertexTemplateFromCells([ classCell1, assoc1, assoc2, assoc3 ], 120, 70, "Synchronous Invocation", !0));
var assoc = new mxCell("name", new mxGeometry(0, 0, 0, 0), "endArrow=block;endFill=1;edgeStyle=orthogonalEdgeStyle;align=left;verticalAlign=top;");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(160, 0), !1), 
assoc.geometry.relative = !0, assoc.geometry.x = -1, assoc.edge = !0;
var sourceLabel = new mxCell("1", new mxGeometry(-1, 0, 0, 0), "resizable=0;align=left;verticalAlign=bottom;labelBackgroundColor=#ffffff;fontSize=10");
sourceLabel.geometry.relative = !0, sourceLabel.setConnectable(!1), sourceLabel.vertex = !0, 
assoc.insert(sourceLabel), content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 160, 0, "Relation", !0));
var assoc = new mxCell("", new mxGeometry(0, 0, 0, 0), "endArrow=none;edgeStyle=orthogonalEdgeStyle;");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(160, 0), !1), 
assoc.edge = !0;
var sourceLabel = new mxCell("parent", new mxGeometry(-1, 0, 0, 0), "resizable=0;align=left;verticalAlign=bottom;labelBackgroundColor=#ffffff;fontSize=10");
sourceLabel.geometry.relative = !0, sourceLabel.setConnectable(!1), sourceLabel.vertex = !0, 
assoc.insert(sourceLabel);
var targetLabel = new mxCell("child", new mxGeometry(1, 0, 0, 0), "resizable=0;align=right;verticalAlign=bottom;labelBackgroundColor=#ffffff;fontSize=10");
targetLabel.geometry.relative = !0, targetLabel.setConnectable(!1), targetLabel.vertex = !0, 
assoc.insert(targetLabel), content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 160, 0, "Association 1", !0));
var assoc = new mxCell("1", new mxGeometry(0, 0, 0, 0), "endArrow=open;endSize=12;startArrow=diamondThin;startSize=14;startFill=0;edgeStyle=orthogonalEdgeStyle;align=left;verticalAlign=bottom;");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(160, 0), !1), 
assoc.geometry.relative = !0, assoc.geometry.x = -1, assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 160, 0, "Composition", !0));
var assoc = new mxCell("Relation", new mxGeometry(0, 0, 0, 0), "endArrow=open;endSize=12;startArrow=diamondThin;startSize=14;startFill=0;edgeStyle=orthogonalEdgeStyle;");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(160, 0), !1), 
assoc.edge = !0;
var sourceLabel = new mxCell("0..n", new mxGeometry(-1, 0, 0, 0), "resizable=0;align=left;verticalAlign=top;labelBackgroundColor=#ffffff;fontSize=10");
sourceLabel.geometry.relative = !0, sourceLabel.setConnectable(!1), sourceLabel.vertex = !0, 
assoc.insert(sourceLabel);
var targetLabel = new mxCell("1", new mxGeometry(1, 0, 0, 0), "resizable=0;align=right;verticalAlign=top;labelBackgroundColor=#ffffff;fontSize=10");
targetLabel.geometry.relative = !0, targetLabel.setConnectable(!1), targetLabel.vertex = !0, 
assoc.insert(targetLabel), content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 160, 0, "Relation", !0));
var assoc = new mxCell("Use", new mxGeometry(0, 0, 0, 0), "endArrow=open;endSize=12;dashed=1");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(160, 0), !1), 
assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 160, 0, "Dependency", !0));
var assoc = new mxCell("Extends", new mxGeometry(0, 0, 0, 0), "endArrow=block;endSize=16;endFill=0;dashed=1");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(160, 0), !1), 
assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 160, 0, "Generalization"));
var assoc = new mxCell("", new mxGeometry(0, 0, 0, 0), "endArrow=block;startArrow=block;endFill=1;startFill=1");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(160, 0), !1), 
assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 160, 0, "Association 2"));
}));
}, Sidebar.prototype.addBpmnPalette = function() {
this.addPalette("bpmn", "BPMN " + mxResources.get("general"), !1, mxUtils.bind(this, function(content) {
content.appendChild(this.createVertexTemplate("shape=ext;rounded=1;", 120, 80, "Task", "Process", !0)), 
content.appendChild(this.createVertexTemplate("shape=ext;rounded=1;double=1;", 120, 80, "Transaction", "Transaction", !0)), 
content.appendChild(this.createVertexTemplate("shape=ext;rounded=1;dashed=1;dashPattern=1 4;", 120, 80, "Event\nSub-Process", "Event Sub-Process", !0)), 
content.appendChild(this.createVertexTemplate("shape=ext;rounded=1;strokeWidth=3;", 120, 80, "Call Activity", "Call Activity", !0)), 
content.appendChild(this.createVertexTemplate("shape=ext;rounded=1;symbol0=plus;symbol0Width=14;symbol0Height=14;symbol0Align=center;symbol0VerticalAlign=bottom;", 120, 80, "Sub-Process", "Sub-Process", !0)), 
content.appendChild(this.createVertexTemplate("shape=ext;rounded=1;symbol0=message;symbol0Width=20;symbol0Height=14;symbol0Align=left;symbol0VerticalAlign=top;symbol0Spacing=4;symbol0ArcSpacing=0.25;", 120, 80, "Receive", "Receive Task", !0)), 
content.appendChild(this.createVertexTemplate("shape=ext;rounded=1;symbol0=actor;symbol0Width=14;symbol0Height=14;symbol0Align=left;symbol0VerticalAlign=top;symbol0Spacing=4;symbol0ArcSpacing=0.25;", 120, 80, "User", "User Task", !0));
var classCell = new mxCell("Process", new mxGeometry(0, 0, 120, 80), "rounded=1");
classCell.vertex = !0;
var classCell1 = new mxCell("", new mxGeometry(1, 1, 30, 30), "shape=mxgraph.bpmn.timer_start;perimeter=ellipsePerimeter;");
classCell1.vertex = !0, classCell1.geometry.relative = !0, classCell1.geometry.offset = new mxPoint(-40, -15), 
classCell.insert(classCell1), content.appendChild(this.createVertexTemplateFromCells([ classCell ], 120, 80, "Attached Timer Event", !0)), 
content.appendChild(this.createVertexTemplate("swimlane;horizontal=0;startSize=20", 320, 240, "Pool", "Pool", !0)), 
content.appendChild(this.createVertexTemplate("swimlane;horizontal=0;swimlaneFillColor=white;swimlaneLine=0;", 300, 120, "Lane", "Lane", !0)), 
content.appendChild(this.createVertexTemplate("shape=hexagon", 60, 50, "", "Conversation", !0)), 
content.appendChild(this.createVertexTemplate("shape=hexagon;strokeWidth=4", 60, 50, "", "Call Conversation", !0));
var classCell = new mxCell("", new mxGeometry(0, 0, 40, 30), "shape=message");
classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 40, 30, "Message", !0));
var classCell = new mxCell("", new mxGeometry(0, 0, 14, 14), "shape=plus;resizable=0;");
classCell.connectable = !1, classCell.vertex = !0, content.appendChild(this.createVertexTemplateFromCells([ classCell ], 14, 14, "Sub-Process Marker", !0));
var assoc = new mxCell("", new mxGeometry(0, 0, 0, 0), "endArrow=block;endFill=1;endSize=6");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(100, 0), !1), 
assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 100, 0, "Sequence Flow", !0));
var assoc = new mxCell("", new mxGeometry(0, 0, 0, 0), "startArrow=dash;startSize=8;endArrow=block;endFill=1;endSize=6");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(100, 0), !1), 
assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 100, 0, "Default Flow", !0));
var assoc = new mxCell("", new mxGeometry(0, 0, 0, 0), "startArrow=diamondThin;startFill=0;startSize=14;endArrow=block;endFill=1;endSize=6");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(100, 0), !1), 
assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 100, 0, "Conditional Flow", !0));
var assoc = new mxCell("", new mxGeometry(0, 0, 0, 0), "startArrow=oval;startFill=0;startSize=7;endArrow=block;endFill=0;endSize=10;dashed=1");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(100, 0), !1), 
assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 100, 0, "Message Flow 1"));
var assoc = new mxCell("", new mxGeometry(0, 0, 0, 0), "startArrow=oval;startFill=0;startSize=7;endArrow=block;endFill=0;endSize=10;dashed=1");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(100, 0), !1), 
assoc.edge = !0;
var sourceLabel = new mxCell("", new mxGeometry(0, 0, 20, 14), "shape=message");
sourceLabel.geometry.relative = !0, sourceLabel.setConnectable(!1), sourceLabel.vertex = !0, 
sourceLabel.geometry.offset = new mxPoint(-10, -7), assoc.insert(sourceLabel), content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 100, 0, "Message Flow 2", !0));
var assoc = new mxCell("", new mxGeometry(0, 0, 0, 0), "shape=link");
assoc.geometry.setTerminalPoint(new mxPoint(0, 0), !0), assoc.geometry.setTerminalPoint(new mxPoint(100, 0), !1), 
assoc.edge = !0, content.appendChild(this.createEdgeTemplateFromCells([ assoc ], 100, 0, "Link", !0));
}));
}, Sidebar.prototype.createTitle = function(label) {
var elt = document.createElement("a");
return elt.setAttribute("href", "javascript:void(0);"), elt.className = "geTitle", 
mxUtils.write(elt, label), elt;
}, Sidebar.prototype.createThumb = function(cells, width, height, parent, title, showLabel) {
this.graph.labelsVisible = null == showLabel || showLabel, this.graph.view.scaleAndTranslate(1, 0, 0), 
this.graph.addCells(cells);
var bounds = this.graph.getGraphBounds(), corr = this.thumbBorder, s = Math.min((width - 2) / (bounds.width - bounds.x + corr), (height - 2) / (bounds.height - bounds.y + corr)), x0 = -Math.min(bounds.x, 0), y0 = -Math.min(bounds.y, 0);
this.graph.view.scaleAndTranslate(s, x0, y0), bounds = this.graph.getGraphBounds();
var dx = Math.max(0, Math.floor((width - bounds.width - bounds.x) / 2)), dy = Math.max(0, Math.floor((height - bounds.height - bounds.y) / 2)), node = null;
this.graph.dialect != mxConstants.DIALECT_SVG || mxClient.NO_FO ? (node = this.graph.container.cloneNode(!1), 
node.innerHTML = this.graph.container.innerHTML) :node = this.graph.view.getCanvas().ownerSVGElement.cloneNode(!0), 
this.graph.getModel().clear(), mxClient.IS_IE6 && (parent.style.backgroundImage = "url(" + this.editorUi.editor.transparentImage + ")");
var dd = 3;
if (node.style.position = "relative", node.style.overflow = "hidden", node.style.cursor = "pointer", 
node.style.left = dx + dd + "px", node.style.top = dy + dd + "px", node.style.width = width + "px", 
node.style.height = height + "px", node.style.visibility = "", node.style.minWidth = "", 
node.style.minHeight = "", parent.appendChild(node), this.sidebarTitles && null != title) {
var border = mxClient.IS_QUIRKS ? 2 * this.thumbPadding + 2 :0;
parent.style.height = this.thumbHeight + border + this.sidebarTitleSize + 8 + "px";
var div = document.createElement("div");
div.style.fontSize = this.sidebarTitleSize + "px", div.style.textAlign = "center", 
div.style.whiteSpace = "nowrap", mxClient.IS_IE && (div.style.height = this.sidebarTitleSize + 12 + "px"), 
div.style.paddingTop = "4px", mxUtils.write(div, title), parent.appendChild(div);
}
}, Sidebar.prototype.createItem = function(cells, title, showLabel) {
var elt = document.createElement("a");
elt.setAttribute("href", "javascript:void(0);"), elt.className = "geItem", elt.style.overflow = "hidden";
var border = mxClient.IS_QUIRKS ? 8 + 2 * this.thumbPadding :6;
return elt.style.width = this.thumbWidth + border + "px", elt.style.height = this.thumbHeight + border + "px", 
elt.style.padding = this.thumbPadding + "px", mxEvent.addListener(elt, "click", function(evt) {
mxEvent.consume(evt);
}), this.createThumb(cells, this.thumbWidth, this.thumbHeight, elt, title, showLabel), 
elt;
}, Sidebar.prototype.createDropHandler = function(cells, allowSplit) {
return function(graph, evt, target, x, y) {
if (graph.isEnabled() && (cells = graph.getImportableCells(cells), cells.length > 0)) {
var validDropTarget = null != target ? graph.isValidDropTarget(target, cells, evt) :!1, select = null;
null == target || validDropTarget || (target = null), allowSplit && graph.isSplitEnabled() && graph.isSplitTarget(target, cells, evt) ? (graph.splitEdge(target, cells, null, x, y), 
select = cells) :cells.length > 0 && (select = graph.importCells(cells, x, y, target)), 
null != select && select.length > 0 && (graph.scrollCellToVisible(select[0]), graph.setSelectionCells(select));
}
};
}, Sidebar.prototype.createDragPreview = function(width, height) {
var elt = document.createElement("div");
return elt.style.border = "1px dashed black", elt.style.width = width + "px", elt.style.height = height + "px", 
elt;
}, Sidebar.prototype.createDragSource = function(elt, dropHandler, preview) {
var dragSource = mxUtils.makeDraggable(elt, this.editorUi.editor.graph, dropHandler, preview, 0, 0, this.editorUi.editor.graph.autoscroll, !0, !0);
return dragSource.getDropTarget = function(graph) {
var target = mxDragSource.prototype.getDropTarget.apply(this, arguments);
return graph.isValidRoot(target) || (target = null), target;
}, dragSource;
}, Sidebar.prototype.itemClicked = function(cells, ds, evt) {
var graph = this.editorUi.editor.graph, gs = graph.getGridSize();
ds.drop(graph, evt, null, gs, gs);
}, Sidebar.prototype.addClickHandler = function(elt, ds, cells) {
var graph = this.editorUi.editor.graph, oldMouseUp = ds.mouseUp, first = null;
mxEvent.addGestureListeners(elt, function(evt) {
first = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
}), ds.mouseUp = mxUtils.bind(this, function(evt) {
if (!mxEvent.isPopupTrigger(evt) && null == this.currentGraph && null != first) {
var tol = graph.tolerance;
Math.abs(first.x - mxEvent.getClientX(evt)) <= tol && Math.abs(first.y - mxEvent.getClientY(evt)) <= tol && this.itemClicked(cells, ds, evt);
}
oldMouseUp.apply(ds, arguments), first = null, this.currentElt = elt;
});
}, Sidebar.prototype.createVertexTemplate = function(style, width, height, value, title, showLabel) {
var cells = [ new mxCell(null != value ? value :"", new mxGeometry(0, 0, width, height), style) ];
return cells[0].vertex = !0, this.createVertexTemplateFromCells(cells, width, height, title, showLabel);
}, Sidebar.prototype.createVertexTemplateFromCells = function(cells, width, height, title, showLabel) {
var elt = this.createItem(cells, title, showLabel), ds = this.createDragSource(elt, this.createDropHandler(cells, !0), this.createDragPreview(width, height));
return this.addClickHandler(elt, ds, cells), ds.isGuidesEnabled = mxUtils.bind(this, function() {
return this.editorUi.editor.graph.graphHandler.guidesEnabled;
}), touchStyle || mxEvent.addListener(elt, "mousemove", mxUtils.bind(this, function() {
this.showTooltip(elt, cells, title, showLabel);
})), elt;
}, Sidebar.prototype.createEdgeTemplate = function(style, width, height, value, title, showLabel) {
var cells = [ new mxCell(null != value ? value :"", new mxGeometry(0, 0, width, height), style) ];
return cells[0].geometry.setTerminalPoint(new mxPoint(0, height), !0), cells[0].geometry.setTerminalPoint(new mxPoint(width, 0), !1), 
cells[0].geometry.relative = !0, cells[0].edge = !0, this.createEdgeTemplateFromCells(cells, width, height, title, showLabel);
}, Sidebar.prototype.createEdgeTemplateFromCells = function(cells, width, height, title, showLabel) {
var elt = this.createItem(cells, title, showLabel);
this.createDragSource(elt, this.createDropHandler(cells, !1), this.createDragPreview(width, height));
var graph = this.editorUi.editor.graph;
return mxEvent.addListener(elt, "click", mxUtils.bind(this, function(evt) {
this.installEdges && graph.setDefaultEdge(cells[0]), elt.style.backgroundColor = "#ffffff", 
window.setTimeout(function() {
elt.style.backgroundColor = "";
}, 300), mxEvent.consume(evt);
})), touchStyle || mxEvent.addListener(elt, "mousemove", mxUtils.bind(this, function() {
this.showTooltip(elt, cells, title, showLabel);
})), elt;
}, Sidebar.prototype.addPalette = function(id, title, expanded, onInit) {
var elt = this.createTitle(title);
this.container.appendChild(elt);
var div = document.createElement("div");
div.className = "geSidebar", expanded ? (onInit(div), onInit = null) :div.style.display = "none", 
this.addFoldingHandler(elt, div, onInit);
var outer = document.createElement("div");
outer.appendChild(div), this.container.appendChild(outer), null != id && (this.palettes[id] = [ elt, outer ]);
}, Sidebar.prototype.addFoldingHandler = function(title, content, funct) {
var initialized = !1;
title.style.backgroundImage = "none" == content.style.display ? "url(" + IMAGE_PATH + "/collapsed.gif)" :"url(" + IMAGE_PATH + "/expanded.gif)", 
title.style.backgroundRepeat = "no-repeat", title.style.backgroundPosition = "0% 50%", 
mxEvent.addListener(title, "click", function(evt) {
if ("none" == content.style.display) {
if (!initialized && (initialized = !0, null != funct)) {
title.style.cursor = "wait";
var prev = title.innerHTML;
title.innerHTML = mxResources.get("loading") + "...", window.setTimeout(function() {
funct(content), title.style.cursor = "", title.innerHTML = prev;
}, 0);
}
title.style.backgroundImage = "url(" + IMAGE_PATH + "/expanded.gif)", content.style.display = "block";
} else title.style.backgroundImage = "url(" + IMAGE_PATH + "/collapsed.gif)", content.style.display = "none";
mxEvent.consume(evt);
});
}, Sidebar.prototype.removePalette = function(id) {
var elts = this.palettes[id];
if (null != elts) {
this.palettes[id] = null;
for (var i = 0; i < elts.length; i++) this.container.removeChild(elts[i]);
return !0;
}
return !1;
}, Sidebar.prototype.addImagePalette = function(id, title, prefix, postfix, items, titles) {
this.addPalette(id, title, !1, mxUtils.bind(this, function(content) {
for (var showTitles = null != titles, i = 0; i < items.length; i++) {
var icon = prefix + items[i] + postfix;
content.appendChild(this.createVertexTemplate("image;image=" + icon, 80, 80, "", showTitles ? titles[i] :null, showTitles));
}
}));
}, Sidebar.prototype.addStencilPalette = function(id, title, stencilFile, style, expand, ignore, onInit, scale) {
scale = null != scale ? scale :1, this.addPalette(id, title, expand, mxUtils.bind(this, function(content) {
null == style && (style = ""), null != onInit && onInit.call(this, content), mxStencilRegistry.loadStencilSet(stencilFile, mxUtils.bind(this, function(packageName, stencilName, displayName, w, h) {
(null == ignore || mxUtils.indexOf(ignore, stencilName) < 0) && content.appendChild(this.createVertexTemplate("shape=" + packageName + stencilName.toLowerCase() + style, Math.round(w * scale), Math.round(h * scale), "", stencilName.replace(/_/g, " "), !0));
}), !0);
}));
}, Toolbar.prototype.init = function() {
this.addItems([ "undo", "redo", "delete", "-", "actualSize", "zoomIn", "zoomOut", "-" ]);
var fontElt = this.addMenu("Helvetica", mxResources.get("fontFamily"), !0, "fontFamily");
fontElt.style.whiteSpace = "nowrap", fontElt.style.overflow = "hidden", fontElt.style.width = "56px", 
this.addSeparator();
var sizeElt = this.addMenu("12", mxResources.get("fontSize"), !0, "fontSize");
sizeElt.style.whiteSpace = "nowrap", sizeElt.style.overflow = "hidden", sizeElt.style.width = "22px", 
this.addItems([ "-", "bold", "italic", "underline" ]);
var align = this.addMenuFunction("geSprite-left", mxResources.get("align"), !1, mxUtils.bind(this, function(menu) {
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_LEFT ], "geIcon geSprite geSprite-left", null).setAttribute("title", mxResources.get("left")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_CENTER ], "geIcon geSprite geSprite-center", null).setAttribute("title", mxResources.get("center")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ALIGN ], [ mxConstants.ALIGN_RIGHT ], "geIcon geSprite geSprite-right", null).setAttribute("title", mxResources.get("right")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_TOP ], "geIcon geSprite geSprite-top", null).setAttribute("title", mxResources.get("top")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_MIDDLE ], "geIcon geSprite geSprite-middle", null).setAttribute("title", mxResources.get("middle")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_VERTICAL_ALIGN ], [ mxConstants.ALIGN_BOTTOM ], "geIcon geSprite geSprite-bottom", null).setAttribute("title", mxResources.get("bottom"));
}));
this.addItems([ "fontColor", "-" ]);
var line = this.addMenuFunction("geSprite-straight", mxResources.get("line"), !1, mxUtils.bind(this, function(menu) {
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_EDGE ], [ null ], "geIcon geSprite geSprite-straight", null).setAttribute("title", mxResources.get("straight")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_EDGE ], [ "entityRelationEdgeStyle" ], "geIcon geSprite geSprite-entity", null).setAttribute("title", mxResources.get("entityRelation")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW ], [ "elbowEdgeStyle", "horizontal" ], "geIcon geSprite geSprite-helbow", null).setAttribute("title", mxResources.get("horizontal")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_EDGE, mxConstants.STYLE_ELBOW ], [ "elbowEdgeStyle", "vertical" ], "geIcon geSprite geSprite-velbow", null).setAttribute("title", mxResources.get("vertical")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_EDGE ], [ "segmentEdgeStyle" ], "geIcon geSprite geSprite-segment", null).setAttribute("title", mxResources.get("manual")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_EDGE ], [ "orthogonalEdgeStyle" ], "geIcon geSprite geSprite-orthogonal", null).setAttribute("title", mxResources.get("automatic"));
})), linestart = this.addMenuFunction("geSprite-startclassic", mxResources.get("lineend"), !1, mxUtils.bind(this, function(menu) {
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.NONE, 0 ], "geIcon geSprite geSprite-noarrow", null).setAttribute("title", mxResources.get("none")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_CLASSIC, 1 ], "geIcon geSprite geSprite-startclassic", null).setAttribute("title", mxResources.get("classic")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_OPEN, 1 ], "geIcon geSprite geSprite-startopen", null).setAttribute("title", mxResources.get("openArrow")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_BLOCK, 1 ], "geIcon geSprite geSprite-startblock", null).setAttribute("title", mxResources.get("block")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_OVAL, 1 ], "geIcon geSprite geSprite-startoval", null).setAttribute("title", mxResources.get("oval")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_DIAMOND, 1 ], "geIcon geSprite geSprite-startdiamond", null).setAttribute("title", mxResources.get("diamond")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_DIAMOND_THIN, 1 ], "geIcon geSprite geSprite-startthindiamond", null).setAttribute("title", mxResources.get("diamondThin")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_CLASSIC, 0 ], "geIcon geSprite geSprite-startclassictrans", null).setAttribute("title", mxResources.get("classic")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_BLOCK, 0 ], "geIcon geSprite geSprite-startblocktrans", null).setAttribute("title", mxResources.get("block")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_OVAL, 0 ], "geIcon geSprite geSprite-startovaltrans", null).setAttribute("title", mxResources.get("oval")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_DIAMOND, 0 ], "geIcon geSprite geSprite-startdiamondtrans", null).setAttribute("title", mxResources.get("diamond")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_STARTARROW, "startFill" ], [ mxConstants.ARROW_DIAMOND_THIN, 0 ], "geIcon geSprite geSprite-startthindiamondtrans", null).setAttribute("title", mxResources.get("diamondThin"));
})), lineend = this.addMenuFunction("geSprite-endclassic", mxResources.get("lineend"), !1, mxUtils.bind(this, function(menu) {
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.NONE, 0 ], "geIcon geSprite geSprite-noarrow", null).setAttribute("title", mxResources.get("none")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_CLASSIC, 1 ], "geIcon geSprite geSprite-endclassic", null).setAttribute("title", mxResources.get("classic")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_OPEN, 1 ], "geIcon geSprite geSprite-endopen", null).setAttribute("title", mxResources.get("openArrow")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_BLOCK, 1 ], "geIcon geSprite geSprite-endblock", null).setAttribute("title", mxResources.get("block")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_OVAL, 1 ], "geIcon geSprite geSprite-endoval", null).setAttribute("title", mxResources.get("oval")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_DIAMOND, 1 ], "geIcon geSprite geSprite-enddiamond", null).setAttribute("title", mxResources.get("diamond")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_DIAMOND_THIN, 1 ], "geIcon geSprite geSprite-endthindiamond", null).setAttribute("title", mxResources.get("diamondThin")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_CLASSIC, 0 ], "geIcon geSprite geSprite-endclassictrans", null).setAttribute("title", mxResources.get("classic")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_BLOCK, 0 ], "geIcon geSprite geSprite-endblocktrans", null).setAttribute("title", mxResources.get("block")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_OVAL, 0 ], "geIcon geSprite geSprite-endovaltrans", null).setAttribute("title", mxResources.get("oval")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_DIAMOND, 0 ], "geIcon geSprite geSprite-enddiamondtrans", null).setAttribute("title", mxResources.get("diamond")), 
this.editorUi.menus.styleChange(menu, "", [ mxConstants.STYLE_ENDARROW, "endFill" ], [ mxConstants.ARROW_DIAMOND_THIN, 0 ], "geIcon geSprite geSprite-endthindiamondtrans", null).setAttribute("title", mxResources.get("diamondThin"));
}));
this.addItems([ "-", "strokeColor", "image", "fillColor" ]), this.addItem("geSprite-gradientcolor", "gradientColor").setAttribute("title", mxResources.get("gradient")), 
this.addItems([ "shadow" ]);
var graph = this.editorUi.editor.graph, update = mxUtils.bind(this, function() {
var ff = "Helvetica", fs = "12", state = graph.getView().getState(graph.getSelectionCell());
null != state && (ff = state.style[mxConstants.STYLE_FONTFAMILY] || ff, fs = state.style[mxConstants.STYLE_FONTSIZE] || fs, 
ff.length > 10 && (ff = ff.substring(0, 8) + "..."), fontElt.innerHTML = ff, sizeElt.innerHTML = fs);
});
graph.getSelectionModel().addListener(mxEvent.CHANGE, update), graph.getModel().addListener(mxEvent.CHANGE, update), 
this.addEdgeSelectionHandler([ line, linestart, lineend ]), this.addSelectionHandler([ align ]);
}, Toolbar.prototype.hideMenu = function() {
null != this.currentMenu && (this.currentMenu.hideMenu(), this.currentMenu.destroy(), 
this.currentMenu = null);
}, Toolbar.prototype.addMenu = function(label, tooltip, showLabels, name) {
var menu = this.editorUi.menus.get(name), elt = this.addMenuFunction(label, tooltip, showLabels, menu.funct);
return menu.addListener("stateChanged", function() {
elt.setEnabled(menu.enabled);
}), elt;
}, Toolbar.prototype.addMenuFunction = function(label, tooltip, showLabels, funct) {
var elt = showLabels ? this.createLabel(label) :this.createButton(label);
return this.initElement(elt, tooltip), this.addMenuHandler(elt, showLabels, funct), 
this.container.appendChild(elt), elt;
}, Toolbar.prototype.addSeparator = function() {
var elt = document.createElement("div");
return elt.className = "geSeparator", this.container.appendChild(elt), elt;
}, Toolbar.prototype.addItems = function(keys) {
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
"-" == key ? this.addSeparator() :this.addItem("geSprite-" + key.toLowerCase(), key);
}
}, Toolbar.prototype.addItem = function(sprite, key) {
var action = this.editorUi.actions.get(key), elt = null;
return null != action && (elt = this.addButton(sprite, action.label, action.funct), 
elt.setEnabled(action.enabled), action.addListener("stateChanged", function() {
elt.setEnabled(action.enabled);
})), elt;
}, Toolbar.prototype.addButton = function(classname, tooltip, funct) {
var elt = this.createButton(classname);
return this.initElement(elt, tooltip), this.addClickHandler(elt, funct), this.container.appendChild(elt), 
elt;
}, Toolbar.prototype.addSelectionHandler = function(items) {
var graph = this.editorUi.editor.graph, selectionListener = function() {
for (var selected = !graph.isSelectionEmpty(), i = 0; i < items.length; i++) items[i].setEnabled(selected);
};
graph.getSelectionModel().addListener(mxEvent.CHANGE, selectionListener), selectionListener();
}, Toolbar.prototype.addEdgeSelectionHandler = function(items) {
var graph = this.editorUi.editor.graph, selectionListener = function() {
var edgeSelected = !1;
if (!graph.isSelectionEmpty()) for (var cells = graph.getSelectionCells(), i = 0; i < cells.length; i++) if (graph.getModel().isEdge(cells[i])) {
edgeSelected = !0;
break;
}
for (var i = 0; i < items.length; i++) items[i].setEnabled(edgeSelected);
};
graph.getSelectionModel().addListener(mxEvent.CHANGE, selectionListener), selectionListener();
}, Toolbar.prototype.initElement = function(elt, tooltip) {
elt.setAttribute("tabindex", "0"), null != tooltip && elt.setAttribute("title", tooltip), 
this.addEnabledState(elt);
}, Toolbar.prototype.addEnabledState = function(elt) {
var classname = elt.className;
elt.setEnabled = function(value) {
elt.enabled = value, elt.className = value ? classname :classname + " geDisabled";
}, elt.setEnabled(!0);
}, Toolbar.prototype.addClickHandler = function(elt, funct) {
null != funct && mxEvent.addListener(elt, "click", function(evt) {
elt.enabled && funct(evt), mxEvent.consume(evt);
});
}, Toolbar.prototype.createButton = function(classname) {
var elt = document.createElement("a");
elt.setAttribute("href", "javascript:void(0);"), elt.className = "geButton";
var inner = document.createElement("div");
return inner.className = "geSprite " + classname, elt.appendChild(inner), elt;
}, Toolbar.prototype.createLabel = function(label) {
var elt = document.createElement("a");
return elt.setAttribute("href", "javascript:void(0);"), elt.className = "geLabel", 
mxUtils.write(elt, label), elt;
}, Toolbar.prototype.addMenuHandler = function(elt, showLabels, funct, showAll) {
if (null != funct) {
var graph = this.editorUi.editor.graph, menu = null;
mxEvent.addListener(elt, "click", mxUtils.bind(this, function(evt) {
(null == elt.enabled || elt.enabled) && (graph.panningHandler.hideMenu(), menu = new mxPopupMenu(funct), 
menu.div.className += " geToolbarMenu", menu.showDisabled = showAll, menu.labels = showLabels, 
menu.autoExpand = !0, menu.popup(elt.offsetLeft, elt.offsetTop + elt.offsetHeight + 34, null, evt), 
this.currentMenu = menu), mxEvent.consume(evt);
}));
}
};

var jscolor = {
dir:"",
bindClass:"color",
binding:!0,
preloading:!0,
install:function() {},
init:function() {
jscolor.preloading && jscolor.preload();
},
getDir:function() {
if (!jscolor.dir) {
var detected = jscolor.detectDir();
jscolor.dir = detected !== !1 ? detected :"jscolor/";
}
return jscolor.dir;
},
detectDir:function() {
for (var base = location.href, e = document.getElementsByTagName("base"), i = 0; i < e.length; i += 1) e[i].href && (base = e[i].href);
for (var e = document.getElementsByTagName("script"), i = 0; i < e.length; i += 1) if (e[i].src && /(^|\/)jscolor\.js([?#].*)?$/i.test(e[i].src)) {
var src = new jscolor.URI(e[i].src), srcAbs = src.toAbsolute(base);
return srcAbs.path = srcAbs.path.replace(/[^\/]+$/, ""), srcAbs.query = null, srcAbs.fragment = null, 
srcAbs.toString();
}
return !1;
},
preload:function() {
for (var fn in jscolor.imgRequire) jscolor.imgRequire.hasOwnProperty(fn) && jscolor.loadImage(fn);
},
images:{
pad:[ 181, 101 ],
sld:[ 16, 101 ],
cross:[ 15, 15 ],
arrow:[ 7, 11 ]
},
imgRequire:{},
imgLoaded:{},
requireImage:function(filename) {
jscolor.imgRequire[filename] = !0;
},
loadImage:function(filename) {
jscolor.imgLoaded[filename] || (jscolor.imgLoaded[filename] = new Image(), jscolor.imgLoaded[filename].src = jscolor.getDir() + filename);
},
fetchElement:function(mixed) {
return "string" == typeof mixed ? document.getElementById(mixed) :mixed;
},
addEvent:function(el, evnt, func) {
el.addEventListener ? el.addEventListener(evnt, func, !1) :el.attachEvent && el.attachEvent("on" + evnt, func);
},
fireEvent:function(el, evnt) {
if (el) if (document.createEvent) {
var ev = document.createEvent("HTMLEvents");
ev.initEvent(evnt, !0, !0), el.dispatchEvent(ev);
} else if (document.createEventObject) {
var ev = document.createEventObject();
el.fireEvent("on" + evnt, ev);
} else el["on" + evnt] && el["on" + evnt]();
},
getElementPos:function(e) {
var e1 = e, e2 = e, x = 0, y = 0;
if (e1.offsetParent) do x += e1.offsetLeft, y += e1.offsetTop; while (e1 = e1.offsetParent);
for (;(e2 = e2.parentNode) && "BODY" !== e2.nodeName.toUpperCase(); ) x -= e2.scrollLeft, 
y -= e2.scrollTop;
return [ x, y ];
},
getElementSize:function(e) {
return [ e.offsetWidth, e.offsetHeight ];
},
getRelMousePos:function(e) {
var x = 0, y = 0;
return e || (e = window.event), "number" == typeof e.offsetX ? (x = e.offsetX, y = e.offsetY) :"number" == typeof e.layerX && (x = e.layerX, 
y = e.layerY), {
x:x,
y:y
};
},
getViewPos:function() {
return "number" == typeof window.pageYOffset ? [ window.pageXOffset, window.pageYOffset ] :document.body && (document.body.scrollLeft || document.body.scrollTop) ? [ document.body.scrollLeft, document.body.scrollTop ] :document.documentElement && (document.documentElement.scrollLeft || document.documentElement.scrollTop) ? [ document.documentElement.scrollLeft, document.documentElement.scrollTop ] :[ 0, 0 ];
},
getViewSize:function() {
return "number" == typeof window.innerWidth ? [ window.innerWidth, window.innerHeight ] :document.body && (document.body.clientWidth || document.body.clientHeight) ? [ document.body.clientWidth, document.body.clientHeight ] :document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight) ? [ document.documentElement.clientWidth, document.documentElement.clientHeight ] :[ 0, 0 ];
},
URI:function(uri) {
function removeDotSegments(path) {
for (var out = ""; path; ) if ("../" === path.substr(0, 3) || "./" === path.substr(0, 2)) path = path.replace(/^\.+/, "").substr(1); else if ("/./" === path.substr(0, 3) || "/." === path) path = "/" + path.substr(3); else if ("/../" === path.substr(0, 4) || "/.." === path) path = "/" + path.substr(4), 
out = out.replace(/\/?[^\/]*$/, ""); else if ("." === path || ".." === path) path = ""; else {
var rm = path.match(/^\/?[^\/]*/)[0];
path = path.substr(rm.length), out += rm;
}
return out;
}
this.scheme = null, this.authority = null, this.path = "", this.query = null, this.fragment = null, 
this.parse = function(uri) {
var m = uri.match(/^(([A-Za-z][0-9A-Za-z+.-]*)(:))?((\/\/)([^\/?#]*))?([^?#]*)((\?)([^#]*))?((#)(.*))?/);
return this.scheme = m[3] ? m[2] :null, this.authority = m[5] ? m[6] :null, this.path = m[7], 
this.query = m[9] ? m[10] :null, this.fragment = m[12] ? m[13] :null, this;
}, this.toString = function() {
var result = "";
return null !== this.scheme && (result = result + this.scheme + ":"), null !== this.authority && (result = result + "//" + this.authority), 
null !== this.path && (result += this.path), null !== this.query && (result = result + "?" + this.query), 
null !== this.fragment && (result = result + "#" + this.fragment), result;
}, this.toAbsolute = function(base) {
var base = new jscolor.URI(base), r = this, t = new jscolor.URI();
return null === base.scheme ? !1 :(null !== r.scheme && r.scheme.toLowerCase() === base.scheme.toLowerCase() && (r.scheme = null), 
null !== r.scheme ? (t.scheme = r.scheme, t.authority = r.authority, t.path = removeDotSegments(r.path), 
t.query = r.query) :(null !== r.authority ? (t.authority = r.authority, t.path = removeDotSegments(r.path), 
t.query = r.query) :("" === r.path ? (t.path = base.path, t.query = null !== r.query ? r.query :base.query) :("/" === r.path.substr(0, 1) ? t.path = removeDotSegments(r.path) :(t.path = null !== base.authority && "" === base.path ? "/" + r.path :base.path.replace(/[^\/]+$/, "") + r.path, 
t.path = removeDotSegments(t.path)), t.query = r.query), t.authority = base.authority), 
t.scheme = base.scheme), t.fragment = r.fragment, t);
}, uri && this.parse(uri);
},
color:function(target, prop) {
function RGB_HSV(r, g, b) {
var n = Math.min(Math.min(r, g), b), v = Math.max(Math.max(r, g), b), m = v - n;
if (0 === m) return [ null, 0, v ];
var h = r === n ? 3 + (b - g) / m :g === n ? 5 + (r - b) / m :1 + (g - r) / m;
return [ 6 === h ? 0 :h, m / v, v ];
}
function HSV_RGB(h, s, v) {
if (null === h) return [ v, v, v ];
var i = Math.floor(h), f = i % 2 ? h - i :1 - (h - i), m = v * (1 - s), n = v * (1 - s * f);
switch (i) {
case 6:
case 0:
return [ v, n, m ];

case 1:
return [ n, v, m ];

case 2:
return [ m, v, n ];

case 3:
return [ m, n, v ];

case 4:
return [ n, m, v ];

case 5:
return [ v, m, n ];
}
}
function removePicker() {
delete jscolor.picker.owner, document.getElementsByTagName("body")[0].removeChild(jscolor.picker.boxB);
}
function drawPicker(x, y) {
function setBtnBorder() {
var insetColors = THIS.pickerInsetColor.split(/\s+/), pickerOutsetColor = insetColors.length < 2 ? insetColors[0] :insetColors[1] + " " + insetColors[0] + " " + insetColors[0] + " " + insetColors[1];
p.btn.style.borderColor = pickerOutsetColor;
}
if (!jscolor.picker) {
jscolor.picker = {
box:document.createElement("div"),
boxB:document.createElement("div"),
pad:document.createElement("div"),
padB:document.createElement("div"),
padM:document.createElement("div"),
sld:document.createElement("div"),
sldB:document.createElement("div"),
sldM:document.createElement("div"),
btn:document.createElement("div"),
btnS:document.createElement("span"),
btnT:document.createTextNode(THIS.pickerCloseText)
};
for (var i = 0, segSize = 4; i < jscolor.images.sld[1]; i += segSize) {
var seg = document.createElement("div");
seg.style.height = segSize + "px", seg.style.fontSize = "1px", seg.style.lineHeight = "0", 
jscolor.picker.sld.appendChild(seg);
}
jscolor.picker.sldB.appendChild(jscolor.picker.sld), jscolor.picker.box.appendChild(jscolor.picker.sldB), 
jscolor.picker.box.appendChild(jscolor.picker.sldM), jscolor.picker.padB.appendChild(jscolor.picker.pad), 
jscolor.picker.box.appendChild(jscolor.picker.padB), jscolor.picker.box.appendChild(jscolor.picker.padM), 
jscolor.picker.btnS.appendChild(jscolor.picker.btnT), jscolor.picker.btn.appendChild(jscolor.picker.btnS), 
jscolor.picker.box.appendChild(jscolor.picker.btn), jscolor.picker.boxB.appendChild(jscolor.picker.box);
}
var p = jscolor.picker;
p.box.onmouseup = p.box.onmouseout = function() {
mxClient.IS_TOUCH || target.focus();
}, p.box.onmousedown = function() {
abortBlur = !0;
}, p.box.onmousemove = function(e) {
(holdPad || holdSld) && (holdPad && setPad(e), holdSld && setSld(e), document.selection ? document.selection.empty() :window.getSelection && window.getSelection().removeAllRanges(), 
dispatchImmediateChange());
}, p.padM.onmouseup = p.padM.onmouseout = function() {
holdPad && (holdPad = !1, jscolor.fireEvent(valueElement, "change"));
}, p.padM.onmousedown = function(e) {
switch (modeID) {
case 0:
0 === THIS.hsv[2] && THIS.fromHSV(null, null, 1);
break;

case 1:
0 === THIS.hsv[1] && THIS.fromHSV(null, 1, null);
}
holdPad = !0, setPad(e), dispatchImmediateChange();
}, p.sldM.onmouseup = p.sldM.onmouseout = function() {
holdSld && (holdSld = !1, jscolor.fireEvent(valueElement, "change"));
}, p.sldM.onmousedown = function(e) {
holdSld = !0, setSld(e), dispatchImmediateChange();
};
var dims = getPickerDims(THIS);
p.box.style.width = dims[0] + "px", p.box.style.height = dims[1] + "px", p.boxB.style.position = "absolute", 
p.boxB.style.clear = "both", p.boxB.style.left = x + "px", p.boxB.style.top = y + "px", 
p.boxB.style.zIndex = THIS.pickerZIndex, p.boxB.style.border = THIS.pickerBorder + "px solid", 
p.boxB.style.borderColor = THIS.pickerBorderColor, p.boxB.style.background = THIS.pickerFaceColor, 
p.pad.style.width = jscolor.images.pad[0] + "px", p.pad.style.height = jscolor.images.pad[1] + "px", 
p.padB.style.position = "absolute", p.padB.style.left = THIS.pickerFace + "px", 
p.padB.style.top = THIS.pickerFace + "px", p.padB.style.border = THIS.pickerInset + "px solid", 
p.padB.style.borderColor = THIS.pickerInsetColor, p.padM.style.position = "absolute", 
p.padM.style.left = "0", p.padM.style.top = "0", p.padM.style.width = THIS.pickerFace + 2 * THIS.pickerInset + jscolor.images.pad[0] + jscolor.images.arrow[0] + "px", 
p.padM.style.height = p.box.style.height, p.padM.style.cursor = "crosshair", p.sld.style.overflow = "hidden", 
p.sld.style.width = jscolor.images.sld[0] + "px", p.sld.style.height = jscolor.images.sld[1] + "px", 
p.sldB.style.display = THIS.slider ? "block" :"none", p.sldB.style.position = "absolute", 
p.sldB.style.right = THIS.pickerFace + "px", p.sldB.style.top = THIS.pickerFace + "px", 
p.sldB.style.border = THIS.pickerInset + "px solid", p.sldB.style.borderColor = THIS.pickerInsetColor, 
p.sldM.style.display = THIS.slider ? "block" :"none", p.sldM.style.position = "absolute", 
p.sldM.style.right = "0", p.sldM.style.top = "0", p.sldM.style.width = jscolor.images.sld[0] + jscolor.images.arrow[0] + THIS.pickerFace + 2 * THIS.pickerInset + "px", 
p.sldM.style.height = p.box.style.height;
try {
p.sldM.style.cursor = "pointer";
} catch (eOldIE) {
p.sldM.style.cursor = "hand";
}
p.btn.style.display = THIS.pickerClosable ? "block" :"none", p.btn.style.position = "absolute", 
p.btn.style.left = THIS.pickerFace + "px", p.btn.style.bottom = THIS.pickerFace + "px", 
p.btn.style.padding = "0 15px", p.btn.style.height = "18px", p.btn.style.border = THIS.pickerInset + "px solid", 
setBtnBorder(), p.btn.style.color = THIS.pickerButtonColor, p.btn.style.font = "12px sans-serif", 
p.btn.style.textAlign = "center";
try {
p.btn.style.cursor = "pointer";
} catch (eOldIE) {
p.btn.style.cursor = "hand";
}
switch (p.btn.onmousedown = function() {
THIS.hidePicker();
}, p.btnS.style.lineHeight = p.btn.style.height, modeID) {
case 0:
var padImg = "hs.png";
break;

case 1:
var padImg = "hv.png";
}
p.padM.style.backgroundImage = "url('" + jscolor.getDir() + "cross.gif')", p.padM.style.backgroundRepeat = "no-repeat", 
p.sldM.style.backgroundImage = "url('" + jscolor.getDir() + "arrow.gif')", p.sldM.style.backgroundRepeat = "no-repeat", 
p.pad.style.backgroundImage = "url('" + jscolor.getDir() + padImg + "')", p.pad.style.backgroundRepeat = "no-repeat", 
p.pad.style.backgroundPosition = "0 0", redrawPad(), redrawSld(), jscolor.picker.owner = THIS, 
document.getElementsByTagName("body")[0].appendChild(p.boxB);
}
function getPickerDims(o) {
var dims = [ 2 * o.pickerInset + 2 * o.pickerFace + jscolor.images.pad[0] + (o.slider ? 2 * o.pickerInset + 2 * jscolor.images.arrow[0] + jscolor.images.sld[0] :0), o.pickerClosable ? 4 * o.pickerInset + 3 * o.pickerFace + jscolor.images.pad[1] + o.pickerButtonHeight :2 * o.pickerInset + 2 * o.pickerFace + jscolor.images.pad[1] ];
return dims;
}
function redrawPad() {
switch (modeID) {
case 0:
var yComponent = 1;
break;

case 1:
var yComponent = 2;
}
var x = Math.round(THIS.hsv[0] / 6 * (jscolor.images.pad[0] - 1)), y = Math.round((1 - THIS.hsv[yComponent]) * (jscolor.images.pad[1] - 1));
jscolor.picker.padM.style.backgroundPosition = THIS.pickerFace + THIS.pickerInset + x - Math.floor(jscolor.images.cross[0] / 2) + "px " + (THIS.pickerFace + THIS.pickerInset + y - Math.floor(jscolor.images.cross[1] / 2)) + "px";
var seg = jscolor.picker.sld.childNodes;
switch (modeID) {
case 0:
for (var rgb = HSV_RGB(THIS.hsv[0], THIS.hsv[1], 1), i = 0; i < seg.length; i += 1) seg[i].style.backgroundColor = "rgb(" + rgb[0] * (1 - i / seg.length) * 100 + "%," + rgb[1] * (1 - i / seg.length) * 100 + "%," + rgb[2] * (1 - i / seg.length) * 100 + "%)";
break;

case 1:
var rgb, s, c = [ THIS.hsv[2], 0, 0 ], i = Math.floor(THIS.hsv[0]), f = i % 2 ? THIS.hsv[0] - i :1 - (THIS.hsv[0] - i);
switch (i) {
case 6:
case 0:
rgb = [ 0, 1, 2 ];
break;

case 1:
rgb = [ 1, 0, 2 ];
break;

case 2:
rgb = [ 2, 0, 1 ];
break;

case 3:
rgb = [ 2, 1, 0 ];
break;

case 4:
rgb = [ 1, 2, 0 ];
break;

case 5:
rgb = [ 0, 2, 1 ];
}
for (var i = 0; i < seg.length; i += 1) s = 1 - 1 / (seg.length - 1) * i, c[1] = c[0] * (1 - s * f), 
c[2] = c[0] * (1 - s), seg[i].style.backgroundColor = "rgb(" + 100 * c[rgb[0]] + "%," + 100 * c[rgb[1]] + "%," + 100 * c[rgb[2]] + "%)";
}
}
function redrawSld() {
switch (modeID) {
case 0:
var yComponent = 2;
break;

case 1:
var yComponent = 1;
}
var y = Math.round((1 - THIS.hsv[yComponent]) * (jscolor.images.sld[1] - 1));
jscolor.picker.sldM.style.backgroundPosition = "0 " + (THIS.pickerFace + THIS.pickerInset + y - Math.floor(jscolor.images.arrow[1] / 2)) + "px";
}
function isPickerOwner() {
return jscolor.picker && jscolor.picker.owner === THIS;
}
function blurTarget() {
valueElement === target && THIS.importColor(), THIS.pickerOnfocus && THIS.hidePicker();
}
function blurValue() {
valueElement !== target && THIS.importColor();
}
function setPad(e) {
var mpos = jscolor.getRelMousePos(e), x = mpos.x - THIS.pickerFace - THIS.pickerInset, y = mpos.y - THIS.pickerFace - THIS.pickerInset;
switch (modeID) {
case 0:
THIS.fromHSV(x * (6 / (jscolor.images.pad[0] - 1)), 1 - y / (jscolor.images.pad[1] - 1), null, leaveSld);
break;

case 1:
THIS.fromHSV(x * (6 / (jscolor.images.pad[0] - 1)), null, 1 - y / (jscolor.images.pad[1] - 1), leaveSld);
}
}
function setSld(e) {
var mpos = jscolor.getRelMousePos(e), y = mpos.y - THIS.pickerFace - THIS.pickerInset;
switch (modeID) {
case 0:
THIS.fromHSV(null, null, 1 - y / (jscolor.images.sld[1] - 1), leavePad);
break;

case 1:
THIS.fromHSV(null, 1 - y / (jscolor.images.sld[1] - 1), null, leavePad);
}
}
function dispatchImmediateChange() {
THIS.onImmediateChange && ("string" == typeof THIS.onImmediateChange ? eval(THIS.onImmediateChange) :THIS.onImmediateChange(THIS));
}
this.required = !0, this.adjust = !0, this.hash = !1, this.caps = !0, this.slider = !0, 
this.valueElement = target, this.styleElement = target, this.onImmediateChange = null, 
this.hsv = [ 0, 0, 1 ], this.rgb = [ 1, 1, 1 ], this.pickerOnfocus = !0, this.pickerMode = "HSV", 
this.pickerPosition = "bottom", this.pickerSmartPosition = !0, this.pickerButtonHeight = 20, 
this.pickerClosable = !1, this.pickerCloseText = "Close", this.pickerButtonColor = "ButtonText", 
this.pickerFace = 0, this.pickerFaceColor = "ThreeDFace", this.pickerBorder = 1, 
this.pickerBorderColor = "ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight", 
this.pickerInset = 1, this.pickerInsetColor = "ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow", 
this.pickerZIndex = 1e4;
for (var p in prop) prop.hasOwnProperty(p) && (this[p] = prop[p]);
this.hidePicker = function() {
isPickerOwner() && removePicker();
}, this.showPicker = function() {
if (!isPickerOwner()) {
var a, b, c, tp = jscolor.getElementPos(target), ts = jscolor.getElementSize(target), vp = jscolor.getViewPos(), vs = jscolor.getViewSize(), ps = getPickerDims(this);
switch (this.pickerPosition.toLowerCase()) {
case "left":
a = 1, b = 0, c = -1;
break;

case "right":
a = 1, b = 0, c = 1;
break;

case "top":
a = 0, b = 1, c = -1;
break;

default:
a = 0, b = 1, c = 1;
}
var l = (ts[b] + ps[b]) / 2;
if (this.pickerSmartPosition) {
[ -vp[a] + tp[a] + ps[a] > vs[a] ? -vp[a] + tp[a] + ts[a] / 2 > vs[a] / 2 && tp[a] + ts[a] - ps[a] >= 0 ? tp[a] + ts[a] - ps[a] :tp[a] :tp[a], -vp[b] + tp[b] + ts[b] + ps[b] - l + l * c > vs[b] ? -vp[b] + tp[b] + ts[b] / 2 > vs[b] / 2 && tp[b] + ts[b] - l - l * c >= 0 ? tp[b] + ts[b] - l - l * c :tp[b] + ts[b] - l + l * c :tp[b] + ts[b] - l + l * c >= 0 ? tp[b] + ts[b] - l + l * c :tp[b] + ts[b] - l - l * c ];
} else {
[ tp[a], tp[b] + ts[b] - l + l * c ];
}
drawPicker(0, 0);
}
}, this.importColor = function() {
valueElement ? this.adjust ? !this.required && /^\s*$/.test(valueElement.value) ? (valueElement.value = "", 
styleElement.style.backgroundImage = styleElement.jscStyle.backgroundImage, styleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor, 
styleElement.style.color = styleElement.jscStyle.color, this.exportColor(leaveValue | leaveStyle)) :this.fromString(valueElement.value) || this.exportColor() :this.fromString(valueElement.value, leaveValue) || (styleElement.style.backgroundImage = styleElement.jscStyle.backgroundImage, 
styleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor, styleElement.style.color = styleElement.jscStyle.color, 
this.exportColor(leaveValue | leaveStyle)) :this.exportColor();
}, this.exportColor = function(flags) {
if (!(flags & leaveValue) && valueElement) {
var value = this.toString();
this.caps && (value = value.toUpperCase()), this.hash && (value = "#" + value), 
valueElement.value = value;
}
flags & leaveStyle || !styleElement || (styleElement.style.backgroundImage = "none", 
styleElement.style.backgroundColor = "#" + this.toString(), styleElement.style.color = .213 * this.rgb[0] + .715 * this.rgb[1] + .072 * this.rgb[2] < .5 ? "#FFF" :"#000"), 
flags & leavePad || !isPickerOwner() || redrawPad(), flags & leaveSld || !isPickerOwner() || redrawSld();
}, this.fromHSV = function(h, s, v, flags) {
0 > h && (h = 0) || h > 6 && (h = 6), 0 > s && (s = 0) || s > 1 && (s = 1), 0 > v && (v = 0) || v > 1 && (v = 1), 
this.rgb = HSV_RGB(null === h ? this.hsv[0] :this.hsv[0] = h, null === s ? this.hsv[1] :this.hsv[1] = s, null === v ? this.hsv[2] :this.hsv[2] = v), 
this.exportColor(flags);
}, this.fromRGB = function(r, g, b, flags) {
0 > r && (r = 0) || r > 1 && (r = 1), 0 > g && (g = 0) || g > 1 && (g = 1), 0 > b && (b = 0) || b > 1 && (b = 1);
var hsv = RGB_HSV(null === r ? this.rgb[0] :this.rgb[0] = r, null === g ? this.rgb[1] :this.rgb[1] = g, null === b ? this.rgb[2] :this.rgb[2] = b);
null !== hsv[0] && (this.hsv[0] = hsv[0]), 0 !== hsv[2] && (this.hsv[1] = hsv[1]), 
this.hsv[2] = hsv[2], this.exportColor(flags);
}, this.fromString = function(hex, flags) {
var m = hex.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i);
return m ? (6 === m[1].length ? this.fromRGB(parseInt(m[1].substr(0, 2), 16) / 255, parseInt(m[1].substr(2, 2), 16) / 255, parseInt(m[1].substr(4, 2), 16) / 255, flags) :this.fromRGB(parseInt(m[1].charAt(0) + m[1].charAt(0), 16) / 255, parseInt(m[1].charAt(1) + m[1].charAt(1), 16) / 255, parseInt(m[1].charAt(2) + m[1].charAt(2), 16) / 255, flags), 
!0) :!1;
}, this.toString = function() {
return (256 | Math.round(255 * this.rgb[0])).toString(16).substr(1) + (256 | Math.round(255 * this.rgb[1])).toString(16).substr(1) + (256 | Math.round(255 * this.rgb[2])).toString(16).substr(1);
};
var THIS = this, modeID = "hvs" === this.pickerMode.toLowerCase() ? 1 :0, abortBlur = !1, valueElement = jscolor.fetchElement(this.valueElement), styleElement = jscolor.fetchElement(this.styleElement), holdPad = !1, holdSld = !1, leaveValue = 1, leaveStyle = 2, leavePad = 4, leaveSld = 8;
if (valueElement) {
var updateField = function() {
THIS.fromString(valueElement.value, leaveValue), dispatchImmediateChange();
};
jscolor.addEvent(valueElement, "keyup", updateField), jscolor.addEvent(valueElement, "input", updateField), 
jscolor.addEvent(valueElement, "blur", blurValue), valueElement.setAttribute("autocomplete", "off");
}
switch (styleElement && (styleElement.jscStyle = {
backgroundImage:styleElement.style.backgroundImage,
backgroundColor:styleElement.style.backgroundColor,
color:styleElement.style.color
}), modeID) {
case 0:
jscolor.requireImage("hs.png");
break;

case 1:
jscolor.requireImage("hv.png");
}
jscolor.requireImage("cross.gif"), jscolor.requireImage("arrow.gif"), this.importColor();
}
};

jscolor.install(), function() {
$.ajaxSetup({
cache:!1
}), $(document).ready(function() {
var HR, _makeTopLevel;
return HR = window.HR, HR.appController = new HR.CandidateController(), require.config({
waitSeconds:60
}), _makeTopLevel = function(source, attributes) {
return _.each(attributes, function(attribute) {
return source && "undefined" !== source[attribute] ? HR[attribute] = source[attribute] :void 0;
});
}, _makeTopLevel(HR.appController, [ "namespace", "requires", "routeNamespace", "restURL", "model", "collection" ]), 
HR.connectionAlert = function() {
var unique_id;
if (HR.candidate.candidateTestModel) return unique_id = HR.candidate.candidateTestModel.get("unique_id"), 
HR.util.candidatemsg("Unable to receive test data from this URL.<br><br> Check your internet connection, and continue when you're back online.<br><br><a href='" + unique_id + "/questions' class='backbone btn'>Continue</a>", !1);
throw "connectionAlert called when no testmodel available.";
}, requirejs.onError = function() {
return Offline && Offline.check(), HR.connectionAlert();
}, HR.router = new HR.CandidateRouter(), Backbone.history.start({
pushState:!0,
root:"/tests/"
});
});
}.call(this);